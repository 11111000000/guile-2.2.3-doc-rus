@c -*-texinfo-*-
@c This is part of the GNU Guile Reference Manual.
@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2010, 2011
@c   Free Software Foundation, Inc.
@c See the file guile.texi for copying conditions.

@node Guile Scripting
@section Скрипты Guile

Подобно AWK, Perl, или другим оболочкам, Guile может интерпретировать файлы сценариев.
Скрипт(Сценарий) Guile это просто файл с кодом Scheme с дополнительной информацией в 
начале, которая сообщает операционной системе, как вызывать Guile, а затем говорит
Guile как обрабатывать код Scheme.

@menu
* The Top of a Script File::    How to start a Guile script.
* The Meta Switch::             Passing complex argument lists to Guile
                                from shell scripts.
* Command Line Handling::       Accessing the command line from a script.
* Scripting Examples::
@end menu

@node The Top of a Script File
@subsection Начало Файла скрипта

Первая строка скрипта Guile должна указывать операционной системе использовать
Guile для вычисления скрипта, а затем указать Guile как это сделать. Вот
самый простой случай:

@itemize @bullet

@item
Первые два символа должны быть @samp{#!}.

Операционная система интерпретирует это, так что оставшаяся часть строки
является именем исполняемого файла, который может интерпретировать скрипт.
Guile, однако, интерпретирует эти символы как начало многострочного коментария,
заканчивающегося символьными знаками @samp{!#} в своей последней строке.
(Это расширение синтаксиса описанного в R5RS, добавлено для поддержки
скриптов оболочки(shell).)

@item
Сразу после этих двух знаков должен идти полный путь к интерпретатору
Guile.  В большинстве систем он будет
@samp{/usr/local/bin/guile}.

@item
Затем должен идти пробел, за которым следует аргумент командной строки
для передачи в Guile; это должен быть @samp{-s}.  Этот переключатель говорит
Guile запустить скрипт, вместо того чтобы просить пользователя вводить команды
в окне терминала. Есть более сложные вещи, которые можно сделать здесь; см. 
@ref{The Meta Switch}.

@item
Далее следует знак новой строки.

@item
Вторая строка скриптам должна содержать только символьные знаки
@samp{!#} --- просто как верхняя строка файла, но в обратном порядке.
Операционная система никогда не читает так далеко, но Guile относится
к этому как к концу комментария, начатому в первой строке символьными
знаками @samp{#!}.

@item
Если файл исходного кода не является закодированным в ASCII или ISO-8859-1,
объявление кодировки, как @code{coding: utf-8} должно появиться в комментарии
где-то в первых пяти строках файла: см @ref{Character
Encoding of Source Files}.

@item
Остальная часть файла должна быть программой Scheme.

@end itemize

Guile читает программу, вычисляет выражения в порядке их появления. Достигнув
конца файла Guile завершает работу.

@node The Meta Switch
@subsection Мета переключатель

Переключатели командной строки Guile позволяют программисту описывать
достаточно сложные действия в скриптах. К сожалению, механизм вызова
скрипта POSIX допускает только один аргумент, который может появиться
в строке @samp{#!} после пути к исполняемому файлу Guile, и накладывает
произвольные ограничения на длину этого аргумента. Предположим вы написали
скрипт, начинающийся так:
@example
#!/usr/local/bin/guile -e main -s
!#
(define (main args)
  (map (lambda (arg) (display arg) (display " "))
       (cdr args))
  (newline))
@end example
Предполагаемое назначение ясно: грузим файл, и вызываем @code{main}
как аргумент командной строки.  Однако система будет относиться ко всему
после пути Guile как одному аргументу --- строка @code{"-e main -s"} --- 
это не то что мы хотим.

В качестве обходного пути, мета переключатель @code{\} позволяет программисту
Guile определять произвольное количество опций без исправления ядра. Если
первым аргументом Guile является @code{\}, Guile откроет файл скрипта имя которого
следует за аргументом @code{\}, и разберет аргументы для старта из файла начиная
со второй строки(в соответствии с правилами описанными ниже), и заменит на них
переключатель @code{\}.

Работая вместе с мета-переключателем, Guile рассматривает символьные знаки
@samp{#!} как начало комментария, который простираетсся до следующей строки,
содержащей только знаки @samp{!#}.  Комментарии такого рода могут появиться
в любом месте программы Guile, но они наиболее полезны в верхней части файла,
волшебным образом объединяясь с механизмом вызова сценариев POSIX.

Итак, рассмотрим скрипт с именем @file{/u/jimb/ekko} который начинается так:
@example
#!/usr/local/bin/guile \
-e main -s
!#
(define (main args)
        (map (lambda (arg) (display arg) (display " "))
             (cdr args))
        (newline))
@end example

Предположим, что пользователь вызывает этот скрипт следующим образом:
@example
$ /u/jimb/ekko a b c
@end example

Вот что здесь происходит:
@itemize @bullet

@item
операционная система распознает токен the @samp{#!} в верху файла и переписывает
командную строку так:
@example
/usr/local/bin/guile \ /u/jimb/ekko a b c
@end example
Это обычное поведение, предписанное POSIX.

@item
Когда Guile видит первые два аргумента, @code{\ /u/jimb/ekko}, он открывает
@file{/u/jimb/ekko}, анализирует три аргумента @code{-e}, @code{main},
and @code{-s} из него, и подставляет их вместо переключателя @code{\}.
Таким образом, командная строка Guile теперь выглядит так:
@example
/usr/local/bin/guile -e main -s /u/jimb/ekko a b c
@end example

@item
Затем Guile обрабатывает ключи: он загружает файл @file{/u/jimb/ekko} как
файл с кодом Scheme (обрабатывая первые три строки как комментраий), и
затем выполняет приложение @code{(main "/u/jimb/ekko" "a" "b" "c")}.

@end itemize

Когда Guile видит метаперключатель @code{\}, он анализирует аргументы командной строки
из файла скрипта в соответствии со следующими правилами:
@itemize @bullet

@item
Каждый символ пробела завершает аргумент.  Это означает что два пробела
подряд вводят аргумент(пустую строку) @code{""}.

@item
Знак табуляции не допускается (если вы не заключите его в кавычки, как описано ниже),
чтобы избежать путаницы.

@item
Знак новой строки завершает последовательность аргументов, а также завершает
последний не пустой аргумент.  (Однако, новая строка после пробела не будет
вводить последний аргумент пустой строки; он только завершает список аргументов.)

@item
Знак обратной косой черты являлется экранирующим(escape) символьным знаком.
Он экранирует обратную косую черту, пробел, знак табуляции и новой строки.
Экранирующий последовательности ANSI C такие как @code{\n} и
@code{\t} также поддерживаются.  Они дают составляющие аргументов; комбинация
из двух знаков @code{\n} не действует как завершающий перевод строки.  
Экранируемая последовательность @code{\@var{NNN}} для ровно трех восмеричных
цифр читает символ с ASCII кодом равным @var{NNN}.  Как и выше,
знаковый символ созданный таким образом является составляющим аргумента. Обратная
косая черта, за которой следуют другие знаки не допускается.

@end itemize

@node Command Line Handling
@subsection Обработка командной строки

@c This section was written and contributed by Martin Grabmueller.

Способность принимать и обрабатывать аргументы командной строки очень важна
при написании скриптов Guile для решения определенных задач, таких как извлечение
информации из текстовых файлов или взаимодействие с существующими приложениями
командной строки.  Эта глава описывает, как Guile делает аргументы командной
строки доступными для скрипта Guile, и утилит которые Guile предоставляет в
помощь в обработке аргументов командной строки.

Когда вызывается скрипт Guile, Guile делает аргументы командной строки доступными
через процедуру @code{command-line}, которая возвращает аргументы в виде списка строк.

Например, если скрипт

@example
#! /usr/local/bin/guile -s
!#
(write (command-line))
(newline)
@end example

@noindent
сохранить в файл @file{cmdline-test.scm} и вызывать используя командную строку
@code{./cmdline-test.scm bar.txt -o foo -frumple grob}, вывод будет

@example
("./cmdline-test.scm" "bar.txt" "-o" "foo" "-frumple" "grob")
@end example

Если вызов скрипта включает опцию @code{-e}, он указывает процедуру
вызываемую после загрузки скрипта, Guile вызовет эту процедуру с
@code{(command-line)} в качестве аргументов.  Итак, скрипту при исползовании
@code{-e} нет необходимости явно ссылаться на @code{command-line}
в своем коде.  Например, скрипт выше будет иметь идентичное поведение, если он
будет написан так:

@example
#! /usr/local/bin/guile \
-e main -s
!#
(define (main args)
  (write args)
  (newline))
@end example

(Обратите внимание на использование мета переключателя @code{\} чтоыб вызов
скрипта мог включать более одной опции Guile: @xref{The Meta Switch}.)

Эти скрипты испольуют @code{#!} соглашение POSIX, чтобы они могли быть выполнены
с использованием их собственного имени файла напрямую, как в примере командной
строки @code{./cmdline-test.scm bar.txt -o foo -frumple grob}.  Но он также может
быть выполнен, напечатав подразумеваемую командную строку  Guile полностью, как в:

@example
$ guile -s ./cmdline-test.scm bar.txt -o foo -frumple grob
@end example

@noindent
or

@example
$ guile -e main -s ./cmdline-test2.scm bar.txt -o foo -frumple grob
@end example

Даже когда сценарий вызывается с использованием этой более длинной формы,
аргументы этого скрипта получаются так же, как если бы они были вызваны
с использованием краткой формы.  Guile гарантирует, что @code{(command-line)}
или аргументы  @code{-e} не зависят от того, как вызывается скрипт, путем
удаления аргументов, которые Guile обрабатывает сам.

Скрипт может анализировать и обрабатывать аргументы командной строки
любым способом, какой он выберет. Там где набор возможных опций и аргументов
сложен, он может получить  сложное извлечение всех опций, проверить правильность
задания аргументов и так далее. Эта задача может быть значительно упрощена
использованием модуля @code{(ice-9 getopt-long)},
который распространяется вместе с Guile, @xref{getopt-long}.

@node Scripting Examples
@subsection Примеры Скриптов

Для начала приведем несколько примеров прямого вызова Guile:

@table @code

@item guile -- a b c
Запуск Guile в интерактивном режиме; @code{(command-line)} должен вернуть @*
@code{("/usr/local/bin/guile" "a" "b" "c")}.

@item guile -s /u/jimb/ex2 a b c
Загрузить файл @file{/u/jimb/ex2}; @code{(command-line)} должен вернуть @*
@code{("/u/jimb/ex2" "a" "b" "c")}.

@item guile -c '(write %load-path) (newline)'
Записывает значение переменной @code{%load-path}, печатает новую строку и выходит.

@item guile -e main -s /u/jimb/ex4 foo
Загружает файл @file{/u/jimb/ex4}, и затем вызвает функцию
@code{main}, передавая в нее список @code{("/u/jimb/ex4" "foo")}.

@item guile -e '(ex4)' -s /u/jimb/ex4.scm foo
Загружает файл @file{/u/jimb/ex4.scm}, и затем вызывает функцию
@code{main} из модуля '(ex4)', передавая в нее список
@code{("/u/jimb/ex4" "foo")}.

@item guile -l first -ds -l last -s script
Загружает файлы @file{first}, @file{script}, и @file{last}, в указанном порядке.
Переключатель @code{-ds} говорит когда обрабатывать ключ the @code{-s}.
Для более мотивированного примера, смотри скрипты ниже.

@end table

Вот очень простой скрипт Guile:
@example
#!/usr/local/bin/guile -s
!#
(display "Hello, world!")
(newline)
@end example
Первая строка помечает файл как скрипт Guile.  Когда пользователь вызывает его
система запускает интерпретатор скрипта @file{/usr/local/bin/guile} передавая ему
параметры @code{-s}, с именем файла, и любые другие аргументы переданные сценарию
в качестве аргументов командной строки.  Когда Guile видит @code{-s
@var{script}}, он загружает  @var{script}.  Таким образом, запуск этой программы
приводит к выводу:
@example
Hello, world!
@end example

Вот скрипт, который печатает факториал своего аргумента:
@example
#!/usr/local/bin/guile -s
!#
(define (fact n)
  (if (zero? n) 1
    (* n (fact (- n 1)))))

(display (fact (string->number (cadr (command-line)))))
(newline)
@end example
В действии:
@example
$ ./fact 5
120
$
@end example

Однако, предположим, что мы хотим использовать определение @code{fact} в этом
файле из другого скрипта.  Мы не можем просто загрузить(@code{load}) файл сценария, а затем 
использовать определение @code{fact}, потому что сценарий попытается вычислить и отобразить
факториал, когда мы его загрузим. Чтобы избежать этой проблемы мы могли бы написать скрипт
так:

@example
#!/usr/local/bin/guile \
-e main -s
!#
(define (fact n)
  (if (zero? n) 1
    (* n (fact (- n 1)))))

(define (main args)
  (display (fact (string->number (cadr args))))
  (newline))
@end example
Эта версия упаковывает действия, которые должен выполнять скрипт в функцию
 @code{main}.  Это позволяет нам загружать файл исключительно ради его
определений, без выполнения каких либо посторонних вычислений.  Для чего
мы исползжуем метаперключатель @code{\} и переключатель указывающий точку
входа @code{-e}, чтобы сообщить Guile что нужно вызвать @code{main} после
загрузки.
@example
$ ./fact 50
30414093201713378043612608166064768844377641568960512000000000000
@end example

Предположим, что теперь мы хотим написать скрипт, который вычисляет функцию
@code{choose}: давая множество @var{m} различных объектов,
@code{(choose @var{n} @var{m})} это число различных подмножеств содержащих
 @var{n} объектов каждое.  Это просто написать @code{choose} используя данное
определение @code{fact}, поэтому мы можем написать скрипт следующим образом:

@example
#!/usr/local/bin/guile \
-l fact -e main -s
!#
(define (choose n m)
  (/ (fact m) (* (fact (- m n)) (fact n))))

(define (main args)
  (let ((n (string->number (cadr args)))
        (m (string->number (caddr args))))
    (display (choose n m))
    (newline)))
@end example

Аргументы командной строки здесь говорят Guile сначала загрузить файл
@file{fact}, и затем запустить сценарийt, с точкой входа в @code{main}.
Другими словами, скрипт @code{choose} может использовать определения в 
скрипте @code{fact}.  Вот примеры некоторых запусков:
@example
$ ./choose 0 4
1
$ ./choose 1 4
4
$ ./choose 2 4
6
$ ./choose 3 4
4
$ ./choose 4 4
1
$ ./choose 50 100
100891344545564193334812497256
@end example

Чтобы вызвать определенную процедуру из данного модуля, мы можем использовать специальную
форму @code{(@@ (@var{module}) @var{procedure})}:

@example
#!/usr/local/bin/guile \
-l fact -e (@@ (fac) main) -s
!#
(define-module (fac)
  #:export (main))

(define (choose n m)
  (/ (fact m) (* (fact (- m n)) (fact n))))

(define (main args)
  (let ((n (string->number (cadr args)))
        (m (string->number (caddr args))))
    (display (choose n m))
    (newline)))
@end example

Мы можем использовать @code{@@@@} для вызова неэкспортируемых процедур.  Для
экспортируемых процедур, мы можем упростить этот вызов с помощью сокращения
@code{(@var{module})}:

@example
#!/usr/local/bin/guile \
-l fact -e (fac) -s
!#
(define-module (fac)
  #:export (main))

(define (choose n m)
  (/ (fact m) (* (fact (- m n)) (fact n))))

(define (main args)
  (let ((n (string->number (cadr args)))
        (m (string->number (caddr args))))
    (display (choose n m))
    (newline)))
@end example

Для максимальной переносимости, мы можем вместо этого использовать оболочку
для выполнения @command{guile} с указанными аргументами командной строки.
Здесь нужно позаботиться о правильном квотировании аргументов команды:

@example
#!/usr/bin/env sh
exec guile -l fact -e '(@@ (fac) main)' -s "$0" "$@@"
!#
(define-module (fac)
  #:export (main))

(define (choose n m)
  (/ (fact m) (* (fact (- m n)) (fact n))))

(define (main args)
  (let ((n (string->number (cadr args)))
        (m (string->number (caddr args))))
    (display (choose n m))
    (newline)))
@end example

Наконец, опытные сценаристы, вероятно упускают упоминание о подпроцессах.
В Bash, например, большинство сценариев оболочки запускают другие программы, такие
как  @code{sed} или ему подобные для выполнения реальной работы.

В Guile часто можно сделать все внутри самого Guile, так что пробуйте
первое.  Но если вам просто необходимо запустить программу и дождаться
ее завершения, используйте  @code{system*}.  Если вам необходимо запустить
подпрограмму и захватить ее выходные данные или вывести их, используйте
@code{open-pipe}.  @xref{Processes}, и @xref{Pipes}, для получения подробной
информации.

@c Local Variables:
@c TeX-master: "guile.texi"
@c End: