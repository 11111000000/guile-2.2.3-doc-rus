#
# Gagin <mikhail-gagin@yandex.ru>, 2018.
#
#. extracted from api-regex.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-04-18 09:44+0300\n"
"PO-Revision-Date: 2018-04-19 15:34+0300\n"
"Last-Translator: Gagin <mikhail-gagin@yandex.ru>\n"
"Language-Team: Russian <mikhail-gagin@yandex.ru>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: api-regex.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2007, 2009, "
"2010, 2012\n"
"@c   Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: api-regex.texi:10
msgid ""
"@node Regular Expressions\n"
"@section Regular Expressions\n"
"@tpindex Regular expressions"
msgstr ""

#: api-regex.texi:14
msgid ""
"@cindex regular expressions\n"
"@cindex regex\n"
"@cindex emacs regexp"
msgstr ""

#: api-regex.texi:18
msgid ""
"A @dfn{regular expression} (or @dfn{regexp}) is a pattern that\n"
"describes a whole class of strings.  A full description of regular\n"
"expressions and their syntax is beyond the scope of this manual."
msgstr ""
"@dfn{Регулярное выражение} (или @dfn{regexp}) представляет собой\n"
"шаблон, который описывает целый класс строкч.  Полное описание\n"
"регулярных выражений и их синтаксис выодит за рамки настоящего\n"
"руководства."

#: api-regex.texi:24
msgid ""
"If your system does not include a POSIX regular expression library,\n"
"and you have not linked Guile with a third-party regexp library such\n"
"as Rx, these functions will not be available.  You can tell whether\n"
"your Guile installation includes regular expression support by\n"
"checking whether @code{(provided? 'regex)} returns true."
msgstr ""
"Если ваша система не содержит библиотеки регулярных выражений POSIX,\n"
"и у вас нет связанной с Guile независимой библиотеки регулярных выражений,\n"
"такой как Rx, эти функции будут вам не доступны. Вы можете узнать,\n"
"включает ли ваша Guile поддержку регулярных выражений проверяя,\n"
"возвращает ли @code{(provided? 'regex)} значение true.\n"

#: api-regex.texi:29
msgid ""
"The following regexp and string matching features are provided by the\n"
"@code{(ice-9 regex)} module.  Before using the described functions,\n"
"you should load this module by executing @code{(use-modules (ice-9\n"
"regex))}."
msgstr ""
"Следующие функции регулярных выражений и соответствия строк предоставляются\n"
"модулем @code{(ice-9 regex)}.  Перед использованием описанных функций вы\n"
"должны загрузить этот модуль, выполнив @code{(use-modules (ice-9 regex))}."

#: api-regex.texi:36
msgid ""
"@menu\n"
"* Regexp Functions::            Functions that create and match regexps.\n"
"* Match Structures::            Finding what was matched by a regexp.\n"
"* Backslash Escapes::           Removing the special meaning of regexp\n"
"                                meta-characters.\n"
"@end menu"
msgstr ""

#: api-regex.texi:40
msgid ""
"@node Regexp Functions\n"
"@subsection Regexp Functions"
msgstr ""

#: api-regex.texi:46
msgid ""
"By default, Guile supports POSIX extended regular expressions.  That\n"
"means that the characters @samp{(}, @samp{)}, @samp{+} and @samp{?} are\n"
"special, and must be escaped if you wish to match the literal characters\n"
"and there is no support for ``non-greedy'' variants of @samp{*},\n"
"@samp{+} or @samp{?}."
msgstr ""
"По умолчанию, Guile поддерживает расширенные регулярные выражения POSIX.\n"
"Это означает, что символы @samp{(}, @samp{)}, @samp{+} и @samp{?} являются\n"
"специальными, и должны быть экранированы, если вы хотите использовать эти\n"
"символы буквально и нет поддержки ``нежелательных'' вариантов @samp{*},\n"
"@samp{+} или @samp{?}.\n"

#: api-regex.texi:50
msgid ""
"This regular expression interface was modeled after that\n"
"implemented by SCSH, the Scheme Shell.  It is intended to be\n"
"upwardly compatible with SCSH regular expressions."
msgstr ""
"Этот интерфейс регулярных выражений был смоделирован после того,\n"
"как реализован SCSH(Scheme shell). Он должен быть совместим с\n"
"регулярными выражениями SCSH."

#: api-regex.texi:54
msgid ""
"Zero bytes (@code{#\\nul}) cannot be used in regex patterns or input\n"
"strings, since the underlying C functions treat that as the end of\n"
"string.  If there's a zero byte an error is thrown."
msgstr ""
"Нулевой байт (@code{#\\nul}) не может использоваться в шаблонах\n"
"регулярных выражений или входных строках, поскольку базовые\n"
"функции Си рассматривают его как конец стороки. Если есть\n"
"нулевой байт, возникнет ошибка."

#: api-regex.texi:61
msgid ""
"Internally, patterns and input strings are converted to the current\n"
"locale's encoding, and then passed to the C library's regular expression\n"
"routines (@pxref{Regular Expressions,,, libc, The GNU C Library\n"
"Reference Manual}).  The returned match structures always point to\n"
"characters in the strings, not to individual bytes, even in the case of\n"
"multi-byte encodings."
msgstr ""
"Внутренние шаблоны и входные строки преобразуются в кодировку текущего \n"
"языка и затем передаются в подпрограммы регулярных выражений библиотеки\n"
"Си (@pxref{Regular Expressions,,, libc, The GNU C Library\n"
"Reference Manual}). Возвращенные структуры соответствия всегда указывают\n"
"на символы в строках, а не на отдельные байты, даже в случае многобайтовых\n"
"кодировок."

#: api-regex.texi:66
msgid ""
"@deffn {Scheme Procedure} string-match pattern str [start]\n"
"Compile the string @var{pattern} into a regular expression and compare\n"
"it with @var{str}.  The optional numeric argument @var{start} specifies\n"
"the position of @var{str} at which to begin matching."
msgstr ""
"@deffn {Scheme Procedure} string-match pattern str [start]\n"
"Компилирует строку @var{pattern} в регулярное выражение и сравнивает его\n"
"со строкой @var{str}.  Опционально аргумент @var{start} указывает\n"
"с какой позиции в строке @var{str} начинать сопоставление."

#: api-regex.texi:72
msgid ""
"@code{string-match} returns a @dfn{match structure} which\n"
"describes what, if anything, was matched by the regular\n"
"expression.  @xref{Match Structures}.  If @var{str} does not match\n"
"@var{pattern} at all, @code{string-match} returns @code{#f}.\n"
"@end deffn"
msgstr ""
"@code{string-match} возвращает @dfn{match structure} которая\n"
"описывает что было сопоставлено с регулярным выражением.  \n"
"@xref{Match Structures}.  Если @var{str} не соответствует\n"
"шаблону @var{pattern} вообще, @code{string-match} возвращается @code{#f}.\n"
"@end deffn\n"

#: api-regex.texi:76
msgid ""
"Two examples of a match follow.  In the first example, the pattern\n"
"matches the four digits in the match string.  In the second, the pattern\n"
"matches nothing."
msgstr ""
"Ниже приводятся два примера поиска соотвествий. В первом примере шаблон\n"
"сопоставляется четырем цифрам в проверяемой строке. Во втором случае\n"
"шаблону ничего не сопоставляется."

#: api-regex.texi:80
msgid ""
"@example\n"
"(string-match \"[0-9][0-9][0-9][0-9]\" \"blah2002\")\n"
"@result{} #(\"blah2002\" (4 . 8))"
msgstr ""

#: api-regex.texi:84
msgid ""
"(string-match \"[A-Za-z]\" \"123456\")\n"
"@result{} #f\n"
"@end example"
msgstr ""

#: api-regex.texi:91
msgid ""
"Each time @code{string-match} is called, it must compile its\n"
"@var{pattern} argument into a regular expression structure.  This\n"
"operation is expensive, which makes @code{string-match} inefficient if\n"
"the same regular expression is used several times (for example, in a\n"
"loop).  For better performance, you can compile a regular expression in\n"
"advance and then match strings against the compiled regexp."
msgstr ""
"Каждый раз когда вызывается @code{string-match}, функция должна "
"скомпилировать\n"
"свой аргумент @var{pattern} во внутреннюю структуру регулярного выражения.\n"
"Это операция занимает много времени, что делает  @code{string-match} не \n"
"эффективной, если одно и тоже регулярное выражение используется несколько "
"раз\n"
"(например в цикле). Для лучшей производительности, вы можете скомпилировать\n"
"регулярное выражение заранее, а затем сопоставлять входные строки с уже\n"
"скопилированным регулярным выражением."

#: api-regex.texi:98
msgid ""
"@deffn {Scheme Procedure} make-regexp pat flag@dots{}\n"
"@deffnx {C Function} scm_make_regexp (pat, flaglst)\n"
"Compile the regular expression described by @var{pat}, and\n"
"return the compiled regexp structure.  If @var{pat} does not\n"
"describe a legal regular expression, @code{make-regexp} throws\n"
"a @code{regular-expression-syntax} error."
msgstr ""
"@deffn {Scheme Procedure} make-regexp pat flag@dots{}\n"
"@deffnx {C Function} scm_make_regexp (pat, flaglst)\n"
"Компилирует регулярное выражение описанное  в @var{pat}, и\n"
"возвращает скопилированную regexp структуру.  Если @var{pat} не \n"
"описывает корректное регулярное выражение, @code{make-regexp} \n"
"вызывает ошибку с кодом @code{regular-expression-syntax}."

#: api-regex.texi:101
msgid ""
"The @var{flag} arguments change the behavior of the compiled\n"
"regular expression.  The following values may be supplied:"
msgstr ""
"Аргумент @var{flag} изменяет поведение компилируемого регулярного\n"
"выражения. Поддерживаются следующие значения флага:"

#: api-regex.texi:106
msgid ""
"@defvar regexp/icase\n"
"Consider uppercase and lowercase letters to be the same when\n"
"matching.\n"
"@end defvar"
msgstr ""
"@defvar regexp/icase\n"
"Считать прописные и строчные буквы одинаковыми при сравнении.\n"
"@end defvar"

#: api-regex.texi:117
msgid ""
"@defvar regexp/newline\n"
"If a newline appears in the target string, then permit the\n"
"@samp{^} and @samp{$} operators to match immediately after or\n"
"immediately before the newline, respectively.  Also, the\n"
"@samp{.} and @samp{[^...]} operators will never match a newline\n"
"character.  The intent of this flag is to treat the target\n"
"string as a buffer containing many lines of text, and the\n"
"regular expression as a pattern that may match a single one of\n"
"those lines.\n"
"@end defvar"
msgstr ""
"@defvar regexp/newline\n"
"Если в целевой строке появляется значение новой стоки, то операторы\n"
"@samp{^} и @samp{$} соотвествуют ей сразу после или непосредственно\n"
"перед ней, соответственно.  Также , операторы @samp{.} и @samp{[^...]} \n"
"никогда не будут соответствовать символу новой строки.\n"
"Цель этого флага в обработке целевой строки в виде буфера, содержащего\n"
"много строк текста и регулярное выражение как шаблон, который может\n"
"соответствовать одной из этих строк\n"
"@end defvar"

#: api-regex.texi:128
msgid ""
"@defvar regexp/basic\n"
"Compile a basic (``obsolete'') regexp instead of the extended\n"
"(``modern'') regexps that are the default.  Basic regexps do\n"
"not consider @samp{|}, @samp{+} or @samp{?} to be special\n"
"characters, and require the @samp{@{...@}} and @samp{(...)}\n"
"metacharacters to be backslash-escaped (@pxref{Backslash\n"
"Escapes}).  There are several other differences between basic\n"
"and extended regular expressions, but these are the most\n"
"significant.\n"
"@end defvar"
msgstr ""
"@defvar regexp/basic\n"
"Компилировать как базовое (``устаревшее'') вместо расширенных\n"
"(``современных'') регулярных выражений, синтаксис которых принимается\n"
"по умолчанию .  Базовые регулярные выражения не считают символы\n"
"@samp{|}, @samp{+} или @samp{?} специальными и требуют, чтобы\n"
"метасимволы @samp{@{...@}} и @samp{(...)}\n"
"экранировались обратным слешем. (@pxref{Backslash\n"
"Escapes}).  Есть несколько других отличий между базовыми и расширенными\n"
"регулярными выражениями, но эти самые значительные.\n"
"@end defvar"

#: api-regex.texi:137
msgid ""
"@defvar regexp/extended\n"
"Compile an extended regular expression rather than a basic\n"
"regexp.  This is the default behavior; this flag will not\n"
"usually be needed.  If a call to @code{make-regexp} includes\n"
"both @code{regexp/basic} and @code{regexp/extended} flags, the\n"
"one which comes last will override the earlier one.\n"
"@end defvar\n"
"@end deffn"
msgstr ""
"@defvar regexp/extended\n"
"Компилировать регуляроное выражение как расширенное, а не \n"
"базовое регулярное выражение.  Данное поведение происходит\n"
"по умолчанию, этот флаг обычно не требуется.  Если вызов\n"
"@code{make-regexp} включает в себя оба флага \n"
"@code{regexp/basic} и @code{regexp/extended}, тот который\n"
"стоит последним будет отменять предыдущий.\n"
"@end defvar\n"
"@end deffn"

#: api-regex.texi:145
msgid ""
"@deffn {Scheme Procedure} regexp-exec rx str [start [flags]]\n"
"@deffnx {C Function} scm_regexp_exec (rx, str, start, flags)\n"
"Match the compiled regular expression @var{rx} against\n"
"@code{str}.  If the optional integer @var{start} argument is\n"
"provided, begin matching from that position in the string.\n"
"Return a match structure describing the results of the match,\n"
"or @code{#f} if no match could be found."
msgstr ""
"@deffn {Scheme Procedure} regexp-exec rx str [start [flags]]\n"
"@deffnx {C Function} scm_regexp_exec (rx, str, start, flags)\n"
"Сопоставляет скомпилированое регулярное выражение @var{rx} \n"
"с входной строкой @code{str}.  Если есть необязательный\n"
"целый аргумент @var{start} сопоставление начинается с указанной\n"
"позиции в строке.\n"
"Возвращается структура, описывающая результа поиска\n"
"соответсвия или @code{#f} если совпадение не может быть\n"
"найдено."

#: api-regex.texi:149
msgid ""
"The @var{flags} argument changes the matching behavior.  The following\n"
"flag values may be supplied, use @code{logior} (@pxref{Bitwise\n"
"Operations}) to combine them,"
msgstr ""
"Аргумент @var{flags} изменяет поведение поиска соответствия.  "
"Последовательность\n"
"значений флага можеть быть объединена операцией @code{logior} "
"(@pxref{Bitwise\n"
"Operations}),"

#: api-regex.texi:153
msgid ""
"@defvar regexp/notbol\n"
"Consider that the @var{start} offset into @var{str} is not the\n"
"beginning of a line and should not match operator @samp{^}."
msgstr ""
"@defvar regexp/notbol\n"
"Считает что начальное смещение @var{start} в строке @var{str} не\n"
"является началом строки и не соответствует оператору @samp{^}."

#: api-regex.texi:157
msgid ""
"If @var{rx} was created with the @code{regexp/newline} option above,\n"
"@samp{^} will still match after a newline in @var{str}.\n"
"@end defvar"
msgstr ""
"Если @var{rx} был создан с испльзованием параметра @code{regexp/newline} из "
"опций\n"
"указанных выше, @samp{^} будет по прежнему соответствовать после новой "
"стороки\n"
"в буфере @var{str}.\n"
"@end defvar"

#: api-regex.texi:161
msgid ""
"@defvar regexp/noteol\n"
"Consider that the end of @var{str} is not the end of a line and should\n"
"not match operator @samp{$}."
msgstr ""
"@defvar regexp/noteol\n"
"Считает что конец @var{str} не является концом стороки и не должен \n"
"совпадать с оператором @samp{$}."

#: api-regex.texi:166
msgid ""
"If @var{rx} was created with the @code{regexp/newline} option above,\n"
"@samp{$} will still match before a newline in @var{str}.\n"
"@end defvar\n"
"@end deffn"
msgstr ""
"Если @var{rx} был создан с опцией @code{regexp/newline} указаных выше,\n"
"@samp{$} по прежнему будет соответствовать перед новой строкой в буфере\n"
"@var{str}.\n"
"@end defvar\n"
"@end deffn"

#: api-regex.texi:170
msgid ""
"@lisp\n"
";; Regexp to match uppercase letters\n"
"(define r (make-regexp \"[A-Z]*\"))"
msgstr ""

#: api-regex.texi:173
msgid ""
";; Regexp to match letters, ignoring case\n"
"(define ri (make-regexp \"[A-Z]*\" regexp/icase))"
msgstr ""

#: api-regex.texi:177
msgid ""
";; Search for bob using regexp r\n"
"(match:substring (regexp-exec r \"bob\"))\n"
"@result{} \"\"                  ; no match"
msgstr ""

#: api-regex.texi:182
msgid ""
";; Search for bob using regexp ri\n"
"(match:substring (regexp-exec ri \"Bob\"))\n"
"@result{} \"Bob\"               ; matched case insensitive\n"
"@end lisp"
msgstr ""

#: api-regex.texi:188
msgid ""
"@deffn {Scheme Procedure} regexp? obj\n"
"@deffnx {C Function} scm_regexp_p (obj)\n"
"Return @code{#t} if @var{obj} is a compiled regular expression,\n"
"or @code{#f} otherwise.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} regexp? obj\n"
"@deffnx {C Function} scm_regexp_p (obj)\n"
"Возвращает @code{#t} если @var{obj} является скомпилированным регулярным\n"
"выражением или @code{#f} если это не так.\n"
"@end deffn"

#: api-regex.texi:195
msgid ""
"@sp 1\n"
"@deffn {Scheme Procedure} list-matches regexp str [flags]\n"
"Return a list of match structures which are the non-overlapping\n"
"matches of @var{regexp} in @var{str}.  @var{regexp} can be either a\n"
"pattern string or a compiled regexp.  The @var{flags} argument is as\n"
"per @code{regexp-exec} above."
msgstr ""
"@sp 1\n"
"@deffn {Scheme Procedure} list-matches regexp str [flags]\n"
"Возвращает список структур соответствия, которые являются не\n"
"перекрывающимися совпадениями регулярного выражения @var{regexp} с\n"
" @var{str}.  @var{regexp} может быть либо строкой шаблона, либо\n"
"скомпилированным регулярным выражением.  Аргумент @var{flags} \n"
"аналогичен рассказанному выше  @code{regexp-exec} ."

#: api-regex.texi:201
msgid ""
"@example\n"
"(map match:substring (list-matches \"[a-z]+\" \"abc 42 def 78\"))\n"
"@result{} (\"abc\" \"def\")\n"
"@end  example\n"
"@end deffn"
msgstr ""

#: api-regex.texi:207
msgid ""
"@deffn {Scheme Procedure} fold-matches regexp str init proc [flags]\n"
"Apply @var{proc} to the non-overlapping matches of @var{regexp} in\n"
"@var{str}, to build a result.  @var{regexp} can be either a pattern\n"
"string or a compiled regexp.  The @var{flags} argument is as per\n"
"@code{regexp-exec} above."
msgstr ""
"@deffn {Scheme Procedure} fold-matches regexp str init proc [flags]\n"
"Применяет @var{proc} к неперекрывающимся совпадениям @var{regexp} с\n"
"@var{str}, и выдает результат.  @var{regexp} может быть строкой \n"
"шаблона или скомпилированным регулярным выражением.  Аргумент @var{flags} \n"
"соответствует выше описанному @code{regexp-exec}."

#: api-regex.texi:213
msgid ""
"@var{proc} is called as @code{(@var{proc} match prev)} where\n"
"@var{match} is a match structure and @var{prev} is the previous return\n"
"from @var{proc}.  For the first call @var{prev} is the given\n"
"@var{init} parameter.  @code{fold-matches} returns the final value\n"
"from @var{proc}."
msgstr ""
"@var{proc} вызывается как: @code{(@var{proc} match prev)} где\n"
"@var{match} это структура соответствия и @var{prev} это предыдущие\n"
"возвраты из @var{proc}.  Для первого вызова @var{prev} используется\n"
"параметр @var{init}.  @code{fold-matches} возвращает окончательное\n"
"значение из @var{proc}."

#: api-regex.texi:215
msgid "For example to count matches,"
msgstr "Для примера посчитаем количество совпадений"

#: api-regex.texi:223
msgid ""
"@example\n"
"(fold-matches \"[a-z][0-9]\" \"abc x1 def y2\" 0\n"
"              (lambda (match count)\n"
"                (1+ count)))\n"
"@result{} 2\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-regex.texi:228
msgid ""
"@sp 1\n"
"Regular expressions are commonly used to find patterns in one string\n"
"and replace them with the contents of another string.  The following\n"
"functions are convenient ways to do this."
msgstr ""
"@sp 1\n"
"Регулярные выражения обычно используются для поиска шаблонов в одной\n"
"строке и их замены содержимым другой строки. Для этого удобны \n"
"следующие функции:"

#: api-regex.texi:234
msgid ""
"@c begin (scm-doc-string \"regex.scm\" \"regexp-substitute\")\n"
"@deffn {Scheme Procedure} regexp-substitute port match item @dots{}\n"
"Write to @var{port} selected parts of the match structure @var{match}.\n"
"Or if @var{port} is @code{#f} then form a string from those parts and\n"
"return that."
msgstr ""
"@c begin (scm-doc-string \"regex.scm\" \"regexp-substitute\")\n"
"@deffn {Scheme Procedure} regexp-substitute port match item @dots{}\n"
"Пишет в @var{port} выделенную часть совпадения структуры соответсвтия.\n"
"@var{match}.\n"
"Или если  @var{port} равен @code{#f} формирует строку из эти частей и\n"
"возвращает ее."

#: api-regex.texi:237
msgid ""
"Each @var{item} specifies a part to be written, and may be one of the\n"
"following,"
msgstr ""
"Каждый элемент @var{item} указывает часть, которая должна быть записана,\n"
"и может быть одним из следующих:"

#: api-regex.texi:241
msgid ""
"@itemize @bullet\n"
"@item\n"
"A string.  String arguments are written out verbatim."
msgstr ""
"@itemize @bullet\n"
"@item\n"
"Строка. Строковые аргументы вписываются дословно."

#: api-regex.texi:245
msgid ""
"@item\n"
"An integer.  The submatch with that number is written\n"
"(@code{match:substring}).  Zero is the entire match."
msgstr ""
"@item\n"
"Целое число.  Будет записано найденное соответствие с этим номером\n"
"(@code{match:substring}).  Если Ноль то это все соотвествие."

#: api-regex.texi:249
msgid ""
"@item\n"
"The symbol @samp{pre}.  The portion of the matched string preceding\n"
"the regexp match is written (@code{match:prefix})."
msgstr ""
"@item\n"
"Символ @samp{pre}.  Будт вписана часть совпадающей строки, преджествующая \n"
"регулярному выражению (@code{match:prefix})."

#: api-regex.texi:254
msgid ""
"@item\n"
"The symbol @samp{post}.  The portion of the matched string following\n"
"the regexp match is written (@code{match:suffix}).\n"
"@end itemize"
msgstr ""
"@item\n"
"Символ @samp{post}.  Будет вписана часть совпадающей строки стоящая после \n"
"соответствия регулярному выражению (@code{match:suffix}).\n"
"@end itemize"

#: api-regex.texi:256
msgid "For example, changing a match and retaining the text before and after,"
msgstr ""
"Для примера, изменяем найденное соответствие и сохраняем текст до и после\n"
"совпадения."

#: api-regex.texi:262
msgid ""
"@example\n"
"(regexp-substitute #f (string-match \"[0-9]+\" \"number 25 is good\")\n"
"                   'pre \"37\" 'post)\n"
"@result{} \"number 37 is good\"\n"
"@end example"
msgstr ""

#: api-regex.texi:265
msgid ""
"Or matching a @sc{yyyymmdd} format date such as @samp{20020828} and\n"
"re-ordering and hyphenating the fields."
msgstr ""
"Или сопоставление даты формата @sc{yyyymmdd} такой как @samp{20020828} и\n"
"реорганизация и перенос полей."

#: api-regex.texi:275
msgid ""
"@lisp\n"
"(define date-regex\n"
"   \"([0-9][0-9][0-9][0-9])([0-9][0-9])([0-9][0-9])\")\n"
"(define s \"Date 20020429 12am.\")\n"
"(regexp-substitute #f (string-match date-regex s)\n"
"                   'pre 2 \"-\" 3 \"-\" 1 'post \" (\" 0 \")\")\n"
"@result{} \"Date 04-29-2002 12am. (20020429)\"\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-regex.texi:284
msgid ""
"@c begin (scm-doc-string \"regex.scm\" \"regexp-substitute\")\n"
"@deffn {Scheme Procedure} regexp-substitute/global port regexp target "
"item@dots{}\n"
"@cindex search and replace\n"
"Write to @var{port} selected parts of matches of @var{regexp} in\n"
"@var{target}.  If @var{port} is @code{#f} then form a string from\n"
"those parts and return that.  @var{regexp} can be a string or a\n"
"compiled regex."
msgstr ""
"@c begin (scm-doc-string \"regex.scm\" \"regexp-substitute\")\n"
"@deffn {Scheme Procedure} regexp-substitute/global port regexp target "
"item@dots{}\n"
"@cindex search and replace\n"
"Пишет в @var{port} выбранные части совпадений регулярного\n"
"выражения @var{regexp} с @var{target}.  Если @var{port} равен @code{#f} \n"
"тогда формируется строка из этих частей и возвращается.  @var{regexp} может "
"быть\n"
"строкой или скомпилированным регулярным выражением."

#: api-regex.texi:288
msgid ""
"This is similar to @code{regexp-substitute}, but allows global\n"
"substitutions on @var{target}.  Each @var{item} behaves as per\n"
"@code{regexp-substitute}, with the following differences,"
msgstr ""
"Работает похоже на @code{regexp-substitute}, но позволяет\n"
"проводить глобальные подстановки в целевой строке @var{target}.\n"
"Каждый элемент @var{item} ведет себя так же как в функции\n"
"@code{regexp-substitute}, со следующими отличиями:"

#: api-regex.texi:294
msgid ""
"@itemize @bullet\n"
"@item\n"
"A function.  Called as @code{(@var{item} match)} with the match\n"
"structure for the @var{regexp} match, it should return a string to be\n"
"written to @var{port}."
msgstr ""
"@itemize @bullet\n"
"@item\n"
"Функция.  Вызывается как @code{(@var{item} match)} с параметром\n"
"структурой соответствия регулярному выражению @var{regexp}, \n"
"она должна вернуть строку которая и будет записана в порт @var{port}.\n"

#: api-regex.texi:299
msgid ""
"@item\n"
"The symbol @samp{post}.  This doesn't output anything, but instead\n"
"causes @code{regexp-substitute/global} to recurse on the unmatched\n"
"portion of @var{target}."
msgstr ""
"@item\n"
"Символ @samp{post}.  Здесь он ничего не выводит, а вместо этого\n"
"вызывает рекурсивно @code{regexp-substitute/global} для оставшейся\n"
"части @var{target}."

#: api-regex.texi:304
msgid ""
"This @emph{must} be supplied to perform a global search and replace on\n"
"@var{target}; without it @code{regexp-substitute/global} returns after\n"
"a single match and output.\n"
"@end itemize"
msgstr ""
"Это необходимо для выполнения глобального поиска и замены на входной\n"
"строке @var{target}; без этого @code{regexp-substitute/global} делает\n"
"возврат после одного совпадения и вывода.\n"
"@end itemize"

#: api-regex.texi:307
msgid ""
"For example, to collapse runs of tabs and spaces to a single hyphen\n"
"each,"
msgstr ""
"Например, чтобы свернуть все последовательности табуляций и пробелов\n"
"в один дефис(для каждой последовательности)"

#: api-regex.texi:313
msgid ""
"@example\n"
"(regexp-substitute/global #f \"[ \\t]+\"  \"this   is   the text\"\n"
"                          'pre \"-\" 'post)\n"
"@result{} \"this-is-the-text\"\n"
"@end example"
msgstr ""

#: api-regex.texi:315
msgid "Or using a function to reverse the letters in each word,"
msgstr ""
"Или что бы использовать функцию reverse, что бы переставить буквы\n"
"в каждом слове."

#: api-regex.texi:321
msgid ""
"@example\n"
"(regexp-substitute/global #f \"[a-z]+\"  \"to do and not-do\"\n"
"  'pre (lambda (m) (string-reverse (match:substring m))) 'post)\n"
"@result{} \"ot od dna ton-od\"\n"
"@end example"
msgstr ""

#: api-regex.texi:326
msgid ""
"Without the @code{post} symbol, just one regexp match is made.  For\n"
"example the following is the date example from\n"
"@code{regexp-substitute} above, without the need for the separate\n"
"@code{string-match} call."
msgstr ""
"Без символа @code{post}, выполняется только одно регулярное совпадение.\n"
"Например, следующее: для даты из указанного выше @code{regexp-substitute},\n"
"отдельного строкового вызова @code{string-match}."

#: api-regex.texi:333
msgid ""
"@lisp\n"
"(define date-regex \n"
"   \"([0-9][0-9][0-9][0-9])([0-9][0-9])([0-9][0-9])\")\n"
"(define s \"Date 20020429 12am.\")\n"
"(regexp-substitute/global #f date-regex s\n"
"                          'pre 2 \"-\" 3 \"-\" 1 'post \" (\" 0 \")\")"
msgstr ""

#: api-regex.texi:337
msgid ""
"@result{} \"Date 04-29-2002 12am. (20020429)\"\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-regex.texi:341
msgid ""
"@node Match Structures\n"
"@subsection Match Structures"
msgstr ""

#: api-regex.texi:343
msgid "@cindex match structures"
msgstr ""

#: api-regex.texi:351
msgid ""
"A @dfn{match structure} is the object returned by @code{string-match} and\n"
"@code{regexp-exec}.  It describes which portion of a string, if any,\n"
"matched the given regular expression.  Match structures include: a\n"
"reference to the string that was checked for matches; the starting and\n"
"ending positions of the regexp match; and, if the regexp included any\n"
"parenthesized subexpressions, the starting and ending positions of each\n"
"submatch."
msgstr ""
"Структура соответствия (@dfn{match structure}) это объек, возвращаемый\n"
"@code{string-match} и @code{regexp-exec}.  Он описывает какая часть строки,\n"
"если таковая имеется, соответствует данному регулярному выражению.\n"
"Структура соответствия включает: ссылку на строку, которая была проверена \n"
"на сответствие, начальную и конечную позицию совпадения с регулярным \n"
"выражением, и если регулярное выражение содержит любые подвыражения в \n"
"скобках, начальную и конечную позицию каждого совпадения с этими \n"
"подвыражениями."

#: api-regex.texi:358
msgid ""
"In each of the regexp match functions described below, the @code{match}\n"
"argument must be a match structure returned by a previous call to\n"
"@code{string-match} or @code{regexp-exec}.  Most of these functions\n"
"return some information about the original target string that was\n"
"matched against a regular expression; we will call that string\n"
"@var{target} for easy reference."
msgstr ""
"В каждой из функций соответствия регулярному выражению, описанных ниже,\n"
"аргумент соответствия должен быть структурой сопоставления, возвращенной\n"
"предыдущим вызовом @code{string-match} или @code{regexp-exec}. Большинство\n"
"этих функций возвращают некоторую информацию об исходной строке, которая\n"
"была сопоставлена с регулярным выражением; мы будем называть эту строку\n"
"целевой (@var{target}) для простоты обращения."

#: api-regex.texi:364
msgid ""
"@c begin (scm-doc-string \"regex.scm\" \"regexp-match?\")\n"
"@deffn {Scheme Procedure} regexp-match? obj\n"
"Return @code{#t} if @var{obj} is a match structure returned by a\n"
"previous call to @code{regexp-exec}, or @code{#f} otherwise.\n"
"@end deffn"
msgstr ""
"@c begin (scm-doc-string \"regex.scm\" \"regexp-match?\")\n"
"@deffn {Scheme Procedure} regexp-match? obj\n"
"Возвращает @code{#t} если @var{obj} является структурой соответствия\n"
"возвращенной предыдущим вызовом @code{regexp-exec}, если нет @code{#f}.\n"
"@end deffn"

#: api-regex.texi:372
msgid ""
"@c begin (scm-doc-string \"regex.scm\" \"match:substring\")\n"
"@deffn {Scheme Procedure} match:substring match [n]\n"
"Return the portion of @var{target} matched by subexpression number\n"
"@var{n}.  Submatch 0 (the default) represents the entire regexp match.\n"
"If the regular expression as a whole matched, but the subexpression\n"
"number @var{n} did not match, return @code{#f}.\n"
"@end deffn"
msgstr ""
"@c begin (scm-doc-string \"regex.scm\" \"match:substring\")\n"
"@deffn {Scheme Procedure} match:substring match [n]\n"
"Возвращает часть целевой строки@var{target} соответствующую номеру\n"
"подвыражения @var{n}.  Подвыражение 0 (по умолчанию) представляет\n"
"полное совпадение регулярного выражения. Если регулярное выражение\n"
"в целом сопоставлено, но число подвыражений не @var{n} не совпало,\n"
"возвращается @code{#f}.\n"
"@end deffn"

#: api-regex.texi:377
msgid ""
"@lisp\n"
"(define s (string-match \"[0-9][0-9][0-9][0-9]\" \"blah2002foo\"))\n"
"(match:substring s)\n"
"@result{} \"2002\""
msgstr ""

#: api-regex.texi:383
msgid ""
";; match starting at offset 6 in the string\n"
"(match:substring\n"
"  (string-match \"[0-9][0-9][0-9][0-9]\" \"blah987654\" 6))\n"
"@result{} \"7654\"\n"
"@end lisp"
msgstr ""

#: api-regex.texi:388
msgid ""
"@c begin (scm-doc-string \"regex.scm\" \"match:start\")\n"
"@deffn {Scheme Procedure} match:start match [n]\n"
"Return the starting position of submatch number @var{n}.\n"
"@end deffn"
msgstr ""
"@c begin (scm-doc-string \"regex.scm\" \"match:start\")\n"
"@deffn {Scheme Procedure} match:start match [n]\n"
"Возвращает начальную позицию совпадения с подвыражением\n"
"@var{n}.\n"
"@end deffn"

#: api-regex.texi:391
msgid ""
"In the following example, the result is 4, since the match starts at\n"
"character index 4:"
msgstr ""
"В последующем примере результат равен 4, так как совпадение начинается\n"
"с символа с численным индексом 4:"

#: api-regex.texi:397
msgid ""
"@lisp\n"
"(define s (string-match \"[0-9][0-9][0-9][0-9]\" \"blah2002foo\"))\n"
"(match:start s)\n"
"@result{} 4\n"
"@end lisp"
msgstr ""

#: api-regex.texi:402
msgid ""
"@c begin (scm-doc-string \"regex.scm\" \"match:end\")\n"
"@deffn {Scheme Procedure} match:end match [n]\n"
"Return the ending position of submatch number @var{n}.\n"
"@end deffn"
msgstr ""
"@c begin (scm-doc-string \"regex.scm\" \"match:end\")\n"
"@deffn {Scheme Procedure} match:end match [n]\n"
"Возвращает конечную позицию совпадения с подвыражением @var{n}.\n"
"@end deffn"

#: api-regex.texi:405
msgid ""
"In the following example, the result is 8, since the match runs between\n"
"characters 4 and 8 (i.e.@: the ``2002'')."
msgstr ""
"In the following example, the result is 8, since the match runs between\n"
"characters 4 and 8 (т.е.@: ``2002'')"

#: api-regex.texi:411
msgid ""
"@lisp\n"
"(define s (string-match \"[0-9][0-9][0-9][0-9]\" \"blah2002foo\"))\n"
"(match:end s)\n"
"@result{} 8\n"
"@end lisp"
msgstr ""

#: api-regex.texi:415
msgid ""
"@c begin (scm-doc-string \"regex.scm\" \"match:prefix\")\n"
"@deffn {Scheme Procedure} match:prefix match\n"
"Return the unmatched portion of @var{target} preceding the regexp match."
msgstr ""
"@c begin (scm-doc-string \"regex.scm\" \"match:prefix\")\n"
"@deffn {Scheme Procedure} match:prefix match\n"
"Возвращет не совпавшую часть целевой строки @var{target} предшествующую\n"
"совпадению с регулярным выражением."

#: api-regex.texi:422
msgid ""
"@lisp\n"
"(define s (string-match \"[0-9][0-9][0-9][0-9]\" \"blah2002foo\"))\n"
"(match:prefix s)\n"
"@result{} \"blah\"\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-regex.texi:427
msgid ""
"@c begin (scm-doc-string \"regex.scm\" \"match:suffix\")\n"
"@deffn {Scheme Procedure} match:suffix match\n"
"Return the unmatched portion of @var{target} following the regexp match.\n"
"@end deffn"
msgstr ""
"@c begin (scm-doc-string \"regex.scm\" \"match:suffix\")\n"
"@deffn {Scheme Procedure} match:suffix match\n"
"Возвращает несовпавшую часть целевой строки @var{target} следующую\n"
"за совпадением с регулярным выражением.\n"
"@end deffn"

#: api-regex.texi:433
msgid ""
"@lisp\n"
"(define s (string-match \"[0-9][0-9][0-9][0-9]\" \"blah2002foo\"))\n"
"(match:suffix s)\n"
"@result{} \"foo\"\n"
"@end lisp"
msgstr ""

#: api-regex.texi:440
msgid ""
"@c begin (scm-doc-string \"regex.scm\" \"match:count\")\n"
"@deffn {Scheme Procedure} match:count match\n"
"Return the number of parenthesized subexpressions from @var{match}.\n"
"Note that the entire regular expression match itself counts as a\n"
"subexpression, and failed submatches are included in the count.\n"
"@end deffn"
msgstr ""
"@c begin (scm-doc-string \"regex.scm\" \"match:count\")\n"
"@deffn {Scheme Procedure} match:count match\n"
"Возвращает количество совпавших подвыражений в скобках из @var{match}.\n"
"Обратите внимание, что полное совпадение с регулярным выражением считается\n"
"также совпавшим подвыражением, а неудачные подвыражения также включены\n"
"в счет.\n"
"@end deffn"

#: api-regex.texi:445
msgid ""
"@c begin (scm-doc-string \"regex.scm\" \"match:string\")\n"
"@deffn {Scheme Procedure} match:string match\n"
"Return the original @var{target} string.\n"
"@end deffn"
msgstr ""
"@c begin (scm-doc-string \"regex.scm\" \"match:string\")\n"
"@deffn {Scheme Procedure} match:string match\n"
"Возвращает исходную целевую строку @var{target}.\n"
"@end deffn"

#: api-regex.texi:451
msgid ""
"@lisp\n"
"(define s (string-match \"[0-9][0-9][0-9][0-9]\" \"blah2002foo\"))\n"
"(match:string s)\n"
"@result{} \"blah2002foo\"\n"
"@end lisp"
msgstr ""

#: api-regex.texi:455
msgid ""
"@node Backslash Escapes\n"
"@subsection Backslash Escapes"
msgstr ""

#: api-regex.texi:463
msgid ""
"Sometimes you will want a regexp to match characters like @samp{*} or\n"
"@samp{$} exactly.  For example, to check whether a particular string\n"
"represents a menu entry from an Info node, it would be useful to match\n"
"it against a regexp like @samp{^* [^:]*::}.  However, this won't work;\n"
"because the asterisk is a metacharacter, it won't match the @samp{*} at\n"
"the beginning of the string.  In this case, we want to make the first\n"
"asterisk un-magic."
msgstr ""
"Иногда вам нужно, что бы регулярное выражение соответствовало символам\n"
"типа @samp{*} или @samp{$}.  Например, чтобы проверить, указывает ли\n"
"конкретная строка на запись меню из узла Info, ее нужно будет сопоставить\n"
"с регулярным выражением, например:  @samp{^* [^:]*::}.  Однако это не \n"
"сработает, так как звездочка является метасимволом, она не будет \n"
"соответствовать симовлу @samp{*} в начале строки.  В нашем случае\n"
"мы хотим чтобы первая звездочка была обычным символом."

#: api-regex.texi:473
msgid ""
"You can do this by preceding the metacharacter with a backslash\n"
"character @samp{\\}.  (This is also called @dfn{quoting} the\n"
"metacharacter, and is known as a @dfn{backslash escape}.)  When Guile\n"
"sees a backslash in a regular expression, it considers the following\n"
"glyph to be an ordinary character, no matter what special meaning it\n"
"would ordinarily have.  Therefore, we can make the above example work by\n"
"changing the regexp to @samp{^\\* [^:]*::}.  The @samp{\\*} sequence tells\n"
"the regular expression engine to match only a single asterisk in the\n"
"target string."
msgstr ""
"Вы можете сделать это указав метасимвол с символом обратной косой черты\n"
"@samp{\\}.  (Это так называемое цитирование метасимвола @dfn{quoting}, \n"
"и известное как @dfn{backslash escape}.)  Когда Guile видит обратную\n"
"косую черту в регулярном выражении, он считает, что следующий символ\n"
"является обычным, не зависимо от того какой особый смысл он обычно имеет.\n"
"Поэтому мы можем выполнить описанный выше пример, изменив регулярное \n"
"выражение на @samp{^\\* [^:]*::}.  Последовательность @samp{\\*} сообщает\n"
"движку регулярных выражений что соответствие должно быть одной звездочке\n"
"в обрабатываемой стоке."

#: api-regex.texi:481
msgid ""
"Since the backslash is itself a metacharacter, you may force a regexp to\n"
"match a backslash in the target string by preceding the backslash with\n"
"itself.  For example, to find variable references in a @TeX{} program,\n"
"you might want to find occurrences of the string @samp{\\let\\} followed\n"
"by any number of alphabetic characters.  The regular expression\n"
"@samp{\\\\let\\\\[A-Za-z]*} would do this: the double backslashes in the\n"
"regexp each match a single backslash in the target string."
msgstr ""
"Поскольку обратная косая черта сама по себе является метасимволом,\n"
"вы можете заставить регулярное выражение соответствовать обратной\n"
"косой черте в обрабатываемой строке, предваряя обратную косую черту\n"
"самой собой(обратной косой чертой).  Например, чтобы найти переменную\n"
"ссылки в программе @TeX{}, вам может потребоваться найти вхождения\n"
"строки @samp{\\let\\} следующим за ним любым количеством символов.\n"
"Регулярное выражение @samp{\\\\let\\\\[A-Za-z]*} будет делать это: \n"
"двойная обратная косая черта в регулярном выражении соответствует\n"
"обычной одиночной косой черте в обрабатываемой строке."

#: api-regex.texi:487
msgid ""
"@c begin (scm-doc-string \"regex.scm\" \"regexp-quote\")\n"
"@deffn {Scheme Procedure} regexp-quote str\n"
"Quote each special character found in @var{str} with a backslash, and\n"
"return the resulting string.\n"
"@end deffn"
msgstr ""
"@c begin (scm-doc-string \"regex.scm\" \"regexp-quote\")\n"
"@deffn {Scheme Procedure} regexp-quote str\n"
"Предваряет каждый специальный символ в  @var{str} обратной косой чертой\n"
"и возвращает строковый результат.\n"
"@end deffn"

#: api-regex.texi:499
msgid ""
"@strong{Very important:} Using backslash escapes in Guile source code\n"
"(as in Emacs Lisp or C) can be tricky, because the backslash character\n"
"has special meaning for the Guile reader.  For example, if Guile\n"
"encounters the character sequence @samp{\\n} in the middle of a string\n"
"while processing Scheme code, it replaces those characters with a\n"
"newline character.  Similarly, the character sequence @samp{\\t} is\n"
"replaced by a horizontal tab.  Several of these @dfn{escape sequences}\n"
"are processed by the Guile reader before your code is executed.\n"
"Unrecognized escape sequences are ignored: if the characters @samp{\\*}\n"
"appear in a string, they will be translated to the single character\n"
"@samp{*}."
msgstr ""
"@strong{Очень важно:} Использование обратной косой черты в исходном коде\n"
"Guile source (как в Emacs Lisp или C) может быть сложным, потому что\n"
"символ обратной косой черты имеет особое значение для Guile.\n"
"Например, если Guile встречает последовательность символов @samp{\\n}\n"
"в середине строки, в то время как обрабатывается код Scheme, он заменяет\n"
"эти символы символом новой строки.  Аналогичным образом, последовательность\n"
"символов @samp{\\t} заменяется символом табуляции.  Некоторые из этих\n"
"@dfn{escape последовательностей} обрабатываются Guile до того как ваш\n"
"код будет выполнен. Неопознанные управляющие последовательности "
"игнорируются:\n"
"если символ @samp{\\*} появляется в строке он будет переведен в одиночный\n"
"символ @samp{*}."

#: api-regex.texi:505
msgid ""
"This translation is obviously undesirable for regular expressions, since\n"
"we want to be able to include backslashes in a string in order to\n"
"escape regexp metacharacters.  Therefore, to make sure that a backslash\n"
"is preserved in a string in your Guile program, you must use @emph{two}\n"
"consecutive backslashes:"
msgstr ""
"Эта трансляция явно нежелательна для регулярных выражений, поскольку\n"
"мы хотим включать обратную косую черту в строку, чтобы экранировать\n"
"метасимволы в регулярном выражении. Следовательно, чтобы убедиться,\n"
"что обратная косая черта сохраняется в вашей программе Guile, вы\n"
"должны использовать две последовательные обратные косые черты."

#: api-regex.texi:509
msgid ""
"@lisp\n"
"(define Info-menu-entry-pattern (make-regexp \"^\\\\* [^:]*\"))\n"
"@end lisp"
msgstr ""

#: api-regex.texi:513
msgid ""
"The string in this example is preprocessed by the Guile reader before\n"
"any code is executed.  The resulting argument to @code{make-regexp} is\n"
"the string @samp{^\\* [^:]*}, which is what we really want."
msgstr ""
"Строка в этом примере предварительно обрабатывается клиентом Guile\n"
"перед выполнением любого кода.  Результирующим аргументом\n"
"@code{make-regexp} будет строка @samp{^\\* [^:]*}, что нам и надо."

#: api-regex.texi:520
msgid ""
"This also means that in order to write a regular expression that matches\n"
"a single backslash character, the regular expression string in the\n"
"source code must include @emph{four} backslashes.  Each consecutive pair\n"
"of backslashes gets translated by the Guile reader to a single\n"
"backslash, and the resulting double-backslash is interpreted by the\n"
"regexp engine as matching a single backslash character.  Hence:"
msgstr ""
"Это также означает, что для того, чтобы написать регулярное выражение,\n"
"которое соответствует одному символу обратной косой черты, строка\n"
"регулярного выражения должна включать в себя ЧЕТЫРЕ!!!! обратных\n"
"косых черты. Каждая последовательная пара обратных косых черт\n"
"переводиться Guile на одиночную обратную косую черту, и полученая\n"
"двойная обратная косая черта интерпретируется движком regexp как\n"
"сопоставление с одним символом обратной косой черты. Следовательно:"

#: api-regex.texi:524
msgid ""
"@lisp\n"
"(define tex-variable-pattern (make-regexp \"\\\\\\\\let\\\\\\\\=[A-Za-z]*"
"\"))\n"
"@end lisp"
msgstr ""

#: api-regex.texi:534
msgid ""
"The reason for the unwieldiness of this syntax is historical.  Both\n"
"regular expression pattern matchers and Unix string processing systems\n"
"have traditionally used backslashes with the special meanings\n"
"described above.  The POSIX regular expression specification and ANSI C\n"
"standard both require these semantics.  Attempting to abandon either\n"
"convention would cause other kinds of compatibility problems, possibly\n"
"more severe ones.  Therefore, without extending the Scheme reader to\n"
"support strings with different quoting conventions (an ungainly and\n"
"confusing extension when implemented in other languages), we must adhere\n"
"to this cumbersome escape syntax."
msgstr ""
"Причина громоздкости этого синтаксиса является исторической. Обе системы:\n"
"построения шаблонов регулярных выражений и система обработки строк Unix\n"
"традиционно использовали обратную косую черту со специальными назначением,\n"
"описанным выше. Спецификация регулярного выражения POSIX и стандарт ANSI C\n"
"требуют этой семантики. Попытка отказаться от любой конвенции может вызвать\n"
"другие проблемы совместимости, возможно более серьезные. Следовательно,\n"
"без расширения программы Scheme для поддержки различными соглашениями\n"
"о квотировании(экранировании) (неуправляемое и запутанное расширение, когда\n"
"оно реализуется на других языках) мы должны придерживаться этого "
"громоздкого\n"
"escape синтаксиса."
