@c -*-texinfo-*-
@c This is part of the GNU Guile Reference Manual.
@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2014
@c   Free Software Foundation, Inc.
@c See the file guile.texi for copying conditions.

@node Programming Overview
@section Обзор программирования на Guile

Guile разработан как интерпретируемый язык расширения, который легко
интегрируется с приложениями написанными на Си(и Си++).
Большая победа здесь для разработчика приложений заключается в том, 
что интеграция Guile, как говорит веб страница, ``снижает энергию хактивации
(взлома) вашего проекта.''  Снижение энергии взлома означет, что вы как
разработчик приложения и ваши пользователи, воспользуются преимуществами
которые вытекают из возможности расширить приложение в языке расширения
высокого уровня, а не просто старым Си.

В абстрактных терминах трудно объяснить, что на самом деле означает и что
включает в себя этот процесс интеграции, поэтому вместо этого давайте
начнем с того что прыгнем прямо в пример того как вы можете интегрировать
Guile в существующую программу и то, что вы могли бы ожидать от этого.
В этом примере под нашими поясами, мы вернемся к более общему анализу
аргументов и диапазону доступных вариантов программирования.

@menu
* Extending Dia::               How one might extend Dia using Guile.
* Scheme vs C::                 Why Scheme is more hackable than C.
* Testbed Example::             Example: using Guile in a testbed.
* Programming Options::         Options for Guile programming.
* User Programming::            How about application users?
@end menu

@node Extending Dia
@subsection Как можно расширить Dia используя Guile

Dia это свободная программа для создания схемных диаграмм, таких как
блок-схемы и планы комнат (@uref{http://www.gnome.org/projects/dia/}).
Этот раздел ведет мысленный эксперимент добавления Guile в Dia.  
При этом он призван проилюстрировать некотоыре из этапов и соображения,
связанные с добавлением Guile к приложениям в целом.

@menu
* Dia Objective::               Deciding why you want to add Guile.
* Dia Steps::                   Four steps required to add Guile.
* Dia Objects::                 How to represent Dia data in Scheme.
* Dia Primitives::              Writing Guile primitives for Dia.
* Dia Hook::                    Providing a hook for Scheme evaluation.
* Dia Structure::               Overall structure for adding Guile.
* Dia Advanced::                Going further with Dia and Guile.
@end menu

@node Dia Objective
@subsubsection Решите, почему вы хотите добавить Guile

Прежде всего, вы должны понять, почему вы хотите добавить Guile в Dia вообще,
и это означает, сформировать картину того, что делает Dia и как она это
делает. Итак, каковы составляющие приложения Dia?

@itemize @bullet
@item
Самое главное, объекты домена приложения(@dfn{application domain objects})
 --- другими словами, концепции, которые отличают Dia от других приложений,
например текстовых процессоров или таблиц: формы, шаблоны, коннекторы,
страницы, а также свойства всех этих вещей.

@item
Код, управляющий графическим интерфейсом приложения, включающий размещение
и отображение указанных выше объектов.

@item
Код, который обрабатывает входные события, которые указывают, что пользователь
приложения хочет что-то сделать.
@end itemize

@noindent
(Другими словами, учебник примера парадигмы модель-вид-контроллер
(@dfn{model - view - controller}).)

Следующий вопрос: как Dia будет полезен после завершения интеграции с Guile?
Возможны несколько (пложительных!) ответов и выбор, очевидно, зависит от 
приложения разработчиков. Тем не менее, один ответ заключается в том, что
основным преимуществом будет способность манипулировать объектами домена
Dia приложения из Scheme.

Предположим, что Dia сделал набор процедур доступных в Scheme,
представляющих наиболее основные операции над объектами, такими как
фигуры, коннекторы и т.д. Используя Scheme, пользователь приложения
может затем написать код, который основывается на этих операциях для
создания более сложных процедур. Например, при базовых процедурах
перечисления объектов на странице, чтобы определить, является ли объект
квадратом, и изменить шаблон заполнения единичной фигуры, пользователь
может написать процедуру Scheme, чтобы изменить шаблон заполнения всех
квадратов на текущей странице.

@lisp
(define (change-squares'-fill-pattern new-pattern)
  (for-each-shape current-page
    (lambda (shape)
      (if (square? shape)
          (change-fill-pattern shape new-pattern)))))
@end lisp

@node Dia Steps
@subsubsection Четыре шага необходимых для добавления Guile

Предполагая эту цель, для ее достижения необходимы четыре шага.

Во-первых. вам нужен способ предоставления ваших объектов, специфичных
для приложения, таких как @code{shape} в предыдущем примере, когда они
передаются в мир Scheme.  Если объекты настолько просты, что они 
естественным образом отображают встроенные типы данных Scheme, такие как
числа и строки, вы вероятно захотите использовать интерфейс внешних
объектов(@dfn{foreign object}) Guile для создания нового типа данных
 Scheme для ваших объектов.

Во-вторых, вам нужно написать код для основных операций, таких как
@code{for-each-shape} и @code{square?} чтобы они имели доступ и
управляли вашими существующими структурами данных. Затем сделайте
эти операции доступными как примитивы(@dfn{primitives}) на уровне
Scheme.

В-третьих, вам необходимо предоставить некоторый механизм в приложении
Dia, который пользователь может подключить, чтобы вызвать произвольный 
код Scheme для вычисления.

Наконец, вам нужно немного перестроить свой Си код верхнего уровня
приложения, чтобы он правильно инициализировал интерпретатор Guile и
объявлял ваши внешние объекты(@dfn{foreign objects}) и примитивы(@dfn{primitives})
в мире Scheme.

Следующие подразделы в свою очередь расширяются по этим четырем
пунктам.

@node Dia Objects
@subsubsection Как представлять данные Dia в Scheme

Для всех, кроме самых тривиальных приложений, вы, вероятно, захотите разрешить
представление объектов домена вашего приложения на уровне Scheme. Здесь
появляются внешние объекты(foreign objects) и связанные с ними вопросы управления
их жизненным циклом и сборкой мусора.

Чтобы получить более конкретную информацию об этом, давайте еще раз взглянем
на пример, который мы дали ранее о том, как пользователи приложения могут
использовать Guile для создания функций более высокого уровня из примитивов,
которые обеспечивает сам Dia.

@lisp
(define (change-squares'-fill-pattern new-pattern)
  (for-each-shape current-page
    (lambda (shape)
      (if (square? shape)
          (change-fill-pattern shape new-pattern)))))
@end lisp

Рассмотрим, что здесь храниться в переменной @code{shape}.  Для каждой
фигуры(shape) на текущей странице примитив @code{for-each-shape} вызывает
лямбда-функцию @code{(lambda (shape) @dots{})} с аргументом, представляющим
фигуру(shape).  Вопрос: как этот аргумент представлен на уровне Scheme?
Проблемы являются следующими.

@itemize @bullet
@item
Каким бы ни было представление, оно должно быть снова декодировано кодом
Си для примитивов @code{square?} и @code{change-fill-pattern}.  Другими
словами, примитивы такие как @code{square?} имеет возможность, так или
иначе, превратить значение, которое оно получает обратно во что-то,
что указывает путь к базовой Си структуре, описывающей фигуру.

@item
Представление также должно справляться с тем, что код Scheme удерживает
значения для дальнейшего использования. Что произойдет, если код Scheme
сохранит @code{shape} в глобальной переменной, но когда эта фигура(shape)
удаляется(таким образом, что код Scheme не знает об этом) и затем некоторый
другой код Scheme снова использует эту глобальную переменную в вызове,
скажем в @code{square?}?

@item
Время жизни и распределение памяти объектов, которые существуют только
в мире Scheme управляются автоматически сборщиком мусора Guile, используя
только одно простое правило: когда нет никаких ссылок на объект, объект
считается мертвым и поэтому его память освобождается. Но для объектов,
которые существуют как в Си так и в Scheme, расклад более сложный; в случае
с Dia, где аргумент @code{shape} передается туда и и обратно в мире Scheme,
было бы совершенно не правильно удалять Си фигуры только потому, что код
Scheme завершил выполнение. Как избежать этого?
@end itemize

Одно из решений этих вопросов заключается в представлении фигуры(shape) на
уровне Scheme новой, Scheme-специфичной Си структурой обернутой в качестве
внешнего объекта. Внешний объект, что передается в код и выводиться из кода
Scheme и Scheme-специфичная Си структура внутри внешнего объекта указывает
на лежащую в их основе Си структуру Dia, так что код для примитивов, таких
как @code{square?} может получить ее.

Чтобы справиться с удалением фигуры, в то время как код Scheme все еще
хранит значение фигуры, базовая Си структура должна иметь новое поле,
которое указывает на Scheme-специфичный внешний объект. Когда фигура
удаляется, соответствую код по цепочке к Scheme-специфичномой структуре
и устанавливает этот обратный указатель на базовую структуру в NULL.  Таким
образом, значение внешнего объекта для фигуры продолжает существовать, но 
любой код примитивов, которые попытается ее использовать, обнаружит, что
базовая фигура была удалена, поскольку указатель базовой стурктуры - NULL.

Итак, суммируем шаги, связанные с этим решением проблемы 
(и предполагая, что базовой структурой Си для фигуры является
@code{struct dia_shape}):

@itemize @bullet
@item
Определим новую Scheme-специфичную структуру которая указывает(@emph{points})
на базовую Си структуру:

@lisp
struct dia_guile_shape
@{
  struct dia_shape * c_shape;   /* NULL => deleted */
@}
@end lisp

@item
Добавим поле в @code{struct dia_shape}, которое указывает на Scheme-специфичную
структуру @code{struct dia_guile_shape}, если оно одно ---

@lisp
struct dia_shape
@{
  @dots{}
  struct dia_guile_shape * guile_shape;
@}
@end lisp

@noindent
--- так что Си код может установить @code{guile_shape->c_shape} в NULL когда
базовая фигура удаляется.

@item
Обернем @code{struct dia_guile_shape} как тип внешнего объекта(foreign object).

@item
Всякий раз, когда вам нужно представить Си фигуру на Scheme уровне, создавайте
экземпляр внешнего объекта для нее и передавайте его.

@item
В коде примитивов, который получает экземпляр внешнего объекта фигуры, проверяйте
поле @code{c_shape} при его расшифровке, чтобы выяснить, продолжает ли сущетсвовать
лежащая в его основе базовая Си фигура.
@end itemize

Что касается управления памятью, значения внешний объектов и их
Scheme-специфичные структуры находятся под управлением сборщика мусора,
тогда как базовые Си структуры явно управляются точно также, как Dia
управляла бы ими до того как мы подумали о добавлении Guile.

Когда сборщик мусора решает освободить значение внешнего объкта фигуры,
он вызывает функцию @dfn{finalizer} которая была указана при определении
типа внешнего объекта фигуры. Поддерживать правильность поля
@code{guile_shape} в базоваой Си структуре, эта функция должна перейти
к базовой сруктуре Си(если она еще существует) и установить ее поле 
@code{guile_shape} в NULL.

Полную документацию по определению и использованию типов внешних объектов
см. @ref{Defining New Foreign Object Types}.

@node Dia Primitives
@subsubsection Написание примитивов Guile для Dia

Как только будут определены детали представления объекта, написание кода
примитивной функции которая вам нужна, как правило, очень просто.

Примитив это просто Си функция, аргументы и возвращаемые значение которой
имеют тип @code{SCM}, и чье тело делает то что вы хотите. В качестве примера
можно привести реализацию примитива @code{square?}:

@lisp
static SCM square_p (SCM shape)
@{
  struct dia_guile_shape * guile_shape;

  /* Check that arg is really a shape object. */
  scm_assert_foreign_object_type (shape_type, shape);

  /* Access Scheme-specific shape structure. */
  guile_shape = scm_foreign_object_ref (shape, 0);

  /* Find out if underlying shape exists and is a
     square; return answer as a Scheme boolean. */
  return scm_from_bool (guile_shape->c_shape &&
                        (guile_shape->c_shape->type == DIA_SQUARE));
@}
@end lisp

Обратите внимание на то, как легко перейти из параметра @code{SCM shape}
который принимает @code{square_p} --- который является внешним объектом
--- к Scheme-специфичной структуре внутри внешнего объекта, а оттуда и
к базовой Си структуре фигуры.

В этом коде @code{scm_assert_foreign_object_type},
@code{scm_foreign_object_ref} и @code{scm_from_bool} из стандартного 
Guile API.  Мы преполагаем, что @code{shape_type} был доступен нам когда
мы создали форму внешнего объекта используя @code{scm_make_foreign_object_type}.
Вызов @code{scm_assert_foreign_object_type} гарантирует, что @var{shape} 
действительноis является фигурой.  Это необходимо для защиты кода Scheme,
использование процедуры @code{square?}  не корретно, как в форме @code{(square? "hello")};
Скрытая типизация в Scheme означает, что такие ошибки использования должнф быть пойманы
во время выполнения.

Написав код Си для ваших примитивов, вы должны сделать их доступными
как процедуры Scheme вызывая функцию @code{scm_c_define_gsubr}. 
@code{scm_c_define_gsubr} (@pxref{Primitive Procedures})
принимает аргументы, которые определяются на уровне Scheme по имени
примитива и количеству требуемых аргументов, необязательных и остальных
аргументов которые функция может принять. Примитив @code{square?} всегда
требует только один аргумент, пэтому вызов делающий его доступным
в Scheme, читается следующим образом:

@lisp
scm_c_define_gsubr ("square?", 1, 0, 0, square_p);
@end lisp

Где поставить этот вызов, смотри подраздел ниже, следующий за структурой
доступа к Guile коду (@pxref{Dia Structure}).

@node Dia Hook
@subsubsection Предоставление хука для выполнения кода Scheme

Чтобы сделать интеграцию Guile полезной, вы должны создать какой-то хук в 
своем приложении, который пользователи приложения могли бы использовать
для выполнения кода Scheme.

Технически это просто; вам просто нужно принять решение о механизме, который
подходит для вашего приложения. Подумайте о Emacs, например, когда вы вводите
@kbd{@key{ESC} :}, вы получаете подсказку, в которой вы можете ввести любой
код Elisp, который затем выполнит Emacs.  Или, снова, как в Emacs, вы можете
предоставить механизм(такой как файл инициализации), чтобы позволить коду
Scheme, который должен быть связан с определенной последовательностью клавиш и
выполнять этот код, когда вводиться эта последовательность клавиш.

В любом случае, если у вас есть код Scheme, который вы хотите выполнять,
как строку оканчивающуюся нулем, вы можете сказать Guile выполнить ее, 
вызывая функцию @code{scm_c_eval_string}.

@node Dia Structure
@subsubsection Структура верхнего уровня доступа Guile в Dia

Предположим, что код пред - Guile Dia выглядит структурно следующим образом:

@itemize @bullet
@item
@code{main ()}

@itemize @bullet
@item
делает много операций инициализации и настройки
@item
вход в основной цикл обработки сообщений Gtk
@end itemize
@end itemize

Когда вы добавляете Guile в программу, одно (если точно, техническое)
требование состоит в том, чтобы  сборщим мусора Guile знал, где находиться
нижняя часть стека Си.  Самый простой способ убедиться в этом использовать
@code{scm_boot_guile} следующим образом:

@itemize @bullet
@item
@code{main ()}

@itemize @bullet
@item
делаем много операций инициализации и настройки
@item
@code{scm_boot_guile (argc, argv, inner_main, NULL)}
@end itemize

@item
@code{inner_main ()}

@itemize @bullet
@item
определяем все типы внешних объектов
@item
экспортируем примитивы в Scheme с помощью @code{scm_c_define_gsubr}
@item
входим в основной цикл обработки Gtk
@end itemize
@end itemize

Другими словами, вы перемещаете внутренности того, что было ранее в вашей
основной функции @code{main} в новую функцию, называемую @code{inner_main},
а затем добавляете вызов @code{scm_boot_guile}, с параметром @code{inner_main},
в конец функции @code{main}.

Предполагая, что вы используете внешние объекты и написали код примитивов,
как описано в передыдущих подразделах вам также необходимо вставить вызовы
для объявления ваших новых внешних объектов и экспортировать примитивы
в Scheme.  Эти декларации должны происходить @emph{внутри} динамического
вызова @code{scm_boot_guile}, на также @emph{перед} любым кодом которы
бы мог использовать их --- начало функции @code{inner_main}
идеальное место для их размещения.

@node Dia Advanced
@subsubsection Далее с Dia и Guile

Шаги, описанные до сих пор, реализуют первоначальную интеграцию Guile,
которая уже дает большую дополнительную мощность для пользователей 
приложений Dia.  Но есть дальнейшие шаги, которые вы могли бы предпринять,
и интересно рассмотреть некоторые из них.

В общем, вы можете постепенно продвигать больше исходного кода Dia из
Си в Scheme.  Это может сделать код более удобным для обслуживания и
расширяемым, и он может открыть дверь для новых парадигм программирования,
которые сложно реализовать на Си, но легко на Scheme.

Конкретным примером этого является то, что вы можете использовать пакет
guile-gtk, который предоставляет процедуры уровня Scheme для большей
части библиотеки Gtk+,  для перемещения кода, который размещает и отображает
объекты Dia, с Си на Scheme.

Поскольку вы следуете этому пути, естественно становиться менее полезным
поддерживать различие между оригинальным исходным кодом  Dia не связанным
с Guile, и его более поздним кодом, реализующим внешние объекты и примитивы
для мира Scheme.

Например предположим, что оригинальный исходный код имел функцию
@code{dia_change_fill_pattern}:

@lisp
void dia_change_fill_pattern (struct dia_shape * shape,
                              struct dia_pattern * pattern)
@{
  /* real pattern change work */
@}
@end lisp

Во время первоначальной интеграции Guile, вы добавляете примитив @code{change_fill_pattern}
для Scheme целей, которые обращаются к базовым структурам из своих значений внешних объектов
и используют @code{dia_change_fill_pattern}, чтобы выполнить настоящую работу.

@lisp
SCM change_fill_pattern (SCM shape, SCM pattern)
@{
  struct dia_shape * d_shape;
  struct dia_pattern * d_pattern;

  @dots{}

  dia_change_fill_pattern (d_shape, d_pattern);

  return SCM_UNSPECIFIED;
@}
@end lisp

На этом этапе имеет смысл сохранить @code{dia_change_fill_pattern} и
@code{change_fill_pattern} отдельно, поскольку @code{dia_change_fill_pattern}
можно так же вызвать вообще без перехода через Scheme, скажем, потому что
пользователь нажимает кнопку, которая вызывает Си зарегистрированный в Gtk+ 
обрабочик.

Но, если код для создания кнопок и регистрации их обратных вызовов перемещается
в Scheme (используя guile-gtk), может оказаться, что @code{dia_change_fill_pattern}
больше не может быть вызван иначе, чем через Scheme.  В этом случае, имеет смысл
отменить его и пеереместить его содержимое непосредственно в @code{change_fill_pattern},
например:

@lisp
SCM change_fill_pattern (SCM shape, SCM pattern)
@{
  struct dia_shape * d_shape;
  struct dia_pattern * d_pattern;

  @dots{}

  /* real pattern change work */

  return SCM_UNSPECIFIED;
@}
@end lisp

Таким образом, дальейшая интеграция Guile постепенно уменьшает количество
функционального кода Си, который вы должны поддерживать в долгосрочной
перспективе.

Аналогичный аргумент применим и к представлению данных.  При обсуждении
внешних объектов ранее возникали проблемы из-за разных моделей управления
памятью и временем жизни, которые обычно применяются к структурам данных
в Си и в Scheme.  Однако, с дальнейшей интеграцией Guile, вы можете решить
эту проблему более радикально, разрешив всем вашим структурам данных быть
под контролем сборщика мусора и сохранять живые ссылки из мира Scheme.
Вместо того, чтобы поддерживать массив или связный список фигур в Си, вы
бы вместо этого хранили список в мире Scheme.

Скорее, подобно объединению @code{dia_change_fill_pattern} и
@code{change_fill_pattern}, практический результат такого изменения
заключается в том, что вам больше не придется поддерживать
отдпельно структуры @code{dia_shape} и @code{dia_guile_shape},
и поэтому больше не нужно беспокоиться о связи между ними. Вместо этого
вы сможете изменить определение внешнего объекта, чтобы обернуть
структуру @code{dia_shape} напрямую и отправить @code{dia_guile_shape}
на помойку.  Убрать промежуточное звено!

Наконец, мы приходим к святому граалю свободного программного обеспечния/
языка расширения Guile. Когда у вас есть представление Scheme для 
интересующих типов данных Dia таких как фигуры(shapes), и удобная группа
примитивов для манипулирования ими, внезапно становиться ясно, что у вас
есть набор функциональных возможностей, котоырй может иметь далеко идущее
применение за пределами самой Dia.  Другими словами, типы данных и 
примитивы теперь могут стать библиотекой, а Dia становиться только одним
из возможных приложений, использующих эту библиотеку, хотя и важным на этой
раннее стадии.

В этой модели, Guile становиться только клеем, который связывает все
вместе.  Представьте себе приложение, которое сочетает в себе функциональность
от Dia, Gnumeric и GnuCash --- это сейчас сложно, потому что такого приложения
пока не существует, но это однажды произойдет @dots{}

@node Scheme vs C
@subsection Почему Scheme более доступная чем Си

Основополагающим предложением Guile является предположение, что программирование
на языке высокого уровня, в частности Guile реализации Scheme,
обязательно лучше каки-то образом чем программирование на Си.
Что мы подразумеваем под этим утверждением, и как мы можем быть так уверены?

Один класс преимуществ применяется не только к Scheme, но и в целом к
любому интерпретируемому языку высокого уровня, языку сценариев, таких
как Emacs Lisp, Python, Ruby, или язык макросов @TeX{}. Общими особенностями
всех этих языков по сравнению с Си являются:

@itemize @bullet
@item
Они поддаются быстрым экспериментальным циклам разработки,
сочетание их интерпретируемости и интегрированной среды разработки
в которой их используют.

@item
Они освобождают разработчиков от некоторых низкоуровневых "бухгалтерских"
задач связанных с программированием на Си, в частности по управлению памятью.


@item
Они предоставляют функции высокого уровня, такие как контейнерные объекты
и обработка исключений, которые упрощают общие задачи программирования.
@end itemize

В случае Scheme, особенности, которые делают программирование проще
--- и веслее! --- являются его мощными механизмами для абстаргирования
частей программ(замыкания --- @pxref{About Closure}) и для итерации
(@pxref{while do}).

Свидетельства в поддержку этого аргумента являются эмпирическими: огромное
количество кода, который был написан на языках расширения для приложений,
поддерживающих этот механизм.  Наиболее примечательны расширения, написанные
в Emacs Lisp для GNU Emacs, на языке макросов @TeX{} для @TeX{}, и на
Script-Fu для Gimp, но теперь все чаще появляется значительный код
эко системы для основанных на Guile приложений, таких как Lilypond и
GnuCash.  Это близкое к немыслимому, что подобное количество функциональности
могло быть добавлено к этим приложениям, просто написав новый код на своих
базовых языках реализации.

@node Testbed Example
@subsection Пример: Использование Guile для тестового стенда Приложения

В качестве примера того, что это означает на практике, представьте себе,
как написать тестовый стенд для приложения которое тестируется путем
отправки различных запросов(через интерфейс Си) и получения определенных
результатов. Предположим далее, что приложение сохраняет представление
о своем текущем состоянии, и что ``правильный'' вывод для данного запроса
можт зависеть от текущего состояния приложения. Полный план ``белого ящика''
@footnote{План тестирования белого ящика(@dfn{white box}) - это тот, который
включает знание внутреннего дизайна приложения в соответствии с заданными
тестами.} для этого приложения будет направлен на то, что
бы представить все возможные запросы в каждом различимом состоянии и проверки
вывода для комбинации всех запросов/состояний.

Написание всего тестового кода на Си было бы очень утомительным.  Предположим,
что тестовый стенд добавляет одну новую Си функцю, чтобы отправить произвольный
запрос и вернуть ответ а зетем использует Guile для экспорта этой функции
в виде процедуры Scheme.  Остальна часть тестового стенда может быть написана
на Scheme, и поэтому выгоды от всех преимуществ программирования на Scheme,
описаны в предыдущем разделе.

(В этом конкретном примере есть дополнительное преимущество написания
большей части тестового стенда на Scheme.  Общей проблемой тестирования
белого ящика является то, что ошибки и ошибочные предположения в тестируемом
приложении можно легко воспроизвести в тестовом коде. Сложнее копировать 
ошибки, подобные этому, когда тестовый стенд написан на языке отличном 
от языка приложения.)

@node Programming Options
@subsection Выбор параметров программирования

Предыдущие аргументы и примеры указывают на модель программирования
Guile, которая применима во многих случаях. Согласно этой модели, 
программирование Guile включает в себя баланс между программированием
на Си и Scheme, с целью извлечь максимально возможный выигрыш от уровня
Scheme и наименьшего количества работы на уровне Си.

Работа на уровне Си, требуемая в этой модели, обычно состоит из упаковки
и экспорта функций и объектов приложения, чтобы их можно было увидеть и
обработать на уровне Scheme.  Чтобы помочь в этом, интерфейс языка Guile
Си включает в себя служебные функции, которые делают эту интеграцию очень
простой для разработчика приложений. Эти функции описанны далее в этой
части руководства: см. REFFIXME.

Однако эта модель в действительности является одной из множества 
вариантов программирования. Если все функции, которые вам нужны
доступны из Scheme, вы можете выбрать писать свое приложение на
Scheme (или одном из других языков высокого уровня, трансляцию
которого поддерживает Guile), и просто использовать Guile в качестве
интерпретатора для Scheme.  (В будущем мы надеемся, что Guile также
сможет скомпилировать код Scheme, сократив разрыв производительности
между кодом Си и Scheme.)  Или, с другой стороны шкалы Си--Scheme, вы
можете написать большую часть своего приложения на Си и только иногда 
вызывать Guile для конкретных действий, таких как чтение конфигурационного
файла или выполнения определенного пользователем расширения. Выбор сводиться
к двум основным вопросам:

@itemize @bullet
@item
Какие части приложения вы пишете на Си, а какие на Scheme
(или другом транслируемом языке высокого уровня)?

@item
Как вы разрабатываете интерфейс между частями  Си и Scheme вашего приложения?
@end itemize

Это конечно вопросы дизайна, и правильный дизайн для любого конкретного
приложения всегда будет зависеть от конкретных требований, которые вы
пытаетесь выполнить в контексте Guile, однако сущетствуют некоторые 
общепринятые соображения, которые могут помочь вам при выработке своих
ответов.

@menu
* Available Functionality::     What functionality is already available?
* Basic Constraints::           Functional and performance constraints.
* Style Choices::               Your preferred programming style.
* Program Control::             What controls program execution?
@end menu

@node Available Functionality
@subsubsection Какая функциональность уже доступна?

Предположим, ради аргумента, что вы предпочитаете писать ваше приложение на 
Scheme.  Тогда доступный API состоит из:

@itemize @bullet
@item
стандартной Scheme

@item
плюс расширения стандартной Scheme предоставляемые Guile в
ее базовом дистрибутиве

@item
плюс любая дополнительная функциональность, которую вы или другие
собрали в пакет, чтобы его можно было загрузить как модуль Guile 
Scheme.
@end itemize

Модуль в последней категории может быть либо чистым модулем Scheme --- 
другими словами набором служебных процедур, закодированных на Scheme --- 
или модулем который прдоставляет Scheme интерфейс к библиотеке расширений,
закодированной на Си --- или другими словами, пакетом в котором некто выполнил
хорошую работу по завершению некоторого полезного для вас кода на Си. Набор
доступных модулей быстро растет и уже включает такие полезные примеры как
@code{(gtk gtk)}, который делает доступными функции рисования Gtk+ на 
Scheme, и @code{(database postgres)}, который обеспечивает SQL доступ к
базе данных Postgres.

Учитывая растущий набор разработанных модулей, вполне возможно, что ваше
приложение может быть реализовано путем комбинации объединения этих модулей
с новым кодом приложений, написанным на Scheme.

Если этого подхода недостаточно, поскольку функциональность, которая 
требуется вашему приложению уже недоступна в этой форме, и невозможно
написать новую функциональность на Scheme, вам нужно будет написать
код Си. Ели требуемая функция уже доступна на Си (например: в библиотеке),
все что вам нужно, это немного клея, чтоебы связать его с миром Guile. 
Если вам не нужно опять писать базовый код, так встройте его в  Guile.

В любом случае важны два общих соображения. Во первых, что такое интерфейс
по которому  функциональность представляется миру Scheme? Состоит ли 
интерфейс только из вызова функций(например, простой интерфейс рисования),
или он должен включать объекты(@dfn{objects}), которые могут быть переданы 
между Си и Scheme и управляться обоими мирами. Во-вторых, как управление 
жизненным циклом и памятью объектов в коде Си соотносится к управляемым
сборщиком мусора объектам Scheme?  В случае когда базовый код Си еще не 
написан, большинство трудностей управления памятью можно избежать использованием
функций языка Си интерфейса Guile с самого начала.

Для полной документации по написанию кода Си для Guile и подключения
существующего Си кода к миру Guile, см. REFFIXME.

@node Basic Constraints
@subsubsection Функциональные и скоростные ограничения

@node Style Choices
@subsubsection Ваш предпочтительный стиль программирования

@node Program Control
@subsubsection Какие управляющие программы выполнять?

@node User Programming
@subsection Как насчет Пользователей Приложения?

До сих пор мы рассматривали, какие средства программирования Guile
предоставляет для разработчика приложения. Но что, если вместо этого
хотите использовать существующее приложение на основе Guile и хотите
знать какие у вас есть варианты для программирования и расширения
этого приложения?

Ответ на этот вопрос варьируется от одного приложения к другому,
поскольку параметры доступрые, неизбежно зависят от того предоставил
ли разработчик приложений какие-либо перехватчики(hooks) что бы вы
могли присоединить к ним собственный код, и если есть такие перехватчики,
что они позволяют вам делать.@footnote{ Конечно, в мире свободного
программного обеспечения у вас всегда есть свобода изменять исходный код
в соответствии с вашими требованиями. Здесь мы имеем дело с вариантами
расширения, которые предоставляет приложение без необходимости изменения
исходного кода.}  Например @dots{}

@itemize @bullet
@item
Если приложение позволяет загружать и выполнять любой Guile, мир становиться
вашим.  Вы можете расширять приложение любым способом, который вы выберете.

@item
Более острожное приложение может позволить вам загружать и выполнять код
Guile, но только в безопасной(@dfn{safe}) средеe, где доступный интерфейс
ограничен приложением из старндатного Guile API.

@item
Или действительно пугливое приложение может НЕ обеспечить крюкчек(hook),
чтобы выполнять пользовательский код, а вместо этого просто использовать 
синтаксис Scheme как удобный способ для пользователя указать приложению 
данные или параметры конфигурации.
@end itemize

В последних двух случаях, что выможете сделать, по определению ограничено
приложением, и вы должны обратиться к документации по приложению чтобы узнать
ваши опции.

Наиболее известным примером первого случая является Emacs, с его языком
расширения Emacs Lisp: как и текстовый редактор, Emacs поддерживает
загрузку и выполнение произвольного кода Emacs Lisp.  Результат такой
открытости был впечатляющим: Emacs сейчас имеет преимущества библиотек
Emacs Lisp от пользователей, котоыре расширяют базовые функции редактирования,
делая все от чтения новостей до психоанализа и игры в приключенческие игры.
Только ограничение заключается в том, что расширения ограничены функциональностью
предоставляемой встроенным набором примитивных операций Emacs. Например, вы
можете взаимодействовать и отображать данные по манипулированию содержимым
буфера Emacs, но вы не можете размещать всплывающие окна рисовать окна с размещением,
который полностью отличается от стандарта Emacs.

Эта ситуация с приложением Guile, которое поддерживает загрузку произольного
кода пользователя аналогична, за исключением, возможно, даже более того,
поскольку Guile также поддерживает загрузку библиотек расширения, написанных
на Си. Этот последний пункт позволяет коду пользователя добавлять новые 
примитивные операции в Guile, и поэтому обойти ограничение, существующее
в Emacs Lisp.

На этом этапе различие между разработчиками приложения и пользователем
приложения становятся размытыми. Вместо того, чтобы видеть себя пользователем
расширяющим приложение, вы могли бы сказать, что вы разрабатываете новое
приложение, используя некотурую примитивную функциональность, предоставляемую
оригинальным приложением. Таким образом, все обсуждения предыдущих разделов
этой главы имеют отношение к тому, как вы можете продолжить разработку ваших
расширений.

@c Local Variables:
@c TeX-master: "guile.texi"
@c End: