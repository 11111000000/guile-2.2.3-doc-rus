#
# Gagin <mikhail-gagin@yandex.ru>, 2018.
#
#. extracted from /home/bear/work/guile/doc/guile/en/data-rep.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-07 12:37+0300\n"
"PO-Revision-Date: 2018-05-15 16:35+0300\n"
"Last-Translator: Gagin <mikhail-gagin@yandex.ru>\n"
"Language-Team: Russian <mikhail-gagin@yandex.ru>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2010, 2015\n"
"@c   Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:9
msgid ""
"@node Data Representation\n"
"@section Data Representation"
msgstr ""
"@node Data Representation\n"
"@section Представление данных"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:16
msgid ""
"Scheme is a latently-typed language; this means that the system cannot,\n"
"in general, determine the type of a given expression at compile time.\n"
"Types only become apparent at run time.  Variables do not have fixed\n"
"types; a variable may hold a pair at one point, an integer at the next,\n"
"and a thousand-element vector later.  Instead, values, not variables,\n"
"have fixed types."
msgstr ""
"Scheme - это язык со скрытой типизацией; это означает, что система\n"
"не может определить тип данных во время компиляции. Типы данных\n"
"становяться известными во время выполнения программы. Переменные не\n"
"имеют фиксированных типов; Переменная может содержать пару(pair) в \n"
"одном месте программы, целое число в следующем и тысячаэлемнтный \n"
"вектор позже. Вместо переменных, значения имеют фиксированный\n"
"тип."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:23
msgid ""
"In order to implement standard Scheme functions like @code{pair?} and\n"
"@code{string?} and provide garbage collection, the representation of\n"
"every value must contain enough information to accurately determine its\n"
"type at run time.  Often, Scheme systems also use this information to\n"
"determine whether a program has attempted to apply an operation to an\n"
"inappropriately typed value (such as taking the @code{car} of a string)."
msgstr ""
"Для реализации стандартных функций Scheme, таких как @code{pair?} и\n"
"@code{string?} и обеспечения сборки мусора, представление каждого значения\n"
"должно содержать достаточно информации для точного определения его типа\n"
"во время выполнения. Часто системы Scheme также используют эту информацию,\n"
"чтобы определить, пыталась ли программа применить операцию к неуместному\n"
"типу значения(например применить @code{car} к строке(string))."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:28
msgid ""
"Because variables, pairs, and vectors may hold values of any type,\n"
"Scheme implementations use a uniform representation for values --- a\n"
"single type large enough to hold either a complete value or a pointer\n"
"to a complete value, along with the necessary typing information."
msgstr ""
"Поскольку переменные, пары и векторы могут содержать значения любого\n"
"типа, реализация Scheme использует единое представление для значений\n"
"--- один тип, достаточно большой, чтобы содержать либо полное значение\n"
"либо указатель на полное значение, а также необходимую информацию о\n"
"типе."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:33
msgid ""
"The following sections will present a simple typing system, and then\n"
"make some refinements to correct its major weaknesses. We then conclude\n"
"with a discussion of specific choices that Guile has made regarding\n"
"garbage collection and data representation."
msgstr ""
"В следующих разделах будет представлена простая система типов, а затем\n"
"сделаны некоторые уточнения для устранения основных ее недостатков. Затем\n"
"мы завершаем обсуждение, конкретным выбором, который выбран для Guile в\n"
"отношении сборки мусора и представления данных."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:41
msgid ""
"@menu\n"
"* A Simple Representation::     \n"
"* Faster Integers::             \n"
"* Cheaper Pairs::               \n"
"* Conservative GC::          \n"
"* The SCM Type in Guile::\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:44
msgid ""
"@node A Simple Representation\n"
"@subsection A Simple Representation"
msgstr ""
"@node A Simple Representation\n"
"@subsection Простейшее представление"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:49
msgid ""
"The simplest way to represent Scheme values in C would be to represent\n"
"each value as a pointer to a structure containing a type indicator,\n"
"followed by a union carrying the real value. Assuming that @code{SCM} is\n"
"the name of our universal type, we can write:"
msgstr ""
"Простейший способ представления значений Scheme в Си представить каждое\n"
"значение как указатель на структуру, содержащую индикатор типа, за\n"
"которым следует объединение, несущее реальное значение. Предполагая, что\n"
"@code{SCM} это имя нашего универсального типа, мы можем написать:"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:52
msgid ""
"@example\n"
"enum type @{ integer, pair, string, vector, ... @};"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:54
msgctxt "/home/bear/work/guile/doc/guile/en/data-rep.texi:54"
msgid "typedef struct value *SCM;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:67
msgid ""
"struct value @{\n"
"  enum type type;\n"
"  union @{\n"
"    int integer;\n"
"    struct @{ SCM car, cdr; @} pair;\n"
"    struct @{ int length; char *elts; @} string;\n"
"    struct @{ int length; SCM  *elts; @} vector;\n"
"    ...\n"
"  @} value;\n"
"@};\n"
"@end example\n"
"with the ellipses replaced with code for the remaining Scheme types."
msgstr ""
"struct value @{\n"
"  enum type type;\n"
"  union @{\n"
"    int integer;\n"
"    struct @{ SCM car, cdr; @} pair;\n"
"    struct @{ int length; char *elts; @} string;\n"
"    struct @{ int length; SCM  *elts; @} vector;\n"
"    ...\n"
"  @} value;\n"
"@};\n"
"@end example\n"
"с точками заменяющими код для остальных типо Scheme."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:84
msgid ""
"This representation is sufficient to implement all of Scheme's\n"
"semantics.  If @var{x} is an @code{SCM} value:\n"
"@itemize @bullet\n"
"@item\n"
"  To test if @var{x} is an integer, we can write @code{@var{x}->type == "
"integer}.\n"
"@item\n"
"  To find its value, we can write @code{@var{x}->value.integer}.\n"
"@item\n"
"  To test if @var{x} is a vector, we can write @code{@var{x}->type == "
"vector}.\n"
"@item\n"
"  If we know @var{x} is a vector, we can write\n"
"  @code{@var{x}->value.vector.elts[0]} to refer to its first element.\n"
"@item\n"
"  If we know @var{x} is a pair, we can write\n"
"  @code{@var{x}->value.pair.car} to extract its car.\n"
"@end itemize"
msgstr ""
"Это представление достаточно для реализации всей семантики Scheme. Если "
"@var{x} \n"
"является значением @code{SCM}:\n"
"@itemize @bullet\n"
"@item\n"
"  Для проверки что @var{x} является целым(integer), мы можем написать "
"@code{@var{x}->type == integer}.\n"
"@item\n"
"  Чтобы найти его значение, мы можем написать @code{@var{x}->value."
"integer}.\n"
"@item\n"
"  Для проверки что @var{x} это вектор(vector), мы можем наисать "
"@code{@var{x}->type == vector}.\n"
"@item\n"
"  Если мы знаем что @var{x} это вектор, мы можем написать\n"
"  @code{@var{x}->value.vector.elts[0]} чтобы сослаться на первый элемент.\n"
"@item\n"
"  Если мы знаем что @var{x} это пара, мы можем написать\n"
"  @code{@var{x}->value.pair.car} чтобы извлечь начало пары(car).\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:88
msgid ""
"@node Faster Integers\n"
"@subsection Faster Integers"
msgstr ""
"@node Faster Integers\n"
"@subsection Быстрые Целые числа"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:97
msgid ""
"Unfortunately, the above representation has a serious disadvantage.  In\n"
"order to return an integer, an expression must allocate a @code{struct\n"
"value}, initialize it to represent that integer, and return a pointer to\n"
"it.  Furthermore, fetching an integer's value requires a memory\n"
"reference, which is much slower than a register reference on most\n"
"processors.  Since integers are extremely common, this representation is\n"
"too costly, in both time and space.  Integers should be very cheap to\n"
"create and manipulate."
msgstr ""
"К сожалению, вышеупомянутое представление имеет серьезный недостаток.\n"
"Чтобы вернуть  целое(integer), выражение должно выделить память под\n"
"структуру значения @code{struct value}, инициализировать его, чтобы\n"
"представить это целое число и вернуть указатель на него. Кроме того,\n"
"для получения значения целого числа требуется ссылка на память,\n"
"которая намного медленне, чем ссылка на регистры для большинства\n"
"процессоров. Поскольку целые числа чрезвычайно распространены,\n"
"это представление является слишком дорогостоящим, как по времени,\n"
"так и по памяти. Целые должны быть очень дешевыми, для создания и\n"
"манипулирования ими."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:104
msgid ""
"One possible solution comes from the observation that, on many\n"
"architectures, heap-allocated data (i.e., what you get when you call\n"
"@code{malloc}) must be aligned on an eight-byte boundary. (Whether or\n"
"not the machine actually requires it, we can write our own allocator for\n"
"@code{struct value} objects that assures this is true.) In this case,\n"
"the lower three bits of the structure's address are known to be zero."
msgstr ""
"Одним из возможных решений кроется в наблюдении, что на многих\n"
"архитектурах, выделеное в куче(heap) место для данных (т.е то, что\n"
"вы получаете при вызове @code{malloc}) должно быть выровнено по\n"
"воьмибайтовой границе. (Независимо от того, действительно ли\n"
"машина требует этого, мы можем написать собственный распределитель\n"
"(allocator) для объектов структур значений@code{struct value} который\n"
"будет гарантировать что это так) В этом случае нижние три бита\n"
"адреса структуры, как известно, равны нулю."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:116
msgid ""
"This gives us the room we need to provide an improved representation\n"
"for integers.  We make the following rules:\n"
"@itemize @bullet\n"
"@item\n"
"If the lower three bits of an @code{SCM} value are zero, then the SCM\n"
"value is a pointer to a @code{struct value}, and everything proceeds as\n"
"before.\n"
"@item\n"
"Otherwise, the @code{SCM} value represents an integer, whose value\n"
"appears in its upper bits.\n"
"@end itemize"
msgstr ""
"Это дает нам место, которое поможет обеспечить улучшенное представление\n"
"целых чисел. Мы создадим последовательность правил:\n"
"@itemize @bullet\n"
"@item\n"
"Если нижние три бита значения @code{SCM} равны нулю, SCM значение\n"
"является указателем на структуру значения @code{struct value}, и все\n"
"работает как и раньше.\n"
"@item\n"
"В противном случае, значение @code{SCM} представляет собой целое\n"
"число, значение которого отображается в его верхних битах.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:120
msgid ""
"Here is C code implementing this convention:\n"
"@example\n"
"enum type @{ pair, string, vector, ... @};"
msgstr ""
"Вот код Си, реализующий это соглашение:\n"
"@example\n"
"enum type @{ pair, string, vector, ... @};"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:122
msgctxt "/home/bear/work/guile/doc/guile/en/data-rep.texi:122"
msgid "typedef struct value *SCM;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:132
msgid ""
"struct value @{\n"
"  enum type type;\n"
"  union @{\n"
"    struct @{ SCM car, cdr; @} pair;\n"
"    struct @{ int length; char *elts; @} string;\n"
"    struct @{ int length; SCM  *elts; @} vector;\n"
"    ...\n"
"  @} value;\n"
"@};"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:135
msgid ""
"#define POINTER_P(x) (((int) (x) & 7) == 0)\n"
"#define INTEGER_P(x) (! POINTER_P (x))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:139
msgid ""
"#define GET_INTEGER(x)  ((int) (x) >> 3)\n"
"#define MAKE_INTEGER(x) ((SCM) (((x) << 3) | 1))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:145
msgid ""
"Notice that @code{integer} no longer appears as an element of @code{enum\n"
"type}, and the union has lost its @code{integer} member.  Instead, we\n"
"use the @code{POINTER_P} and @code{INTEGER_P} macros to make a coarse\n"
"classification of values into integers and non-integers, and do further\n"
"type testing as before."
msgstr ""
"Обратите внимание, что целое(@code{integer}) больше не отображается как\n"
"элемент типа перечисления@code{enum type}, и объединение теряет \n"
"целочисленный член.  Вместо этого мы используем макросы @code{POINTER_P} \n"
"и @code{INTEGER_P} для создания грубого разделения значений на целые\n"
"и не целые числа, а также тестирования типов прежде использования."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:168
msgid ""
"Here's how we would answer the questions posed above (again, assume\n"
"@var{x} is an @code{SCM} value):\n"
"@itemize @bullet\n"
"@item\n"
"  To test if @var{x} is an integer, we can write @code{INTEGER_P "
"(@var{x})}.\n"
"@item\n"
"  To find its value, we can write @code{GET_INTEGER (@var{x})}.\n"
"@item\n"
"  To test if @var{x} is a vector, we can write:\n"
"@example\n"
"  @code{POINTER_P (@var{x}) && @var{x}->type == vector}\n"
"@end example\n"
"  Given the new representation, we must make sure @var{x} is truly a\n"
"  pointer before we dereference it to determine its complete type.\n"
"@item\n"
"  If we know @var{x} is a vector, we can write\n"
"  @code{@var{x}->value.vector.elts[0]} to refer to its first element, as\n"
"  before.\n"
"@item\n"
"  If we know @var{x} is a pair, we can write\n"
"  @code{@var{x}->value.pair.car} to extract its car, just as before.\n"
"@end itemize"
msgstr ""
"Здесь мы ответим на поставленные выше вопросы(опять же предположим что\n"
"@var{x} это значение @code{SCM}):\n"
"@itemize @bullet\n"
"@item\n"
"  Чтобы проверить, является ли @var{x} целым числом, мы можем написать\n"
" @code{INTEGER_P (@var{x})}.\n"
"@item\n"
"  Чтобы найти его значение, мы можем написать @code{GET_INTEGER (@var{x})}.\n"
"@item\n"
"  Чтобы проверить, является ли @var{x} вектором, мы можем написать:\n"
"@example\n"
"  @code{POINTER_P (@var{x}) && @var{x}->type == vector}\n"
"@end example\n"
"  Учитывая новое представление, мы должны убедиться, что @var{x} "
"действительно\n"
"  является указателем перед разыменовыванием, чтобы определить его полный "
"тип.\n"
"@item\n"
"  Если мы знаем что @var{x} это вектор, мы можем записать\n"
"  @code{@var{x}->value.vector.elts[0]}, чтобы ссылаться на его первый "
"элемент,\n"
"  как и раньше\n"
"@item\n"
"  Если мы знаем что @var{x} это пара, мы можем записать\n"
"  @code{@var{x}->value.pair.car} чтобы извлечь первый элемент пары(car), "
"также как\n"
"  и раньше.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:180
msgid ""
"This representation allows us to operate more efficiently on integers\n"
"than the first.  For example, if @var{x} and @var{y} are known to be\n"
"integers, we can compute their sum as follows:\n"
"@example\n"
"MAKE_INTEGER (GET_INTEGER (@var{x}) + GET_INTEGER (@var{y}))\n"
"@end example\n"
"Now, integer math requires no allocation or memory references. Most real\n"
"Scheme systems actually implement addition and other operations using an\n"
"even more efficient algorithm, but this essay isn't about\n"
"bit-twiddling. (Hint: how do you decide when to overflow to a bignum?\n"
"How would you do it in assembly?)"
msgstr ""
"Это представление позволяет более эффективно работать с целыми числами,\n"
"чем первое.  Например если известно что @var{x} и @var{y} целые числа,\n"
"мы можем вычислить их сумму следующим образом:\n"
"@example\n"
"MAKE_INTEGER (GET_INTEGER (@var{x}) + GET_INTEGER (@var{y}))\n"
"@end example\n"
"Теперь, целочисленная математика не требует выделения памяти или ссылок.\n"
"Реальные системы Scheme реализуют сложение и другие операции, используя\n"
"еще более эффективный алгоритм, но это эссе не о bit-twiddling. \n"
"(Подсказка: как вы решаете, когда переполниться большое число? Как вы\n"
"это сделаете на ассемблере?)"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:184
msgid ""
"@node Cheaper Pairs\n"
"@subsection Cheaper Pairs"
msgstr ""
"@node Cheaper Pairs\n"
"@subsection Дешевые Пары"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:192
msgid ""
"However, there is yet another issue to confront. Most Scheme heaps\n"
"contain more pairs than any other type of object; Jonathan Rees said at\n"
"one point that pairs occupy 45% of the heap in his Scheme\n"
"implementation, Scheme 48. However, our representation above spends\n"
"three @code{SCM}-sized words per pair --- one for the type, and two for\n"
"the @sc{car} and @sc{cdr}. Is there any way to represent pairs using\n"
"only two words?"
msgstr ""
"Однако, есть еще одна проблема, с которой можно столкнуться. Значительная\n"
"часть кучи(heap) Scheme содержат пары, их большее чем других типов "
"объектов; \n"
"Как то Jonathan Rees обратил внимание на то, что пары занимаеют  45% \n"
"кучи в его реализации  Scheme (Scheme 48). Однако наше представление, выше,\n"
"тратит три слова @code{SCM} на пару - одно для типа и два для @sc{car} и \n"
"@sc{cdr}. Есть ли способ представить пары, используя только два слова?"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:206
msgid ""
"Let us refine the convention we established earlier.  Let us assert\n"
"that:\n"
"@itemize @bullet\n"
"@item\n"
"  If the bottom three bits of an @code{SCM} value are @code{#b000}, then\n"
"  it is a pointer, as before.\n"
"@item\n"
"  If the bottom three bits are @code{#b001}, then the upper bits are an\n"
"  integer.  This is a bit more restrictive than before.\n"
"@item\n"
"  If the bottom two bits are @code{#b010}, then the value, with the bottom\n"
"  three bits masked out, is the address of a pair.\n"
"@end itemize"
msgstr ""
"Давайте уточним соглашение, которое мы установили ранее для представления\n"
"целых integer.  Допустим, что:\n"
"that:\n"
"@itemize @bullet\n"
"@item\n"
"  Если нижние три бита значения @code{SCM} равны @code{#b000}, то это\n"
"  указатель, как и раньше.\n"
"@item\n"
"  Если нижние три бита равны @code{#b001}, то верхние биты являются\n"
"  целым числом. Это немного более строгое ограничение чем раньше.\n"
"@item\n"
"  Если нижние три бита равны @code{#b010}, тогда значение с нижними\n"
"  тремя битами отбрасывается, а верхние являются адресом пары.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:210
msgid ""
"Here is the new C code:\n"
"@example\n"
"enum type @{ string, vector, ... @};"
msgstr ""
"Здесь представлен новый Си код:\n"
"@example\n"
"enum type @{ string, vector, ... @};"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:212
msgctxt "/home/bear/work/guile/doc/guile/en/data-rep.texi:212"
msgid "typedef struct value *SCM;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:221
msgid ""
"struct value @{\n"
"  enum type type;\n"
"  union @{\n"
"    struct @{ int length; char *elts; @} string;\n"
"    struct @{ int length; SCM  *elts; @} vector;\n"
"    ...\n"
"  @} value;\n"
"@};"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:225
msgid ""
"struct pair @{\n"
"  SCM car, cdr;\n"
"@};"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:227
msgid "#define POINTER_P(x) (((int) (x) & 7) == 0)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:231
msgid ""
"#define INTEGER_P(x)  (((int) (x) & 7) == 1)\n"
"#define GET_INTEGER(x)  ((int) (x) >> 3)\n"
"#define MAKE_INTEGER(x) ((SCM) (((x) << 3) | 1))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:235
msgid ""
"#define PAIR_P(x) (((int) (x) & 7) == 2)\n"
"#define GET_PAIR(x) ((struct pair *) ((int) (x) & ~7))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:240
msgid ""
"Notice that @code{enum type} and @code{struct value} now only contain\n"
"provisions for vectors and strings; both integers and pairs have become\n"
"special cases.  The code above also assumes that an @code{int} is large\n"
"enough to hold a pointer, which isn't generally true."
msgstr ""
"Обратите внимание, что перечисление(@code{enum type}) и структура значения\n"
"(@code{struct value}) теперь содержат только положения для векторов и "
"строк;\n"
"как целые числа, так и пары стали особыми случаями. Выше приведеный код\n"
"также предполагает что @code{int} достаточно велик, чтобы содержать "
"указатель,\n"
"что обычно не так."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:266
msgid ""
"Our list of examples is now as follows:\n"
"@itemize @bullet\n"
"@item\n"
"  To test if @var{x} is an integer, we can write @code{INTEGER_P\n"
"  (@var{x})}; this is as before.\n"
"@item\n"
"  To find its value, we can write @code{GET_INTEGER (@var{x})}, as\n"
"  before.\n"
"@item\n"
"  To test if @var{x} is a vector, we can write:\n"
"@example\n"
"  @code{POINTER_P (@var{x}) && @var{x}->type == vector}\n"
"@end example\n"
"  We must still make sure that @var{x} is a pointer to a @code{struct\n"
"  value} before dereferencing it to find its type.\n"
"@item\n"
"  If we know @var{x} is a vector, we can write\n"
"  @code{@var{x}->value.vector.elts[0]} to refer to its first element, as\n"
"  before.\n"
"@item\n"
"  We can write @code{PAIR_P (@var{x})} to determine if @var{x} is a\n"
"  pair, and then write @code{GET_PAIR (@var{x})->car} to refer to its\n"
"  car.\n"
"@end itemize"
msgstr ""
"Ниже приведен список наших примеров:\n"
"@itemize @bullet\n"
"@item\n"
"  Чтобы проверить, является ли @var{x} целым числом, мы можем\n"
"  написать @code{INTEGER_P (@var{x})}; как и раньше.\n"
"@item\n"
"  Чтобы получить значение, мы можем написать @code{GET_INTEGER (@var{x})},\n"
"  как и раньше.\n"
"@item\n"
"  Чтобы проверить является ли @var{x} вектором, мы можем записать:\n"
"@example\n"
"  @code{POINTER_P (@var{x}) && @var{x}->type == vector}\n"
"@end example\n"
"  Мы все равно должны убедиться, что @var{x} является указателем\n"
"  перед разыменовыванием @code{struct value} в соответстви с типом.\n"
"@item\n"
"  Если мы знаем, что тип @var{x} это вектор, мы можем записать\n"
"  @code{@var{x}->value.vector.elts[0]}, чтобы ссылаться на на его \n"
"  первый элемент, как и раньше.\n"
"@item\n"
"  Мы можем написать @code{PAIR_P (@var{x})} чтобы определить является\n"
"  ли  @var{x} парой, а затем записать @code{GET_PAIR (@var{x})->car}\n"
"  чтобы получить ссылку на ее первый элемент car.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:272
msgid ""
"This change in representation reduces our heap size by 15%.  It also\n"
"makes it cheaper to decide if a value is a pair, because no memory\n"
"references are necessary; it suffices to check the bottom two bits of\n"
"the @code{SCM} value.  This may be significant when traversing lists, a\n"
"common activity in a Scheme system."
msgstr ""
"Это изменение представления уменьшает размер нашей кучи на 15%.  \n"
"Это также делает его более быстрым при решении является ли\n"
"значение парой или нет, поскольку ссылки на память для этого не нужны; \n"
"достаточно проверить нижние два бита значения @code{SCM}. Это может быть\n"
"значительным при просмотре списков, являющемся основной деятельностью\n"
"системы Scheme."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:279
msgid ""
"Again, most real Scheme systems use a slightly different implementation;\n"
"for example, if GET_PAIR subtracts off the low bits of @code{x}, instead\n"
"of masking them off, the optimizer will often be able to combine that\n"
"subtraction with the addition of the offset of the structure member we\n"
"are referencing, making a modified pointer as fast to use as an\n"
"unmodified pointer."
msgstr ""
"Опять же, большинство реальных систем Scheme используют немного другую\n"
"реализацию; например, если GET_PAIR вычитает младшие биты @code{x},\n"
"а не маскирует их, оптимизатор может сочетать это вычитание с добавлением\n"
"смещения члена структуры, на который мы ссылаемся, делая измененный "
"указатель\n"
"столь же быстрым в использовании, как и немодифицированный указатель."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:283
msgid ""
"@node Conservative GC\n"
"@subsection Conservative Garbage Collection"
msgstr ""
"@node Conservative GC\n"
"@subsection Консервативная сборка мусора"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:288
msgid ""
"Aside from the latent typing, the major source of constraints on a\n"
"Scheme implementation's data representation is the garbage collector.\n"
"The collector must be able to traverse every live object in the heap, to\n"
"determine which objects are not live, and thus collectable."
msgstr ""
"Помимо скрытой типизации, основным источником ограничений на реализацию\n"
"в Scheme представлений данных накладывает сбощик мусора. Сборщик должен\n"
"иметь возможность, чтобы определить какой объект живой в куче, а какой\n"
"не живой и следовательно, должен быть собран. "

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:294
msgid ""
"There are many ways to implement this. Guile's garbage collection is\n"
"built on a library, the Boehm-Demers-Weiser conservative garbage\n"
"collector (BDW-GC). The BDW-GC ``just works'', for the most part. But\n"
"since it is interesting to know how these things work, we include here a\n"
"high-level description of what the BDW-GC does."
msgstr ""
"Существует много способов реализовать его. Сборщик мусора Guile\n"
"построен на библиотеке консервативного сборщика мусора Boehm-Demers-Weiser\n"
"(BDW-GC). BDW-GC ``просто работает'', по большей части. Но поскольку\n"
"интересно знать, как он работает, мы включаем здесь описание на\n"
"высоком уровне, что делает BDW-GC."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:300
msgid ""
"Garbage collection has two logical phases: a @dfn{mark} phase, in which\n"
"the set of live objects is enumerated, and a @dfn{sweep} phase, in which\n"
"objects not traversed in the mark phase are collected. Correct\n"
"functioning of the collector depends on being able to traverse the\n"
"entire set of live objects."
msgstr ""
"Сбор мусор имеет две логические фазы% фазу @dfn{пометки(mark)}, в которой\n"
"устанавливается набор живых объектов, и фазу @dfn{чистки(sweep)}, в которой\n"
"объекты не прошедшие пометку убираются. Корректное функционирование\n"
"сборщика зависит от возможности пройти весь набор живых объектов."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:307
msgid ""
"In the mark phase, the collector scans the system's global variables and\n"
"the local variables on the stack to determine which objects are\n"
"immediately accessible by the C code. It then scans those objects to\n"
"find the objects they point to, and so on. The collector logically sets\n"
"a @dfn{mark bit} on each object it finds, so each object is traversed\n"
"only once."
msgstr ""
"В фазе пометки коллекционер сканирует глобальные переменные системы\n"
"и локальные переменные в стеке, чтобы определить какие объекты\n"
"сразу(непосредственно) доступны Си-коду. Тогда он сканирует эти\n"
"объпкты, чтобы айти объекты, на которые они указывают и так далее.\n"
"Сборщик логически устанавливает @dfn{бит метки(mark bit)} для\n"
"каждого найденного объекта, поэтому каждый объект проходиться только\n"
"один раз."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:312
msgid ""
"When the collector can find no unmarked objects pointed to by marked\n"
"objects, it assumes that any objects that are still unmarked will never\n"
"be used by the program (since there is no path of dereferences from any\n"
"global or local variable that reaches them) and deallocates them."
msgstr ""
"Когда сборщик мусора не может найти никаких немаркированных объектов, \n"
"на которые указывают отмеченные объекты, предполагается, что любые\n"
"объекты, которые все еще не отмечены, никогда не будут использоваться\n"
"программой (т.к. нет разметки из любой глобальной или локальной \n"
"переменной, которая достигает их) и освобождает их."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:319
msgid ""
"In the above paragraphs, we did not specify how the garbage collector\n"
"finds the global and local variables; as usual, there are many different\n"
"approaches.  Frequently, the programmer must maintain a list of pointers\n"
"to all global variables that refer to the heap, and another list\n"
"(adjusted upon entry to and exit from each function) of local variables,\n"
"for the collector's benefit."
msgstr ""
"В приведенных выше пунктах мы не указали, как сборщик мусора находит\n"
"глобальные и локальные перменные; как обычно существует много разных\n"
"подходов. Часто программист должен содержать список указателей на \n"
"все глобальные переменные, относящиеся к куче, и другой список\n"
"(корректирующийся при входе и выходе из каждой функции) локальных\n"
"переменных, для работы сборщика."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:326
msgid ""
"The list of global variables is usually not too difficult to maintain,\n"
"since global variables are relatively rare. However, an explicitly\n"
"maintained list of local variables (in the author's personal experience)\n"
"is a nightmare to maintain. Thus, the BDW-GC uses a technique called\n"
"@dfn{conservative garbage collection}, to make the local variable list\n"
"unnecessary."
msgstr ""
"Список глобальных переменных обычно не так сложно поддерживать, поскольку\n"
"глобальные переменные относительно редки. Тем не менее, явно поддерживаемый\n"
"список локальных переменных(по личному опыту) - это кошмар для поддержания.\n"
"Таким образом, BDW-GC использует технику так называемой @dfn{консервативной "
"сборки\n"
"мусора}, чтобы сделать список локальных переменных не нужным."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:332
msgid ""
"The trick to conservative collection is to treat the stack as an\n"
"ordinary range of memory, and assume that @emph{every} word on the stack\n"
"is a pointer into the heap.  Thus, the collector marks all objects whose\n"
"addresses appear anywhere in the stack, without knowing for sure how\n"
"that word is meant to be interpreted."
msgstr ""
"Трюк консервативной сборки мусора заключается в том, чтобы рассматривать\n"
"стек как обычный диапазон памяти, и предполагать, что каждое слово в\n"
"стеке является указателем на кучу. Таким образом, сборщик отмечает все\n"
"объекты, адреса которых отображаются в любом месте стека, не зная наверняка\n"
"как это слово правильно толковать."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:336
msgid ""
"In addition to the stack, the BDW-GC will also scan static data\n"
"sections. This means that global variables are also scanned when looking\n"
"for live Scheme objects."
msgstr ""
"Помимо стека, BDW-GC также сканирует разделы статических данных. Это "
"означает\n"
"что глобальные переменные также сканируются при поиске живых объектов Scheme."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:344
msgid ""
"Obviously, such a system will occasionally retain objects that are\n"
"actually garbage, and should be freed. In practice, this is not a\n"
"problem. The alternative, an explicitly maintained list of local\n"
"variable addresses, is effectively much less reliable, due to programmer\n"
"error. Interested readers should see the BDW-GC web page at\n"
"@uref{http://www.hboehm.info/gc/}, for more\n"
"information."
msgstr ""
"Очевидно, что такая система будет иногда сохранять объекты, которые\n"
"на самом деле являются мусором, и должны быть освобождены. На практике\n"
"это не является проблемой. Альтернатива, с явно поддерживаемым списком\n"
"адресов локальных переменных, значительно менее надежна, из-за ошибок\n"
"программиста. Заинтересованные читатели должны посмотреть веб страницу\n"
"BDW-GC по адресу @uref{http://www.hboehm.info/gc/}, чтобы получить больше\n"
"информации."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:348
msgid ""
"@node The SCM Type in Guile\n"
"@subsection The SCM Type in Guile"
msgstr ""
"@node The SCM Type in Guile\n"
"@subsection Тип SCM в Guile"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:351
msgid ""
"Guile classifies Scheme objects into two kinds: those that fit entirely\n"
"within an @code{SCM}, and those that require heap storage."
msgstr ""
"Guile разделяет объекты Scheme на два вида: те которые полностью \n"
"соответствуют  @code{SCM}, и те которые требуют храненения в куче."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:355
msgid ""
"The former class are called @dfn{immediates}.  The class of immediates\n"
"includes small integers, characters, boolean values, the empty list, the\n"
"mysterious end-of-file object, and some others."
msgstr ""
"Первый класс называется @dfn{непосредственным(immediates)}.  Класс "
"непосредственных\n"
"включает в себя малые целые числа, символы, знаковые символы, логические "
"значения,\n"
"пустой список, таинственный объект конца файла и некоторые другие."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:361
msgid ""
"The remaining types are called, not surprisingly, @dfn{non-immediates}.\n"
"They include pairs, procedures, strings, vectors, and all other data\n"
"types in Guile. For non-immediates, the @code{SCM} word contains a\n"
"pointer to data on the heap, with further information about the object\n"
"in question is stored in that data."
msgstr ""
"Оставшиеся типы называются, что неудивительно, @dfn{опосредованными\n"
"(non-immediates)}.\n"
"Они включают в себя пары, процедуры, строки, вектор и все другие\n"
"типы данных в  Guile. Для опосредованных, слово @code{SCM} содержит\n"
"указатель на данные в куче, с дополнительной информацией об объекте\n"
"в вопросе что храниться в этих данных."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:366
msgid ""
"This section describes how the @code{SCM} type is actually represented\n"
"and used at the C level. Interested readers should see\n"
"@code{libguile/tags.h} for an exposition of how Guile stores type\n"
"information."
msgstr ""
"В этом разделе описывается, как тип @code{SCM} фактически представлен и\n"
"исползуется на уровне Си. Заинтересованные читатели должны посмотреть\n"
"файл @code{libguile/tags.h} для представления того как Guile хранит\n"
"инофрмацию о типах."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:369
msgid ""
"In fact, there are two basic C data types to represent objects in\n"
"Guile: @code{SCM} and @code{scm_t_bits}."
msgstr ""
"Фактически, для представления объектов в Guile существуют два базовых\n"
"типа данных Си: @code{SCM} и @code{scm_t_bits}."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:378
msgid ""
"@menu\n"
"* Relationship between SCM and scm_t_bits::\n"
"* Immediate objects::\n"
"* Non-immediate objects::\n"
"* Allocating Cells::\n"
"* Heap Cell Type Information::\n"
"* Accessing Cell Entries::\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:382
msgid ""
"@node Relationship between SCM and scm_t_bits\n"
"@subsubsection Relationship between @code{SCM} and @code{scm_t_bits}"
msgstr ""
"@node Relationship between SCM and scm_t_bits\n"
"@subsubsection Связь между @code{SCM} и @code{scm_t_bits}"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:388
msgid ""
"A variable of type @code{SCM} is guaranteed to hold a valid Scheme\n"
"object.  A variable of type @code{scm_t_bits}, on the other hand, may\n"
"hold a representation of a @code{SCM} value as a C integral type, but\n"
"may also hold any C value, even if it does not correspond to a valid\n"
"Scheme object."
msgstr ""
"Переменная типа @code{SCM} гарантированно содержит действительный\n"
"объект Scheme. С другой стороны, переменная типа @code{scm_t_bits},\n"
"может содержать представление значения @code{SCM} как интегрального\n"
"значения Си типа, но также может содержать любое значение Си, даже\n"
"если оно не соответствует действительному объекту Scheme."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:400
msgid ""
"For a variable @var{x} of type @code{SCM}, the Scheme object's type\n"
"information is stored in a form that is not directly usable.  To be able\n"
"to work on the type encoding of the scheme value, the @code{SCM}\n"
"variable has to be transformed into the corresponding representation as\n"
"a @code{scm_t_bits} variable @var{y} by using the @code{SCM_UNPACK}\n"
"macro.  Once this has been done, the type of the scheme object @var{x}\n"
"can be derived from the content of the bits of the @code{scm_t_bits}\n"
"value @var{y}, in the way illustrated by the example earlier in this\n"
"chapter (@pxref{Cheaper Pairs}).  Conversely, a valid bit encoding of a\n"
"Scheme value as a @code{scm_t_bits} variable can be transformed into the\n"
"corresponding @code{SCM} value using the @code{SCM_PACK} macro."
msgstr ""
"Для переменной @var{x} типа @code{SCM}, информация о типе объекта\n"
"Scheme храниться в форме, которая не может быть использована\n"
"непосредственно. Чтобы иметь возможность рабоать с типом кодирующим\n"
"значение scheme, переменная @code{SCM} должна быть преобразована в\n"
"соответствующее представление,  такое как @code{scm_t_bits} переменной\n"
"@var{y}, используя макрос @code{SCM_UNPACK}.  Как только это будет\n"
"сделано, тип объекта scheme  @var{x} может быть получен из содержимого\n"
"битов значения @code{scm_t_bits} @var{y}, способом проилюстрированным\n"
"ранее в этой главе (@pxref{Cheaper Pairs}).  И наоборот, действительное\n"
"битовое кодирование значения переменной @code{scm_t_bits} может быть\n"
"преобразовано в соответствующее значение @code{SCM} используя макрос\n"
"@code{SCM_PACK}."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:403
msgid ""
"@node Immediate objects\n"
"@subsubsection Immediate objects"
msgstr ""
"@node Immediate objects\n"
"@subsubsection Непосредственные Объекты"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:410
msgid ""
"A Scheme object may either be an immediate, i.e.@: carrying all necessary\n"
"information by itself, or it may contain a reference to a @dfn{cell}\n"
"with additional information on the heap.  Although in general it should\n"
"be irrelevant for user code whether an object is an immediate or not,\n"
"within Guile's own code the distinction is sometimes of importance.\n"
"Thus, the following low level macro is provided:"
msgstr ""
"Объект Scheme может быть либо непосредственным, т.е.: содержать всю "
"необходимую\n"
"информацию в себе, или он может содержать ссылку на @dfn{ячейку(cell)} с\n"
"дополнительной инфомрацией в куче. Хотя в общем случае для кода "
"пользователя\n"
"не должно быть никакого значения, является ли объект непосредственным или "
"нет,\n"
"в собственном коде Guile различие иногда имеет значение. Работа "
"обеспечивается\n"
"следующими предоставляемыми низкоуровневыми макросами:"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:418
msgid ""
"@deftypefn Macro int SCM_IMP (SCM @var{x})\n"
"A Scheme object is an immediate if it fulfills the @code{SCM_IMP}\n"
"predicate, otherwise it holds an encoded reference to a heap cell.  The\n"
"result of the predicate is delivered as a C style boolean value.  User\n"
"code and code that extends Guile should normally not be required to use\n"
"this macro.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Macro int SCM_IMP (SCM @var{x})\n"
"Объект Scheme является непосредственным, если для него выполняется\n"
"предикат @code{SCM_IMP}, в противном случае он содержит закодированную\n"
"ссылку на ячейку в куче. Результат предиката предоставляется Си как\n"
"булево значение. Коду пользователя и коду, который расширяет Guile,\n"
"обычно не требуется использовать этот макрос.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:430
msgid ""
"@noindent\n"
"Summary:\n"
"@itemize @bullet\n"
"@item\n"
"Given a Scheme object @var{x} of unknown type, check first\n"
"with @code{SCM_IMP (@var{x})} if it is an immediate object.\n"
"@item\n"
"If so, all of the type and value information can be determined from the\n"
"@code{scm_t_bits} value that is delivered by @code{SCM_UNPACK\n"
"(@var{x})}.\n"
"@end itemize"
msgstr ""
"@noindent\n"
"Резюмируем:\n"
"@itemize @bullet\n"
"@item\n"
"Если задан Scheme объект @var{x} неизвестного типа, сначала проверьте с\n"
"помощью @code{SCM_IMP (@var{x})} не непосредственный ли это объект.\n"
"@item\n"
"Если это так, всю информацию о типе и значении можно определить из\n"
"значения @code{scm_t_bits}, которое предоставляется макросом \n"
"@code{SCM_UNPACK(@var{x})}.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:434
msgid ""
"There are a number of special values in Scheme, most of them documented\n"
"elsewhere in this manual. It's not quite the right place to put them,\n"
"but for now, here's a list of the C names given to some of these values:"
msgstr ""
"В Scheme имеется ряд специальных значений, большинство из которых \n"
"задокументировано в других местах этого руководства. Это не совсем "
"подходящее\n"
"место для их размещения, но пока вот список Си имен, присвоенных некоторым\n"
"из этих значений:"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:439
msgid ""
"@deftypefn Macro SCM SCM_EOL\n"
"The Scheme empty list object, or ``End Of List'' object, usually written\n"
"in Scheme as @code{'()}.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Macro SCM SCM_EOL\n"
"Объект пустого списка Scheme или объект ``End Of List'', обычно "
"записываемый\n"
"в Scheme как @code{'()}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:444
msgid ""
"@deftypefn Macro SCM SCM_EOF_VAL\n"
"The Scheme end-of-file value.  It has no standard written\n"
"representation, for obvious reasons.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Macro SCM SCM_EOF_VAL\n"
"Значение - конец файла(end-of-file) в Scheme.  Оне не имеет стандартного \n"
"представления, по очевидным причинам.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:448
msgid ""
"@deftypefn Macro SCM SCM_UNSPECIFIED\n"
"The value returned by some (but not all) expressions that the Scheme\n"
"standard says return an ``unspecified'' value."
msgstr ""
"@deftypefn Macro SCM SCM_UNSPECIFIED\n"
"Значение, возвращаемое некоторыми(но не всеми) выражениями, указанными\n"
"в стандарте Scheme возвращающими ``неопределенное(unspecified)'' значение."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:454
msgid ""
"This is sort of a weirdly literal way to take things, but the standard\n"
"read-eval-print loop prints nothing when the expression returns this\n"
"value, so it's not a bad idea to return this when you can't think of\n"
"anything else helpful.\n"
"@end deftypefn"
msgstr ""
"Это своего рода своего рода буквальный способ использования стандарта,\n"
"цикл read-eval-print не печатает ничего, когда выражение возвращает\n"
"это значение. Поэтому неплохо вернуть это значение, когда вы не можете\n"
"придумать ничего полезного.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:459
msgid ""
"@deftypefn Macro SCM SCM_UNDEFINED\n"
"The ``undefined'' value.  Its most important property is that is not\n"
"equal to any valid Scheme value.  This is put to various internal uses\n"
"by C code interacting with Guile."
msgstr ""
"@deftypefn Macro SCM SCM_UNDEFINED\n"
"``Неопределенное'' значение.  Его наиболее важным свойством является то, "
"что\n"
"он не равен действительным значениям Scheme. Это связано с различными\n"
"внутренними потребностями используемого Си кода, взаимодействующего с Guile."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:463
msgid ""
"For example, when you write a C function that is callable from Scheme\n"
"and which takes optional arguments, the interpreter passes\n"
"@code{SCM_UNDEFINED} for any arguments you did not receive."
msgstr ""
"Например, когда вы пишите функцию Си, вызываемую из Scheme и\n"
"которая принимает необязательные аргументы, интерпретатор \n"
"передает @code{SCM_UNDEFINED} для любых аргументов которые\n"
"вы не получили."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:466
msgid ""
"We also use this to mark unbound variables.\n"
"@end deftypefn"
msgstr ""
"Мы также используем это для обозначения несвязанных переменных.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:472
msgid ""
"@deftypefn Macro int SCM_UNBNDP (SCM @var{x})\n"
"Return true if @var{x} is @code{SCM_UNDEFINED}.  Note that this is not a\n"
"check to see if @var{x} is @code{SCM_UNBOUND}.  History will not be kind\n"
"to us.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Macro int SCM_UNBNDP (SCM @var{x})\n"
"Возвращает true, если @var{x} равна @code{SCM_UNDEFINED}.  Обратите "
"внимание,\n"
"что это не проверка является ли @var{x} - @code{SCM_UNBOUND}(является ли х "
"связанным).\n"
"История не простит такое название нам.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:476
msgid ""
"@node Non-immediate objects\n"
"@subsubsection Non-immediate objects"
msgstr ""
"@node Non-immediate objects\n"
"@subsubsection Опосредованные(Non-immediate) Объекты"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:482
msgid ""
"A Scheme object of type @code{SCM} that does not fulfill the\n"
"@code{SCM_IMP} predicate holds an encoded reference to a heap cell.\n"
"This reference can be decoded to a C pointer to a heap cell using the\n"
"@code{SCM2PTR} macro.  The encoding of a pointer to a heap cell into a\n"
"@code{SCM} value is done using the @code{PTR2SCM} macro."
msgstr ""
"Объект Scheme типа @code{SCM}, для которого не выполнен предикат \n"
"@code{SCM_IMP}, содержит закодированную ссылку на ячеку из кучи.\n"
"Эта ссылка может быть декодирована в Си указатель на ячеку кучи,\n"
"использованием макроса @code{SCM2PTR}.  Кодирование указателя\n"
"на ячейку кучи в значение @code{SCM} выполняется с использоанием\n"
"макроса @code{PTR2SCM}."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:488
msgid ""
"@c (FIXME:: this name should be changed)\n"
"@deftypefn Macro {scm_t_cell *} SCM2PTR (SCM @var{x})\n"
"Extract and return the heap cell pointer from a non-immediate @code{SCM}\n"
"object @var{x}.\n"
"@end deftypefn"
msgstr ""
"@c (FIXME:: this name should be changed)\n"
"@deftypefn Macro {scm_t_cell *} SCM2PTR (SCM @var{x})\n"
"Извлечь и вернуть указатель ячеки кучи из опосредствованого объекта\n"
"@code{SCM} @var{x}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:494
msgid ""
"@c (FIXME:: this name should be changed)\n"
"@deftypefn Macro SCM PTR2SCM (scm_t_cell * @var{x})\n"
"Return a @code{SCM} value that encodes a reference to the heap cell\n"
"pointer @var{x}.\n"
"@end deftypefn"
msgstr ""
"@c (FIXME:: this name should be changed)\n"
"@deftypefn Macro SCM PTR2SCM (scm_t_cell * @var{x})\n"
"Возвращает значение @code{SCM}, которое кодирует ссылку на указатель\n"
"@var{x} кучи.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:502
msgid ""
"Note that it is also possible to transform a non-immediate @code{SCM}\n"
"value by using @code{SCM_UNPACK} into a @code{scm_t_bits} variable.\n"
"However, the result of @code{SCM_UNPACK} may not be used as a pointer to\n"
"a @code{scm_t_cell}: only @code{SCM2PTR} is guaranteed to transform a\n"
"@code{SCM} object into a valid pointer to a heap cell.  Also, it is not\n"
"allowed to apply @code{PTR2SCM} to anything that is not a valid pointer\n"
"to a heap cell."
msgstr ""
"Обратите внимание, что также возможно преобразовать опосредствованное\n"
"значение @code{SCM} используя @code{SCM_UNPACK} в переменную "
"@code{scm_t_bits}.\n"
"Однако, результат @code{SCM_UNPACK} не может быть использован как указатель\n"
"на @code{scm_t_cell}: только @code{SCM2PTR} гарантированно преобразует "
"объект\n"
"@code{SCM} в действительный указатель на ячейку кучи. Кроме того, не\n"
"разрешается применять @code{PTR2SCM} ко всему, что не является\n"
"действительным указателем на ячейки кучи."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:515
msgid ""
"@noindent\n"
"Summary:  \n"
"@itemize @bullet\n"
"@item\n"
"Only use @code{SCM2PTR} on @code{SCM} values for which @code{SCM_IMP} is\n"
"false!\n"
"@item\n"
"Don't use @code{(scm_t_cell *) SCM_UNPACK (@var{x})}!  Use @code{SCM2PTR\n"
"(@var{x})} instead!\n"
"@item\n"
"Don't use @code{PTR2SCM} for anything but a cell pointer!\n"
"@end itemize"
msgstr ""
"@noindent\n"
"Резюме:  \n"
"@itemize @bullet\n"
"@item\n"
"Используйте @code{SCM2PTR} только для значений @code{SCM}, для которых "
"@code{SCM_IMP}\n"
"является ложным!\n"
"@item\n"
"Не используйте @code{(scm_t_cell *) SCM_UNPACK (@var{x})}!  Вместо этог "
"используйте\n"
"{SCM2PTR (@var{x})}!\n"
"@item\n"
"Не ипользуйте @code{PTR2SCM} для чего либо, кроме как указателя на ячейку из "
"кучи!\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:518
msgid ""
"@node Allocating Cells\n"
"@subsubsection Allocating Cells"
msgstr ""
"@node Allocating Cells\n"
"@subsubsection Выделение Ячеек"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:522
msgid ""
"Guile provides both ordinary cells with two slots, and double cells\n"
"with four slots.  The following two function are the most primitive\n"
"way to allocate such cells."
msgstr ""
"Guile предоставляет как обычные ячейки с двумя слотами, так и двойные\n"
"ячейки с четырьмя слотами.  Следующие функции являются наибольее \n"
"примитивным способом выделения ячеек."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:529
msgid ""
"If the caller intends to use it as a header for some other type, she\n"
"must pass an appropriate magic value in @var{word_0}, to mark it as a\n"
"member of that type, and pass whatever value as @var{word_1}, etc that\n"
"the type expects.  You should generally not need these functions,\n"
"unless you are implementing a new datatype, and thoroughly understand\n"
"the code in @code{<libguile/tags.h>}."
msgstr ""
"Если вызывающий намерен использовать его в качестве заголовка для\n"
"какого-либо другого типа, он должен передать соответствующее\n"
"магическое значение в  @var{word_0}, чтобы пометить его\n"
"как член этого типа и передать все значение как @var{word_1}, и т.д.,\n"
"которое необходимо данному типу. Обычно вам не нужны эти функции,\n"
"если вы не внедряете новый тип данных лезете глубоко в код\n"
" @code{<libguile/tags.h>}."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:531
msgid "If you just want to allocate pairs, use @code{scm_cons}."
msgstr "Если вы просто хотите выделить пару, используйте @code{scm_cons}."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:535
msgid ""
"@deftypefn Function SCM scm_cell (scm_t_bits word_0, scm_t_bits word_1)\n"
"Allocate a new cell, initialize the two slots with @var{word_0} and\n"
"@var{word_1}, and return it."
msgstr ""
"@deftypefn Function SCM scm_cell (scm_t_bits word_0, scm_t_bits word_1)\n"
"Выделяет новую ячейку, инициализирует два слота значениями @var{word_0} и\n"
"@var{word_1}, и возвращает ее."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:540
msgid ""
"Note that @var{word_0} and @var{word_1} are of type @code{scm_t_bits}.\n"
"If you want to pass a @code{SCM} object, you need to use\n"
"@code{SCM_UNPACK}.\n"
"@end deftypefn"
msgstr ""
"Обратите внимание, что слова @var{word_0} и @var{word_1} имеют тип "
"@code{scm_t_bits}.\n"
"Если вы хотите передать объект @code{SCM} вам необдимо использовать\n"
"@code{SCM_UNPACK}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:545
msgid ""
"@deftypefn Function SCM scm_double_cell (scm_t_bits word_0, scm_t_bits "
"word_1, scm_t_bits word_2, scm_t_bits word_3)\n"
"Like @code{scm_cell}, but allocates a double cell with four\n"
"slots.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Function SCM scm_double_cell (scm_t_bits word_0, scm_t_bits "
"word_1, scm_t_bits word_2, scm_t_bits word_3)\n"
"Подобно @code{scm_cell}, но выделяет двойную ячейку с четыремя слотами.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:548
msgid ""
"@node Heap Cell Type Information\n"
"@subsubsection Heap Cell Type Information"
msgstr ""
"@node Heap Cell Type Information\n"
"@subsubsection Ячейка Кучи Информация о типе"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:554
msgid ""
"Heap cells contain a number of entries, each of which is either a scheme\n"
"object of type @code{SCM} or a raw C value of type @code{scm_t_bits}.\n"
"Which of the cell entries contain Scheme objects and which contain raw C\n"
"values is determined by the first entry of the cell, which holds the\n"
"cell type information."
msgstr ""
"Ячейки кучи содержат несколько записей, каждая из которых является либо\n"
"объектом scheme типа @code{SCM} или наобработанным значением Си типа\n"
"@code{scm_t_bits}. Какая из записей ячейки содержит объекты Scheme\n"
"и какая содержит необработанные значения Си, определяется первой записью\n"
"ячейки, которая содержит ячейку типа информации."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:560
msgid ""
"@deftypefn Macro scm_t_bits SCM_CELL_TYPE (SCM @var{x})\n"
"For a non-immediate Scheme object @var{x}, deliver the content of the\n"
"first entry of the heap cell referenced by @var{x}.  This value holds\n"
"the information about the cell type.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Macro scm_t_bits SCM_CELL_TYPE (SCM @var{x})\n"
"Для опосредованного объекта Scheme  @var{x}, достает содержимое первой\n"
"записи ячейки кучи, на которую ссылается @var{x}.  Это значение\n"
"содержит информацию о типе ячейки.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:566
msgid ""
"@deftypefn Macro void SCM_SET_CELL_TYPE (SCM @var{x}, scm_t_bits @var{t})\n"
"For a non-immediate Scheme object @var{x}, write the value @var{t} into\n"
"the first entry of the heap cell referenced by @var{x}.  The value\n"
"@var{t} must hold a valid cell type.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Macro void SCM_SET_CELL_TYPE (SCM @var{x}, scm_t_bits @var{t})\n"
"Для опосредованного объекта Scheme @var{x}, записывает значение @var{t} в\n"
"первую запись ячеейки кучи на которую ссылается @var{x}.  Значение @var{t} \n"
"должно содержать действительный тип ячекйки.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:570
msgid ""
"@node Accessing Cell Entries\n"
"@subsubsection Accessing Cell Entries"
msgstr ""
"@node Accessing Cell Entries\n"
"@subsubsection Доступ к содержимому Ячеек"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:577
msgid ""
"For a non-immediate Scheme object @var{x}, the object type can be\n"
"determined by reading the cell type entry using the @code{SCM_CELL_TYPE}\n"
"macro.  For each different type of cell it is known which cell entries\n"
"hold Scheme objects and which cell entries hold raw C data.  To access\n"
"the different cell entries appropriately, the following macros are\n"
"provided."
msgstr ""
"Для опосредованного объекта Scheme @var{x}, тип объекта можно определить\n"
"прочитав ячейку типа используя макрос @code{SCM_CELL_TYPE}.  Для каждого\n"
"типа ячкейки известно какие записи содержат ячейки объектов Scheme и\n"
"и какие записи содержат ячейки необработанных Си данных. Для доступа\n"
"к различным записям ячеек соответственно, предоставляются следующие\n"
"макросы."

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:594
msgid ""
"@deftypefn Macro scm_t_bits SCM_CELL_WORD (SCM @var{x}, unsigned int "
"@var{n})\n"
"Deliver the cell entry @var{n} of the heap cell referenced by the\n"
"non-immediate Scheme object @var{x} as raw data.  It is illegal, to\n"
"access cell entries that hold Scheme objects by using these macros.  For\n"
"convenience, the following macros are also provided.\n"
"@itemize @bullet\n"
"@item\n"
"SCM_CELL_WORD_0 (@var{x}) @result{} SCM_CELL_WORD (@var{x}, 0)\n"
"@item\n"
"SCM_CELL_WORD_1 (@var{x}) @result{} SCM_CELL_WORD (@var{x}, 1)\n"
"@item\n"
"@dots{}\n"
"@item\n"
"SCM_CELL_WORD_@var{n} (@var{x}) @result{} SCM_CELL_WORD (@var{x}, @var{n})\n"
"@end itemize\n"
"@end deftypefn"
msgstr ""
"@deftypefn Macro scm_t_bits SCM_CELL_WORD (SCM @var{x}, unsigned int "
"@var{n})\n"
"Достать запись ячейки @var{n}, на которую ссылается опосредованный объект\n"
"Scheme @var{x} как необработанные данные.  Это незаконно, для доступа\n"
"к ячейкам, в которых объекты Scheme используют эти макросы. Для удобства\n"
"предусмотрены следующие макросы:@itemize @bullet\n"
"@item\n"
"SCM_CELL_WORD_0 (@var{x}) @result{} SCM_CELL_WORD (@var{x}, 0)\n"
"@item\n"
"SCM_CELL_WORD_1 (@var{x}) @result{} SCM_CELL_WORD (@var{x}, 1)\n"
"@item\n"
"@dots{}\n"
"@item\n"
"SCM_CELL_WORD_@var{n} (@var{x}) @result{} SCM_CELL_WORD (@var{x}, @var{n})\n"
"@end itemize\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:612
msgid ""
"@deftypefn Macro SCM SCM_CELL_OBJECT (SCM @var{x}, unsigned int @var{n})\n"
"Deliver the cell entry @var{n} of the heap cell referenced by the\n"
"non-immediate Scheme object @var{x} as a Scheme object.  It is illegal,\n"
"to access cell entries that do not hold Scheme objects by using these\n"
"macros.  For convenience, the following macros are also provided.\n"
"@itemize @bullet\n"
"@item\n"
"SCM_CELL_OBJECT_0 (@var{x}) @result{} SCM_CELL_OBJECT (@var{x}, 0)\n"
"@item\n"
"SCM_CELL_OBJECT_1 (@var{x}) @result{} SCM_CELL_OBJECT (@var{x}, 1)\n"
"@item\n"
"@dots{}\n"
"@item\n"
"SCM_CELL_OBJECT_@var{n} (@var{x}) @result{} SCM_CELL_OBJECT (@var{x},\n"
"@var{n})\n"
"@end itemize\n"
"@end deftypefn"
msgstr ""
"@deftypefn Macro SCM SCM_CELL_OBJECT (SCM @var{x}, unsigned int @var{n})\n"
"Достать запись @var{n} ячейки из кучи, на которую ссылается опосредованный\n"
"объект Scheme @var{x} как объект Scheme.  Это незаконно, для доступа к \n"
"записям ячеек которые не хранят объекты Scheme с помощью использования\n"
"данных макросов. для удобства, предусмотрены следующие макросы.\n"
"@itemize @bullet\n"
"@item\n"
"SCM_CELL_OBJECT_0 (@var{x}) @result{} SCM_CELL_OBJECT (@var{x}, 0)\n"
"@item\n"
"SCM_CELL_OBJECT_1 (@var{x}) @result{} SCM_CELL_OBJECT (@var{x}, 1)\n"
"@item\n"
"@dots{}\n"
"@item\n"
"SCM_CELL_OBJECT_@var{n} (@var{x}) @result{} SCM_CELL_OBJECT (@var{x},\n"
"@var{n})\n"
"@end itemize\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:636
msgid ""
"@deftypefn Macro void SCM_SET_CELL_WORD (SCM @var{x}, unsigned int @var{n}, "
"scm_t_bits @var{w})\n"
"Write the raw C value @var{w} into entry number @var{n} of the heap cell\n"
"referenced by the non-immediate Scheme value @var{x}.  Values that are\n"
"written into cells this way may only be read from the cells using the\n"
"@code{SCM_CELL_WORD} macros or, in case cell entry 0 is written, using\n"
"the @code{SCM_CELL_TYPE} macro.  For the special case of cell entry 0 it\n"
"has to be made sure that @var{w} contains a cell type information which\n"
"does not describe a Scheme object.  For convenience, the following\n"
"macros are also provided.\n"
"@itemize @bullet\n"
"@item\n"
"SCM_SET_CELL_WORD_0 (@var{x}, @var{w}) @result{} SCM_SET_CELL_WORD\n"
"(@var{x}, 0, @var{w})\n"
"@item\n"
"SCM_SET_CELL_WORD_1 (@var{x}, @var{w}) @result{} SCM_SET_CELL_WORD\n"
"(@var{x}, 1, @var{w})\n"
"@item\n"
"@dots{}\n"
"@item\n"
"SCM_SET_CELL_WORD_@var{n} (@var{x}, @var{w}) @result{} SCM_SET_CELL_WORD\n"
"(@var{x}, @var{n}, @var{w})\n"
"@end itemize\n"
"@end deftypefn"
msgstr ""
"@deftypefn Macro void SCM_SET_CELL_WORD (SCM @var{x}, unsigned int @var{n}, "
"scm_t_bits @var{w})\n"
"Записать необработанное значение Си @var{w} в запись с номером @var{n} \n"
"ячейки кучи опосредованного значения Scheme @var{x}.  Значения, которые\n"
"записываются в ячейки таким образом, могут считываться из ячеек с \n"
"использованием макросов @code{SCM_CELL_WORD} или, в случае, если это "
"нулевая\n"
"запись ячейки макросом @code{SCM_CELL_TYPE}.  Для частного случая нулевой\n"
"записи ячейки надо убедиться что @var{w} содержит информацию  о типе "
"ячейки,\n"
"которая не описывает объект Scheme.  Для удобства, предусмотрены следующие\n"
"макросы.\n"
"@itemize @bullet\n"
"@item\n"
"SCM_SET_CELL_WORD_0 (@var{x}, @var{w}) @result{} SCM_SET_CELL_WORD\n"
"(@var{x}, 0, @var{w})\n"
"@item\n"
"SCM_SET_CELL_WORD_1 (@var{x}, @var{w}) @result{} SCM_SET_CELL_WORD\n"
"(@var{x}, 1, @var{w})\n"
"@item\n"
"@dots{}\n"
"@item\n"
"SCM_SET_CELL_WORD_@var{n} (@var{x}, @var{w}) @result{} SCM_SET_CELL_WORD\n"
"(@var{x}, @var{n}, @var{w})\n"
"@end itemize\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:660
msgid ""
"@deftypefn Macro void SCM_SET_CELL_OBJECT (SCM @var{x}, unsigned int "
"@var{n}, SCM @var{o})\n"
"Write the Scheme object @var{o} into entry number @var{n} of the heap\n"
"cell referenced by the non-immediate Scheme value @var{x}.  Values that\n"
"are written into cells this way may only be read from the cells using\n"
"the @code{SCM_CELL_OBJECT} macros or, in case cell entry 0 is written,\n"
"using the @code{SCM_CELL_TYPE} macro.  For the special case of cell\n"
"entry 0 the writing of a Scheme object into this cell is only allowed\n"
"if the cell forms a Scheme pair.  For convenience, the following macros\n"
"are also provided.\n"
"@itemize @bullet\n"
"@item\n"
"SCM_SET_CELL_OBJECT_0 (@var{x}, @var{o}) @result{} SCM_SET_CELL_OBJECT\n"
"(@var{x}, 0, @var{o})\n"
"@item\n"
"SCM_SET_CELL_OBJECT_1 (@var{x}, @var{o}) @result{} SCM_SET_CELL_OBJECT\n"
"(@var{x}, 1, @var{o})\n"
"@item\n"
"@dots{}\n"
"@item\n"
"SCM_SET_CELL_OBJECT_@var{n} (@var{x}, @var{o}) @result{}\n"
"SCM_SET_CELL_OBJECT (@var{x}, @var{n}, @var{o})\n"
"@end itemize\n"
"@end deftypefn"
msgstr ""
"@deftypefn Macro void SCM_SET_CELL_OBJECT (SCM @var{x}, unsigned int "
"@var{n}, SCM @var{o})\n"
"\n"
"Записать объект Scheme @var{o} в запись с номером @var{n} \n"
"ячейки кучи опосредованного значения Scheme @var{x}.  Значения, которые\n"
"записываются в ячейки таким образом, могут считываться из ячеек с \n"
"использованием макросов @code{SCM_CELL_OBJECT} или, в случае, если это "
"нулевая\n"
"запись ячейки макросом @code{SCM_CELL_TYPE}.  Для частного случая нулевой\n"
"запись объекта Scheme в эту ячейку разрешена только в том случае, если\n"
"ячейка формирует пару.  Для удобства, предусмотрены следующие\n"
"макросы.@itemize @bullet\n"
"@item\n"
"SCM_SET_CELL_OBJECT_0 (@var{x}, @var{o}) @result{} SCM_SET_CELL_OBJECT\n"
"(@var{x}, 0, @var{o})\n"
"@item\n"
"SCM_SET_CELL_OBJECT_1 (@var{x}, @var{o}) @result{} SCM_SET_CELL_OBJECT\n"
"(@var{x}, 1, @var{o})\n"
"@item\n"
"@dots{}\n"
"@item\n"
"SCM_SET_CELL_OBJECT_@var{n} (@var{x}, @var{o}) @result{}\n"
"SCM_SET_CELL_OBJECT (@var{x}, @var{n}, @var{o})\n"
"@end itemize\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:672
msgid ""
"@noindent\n"
"Summary:\n"
"@itemize @bullet\n"
"@item\n"
"For a non-immediate Scheme object @var{x} of unknown type, get the type\n"
"information by using @code{SCM_CELL_TYPE (@var{x})}.\n"
"@item\n"
"As soon as the cell type information is available, only use the\n"
"appropriate access methods to read and write data to the different cell\n"
"entries.\n"
"@end itemize"
msgstr ""
"@noindent\n"
"Резюме:\n"
"@itemize @bullet\n"
"@item\n"
"Для опосредованного объекта Scheme @var{x} неизвестного типа, получить тип\n"
"можно используя макрос @code{SCM_CELL_TYPE (@var{x})}.\n"
"@item\n"
"Как только информация о типе ячейки будет доступна, используйте только\n"
"соответствующие методы доступа для чтения и записи данных в разные\n"
"записи ячейки.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/data-rep.texi:676
msgid ""
"@c Local Variables:\n"
"@c TeX-master: \"guile.texi\"\n"
"@c End:"
msgstr ""
