#
# Gagin <mikhail-gagin@yandex.ru>, 2018.
#
#. extracted from /home/bear/work/guile/doc/guile/en/libguile-program.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-07 12:37+0300\n"
"PO-Revision-Date: 2018-07-10 09:23+0300\n"
"Last-Translator: Gagin <mikhail-gagin@yandex.ru>\n"
"Language-Team: Russian <mikhail-gagin@yandex.ru>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2014\n"
"@c   Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:9
msgid ""
"@node Programming Overview\n"
"@section An Overview of Guile Programming"
msgstr ""
"@node Programming Overview\n"
"@section Обзор программирования на Guile"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:18
msgid ""
"Guile is designed as an extension language interpreter that is\n"
"straightforward to integrate with applications written in C (and C++).\n"
"The big win here for the application developer is that Guile\n"
"integration, as the Guile web page says, ``lowers your project's\n"
"hacktivation energy.''  Lowering the hacktivation energy means that you,\n"
"as the application developer, @emph{and your users}, reap the benefits\n"
"that flow from being able to extend the application in a high level\n"
"extension language rather than in plain old C."
msgstr ""
"Guile разработан как интерпретируемый язык расширения, который легко\n"
"интегрируется с приложениями написанными на Си(и Си++).\n"
"Большая победа здесь для разработчика приложений заключается в том, \n"
"что интеграция Guile, как говорит веб страница, ``снижает энергию "
"хактивации\n"
"(взлома) вашего проекта.''  Снижение энергии взлома означет, что вы как\n"
"разработчик приложения и ваши пользователи, воспользуются преимуществами\n"
"которые вытекают из возможности расширить приложение в языке расширения\n"
"высокого уровня, а не просто старым Си."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:26
msgid ""
"In abstract terms, it's difficult to explain what this really means and\n"
"what the integration process involves, so instead let's begin by jumping\n"
"straight into an example of how you might integrate Guile into an\n"
"existing program, and what you could expect to gain by so doing.  With\n"
"that example under our belts, we'll then return to a more general\n"
"analysis of the arguments involved and the range of programming options\n"
"available."
msgstr ""
"В абстрактных терминах трудно объяснить, что на самом деле означает и что\n"
"включает в себя этот процесс интеграции, поэтому вместо этого давайте\n"
"начнем с того что прыгнем прямо в пример того как вы можете интегрировать\n"
"Guile в существующую программу и то, что вы могли бы ожидать от этого.\n"
"В этом примере под нашими поясами, мы вернемся к более общему анализу\n"
"аргументов и диапазону доступных вариантов программирования."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:34
msgid ""
"@menu\n"
"* Extending Dia::               How one might extend Dia using Guile.\n"
"* Scheme vs C::                 Why Scheme is more hackable than C.\n"
"* Testbed Example::             Example: using Guile in a testbed.\n"
"* Programming Options::         Options for Guile programming.\n"
"* User Programming::            How about application users?\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:38
msgid ""
"@node Extending Dia\n"
"@subsection How One Might Extend Dia Using Guile"
msgstr ""
"@node Extending Dia\n"
"@subsection Как можно расширить Dia используя Guile"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:45
msgid ""
"Dia is a free software program for drawing schematic diagrams like flow\n"
"charts and floor plans (@uref{http://www.gnome.org/projects/dia/}).\n"
"This section conducts the thought\n"
"experiment of adding Guile to Dia.  In so doing, it aims to illustrate\n"
"several of the steps and considerations involved in adding Guile to\n"
"applications in general."
msgstr ""
"Dia это свободная программа для создания схемных диаграмм, таких как\n"
"блок-схемы и планы комнат (@uref{http://www.gnome.org/projects/dia/}).\n"
"Этот раздел ведет мысленный эксперимент добавления Guile в Dia.  \n"
"При этом он призван проилюстрировать некотоыре из этапов и соображения,\n"
"связанные с добавлением Guile к приложениям в целом."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:55
msgid ""
"@menu\n"
"* Dia Objective::               Deciding why you want to add Guile.\n"
"* Dia Steps::                   Four steps required to add Guile.\n"
"* Dia Objects::                 How to represent Dia data in Scheme.\n"
"* Dia Primitives::              Writing Guile primitives for Dia.\n"
"* Dia Hook::                    Providing a hook for Scheme evaluation.\n"
"* Dia Structure::               Overall structure for adding Guile.\n"
"* Dia Advanced::                Going further with Dia and Guile.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:59
msgid ""
"@node Dia Objective\n"
"@subsubsection Deciding Why You Want to Add Guile"
msgstr ""
"@node Dia Objective\n"
"@subsubsection Решите, почему вы хотите добавить Guile"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:63
msgid ""
"First off, you should understand why you want to add Guile to Dia at\n"
"all, and that means forming a picture of what Dia does and how it does\n"
"it.  So, what are the constituents of the Dia application?"
msgstr ""
"Прежде всего, вы должны понять, почему вы хотите добавить Guile в Dia "
"вообще,\n"
"и это означает, сформировать картину того, что делает Dia и как она это\n"
"делает. Итак, каковы составляющие приложения Dia?"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:70
msgid ""
"@itemize @bullet\n"
"@item\n"
"Most importantly, the @dfn{application domain objects} --- in other\n"
"words, the concepts that differentiate Dia from another application such\n"
"as a word processor or spreadsheet: shapes, templates, connectors,\n"
"pages, plus the properties of all these things."
msgstr ""
"@itemize @bullet\n"
"@item\n"
"Самое главное, объекты домена приложения(@dfn{application domain objects})\n"
" --- другими словами, концепции, которые отличают Dia от других приложений,\n"
"например текстовых процессоров или таблиц: формы, шаблоны, коннекторы,\n"
"страницы, а также свойства всех этих вещей."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:74
msgid ""
"@item\n"
"The code that manages the graphical face of the application, including\n"
"the layout and display of the objects above."
msgstr ""
"@item\n"
"Код, управляющий графическим интерфейсом приложения, включающий размещение\n"
"и отображение указанных выше объектов."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:79
msgid ""
"@item\n"
"The code that handles input events, which indicate that the application\n"
"user is wanting to do something.\n"
"@end itemize"
msgstr ""
"@item\n"
"Код, который обрабатывает входные события, которые указывают, что "
"пользователь\n"
"приложения хочет что-то сделать.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:83
msgid ""
"@noindent\n"
"(In other words, a textbook example of the @dfn{model - view -\n"
"controller} paradigm.)"
msgstr ""
"@noindent\n"
"(Другими словами, учебник примера парадигмы модель-вид-контроллер\n"
"(@dfn{model - view - controller}).)"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:89
msgid ""
"Next question: how will Dia benefit once the Guile integration is\n"
"complete?  Several (positive!) answers are possible here, and the choice\n"
"is obviously up to the application developers.  Still, one answer is\n"
"that the main benefit will be the ability to manipulate Dia's\n"
"application domain objects from Scheme."
msgstr ""
"Следующий вопрос: как Dia будет полезен после завершения интеграции с "
"Guile?\n"
"Возможны несколько (пложительных!) ответов и выбор, очевидно, зависит от \n"
"приложения разработчиков. Тем не менее, один ответ заключается в том, что\n"
"основным преимуществом будет способность манипулировать объектами домена\n"
"Dia приложения из Scheme."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:99
msgid ""
"Suppose that Dia made a set of procedures available in Scheme,\n"
"representing the most basic operations on objects such as shapes,\n"
"connectors, and so on.  Using Scheme, the application user could then\n"
"write code that builds upon these basic operations to create more\n"
"complex procedures.  For example, given basic procedures to enumerate\n"
"the objects on a page, to determine whether an object is a square, and\n"
"to change the fill pattern of a single shape, the user can write a\n"
"Scheme procedure to change the fill pattern of all squares on the\n"
"current page:"
msgstr ""
"Предположим, что Dia сделал набор процедур доступных в Scheme,\n"
"представляющих наиболее основные операции над объектами, такими как\n"
"фигуры, коннекторы и т.д. Используя Scheme, пользователь приложения\n"
"может затем написать код, который основывается на этих операциях для\n"
"создания более сложных процедур. Например, при базовых процедурах\n"
"перечисления объектов на странице, чтобы определить, является ли объект\n"
"квадратом, и изменить шаблон заполнения единичной фигуры, пользователь\n"
"может написать процедуру Scheme, чтобы изменить шаблон заполнения всех\n"
"квадратов на текущей странице."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:107
msgctxt "/home/bear/work/guile/doc/guile/en/libguile-program.texi:107"
msgid ""
"@lisp\n"
"(define (change-squares'-fill-pattern new-pattern)\n"
"  (for-each-shape current-page\n"
"    (lambda (shape)\n"
"      (if (square? shape)\n"
"          (change-fill-pattern shape new-pattern)))))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:111
msgid ""
"@node Dia Steps\n"
"@subsubsection Four Steps Required to Add Guile"
msgstr ""
"@node Dia Steps\n"
"@subsubsection Четыре шага необходимых для добавления Guile"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:113
msgid "Assuming this objective, four steps are needed to achieve it."
msgstr "Предполагая эту цель, для ее достижения необходимы четыре шага."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:120
msgid ""
"First, you need a way of representing your application-specific objects\n"
"--- such as @code{shape} in the previous example --- when they are\n"
"passed into the Scheme world.  Unless your objects are so simple that\n"
"they map naturally into builtin Scheme data types like numbers and\n"
"strings, you will probably want to use Guile's @dfn{foreign object}\n"
"interface to create a new Scheme data type for your objects."
msgstr ""
"Во-первых. вам нужен способ предоставления ваших объектов, специфичных\n"
"для приложения, таких как @code{shape} в предыдущем примере, когда они\n"
"передаются в мир Scheme.  Если объекты настолько просты, что они \n"
"естественным образом отображают встроенные типы данных Scheme, такие как\n"
"числа и строки, вы вероятно захотите использовать интерфейс внешних\n"
"объектов(@dfn{foreign object}) Guile для создания нового типа данных\n"
" Scheme для ваших объектов."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:125
msgid ""
"Second, you need to write code for the basic operations like\n"
"@code{for-each-shape} and @code{square?} such that they access and\n"
"manipulate your existing data structures correctly, and then make these\n"
"operations available as @dfn{primitives} on the Scheme level."
msgstr ""
"Во-вторых, вам нужно написать код для основных операций, таких как\n"
"@code{for-each-shape} и @code{square?} чтобы они имели доступ и\n"
"управляли вашими существующими структурами данных. Затем сделайте\n"
"эти операции доступными как примитивы(@dfn{primitives}) на уровне\n"
"Scheme."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:129
msgid ""
"Third, you need to provide some mechanism within the Dia application\n"
"that a user can hook into to cause arbitrary Scheme code to be\n"
"evaluated."
msgstr ""
"В-третьих, вам необходимо предоставить некоторый механизм в приложении\n"
"Dia, который пользователь может подключить, чтобы вызвать произвольный \n"
"код Scheme для вычисления."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:134
msgid ""
"Finally, you need to restructure your top-level application C code a\n"
"little so that it initializes the Guile interpreter correctly and\n"
"declares your @dfn{foreign objects} and @dfn{primitives} to the Scheme\n"
"world."
msgstr ""
"Наконец, вам нужно немного перестроить свой Си код верхнего уровня\n"
"приложения, чтобы он правильно инициализировал интерпретатор Guile и\n"
"объявлял ваши внешние объекты(@dfn{foreign objects}) и "
"примитивы(@dfn{primitives})\n"
"в мире Scheme."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:136
msgid "The following subsections expand on these four points in turn."
msgstr ""
"Следующие подразделы в свою очередь расширяются по этим четырем\n"
"пунктам."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:140
msgid ""
"@node Dia Objects\n"
"@subsubsection How to Represent Dia Data in Scheme"
msgstr ""
"@node Dia Objects\n"
"@subsubsection Как представлять данные Dia в Scheme"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:145
msgid ""
"For all but the most trivial applications, you will probably want to\n"
"allow some representation of your domain objects to exist on the Scheme\n"
"level.  This is where foreign objects come in, and with them issues of\n"
"lifetime management and garbage collection."
msgstr ""
"Для всех, кроме самых тривиальных приложений, вы, вероятно, захотите "
"разрешить\n"
"представление объектов домена вашего приложения на уровне Scheme. Здесь\n"
"появляются внешние объекты(foreign objects) и связанные с ними вопросы "
"управления\n"
"их жизненным циклом и сборкой мусора."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:149
msgid ""
"To get more concrete about this, let's look again at the example we gave\n"
"earlier of how application users can use Guile to build higher-level\n"
"functions from the primitives that Dia itself provides."
msgstr ""
"Чтобы получить более конкретную информацию об этом, давайте еще раз "
"взглянем\n"
"на пример, который мы дали ранее о том, как пользователи приложения могут\n"
"использовать Guile для создания функций более высокого уровня из "
"примитивов,\n"
"которые обеспечивает сам Dia."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:157
msgctxt "/home/bear/work/guile/doc/guile/en/libguile-program.texi:157"
msgid ""
"@lisp\n"
"(define (change-squares'-fill-pattern new-pattern)\n"
"  (for-each-shape current-page\n"
"    (lambda (shape)\n"
"      (if (square? shape)\n"
"          (change-fill-pattern shape new-pattern)))))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:163
msgid ""
"Consider what is stored here in the variable @code{shape}.  For each\n"
"shape on the current page, the @code{for-each-shape} primitive calls\n"
"@code{(lambda (shape) @dots{})} with an argument representing that\n"
"shape.  Question is: how is that argument represented on the Scheme\n"
"level?  The issues are as follows."
msgstr ""
"Рассмотрим, что здесь храниться в переменной @code{shape}.  Для каждой\n"
"фигуры(shape) на текущей странице примитив @code{for-each-shape} вызывает\n"
"лямбда-функцию @code{(lambda (shape) @dots{})} с аргументом, представляющим\n"
"фигуру(shape).  Вопрос: как этот аргумент представлен на уровне Scheme?\n"
"Проблемы являются следующими."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:171
msgid ""
"@itemize @bullet\n"
"@item\n"
"Whatever the representation, it has to be decodable again by the C code\n"
"for the @code{square?} and @code{change-fill-pattern} primitives.  In\n"
"other words, a primitive like @code{square?} has somehow to be able to\n"
"turn the value that it receives back into something that points to the\n"
"underlying C structure describing a shape."
msgstr ""
"@itemize @bullet\n"
"@item\n"
"Каким бы ни было представление, оно должно быть снова декодировано кодом\n"
"Си для примитивов @code{square?} и @code{change-fill-pattern}.  Другими\n"
"словами, примитивы такие как @code{square?} имеет возможность, так или\n"
"иначе, превратить значение, которое оно получает обратно во что-то,\n"
"что указывает путь к базовой Си структуре, описывающей фигуру."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:179
msgid ""
"@item\n"
"The representation must also cope with Scheme code holding on to the\n"
"value for later use.  What happens if the Scheme code stores\n"
"@code{shape} in a global variable, but then that shape is deleted (in a\n"
"way that the Scheme code is not aware of), and later on some other\n"
"Scheme code uses that global variable again in a call to, say,\n"
"@code{square?}?"
msgstr ""
"@item\n"
"Представление также должно справляться с тем, что код Scheme удерживает\n"
"значения для дальнейшего использования. Что произойдет, если код Scheme\n"
"сохранит @code{shape} в глобальной переменной, но когда эта фигура(shape)\n"
"удаляется(таким образом, что код Scheme не знает об этом) и затем некоторый\n"
"другой код Scheme снова использует эту глобальную переменную в вызове,\n"
"скажем в @code{square?}?"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:191
msgid ""
"@item\n"
"The lifetime and memory allocation of objects that exist @emph{only} in\n"
"the Scheme world is managed automatically by Guile's garbage collector\n"
"using one simple rule: when there are no remaining references to an\n"
"object, the object is considered dead and so its memory is freed.  But\n"
"for objects that exist in both C and Scheme, the picture is more\n"
"complicated; in the case of Dia, where the @code{shape} argument passes\n"
"transiently in and out of the Scheme world, it would be quite wrong the\n"
"@strong{delete} the underlying C shape just because the Scheme code has\n"
"finished evaluation.  How do we avoid this happening?\n"
"@end itemize"
msgstr ""
"@item\n"
"Время жизни и распределение памяти объектов, которые существуют только\n"
"в мире Scheme управляются автоматически сборщиком мусора Guile, используя\n"
"только одно простое правило: когда нет никаких ссылок на объект, объект\n"
"считается мертвым и поэтому его память освобождается. Но для объектов,\n"
"которые существуют как в Си так и в Scheme, расклад более сложный; в случае\n"
"с Dia, где аргумент @code{shape} передается туда и и обратно в мире Scheme,\n"
"было бы совершенно не правильно удалять Си фигуры только потому, что код\n"
"Scheme завершил выполнение. Как избежать этого?\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:198
msgid ""
"One resolution of these issues is for the Scheme-level representation of\n"
"a shape to be a new, Scheme-specific C structure wrapped up as a foreign\n"
"object.  The foreign object is what is passed into and out of Scheme\n"
"code, and the Scheme-specific C structure inside the foreign object\n"
"points to Dia's underlying C structure so that the code for primitives\n"
"like @code{square?} can get at it."
msgstr ""
"Одно из решений этих вопросов заключается в представлении фигуры(shape) на\n"
"уровне Scheme новой, Scheme-специфичной Си структурой обернутой в качестве\n"
"внешнего объекта. Внешний объект, что передается в код и выводиться из кода\n"
"Scheme и Scheme-специфичная Си структура внутри внешнего объекта указывает\n"
"на лежащую в их основе Си структуру Dia, так что код для примитивов, таких\n"
"как @code{square?} может получить ее."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:208
msgid ""
"To cope with an underlying shape being deleted while Scheme code is\n"
"still holding onto a Scheme shape value, the underlying C structure\n"
"should have a new field that points to the Scheme-specific foreign\n"
"object.  When a shape is deleted, the relevant code chains through to\n"
"the Scheme-specific structure and sets its pointer back to the\n"
"underlying structure to NULL.  Thus the foreign object value for the\n"
"shape continues to exist, but any primitive code that tries to use it\n"
"will detect that the underlying shape has been deleted because the\n"
"underlying structure pointer is NULL."
msgstr ""
"Чтобы справиться с удалением фигуры, в то время как код Scheme все еще\n"
"хранит значение фигуры, базовая Си структура должна иметь новое поле,\n"
"которое указывает на Scheme-специфичный внешний объект. Когда фигура\n"
"удаляется, соответствую код по цепочке к Scheme-специфичномой структуре\n"
"и устанавливает этот обратный указатель на базовую структуру в NULL.  Таким\n"
"образом, значение внешнего объекта для фигуры продолжает существовать, но \n"
"любой код примитивов, которые попытается ее использовать, обнаружит, что\n"
"базовая фигура была удалена, поскольку указатель базовой стурктуры - NULL."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:212
msgid ""
"So, to summarize the steps involved in this resolution of the problem\n"
"(and assuming that the underlying C structure for a shape is\n"
"@code{struct dia_shape}):"
msgstr ""
"Итак, суммируем шаги, связанные с этим решением проблемы \n"
"(и предполагая, что базовой структурой Си для фигуры является\n"
"@code{struct dia_shape}):"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:217
msgid ""
"@itemize @bullet\n"
"@item\n"
"Define a new Scheme-specific structure that @emph{points} to the\n"
"underlying C structure:"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"Определим новую Scheme-специфичную структуру которая "
"указывает(@emph{points})\n"
"на базовую Си структуру:"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:224
msgid ""
"@lisp\n"
"struct dia_guile_shape\n"
"@{\n"
"  struct dia_shape * c_shape;   /* NULL => deleted */\n"
"@}\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:228
msgid ""
"@item\n"
"Add a field to @code{struct dia_shape} that points to its @code{struct\n"
"dia_guile_shape} if it has one ---"
msgstr ""
"@item\n"
"Добавим поле в @code{struct dia_shape}, которое указывает на Scheme-"
"специфичную\n"
"структуру @code{struct dia_guile_shape}, если оно одно ---"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:236
msgid ""
"@lisp\n"
"struct dia_shape\n"
"@{\n"
"  @dots{}\n"
"  struct dia_guile_shape * guile_shape;\n"
"@}\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:240
msgid ""
"@noindent\n"
"--- so that C code can set @code{guile_shape->c_shape} to NULL when the\n"
"underlying shape is deleted."
msgstr ""
"@noindent\n"
"--- так что Си код может установить @code{guile_shape->c_shape} в NULL "
"когда\n"
"базовая фигура удаляется."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:243
msgid ""
"@item\n"
"Wrap @code{struct dia_guile_shape} as a foreign object type."
msgstr ""
"@item\n"
"Обернем @code{struct dia_guile_shape} как тип внешнего объекта(foreign "
"object)."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:247
msgid ""
"@item\n"
"Whenever you need to represent a C shape onto the Scheme level, create a\n"
"foreign object instance for it, and pass that."
msgstr ""
"@item\n"
"Всякий раз, когда вам нужно представить Си фигуру на Scheme уровне, "
"создавайте\n"
"экземпляр внешнего объекта для нее и передавайте его."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:253
msgid ""
"@item\n"
"In primitive code that receives a shape foreign object instance, check the\n"
"@code{c_shape} field when decoding it, to find out whether the\n"
"underlying C shape is still there.\n"
"@end itemize"
msgstr ""
"@item\n"
"В коде примитивов, который получает экземпляр внешнего объекта фигуры, "
"проверяйте\n"
"поле @code{c_shape} при его расшифровке, чтобы выяснить, продолжает ли "
"сущетсвовать\n"
"лежащая в его основе базовая Си фигура.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:259
msgid ""
"As far as memory management is concerned, the foreign object values and\n"
"their Scheme-specific structures are under the control of the garbage\n"
"collector, whereas the underlying C structures are explicitly managed in\n"
"exactly the same way that Dia managed them before we thought of adding\n"
"Guile."
msgstr ""
"Что касается управления памятью, значения внешний объектов и их\n"
"Scheme-специфичные структуры находятся под управлением сборщика мусора,\n"
"тогда как базовые Си структуры явно управляются точно также, как Dia\n"
"управляла бы ими до того как мы подумали о добавлении Guile."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:266
msgid ""
"When the garbage collector decides to free a shape foreign object value,\n"
"it calls the @dfn{finalizer} function that was specified when defining\n"
"the shape foreign object type.  To maintain the correctness of the\n"
"@code{guile_shape} field in the underlying C structure, this function\n"
"should chain through to the underlying C structure (if it still exists)\n"
"and set its @code{guile_shape} field to NULL."
msgstr ""
"Когда сборщик мусора решает освободить значение внешнего объкта фигуры,\n"
"он вызывает функцию @dfn{finalizer} которая была указана при определении\n"
"типа внешнего объекта фигуры. Поддерживать правильность поля\n"
"@code{guile_shape} в базоваой Си структуре, эта функция должна перейти\n"
"к базовой сруктуре Си(если она еще существует) и установить ее поле \n"
"@code{guile_shape} в NULL."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:269
msgid ""
"For full documentation on defining and using foreign object types, see\n"
"@ref{Defining New Foreign Object Types}."
msgstr ""
"Полную документацию по определению и использованию типов внешних объектов\n"
"см. @ref{Defining New Foreign Object Types}."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:273
msgid ""
"@node Dia Primitives\n"
"@subsubsection Writing Guile Primitives for Dia"
msgstr ""
"@node Dia Primitives\n"
"@subsubsection Написание примитивов Guile для Dia"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:276
msgid ""
"Once the details of object representation are decided, writing the\n"
"primitive function code that you need is usually straightforward."
msgstr ""
"Как только будут определены детали представления объекта, написание кода\n"
"примитивной функции которая вам нужна, как правило, очень просто."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:281
msgid ""
"A primitive is simply a C function whose arguments and return value are\n"
"all of type @code{SCM}, and whose body does whatever you want it to do.\n"
"As an example, here is a possible implementation of the @code{square?}\n"
"primitive:"
msgstr ""
"Примитив это просто Си функция, аргументы и возвращаемые значение которой\n"
"имеют тип @code{SCM}, и чье тело делает то что вы хотите. В качестве "
"примера\n"
"можно привести реализацию примитива @code{square?}:"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:286
msgid ""
"@lisp\n"
"static SCM square_p (SCM shape)\n"
"@{\n"
"  struct dia_guile_shape * guile_shape;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:289
msgid ""
"  /* Check that arg is really a shape object. */\n"
"  scm_assert_foreign_object_type (shape_type, shape);"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:292
msgid ""
"  /* Access Scheme-specific shape structure. */\n"
"  guile_shape = scm_foreign_object_ref (shape, 0);"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:299
msgid ""
"  /* Find out if underlying shape exists and is a\n"
"     square; return answer as a Scheme boolean. */\n"
"  return scm_from_bool (guile_shape->c_shape &&\n"
"                        (guile_shape->c_shape->type == DIA_SQUARE));\n"
"@}\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:304
msgid ""
"Notice how easy it is to chain through from the @code{SCM shape}\n"
"parameter that @code{square_p} receives --- which is a foreign object\n"
"--- to the Scheme-specific structure inside the foreign object, and\n"
"thence to the underlying C structure for the shape."
msgstr ""
"Обратите внимание на то, как легко перейти из параметра @code{SCM shape}\n"
"который принимает @code{square_p} --- который является внешним объектом\n"
"--- к Scheme-специфичной структуре внутри внешнего объекта, а оттуда и\n"
"к базовой Си структуре фигуры."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:315
msgid ""
"In this code, @code{scm_assert_foreign_object_type},\n"
"@code{scm_foreign_object_ref}, and @code{scm_from_bool} are from the\n"
"standard Guile API.  We assume that @code{shape_type} was given to us\n"
"when we made the shape foreign object type, using\n"
"@code{scm_make_foreign_object_type}.  The call to\n"
"@code{scm_assert_foreign_object_type} ensures that @var{shape} is indeed\n"
"a shape.  This is needed to guard against Scheme code using the\n"
"@code{square?}  procedure incorrectly, as in @code{(square? \"hello\")};\n"
"Scheme's latent typing means that usage errors like this must be caught\n"
"at run time."
msgstr ""
"В этом коде @code{scm_assert_foreign_object_type},\n"
"@code{scm_foreign_object_ref} и @code{scm_from_bool} из стандартного \n"
"Guile API.  Мы преполагаем, что @code{shape_type} был доступен нам когда\n"
"мы создали форму внешнего объекта используя "
"@code{scm_make_foreign_object_type}.\n"
"Вызов @code{scm_assert_foreign_object_type} гарантирует, что @var{shape} \n"
"действительноis является фигурой.  Это необходимо для защиты кода Scheme,\n"
"использование процедуры @code{square?}  не корретно, как в форме "
"@code{(square? \"hello\")};\n"
"Скрытая типизация в Scheme означает, что такие ошибки использования должнф "
"быть пойманы\n"
"во время выполнения."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:323
msgid ""
"Having written the C code for your primitives, you need to make them\n"
"available as Scheme procedures by calling the @code{scm_c_define_gsubr}\n"
"function.  @code{scm_c_define_gsubr} (@pxref{Primitive Procedures})\n"
"takes arguments that specify the Scheme-level name for the primitive and\n"
"how many required, optional and rest arguments it can accept.  The\n"
"@code{square?} primitive always requires exactly one argument, so the\n"
"call to make it available in Scheme reads like this:"
msgstr ""
"Написав код Си для ваших примитивов, вы должны сделать их доступными\n"
"как процедуры Scheme вызывая функцию @code{scm_c_define_gsubr}. \n"
"@code{scm_c_define_gsubr} (@pxref{Primitive Procedures})\n"
"принимает аргументы, которые определяются на уровне Scheme по имени\n"
"примитива и количеству требуемых аргументов, необязательных и остальных\n"
"аргументов которые функция может принять. Примитив @code{square?} всегда\n"
"требует только один аргумент, пэтому вызов делающий его доступным\n"
"в Scheme, читается следующим образом:"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:327
msgid ""
"@lisp\n"
"scm_c_define_gsubr (\"square?\", 1, 0, 0, square_p);\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:330
msgid ""
"For where to put this call, see the subsection after next on the\n"
"structure of Guile-enabled code (@pxref{Dia Structure})."
msgstr ""
"Где поставить этот вызов, смотри подраздел ниже, следующий за структурой\n"
"доступа к Guile коду (@pxref{Dia Structure})."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:334
msgid ""
"@node Dia Hook\n"
"@subsubsection Providing a Hook for the Evaluation of Scheme Code"
msgstr ""
"@node Dia Hook\n"
"@subsubsection Предоставление хука для выполнения кода Scheme"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:338
msgid ""
"To make the Guile integration useful, you have to design some kind of\n"
"hook into your application that application users can use to cause their\n"
"Scheme code to be evaluated."
msgstr ""
"Чтобы сделать интеграцию Guile полезной, вы должны создать какой-то хук в \n"
"своем приложении, который пользователи приложения могли бы использовать\n"
"для выполнения кода Scheme."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:346
msgid ""
"Technically, this is straightforward; you just have to decide on a\n"
"mechanism that is appropriate for your application.  Think of Emacs, for\n"
"example: when you type @kbd{@key{ESC} :}, you get a prompt where you can\n"
"type in any Elisp code, which Emacs will then evaluate.  Or, again like\n"
"Emacs, you could provide a mechanism (such as an init file) to allow\n"
"Scheme code to be associated with a particular key sequence, and\n"
"evaluate the code when that key sequence is entered."
msgstr ""
"Технически это просто; вам просто нужно принять решение о механизме, "
"который\n"
"подходит для вашего приложения. Подумайте о Emacs, например, когда вы "
"вводите\n"
"@kbd{@key{ESC} :}, вы получаете подсказку, в которой вы можете ввести любой\n"
"код Elisp, который затем выполнит Emacs.  Или, снова, как в Emacs, вы "
"можете\n"
"предоставить механизм(такой как файл инициализации), чтобы позволить коду\n"
"Scheme, который должен быть связан с определенной последовательностью клавиш "
"и\n"
"выполнять этот код, когда вводиться эта последовательность клавиш."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:350
msgid ""
"In either case, once you have the Scheme code that you want to evaluate,\n"
"as a null terminated string, you can tell Guile to evaluate it by\n"
"calling the @code{scm_c_eval_string} function."
msgstr ""
"В любом случае, если у вас есть код Scheme, который вы хотите выполнять,\n"
"как строку оканчивающуюся нулем, вы можете сказать Guile выполнить ее, \n"
"вызывая функцию @code{scm_c_eval_string}."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:354
msgid ""
"@node Dia Structure\n"
"@subsubsection Top-level Structure of Guile-enabled Dia"
msgstr ""
"@node Dia Structure\n"
"@subsubsection Структура верхнего уровня доступа Guile в Dia"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:356
msgid "Let's assume that the pre-Guile Dia code looks structurally like this:"
msgstr ""
"Предположим, что код пред - Guile Dia выглядит структурно следующим образом:"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:360
msgctxt "/home/bear/work/guile/doc/guile/en/libguile-program.texi:360"
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{main ()}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:368
msgid ""
"@itemize @bullet\n"
"@item\n"
"do lots of initialization and setup stuff\n"
"@item\n"
"enter Gtk main loop\n"
"@end itemize\n"
"@end itemize"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"делает много операций инициализации и настройки\n"
"@item\n"
"вход в основной цикл обработки сообщений Gtk\n"
"@end itemize\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:373
msgid ""
"When you add Guile to a program, one (rather technical) requirement is\n"
"that Guile's garbage collector needs to know where the bottom of the C\n"
"stack is.  The easiest way to ensure this is to use\n"
"@code{scm_boot_guile} like this:"
msgstr ""
"Когда вы добавляете Guile в программу, одно (если точно, техническое)\n"
"требование состоит в том, чтобы  сборщим мусора Guile знал, где находиться\n"
"нижняя часть стека Си.  Самый простой способ убедиться в этом использовать\n"
"@code{scm_boot_guile} следующим образом:"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:377
msgctxt "/home/bear/work/guile/doc/guile/en/libguile-program.texi:377"
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{main ()}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:384
msgid ""
"@itemize @bullet\n"
"@item\n"
"do lots of initialization and setup stuff\n"
"@item\n"
"@code{scm_boot_guile (argc, argv, inner_main, NULL)}\n"
"@end itemize"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"делаем много операций инициализации и настройки\n"
"@item\n"
"@code{scm_boot_guile (argc, argv, inner_main, NULL)}\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:387
msgid ""
"@item\n"
"@code{inner_main ()}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:397
msgid ""
"@itemize @bullet\n"
"@item\n"
"define all foreign object types\n"
"@item\n"
"export primitives to Scheme using @code{scm_c_define_gsubr}\n"
"@item\n"
"enter Gtk main loop\n"
"@end itemize\n"
"@end itemize"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"определяем все типы внешних объектов\n"
"@item\n"
"экспортируем примитивы в Scheme с помощью @code{scm_c_define_gsubr}\n"
"@item\n"
"входим в основной цикл обработки Gtk\n"
"@end itemize\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:402
msgid ""
"In other words, you move the guts of what was previously in your\n"
"@code{main} function into a new function called @code{inner_main}, and\n"
"then add a @code{scm_boot_guile} call, with @code{inner_main} as a\n"
"parameter, to the end of @code{main}."
msgstr ""
"Другими словами, вы перемещаете внутренности того, что было ранее в вашей\n"
"основной функции @code{main} в новую функцию, называемую @code{inner_main},\n"
"а затем добавляете вызов @code{scm_boot_guile}, с параметром "
"@code{inner_main},\n"
"в конец функции @code{main}."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:410
msgid ""
"Assuming that you are using foreign objects and have written primitive\n"
"code as described in the preceding subsections, you also need to insert\n"
"calls to declare your new foreign objects and export the primitives to\n"
"Scheme.  These declarations must happen @emph{inside} the dynamic scope\n"
"of the @code{scm_boot_guile} call, but also @emph{before} any code is\n"
"run that could possibly use them --- the beginning of @code{inner_main}\n"
"is an ideal place for this."
msgstr ""
"Предполагая, что вы используете внешние объекты и написали код примитивов,\n"
"как описано в передыдущих подразделах вам также необходимо вставить вызовы\n"
"для объявления ваших новых внешних объектов и экспортировать примитивы\n"
"в Scheme.  Эти декларации должны происходить @emph{внутри} динамического\n"
"вызова @code{scm_boot_guile}, на также @emph{перед} любым кодом которы\n"
"бы мог использовать их --- начало функции @code{inner_main}\n"
"идеальное место для их размещения."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:414
msgid ""
"@node Dia Advanced\n"
"@subsubsection Going Further with Dia and Guile"
msgstr ""
"@node Dia Advanced\n"
"@subsubsection Далее с Dia и Guile"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:419
msgid ""
"The steps described so far implement an initial Guile integration that\n"
"already gives a lot of additional power to Dia application users.  But\n"
"there are further steps that you could take, and it's interesting to\n"
"consider a few of these."
msgstr ""
"Шаги, описанные до сих пор, реализуют первоначальную интеграцию Guile,\n"
"которая уже дает большую дополнительную мощность для пользователей \n"
"приложений Dia.  Но есть дальнейшие шаги, которые вы могли бы предпринять,\n"
"и интересно рассмотреть некоторые из них."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:424
msgid ""
"In general, you could progressively move more of Dia's source code from\n"
"C into Scheme.  This might make the code more maintainable and\n"
"extensible, and it could open the door to new programming paradigms that\n"
"are tricky to effect in C but straightforward in Scheme."
msgstr ""
"В общем, вы можете постепенно продвигать больше исходного кода Dia из\n"
"Си в Scheme.  Это может сделать код более удобным для обслуживания и\n"
"расширяемым, и он может открыть дверь для новых парадигм программирования,\n"
"которые сложно реализовать на Си, но легко на Scheme."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:428
msgid ""
"A specific example of this is that you could use the guile-gtk package,\n"
"which provides Scheme-level procedures for most of the Gtk+ library, to\n"
"move the code that lays out and displays Dia objects from C to Scheme."
msgstr ""
"Конкретным примером этого является то, что вы можете использовать пакет\n"
"guile-gtk, который предоставляет процедуры уровня Scheme для большей\n"
"части библиотеки Gtk+,  для перемещения кода, который размещает и "
"отображает\n"
"объекты Dia, с Си на Scheme."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:433
msgid ""
"As you follow this path, it naturally becomes less useful to maintain a\n"
"distinction between Dia's original non-Guile-related source code, and\n"
"its later code implementing foreign objects and primitives for the\n"
"Scheme world."
msgstr ""
"Поскольку вы следуете этому пути, естественно становиться менее полезным\n"
"поддерживать различие между оригинальным исходным кодом  Dia не связанным\n"
"с Guile, и его более поздним кодом, реализующим внешние объекты и примитивы\n"
"для мира Scheme."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:436
msgid ""
"For example, suppose that the original source code had a\n"
"@code{dia_change_fill_pattern} function:"
msgstr ""
"Например предположим, что оригинальный исходный код имел функцию\n"
"@code{dia_change_fill_pattern}:"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:444
msgid ""
"@lisp\n"
"void dia_change_fill_pattern (struct dia_shape * shape,\n"
"                              struct dia_pattern * pattern)\n"
"@{\n"
"  /* real pattern change work */\n"
"@}\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:449
msgid ""
"During initial Guile integration, you add a @code{change_fill_pattern}\n"
"primitive for Scheme purposes, which accesses the underlying structures\n"
"from its foreign object values and uses @code{dia_change_fill_pattern}\n"
"to do the real work:"
msgstr ""
"Во время первоначальной интеграции Guile, вы добавляете примитив "
"@code{change_fill_pattern}\n"
"для Scheme целей, которые обращаются к базовым структурам из своих значений "
"внешних объектов\n"
"и используют @code{dia_change_fill_pattern}, чтобы выполнить настоящую "
"работу."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:455
msgctxt "/home/bear/work/guile/doc/guile/en/libguile-program.texi:455"
msgid ""
"@lisp\n"
"SCM change_fill_pattern (SCM shape, SCM pattern)\n"
"@{\n"
"  struct dia_shape * d_shape;\n"
"  struct dia_pattern * d_pattern;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:457
msgctxt "/home/bear/work/guile/doc/guile/en/libguile-program.texi:457"
msgid "  @dots{}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:459
msgid "  dia_change_fill_pattern (d_shape, d_pattern);"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:463
msgctxt "/home/bear/work/guile/doc/guile/en/libguile-program.texi:463"
msgid ""
"  return SCM_UNSPECIFIED;\n"
"@}\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:469
msgid ""
"At this point, it makes sense to keep @code{dia_change_fill_pattern} and\n"
"@code{change_fill_pattern} separate, because\n"
"@code{dia_change_fill_pattern} can also be called without going through\n"
"Scheme at all, say because the user clicks a button which causes a\n"
"C-registered Gtk+ callback to be called."
msgstr ""
"На этом этапе имеет смысл сохранить @code{dia_change_fill_pattern} и\n"
"@code{change_fill_pattern} отдельно, поскольку "
"@code{dia_change_fill_pattern}\n"
"можно так же вызвать вообще без перехода через Scheme, скажем, потому что\n"
"пользователь нажимает кнопку, которая вызывает Си зарегистрированный в Gtk"
"+ \n"
"обрабочик."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:475
msgid ""
"But, if the code for creating buttons and registering their callbacks is\n"
"moved into Scheme (using guile-gtk), it may become true that\n"
"@code{dia_change_fill_pattern} can no longer be called other than\n"
"through Scheme.  In which case, it makes sense to abolish it and move\n"
"its contents directly into @code{change_fill_pattern}, like this:"
msgstr ""
"Но, если код для создания кнопок и регистрации их обратных вызовов "
"перемещается\n"
"в Scheme (используя guile-gtk), может оказаться, что "
"@code{dia_change_fill_pattern}\n"
"больше не может быть вызван иначе, чем через Scheme.  В этом случае, имеет "
"смысл\n"
"отменить его и пеереместить его содержимое непосредственно в "
"@code{change_fill_pattern},\n"
"например:"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:481
msgctxt "/home/bear/work/guile/doc/guile/en/libguile-program.texi:481"
msgid ""
"@lisp\n"
"SCM change_fill_pattern (SCM shape, SCM pattern)\n"
"@{\n"
"  struct dia_shape * d_shape;\n"
"  struct dia_pattern * d_pattern;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:483
msgctxt "/home/bear/work/guile/doc/guile/en/libguile-program.texi:483"
msgid "  @dots{}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:485
msgid "  /* real pattern change work */"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:489
msgctxt "/home/bear/work/guile/doc/guile/en/libguile-program.texi:489"
msgid ""
"  return SCM_UNSPECIFIED;\n"
"@}\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:492
msgid ""
"So further Guile integration progressively @emph{reduces} the amount of\n"
"functional C code that you have to maintain over the long term."
msgstr ""
"Таким образом, дальейшая интеграция Guile постепенно уменьшает количество\n"
"функционального кода Си, который вы должны поддерживать в долгосрочной\n"
"перспективе."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:502
msgid ""
"A similar argument applies to data representation.  In the discussion of\n"
"foreign objects earlier, issues arose because of the different memory\n"
"management and lifetime models that normally apply to data structures in\n"
"C and in Scheme.  However, with further Guile integration, you can\n"
"resolve this issue in a more radical way by allowing all your data\n"
"structures to be under the control of the garbage collector, and kept\n"
"alive by references from the Scheme world.  Instead of maintaining an\n"
"array or linked list of shapes in C, you would instead maintain a list\n"
"in Scheme."
msgstr ""
"Аналогичный аргумент применим и к представлению данных.  При обсуждении\n"
"внешних объектов ранее возникали проблемы из-за разных моделей управления\n"
"памятью и временем жизни, которые обычно применяются к структурам данных\n"
"в Си и в Scheme.  Однако, с дальнейшей интеграцией Guile, вы можете решить\n"
"эту проблему более радикально, разрешив всем вашим структурам данных быть\n"
"под контролем сборщика мусора и сохранять живые ссылки из мира Scheme.\n"
"Вместо того, чтобы поддерживать массив или связный список фигур в Си, вы\n"
"бы вместо этого хранили список в мире Scheme."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:511
msgid ""
"Rather like the coalescing of @code{dia_change_fill_pattern} and\n"
"@code{change_fill_pattern}, the practical upshot of such a change is\n"
"that you would no longer have to keep the @code{dia_shape} and\n"
"@code{dia_guile_shape} structures separate, and so wouldn't need to\n"
"worry about the pointers between them.  Instead, you could change the\n"
"foreign object definition to wrap the @code{dia_shape} structure\n"
"directly, and send @code{dia_guile_shape} off to the scrap yard.  Cut\n"
"out the middle man!"
msgstr ""
"Скорее, подобно объединению @code{dia_change_fill_pattern} и\n"
"@code{change_fill_pattern}, практический результат такого изменения\n"
"заключается в том, что вам больше не придется поддерживать\n"
"отдпельно структуры @code{dia_shape} и @code{dia_guile_shape},\n"
"и поэтому больше не нужно беспокоиться о связи между ними. Вместо этого\n"
"вы сможете изменить определение внешнего объекта, чтобы обернуть\n"
"структуру @code{dia_shape} напрямую и отправить @code{dia_guile_shape}\n"
"на помойку.  Убрать промежуточное звено!"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:520
msgid ""
"Finally, we come to the holy grail of Guile's free software / extension\n"
"language approach.  Once you have a Scheme representation for\n"
"interesting Dia data types like shapes, and a handy bunch of primitives\n"
"for manipulating them, it suddenly becomes clear that you have a bundle\n"
"of functionality that could have far-ranging use beyond Dia itself.  In\n"
"other words, the data types and primitives could now become a library,\n"
"and Dia becomes just one of the many possible applications using that\n"
"library --- albeit, at this early stage, a rather important one!"
msgstr ""
"Наконец, мы приходим к святому граалю свободного программного обеспечния/\n"
"языка расширения Guile. Когда у вас есть представление Scheme для \n"
"интересующих типов данных Dia таких как фигуры(shapes), и удобная группа\n"
"примитивов для манипулирования ими, внезапно становиться ясно, что у вас\n"
"есть набор функциональных возможностей, котоырй может иметь далеко идущее\n"
"применение за пределами самой Dia.  Другими словами, типы данных и \n"
"примитивы теперь могут стать библиотекой, а Dia становиться только одним\n"
"из возможных приложений, использующих эту библиотеку, хотя и важным на этой\n"
"раннее стадии."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:525
msgid ""
"In this model, Guile becomes just the glue that binds everything\n"
"together.  Imagine an application that usefully combined functionality\n"
"from Dia, Gnumeric and GnuCash --- it's tricky right now, because no\n"
"such application yet exists; but it'll happen some day @dots{}"
msgstr ""
"В этой модели, Guile становиться только клеем, который связывает все\n"
"вместе.  Представьте себе приложение, которое сочетает в себе "
"функциональность\n"
"от Dia, Gnumeric и GnuCash --- это сейчас сложно, потому что такого "
"приложения\n"
"пока не существует, но это однажды произойдет @dots{}"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:529
msgid ""
"@node Scheme vs C\n"
"@subsection Why Scheme is More Hackable Than C"
msgstr ""
"@node Scheme vs C\n"
"@subsection Почему Scheme более доступная чем Си"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:534
msgid ""
"Underlying Guile's value proposition is the assumption that programming\n"
"in a high level language, specifically Guile's implementation of Scheme,\n"
"is necessarily better in some way than programming in C.  What do we\n"
"mean by this claim, and how can we be so sure?"
msgstr ""
"Основополагающим предложением Guile является предположение, что "
"программирование\n"
"на языке высокого уровня, в частности Guile реализации Scheme,\n"
"обязательно лучше каки-то образом чем программирование на Си.\n"
"Что мы подразумеваем под этим утверждением, и как мы можем быть так уверены?"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:539
msgid ""
"One class of advantages applies not only to Scheme, but more generally\n"
"to any interpretable, high level, scripting language, such as Emacs\n"
"Lisp, Python, Ruby, or @TeX{}'s macro language.  Common features of all\n"
"such languages, when compared to C, are that:"
msgstr ""
"Один класс преимуществ применяется не только к Scheme, но и в целом к\n"
"любому интерпретируемому языку высокого уровня, языку сценариев, таких\n"
"как Emacs Lisp, Python, Ruby, или язык макросов @TeX{}. Общими "
"особенностями\n"
"всех этих языков по сравнению с Си являются:"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:545
msgid ""
"@itemize @bullet\n"
"@item\n"
"They lend themselves to rapid and experimental development cycles,\n"
"owing usually to a combination of their interpretability and the\n"
"integrated development environment in which they are used."
msgstr ""
"@itemize @bullet\n"
"@item\n"
"Они поддаются быстрым экспериментальным циклам разработки,\n"
"сочетание их интерпретируемости и интегрированной среды разработки\n"
"в которой их используют."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:549
msgid ""
"@item\n"
"They free developers from some of the low level bookkeeping tasks\n"
"associated with C programming, notably memory management."
msgstr ""
"@item\n"
"Они освобождают разработчиков от некоторых низкоуровневых \"бухгалтерских\"\n"
"задач связанных с программированием на Си, в частности по управлению "
"памятью.\n"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:554
msgid ""
"@item\n"
"They provide high level features such as container objects and exception\n"
"handling that make common programming tasks easier.\n"
"@end itemize"
msgstr ""
"@item\n"
"Они предоставляют функции высокого уровня, такие как контейнерные объекты\n"
"и обработка исключений, которые упрощают общие задачи программирования.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:559
msgid ""
"In the case of Scheme, particular features that make programming easier\n"
"--- and more fun! --- are its powerful mechanisms for abstracting parts\n"
"of programs (closures --- @pxref{About Closure}) and for iteration\n"
"(@pxref{while do})."
msgstr ""
"В случае Scheme, особенности, которые делают программирование проще\n"
"--- и веслее! --- являются его мощными механизмами для абстаргирования\n"
"частей программ(замыкания --- @pxref{About Closure}) и для итерации\n"
"(@pxref{while do})."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:569
msgid ""
"The evidence in support of this argument is empirical: the huge amount\n"
"of code that has been written in extension languages for applications\n"
"that support this mechanism.  Most notable are extensions written in\n"
"Emacs Lisp for GNU Emacs, in @TeX{}'s macro language for @TeX{}, and in\n"
"Script-Fu for the Gimp, but there is increasingly now a significant code\n"
"eco-system for Guile-based applications as well, such as Lilypond and\n"
"GnuCash.  It is close to inconceivable that similar amounts of\n"
"functionality could have been added to these applications just by\n"
"writing new code in their base implementation languages."
msgstr ""
"Свидетельства в поддержку этого аргумента являются эмпирическими: огромное\n"
"количество кода, который был написан на языках расширения для приложений,\n"
"поддерживающих этот механизм.  Наиболее примечательны расширения, "
"написанные\n"
"в Emacs Lisp для GNU Emacs, на языке макросов @TeX{} для @TeX{}, и на\n"
"Script-Fu для Gimp, но теперь все чаще появляется значительный код\n"
"эко системы для основанных на Guile приложений, таких как Lilypond и\n"
"GnuCash.  Это близкое к немыслимому, что подобное количество "
"функциональности\n"
"могло быть добавлено к этим приложениям, просто написав новый код на своих\n"
"базовых языках реализации."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:573
msgid ""
"@node Testbed Example\n"
"@subsection Example: Using Guile for an Application Testbed"
msgstr ""
"@node Testbed Example\n"
"@subsection Пример: Использование Guile для тестового стенда Приложения"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:584
msgid ""
"As an example of what this means in practice, imagine writing a testbed\n"
"for an application that is tested by submitting various requests (via a\n"
"C interface) and validating the output received.  Suppose further that\n"
"the application keeps an idea of its current state, and that the\n"
"``correct'' output for a given request may depend on the current\n"
"application state.  A complete ``white box''@footnote{A @dfn{white box}\n"
"test plan is one that incorporates knowledge of the internal design of\n"
"the application under test.} test plan for this application would aim to\n"
"submit all possible requests in each distinguishable state, and validate\n"
"the output for all request/state combinations."
msgstr ""
"В качестве примера того, что это означает на практике, представьте себе,\n"
"как написать тестовый стенд для приложения которое тестируется путем\n"
"отправки различных запросов(через интерфейс Си) и получения определенных\n"
"результатов. Предположим далее, что приложение сохраняет представление\n"
"о своем текущем состоянии, и что ``правильный'' вывод для данного запроса\n"
"можт зависеть от текущего состояния приложения. Полный план ``белого "
"ящика''\n"
"@footnote{План тестирования белого ящика(@dfn{white box}) - это тот, "
"который\n"
"включает знание внутреннего дизайна приложения в соответствии с заданными\n"
"тестами.} для этого приложения будет направлен на то, что\n"
"бы представить все возможные запросы в каждом различимом состоянии и "
"проверки\n"
"вывода для комбинации всех запросов/состояний."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:591
msgid ""
"To write all this test code in C would be very tedious.  Suppose instead\n"
"that the testbed code adds a single new C function, to submit an\n"
"arbitrary request and return the response, and then uses Guile to export\n"
"this function as a Scheme procedure.  The rest of the testbed can then\n"
"be written in Scheme, and so benefits from all the advantages of\n"
"programming in Scheme that were described in the previous section."
msgstr ""
"Написание всего тестового кода на Си было бы очень утомительным.  "
"Предположим,\n"
"что тестовый стенд добавляет одну новую Си функцю, чтобы отправить "
"произвольный\n"
"запрос и вернуть ответ а зетем использует Guile для экспорта этой функции\n"
"в виде процедуры Scheme.  Остальна часть тестового стенда может быть "
"написана\n"
"на Scheme, и поэтому выгоды от всех преимуществ программирования на Scheme,\n"
"описаны в предыдущем разделе."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:598
msgid ""
"(In this particular example, there is an additional benefit of writing\n"
"most of the testbed in Scheme.  A common problem for white box testing\n"
"is that mistakes and mistaken assumptions in the application under test\n"
"can easily be reproduced in the testbed code.  It is more difficult to\n"
"copy mistakes like this when the testbed is written in a different\n"
"language from the application.)"
msgstr ""
"(В этом конкретном примере есть дополнительное преимущество написания\n"
"большей части тестового стенда на Scheme.  Общей проблемой тестирования\n"
"белого ящика является то, что ошибки и ошибочные предположения в "
"тестируемом\n"
"приложении можно легко воспроизвести в тестовом коде. Сложнее копировать \n"
"ошибки, подобные этому, когда тестовый стенд написан на языке отличном \n"
"от языка приложения.)"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:602
msgid ""
"@node Programming Options\n"
"@subsection A Choice of Programming Options"
msgstr ""
"@node Programming Options\n"
"@subsection Выбор параметров программирования"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:608
msgid ""
"The preceding arguments and example point to a model of Guile\n"
"programming that is applicable in many cases.  According to this model,\n"
"Guile programming involves a balance between C and Scheme programming,\n"
"with the aim being to extract the greatest possible Scheme level benefit\n"
"from the least amount of C level work."
msgstr ""
"Предыдущие аргументы и примеры указывают на модель программирования\n"
"Guile, которая применима во многих случаях. Согласно этой модели, \n"
"программирование Guile включает в себя баланс между программированием\n"
"на Си и Scheme, с целью извлечь максимально возможный выигрыш от уровня\n"
"Scheme и наименьшего количества работы на уровне Си."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:615
msgid ""
"The C level work required in this model usually consists of packaging\n"
"and exporting functions and application objects such that they can be\n"
"seen and manipulated on the Scheme level.  To help with this, Guile's C\n"
"language interface includes utility features that aim to make this kind\n"
"of integration very easy for the application developer.  These features\n"
"are documented later in this part of the manual: see REFFIXME."
msgstr ""
"Работа на уровне Си, требуемая в этой модели, обычно состоит из упаковки\n"
"и экспорта функций и объектов приложения, чтобы их можно было увидеть и\n"
"обработать на уровне Scheme.  Чтобы помочь в этом, интерфейс языка Guile\n"
"Си включает в себя служебные функции, которые делают эту интеграцию очень\n"
"простой для разработчика приложений. Эти функции описанны далее в этой\n"
"части руководства: см. REFFIXME."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:628
msgid ""
"This model, though, is really just one of a range of possible\n"
"programming options.  If all of the functionality that you need is\n"
"available from Scheme, you could choose instead to write your whole\n"
"application in Scheme (or one of the other high level languages that\n"
"Guile supports through translation), and simply use Guile as an\n"
"interpreter for Scheme.  (In the future, we hope that Guile will also be\n"
"able to compile Scheme code, so lessening the performance gap between C\n"
"and Scheme code.)  Or, at the other end of the C--Scheme scale, you\n"
"could write the majority of your application in C, and only call out to\n"
"Guile occasionally for specific actions such as reading a configuration\n"
"file or executing a user-specified extension.  The choices boil down to\n"
"two basic questions:"
msgstr ""
"Однако эта модель в действительности является одной из множества \n"
"вариантов программирования. Если все функции, которые вам нужны\n"
"доступны из Scheme, вы можете выбрать писать свое приложение на\n"
"Scheme (или одном из других языков высокого уровня, трансляцию\n"
"которого поддерживает Guile), и просто использовать Guile в качестве\n"
"интерпретатора для Scheme.  (В будущем мы надеемся, что Guile также\n"
"сможет скомпилировать код Scheme, сократив разрыв производительности\n"
"между кодом Си и Scheme.)  Или, с другой стороны шкалы Си--Scheme, вы\n"
"можете написать большую часть своего приложения на Си и только иногда \n"
"вызывать Guile для конкретных действий, таких как чтение конфигурационного\n"
"файла или выполнения определенного пользователем расширения. Выбор "
"сводиться\n"
"к двум основным вопросам:"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:633
msgid ""
"@itemize @bullet\n"
"@item\n"
"Which parts of the application do you write in C, and which in Scheme\n"
"(or another high level translated language)?"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"Какие части приложения вы пишете на Си, а какие на Scheme\n"
"(или другом транслируемом языке высокого уровня)?"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:638
msgid ""
"@item\n"
"How do you design the interface between the C and Scheme parts of your\n"
"application?\n"
"@end itemize"
msgstr ""
"@item\n"
"Как вы разрабатываете интерфейс между частями  Си и Scheme вашего "
"приложения?\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:644
msgid ""
"These are of course design questions, and the right design for any given\n"
"application will always depend upon the particular requirements that you\n"
"are trying to meet.  In the context of Guile, however, there are some\n"
"generally applicable considerations that can help you when designing\n"
"your answers."
msgstr ""
"Это конечно вопросы дизайна, и правильный дизайн для любого конкретного\n"
"приложения всегда будет зависеть от конкретных требований, которые вы\n"
"пытаетесь выполнить в контексте Guile, однако сущетствуют некоторые \n"
"общепринятые соображения, которые могут помочь вам при выработке своих\n"
"ответов."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:651
msgid ""
"@menu\n"
"* Available Functionality::     What functionality is already available?\n"
"* Basic Constraints::           Functional and performance constraints.\n"
"* Style Choices::               Your preferred programming style.\n"
"* Program Control::             What controls program execution?\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:655
msgid ""
"@node Available Functionality\n"
"@subsubsection What Functionality is Already Available?"
msgstr ""
"@node Available Functionality\n"
"@subsubsection Какая функциональность уже доступна?"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:658
msgid ""
"Suppose, for the sake of argument, that you would prefer to write your\n"
"whole application in Scheme.  Then the API available to you consists of:"
msgstr ""
"Предположим, ради аргумента, что вы предпочитаете писать ваше приложение "
"на \n"
"Scheme.  Тогда доступный API состоит из:"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:662
msgid ""
"@itemize @bullet\n"
"@item\n"
"standard Scheme"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"стандартной Scheme"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:666
msgid ""
"@item\n"
"plus the extensions to standard Scheme provided by\n"
"Guile in its core distribution"
msgstr ""
"@item\n"
"плюс расширения стандартной Scheme предоставляемые Guile в\n"
"ее базовом дистрибутиве"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:671
msgid ""
"@item\n"
"plus any additional functionality that you or others have packaged so\n"
"that it can be loaded as a Guile Scheme module.\n"
"@end itemize"
msgstr ""
"@item\n"
"плюс любая дополнительная функциональность, которую вы или другие\n"
"собрали в пакет, чтобы его можно было загрузить как модуль Guile \n"
"Scheme.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:681
msgid ""
"A module in the last category can either be a pure Scheme module --- in\n"
"other words a collection of utility procedures coded in Scheme --- or a\n"
"module that provides a Scheme interface to an extension library coded in\n"
"C --- in other words a nice package where someone else has done the work\n"
"of wrapping up some useful C code for you.  The set of available modules\n"
"is growing quickly and already includes such useful examples as\n"
"@code{(gtk gtk)}, which makes Gtk+ drawing functions available in\n"
"Scheme, and @code{(database postgres)}, which provides SQL access to a\n"
"Postgres database."
msgstr ""
"Модуль в последней категории может быть либо чистым модулем Scheme --- \n"
"другими словами набором служебных процедур, закодированных на Scheme --- \n"
"или модулем который прдоставляет Scheme интерфейс к библиотеке расширений,\n"
"закодированной на Си --- или другими словами, пакетом в котором некто "
"выполнил\n"
"хорошую работу по завершению некоторого полезного для вас кода на Си. Набор\n"
"доступных модулей быстро растет и уже включает такие полезные примеры как\n"
"@code{(gtk gtk)}, который делает доступными функции рисования Gtk+ на \n"
"Scheme, и @code{(database postgres)}, который обеспечивает SQL доступ к\n"
"базе данных Postgres."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:686
msgid ""
"Given the growing collection of pre-existing modules, it is quite\n"
"feasible that your application could be implemented by combining a\n"
"selection of these modules together with new application code written in\n"
"Scheme."
msgstr ""
"Учитывая растущий набор разработанных модулей, вполне возможно, что ваше\n"
"приложение может быть реализовано путем комбинации объединения этих модулей\n"
"с новым кодом приложений, написанным на Scheme."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:694
msgid ""
"If this approach is not enough, because the functionality that your\n"
"application needs is not already available in this form, and it is\n"
"impossible to write the new functionality in Scheme, you will need to\n"
"write some C code.  If the required function is already available in C\n"
"(e.g.@: in a library), all you need is a little glue to connect it to the\n"
"world of Guile.  If not, you need both to write the basic code and to\n"
"plumb it into Guile."
msgstr ""
"Если этого подхода недостаточно, поскольку функциональность, которая \n"
"требуется вашему приложению уже недоступна в этой форме, и невозможно\n"
"написать новую функциональность на Scheme, вам нужно будет написать\n"
"код Си. Ели требуемая функция уже доступна на Си (например: в библиотеке),\n"
"все что вам нужно, это немного клея, чтоебы связать его с миром Guile. \n"
"Если вам не нужно опять писать базовый код, так встройте его в  Guile."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:705
msgid ""
"In either case, two general considerations are important.  Firstly, what\n"
"is the interface by which the functionality is presented to the Scheme\n"
"world?  Does the interface consist only of function calls (for example,\n"
"a simple drawing interface), or does it need to include @dfn{objects} of\n"
"some kind that can be passed between C and Scheme and manipulated by\n"
"both worlds.  Secondly, how does the lifetime and memory management of\n"
"objects in the C code relate to the garbage collection governed approach\n"
"of Scheme objects?  In the case where the basic C code is not already\n"
"written, most of the difficulties of memory management can be avoided by\n"
"using Guile's C interface features from the start."
msgstr ""
"В любом случае важны два общих соображения. Во первых, что такое интерфейс\n"
"по которому  функциональность представляется миру Scheme? Состоит ли \n"
"интерфейс только из вызова функций(например, простой интерфейс рисования),\n"
"или он должен включать объекты(@dfn{objects}), которые могут быть переданы \n"
"между Си и Scheme и управляться обоими мирами. Во-вторых, как управление \n"
"жизненным циклом и памятью объектов в коде Си соотносится к управляемым\n"
"сборщиком мусора объектам Scheme?  В случае когда базовый код Си еще не \n"
"написан, большинство трудностей управления памятью можно избежать "
"использованием\n"
"функций языка Си интерфейса Guile с самого начала."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:708
msgid ""
"For the full documentation on writing C code for Guile and connecting\n"
"existing C code to the Guile world, see REFFIXME."
msgstr ""
"Для полной документации по написанию кода Си для Guile и подключения\n"
"существующего Си кода к миру Guile, см. REFFIXME."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:712
msgid ""
"@node Basic Constraints\n"
"@subsubsection Functional and Performance Constraints"
msgstr ""
"@node Basic Constraints\n"
"@subsubsection Функциональные и скоростные ограничения"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:716
msgid ""
"@node Style Choices\n"
"@subsubsection Your Preferred Programming Style"
msgstr ""
"@node Style Choices\n"
"@subsubsection Ваш предпочтительный стиль программирования"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:720
msgid ""
"@node Program Control\n"
"@subsubsection What Controls Program Execution?"
msgstr ""
"@node Program Control\n"
"@subsubsection Какие управляющие программы выполнять?"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:724
msgid ""
"@node User Programming\n"
"@subsection How About Application Users?"
msgstr ""
"@node User Programming\n"
"@subsection Как насчет Пользователей Приложения?"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:729
msgid ""
"So far we have considered what Guile programming means for an\n"
"application developer.  But what if you are instead @emph{using} an\n"
"existing Guile-based application, and want to know what your\n"
"options are for programming and extending this application?"
msgstr ""
"До сих пор мы рассматривали, какие средства программирования Guile\n"
"предоставляет для разработчика приложения. Но что, если вместо этого\n"
"хотите использовать существующее приложение на основе Guile и хотите\n"
"знать какие у вас есть варианты для программирования и расширения\n"
"этого приложения?"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:739
msgid ""
"The answer to this question varies from one application to another,\n"
"because the options available depend inevitably on whether the\n"
"application developer has provided any hooks for you to hang your own\n"
"code on and, if there are such hooks, what they allow you to\n"
"do.@footnote{Of course, in the world of free software, you always have\n"
"the freedom to modify the application's source code to your own\n"
"requirements.  Here we are concerned with the extension options that the\n"
"application has provided for without your needing to modify its source\n"
"code.}  For example@dots{}"
msgstr ""
"Ответ на этот вопрос варьируется от одного приложения к другому,\n"
"поскольку параметры доступрые, неизбежно зависят от того предоставил\n"
"ли разработчик приложений какие-либо перехватчики(hooks) что бы вы\n"
"могли присоединить к ним собственный код, и если есть такие перехватчики,\n"
"что они позволяют вам делать.@footnote{ Конечно, в мире свободного\n"
"программного обеспечения у вас всегда есть свобода изменять исходный код\n"
"в соответствии с вашими требованиями. Здесь мы имеем дело с вариантами\n"
"расширения, которые предоставляет приложение без необходимости изменения\n"
"исходного кода.}  Например @dots{}"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:745
msgid ""
"@itemize @bullet\n"
"@item\n"
"If the application permits you to load and execute any Guile code, the\n"
"world is your oyster.  You can extend the application in any way that\n"
"you choose."
msgstr ""
"@itemize @bullet\n"
"@item\n"
"Если приложение позволяет загружать и выполнять любой Guile, мир "
"становиться\n"
"вашим.  Вы можете расширять приложение любым способом, который вы выберете."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:750
msgid ""
"@item\n"
"A more cautious application might allow you to load and execute Guile\n"
"code, but only in a @dfn{safe} environment, where the interface\n"
"available is restricted by the application from the standard Guile API."
msgstr ""
"@item\n"
"Более острожное приложение может позволить вам загружать и выполнять код\n"
"Guile, но только в безопасной(@dfn{safe}) средеe, где доступный интерфейс\n"
"ограничен приложением из старндатного Guile API."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:756
msgid ""
"@item\n"
"Or a really fearful application might not provide a hook to really\n"
"execute user code at all, but just use Scheme syntax as a convenient way\n"
"for users to specify application data or configuration options.\n"
"@end itemize"
msgstr ""
"@item\n"
"Или действительно пугливое приложение может НЕ обеспечить крюкчек(hook),\n"
"чтобы выполнять пользовательский код, а вместо этого просто использовать \n"
"синтаксис Scheme как удобный способ для пользователя указать приложению \n"
"данные или параметры конфигурации.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:760
msgid ""
"In the last two cases, what you can do is, by definition, restricted by\n"
"the application, and you should refer to the application's own manual to\n"
"find out your options."
msgstr ""
"В последних двух случаях, что выможете сделать, по определению ограничено\n"
"приложением, и вы должны обратиться к документации по приложению чтобы "
"узнать\n"
"ваши опции."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:773
msgid ""
"The most well known example of the first case is Emacs, with its\n"
"extension language Emacs Lisp: as well as being a text editor, Emacs\n"
"supports the loading and execution of arbitrary Emacs Lisp code.  The\n"
"result of such openness has been dramatic: Emacs now benefits from\n"
"user-contributed Emacs Lisp libraries that extend the basic editing\n"
"function to do everything from reading news to psychoanalysis and\n"
"playing adventure games.  The only limitation is that extensions are\n"
"restricted to the functionality provided by Emacs's built-in set of\n"
"primitive operations.  For example, you can interact and display data by\n"
"manipulating the contents of an Emacs buffer, but you can't pop-up and\n"
"draw a window with a layout that is totally different to the Emacs\n"
"standard."
msgstr ""
"Наиболее известным примером первого случая является Emacs, с его языком\n"
"расширения Emacs Lisp: как и текстовый редактор, Emacs поддерживает\n"
"загрузку и выполнение произвольного кода Emacs Lisp.  Результат такой\n"
"открытости был впечатляющим: Emacs сейчас имеет преимущества библиотек\n"
"Emacs Lisp от пользователей, котоыре расширяют базовые функции "
"редактирования,\n"
"делая все от чтения новостей до психоанализа и игры в приключенческие игры.\n"
"Только ограничение заключается в том, что расширения ограничены "
"функциональностью\n"
"предоставляемой встроенным набором примитивных операций Emacs. Например, вы\n"
"можете взаимодействовать и отображать данные по манипулированию содержимым\n"
"буфера Emacs, но вы не можете размещать всплывающие окна рисовать окна с "
"размещением,\n"
"который полностью отличается от стандарта Emacs."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:779
msgid ""
"This situation with a Guile application that supports the loading of\n"
"arbitrary user code is similar, except perhaps even more so, because\n"
"Guile also supports the loading of extension libraries written in C.\n"
"This last point enables user code to add new primitive operations to\n"
"Guile, and so to bypass the limitation present in Emacs Lisp."
msgstr ""
"Эта ситуация с приложением Guile, которое поддерживает загрузку "
"произольного\n"
"кода пользователя аналогична, за исключением, возможно, даже более того,\n"
"поскольку Guile также поддерживает загрузку библиотек расширения, "
"написанных\n"
"на Си. Этот последний пункт позволяет коду пользователя добавлять новые \n"
"примитивные операции в Guile, и поэтому обойти ограничение, существующее\n"
"в Emacs Lisp."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:787
msgid ""
"At this point, the distinction between an application developer and an\n"
"application user becomes rather blurred.  Instead of seeing yourself as\n"
"a user extending an application, you could equally well say that you are\n"
"developing a new application of your own using some of the primitive\n"
"functionality provided by the original application.  As such, all the\n"
"discussions of the preceding sections of this chapter are relevant to\n"
"how you can proceed with developing your extension."
msgstr ""
"На этом этапе различие между разработчиками приложения и пользователем\n"
"приложения становятся размытыми. Вместо того, чтобы видеть себя "
"пользователем\n"
"расширяющим приложение, вы могли бы сказать, что вы разрабатываете новое\n"
"приложение, используя некотурую примитивную функциональность, "
"предоставляемую\n"
"оригинальным приложением. Таким образом, все обсуждения предыдущих разделов\n"
"этой главы имеют отношение к тому, как вы можете продолжить разработку "
"ваших\n"
"расширений."

#: /home/bear/work/guile/doc/guile/en/libguile-program.texi:791
msgid ""
"@c Local Variables:\n"
"@c TeX-master: \"guile.texi\"\n"
"@c End:"
msgstr ""
