@c -*-texinfo-*-
@c This is part of the GNU Guile Reference Manual.
@c Copyright (C)  1996-1997, 2000-2005, 2010-2011, 2013-2016
@c   Free Software Foundation, Inc.
@c See the file guile.texi for copying conditions.

@node General Libguile Concepts
@section Общие понятия для использования libguile

Когда вы хотите встроить интерпретатор Guile Scheme в свою программу или
библиотеку, вам необходимо связать их с библиотекой @file{libguile} 
(@pxref{Linking Programs With Guile}).  После того, как вы это сделали,
ваш код Си получает доступ к нескольким типам данных и функциям, которые
могут использоваться для вызова интерпретатора или создания новых функций,
которые вы хотите написать на Си и сделать их доступными для вызова из
кода Scheme, среди прочего.

Scheme отличаетс от Си несколькими существенными моментами, и Guile
пытается сделать преимущества Scheme доступными для Си. Таким образом,
в дополнение к интерпретатору Scheme, libguile ткже предоставляет динамические
типы, сборщика мусора, продолжения, арифметику с числами произвольной длины и
другие вещи.

Двумя основными понятиями являются динамические типы и сборка мусора.
Вам необходимо понять, как libguile предлагает их программам Си, чтобы
использовать остальную часть libguile.  Также, должен быть рассмотрен
общий поток управления Scheme вызыванный продолжениями.

Запуск асинхронных обработчиков сигналов и многопоточность известны Си
коду, но есть несколько дополнительных правил при их использовании
совместно с libguile.

@menu
* Dynamic Types::               Dynamic Types.
* Garbage Collection::          Garbage Collection.
* Control Flow::                Control Flow.
* Asynchronous Signals::        Asynchronous Signals
* Multi-Threading::             Multi-Threading
@end menu

@node Dynamic Types
@subsection Динамические типы

Scheme --- динамически типизированный язык, это означает. что система
вообще не может определить тип данного выражения во время компиляции.
Типы становятся известными только во время выполнения. Переменные
не имеют фиксированных типов; переменная может содержать пару в один момент
времени; целое число в следующий и тысячный элемент позже. Вместо этого
значения имеют фиксированные типы, а не переменные.

В порядке реализации стандартных функций Scheme, таких как @code{pair?} и
@code{string?} и обеспечения сборки мусора, представление каждого значения
должно содержать достаточно информации для точного определения его типа во
время выполнения. Часто системы Scheme также используют эту информацию
для определения, пыталась ли программа применить операцию к неуместному
типу значения (например, получения первого элемента @code{car} от строки(string)).

Поскольку переменные, пары и вектора могут содержать значения любого
типа, реализации Scheme используют единое представление для значений
--- один тип, достаточно большой. чтобы удерживать либо полное значение,
либо указатель на полное значение, а также необходимую информацию для
информации о типе.

В Guile, данное единое представление всех значений Scheme является
Си типом @code{SCM}.  Это непрозрачный тип и его размеры обычно эквивалентны
указателю на @code{void}.  Таким образом, значения @code{SCM} могут эффективно
передаваться, и они занимают мало достаточно мало места.

Самое важное правило: Вы никогда не получаеете доступ к значению 
@code{SCM} напрямую; Вы передаете его только функции и ли макросу
определенным в libguile.

В качестве очевидного примера, хотя переменная @code{SCM} может содержать
целые числа, вы конечно не можете сложить их используя Си оператор @code{+}.
Вы должны использовать функцию libguile @code{scm_sum}.

Менее очевидно и поэтому важно помнить, что вы также не можете 
непосредственно проверять значения @code{SCM} на истинность.  В Scheme,
значение @code{#f} считается ложным и конечно, переменная @code{SCM}
может представлять это значения. Но нет никакой гарантии, что @code{SCM}
представление @code{#f} выглядит ложным и для Си кода. Вам нужно
использовать @code{scm_is_true} или @code{scm_is_false} для проверки
значения @code{SCM} на истинность или ложность, соответственно.

Вы также не можете на прямую сравнить два значения @code{SCM}, чтобы
выяснить являются ли они идентичными (т.е. являются ли они
эквивалентными(@code{eq?}) в терминах Scheme).  Вам необходимо 
использовать для этого @code{scm_is_eq}.

Единственное исключение состоит в том, что вы можете напрямую назначить
значение @code{SCM} переменной @code{SCM} используя Си оператор @code{=}.

Следующий (надуманный) пример показывает, как сделать это правильно.
Он реализует функцию двух аргументов (@var{a} и @var{flag}) которая
возвращает @var{a}+1 если @var{flag} является истиной, иначе она вернет
неизменненное @var{a}.

@example
SCM
my_incrementing_function (SCM a, SCM flag)
@{
  SCM result;

  if (scm_is_true (flag))
    result = scm_sum (a, scm_from_int (1));
  else
    result = a;

  return result;
@}
@end example

Часто вам нужно преобразовать значения @code{SCM} в соответствующие
значения Си и наоборот. Например, нам нужно преобразовать целое @code{1}
в представление @code{SCM} чтобы добавить его в @var{a}.  Libguile
предоставляет множество функций для этих преобразований, как из Си в 
@code{SCM}, таки из @code{SCM} в Си.

Функции преобразования следуют общей схеме именования: те, которые создают
значение @code{SCM} из значения Си имеют имена в форме @code{scm_from_@var{type} (@dots{})} 
и те которые конвертируют из занчений @code{SCM} в значения Си используют форму 
@code{scm_to_@var{type} (@dots{})}.

Однако лучше избегать преобразования значений, когда можете. Когда вы
должны объединить Си и @code{SCM} значения в вычислении, часто лучше
преобразовать Си значения в @code{SCM} значения и выполнить вычисления
с использованием функций libguile, а не наоборот (преобразовывать @code{SCM}
в Си и выполнять вычисления другим способом).

В качестве простого примера рассмотрим эту версию
@code{my_incrementing_function}:

@example
SCM
my_other_incrementing_function (SCM a, SCM flag)
@{
  int result;

  if (scm_is_true (flag))
    result = scm_to_int (a) + 1;
  else
    result = scm_to_int (a);

  return scm_from_int (result);
@}
@end example

Эта версия гораздо менее общая, чем оригинальная: она будет работать
только для значений @var{A}, которые могуть вписаться в @code{int}.
Оригинальная функция работала для значений, которые может пердставлять
Guile и что @code{scm_sum} может понять, включая целые числа, большие чем
длинные, с плавающей запятой числа, комплексные числа и новые числовые
типы, которые были добавлены в Guile сторонними библиотеками.

Кроме того, вычисления с помощью @code{SCM} не обязательно не эффективны.
Малые целые числа будут закодированы непосредственно в значение @code{SCM},
например, и не нуждаются в дополнительной памяти в куче. См. @ref{Data
Representation}, чтобы узнать подробности.

Некоторые специальные значения @code{SCM} доступны для Си кода без необходимости
их преобразования из Си значений:

@multitable {Scheme value} {C representation}
@item Scheme value @tab C representation
@item @nicode{#f}  @tab @nicode{SCM_BOOL_F}
@item @nicode{#t}  @tab @nicode{SCM_BOOL_T}
@item @nicode{()}  @tab @nicode{SCM_EOL}
@end multitable

В дополнении к @code{SCM}, Guile также определяет родственный тип
@code{scm_t_bits}.  Это беззнаковый интегральный тип достаточного размера
для хранения всей информации, которая содержиться непосредственно в значении
@code{SCM}.  Тип @code{scm_t_bits} используется внутри Guile все объяснения
бит есть в @ref{Data Representation}, но вы будете сталкиваться с ним иногда
в низкоуровневом коде пользователя.

@node Garbage Collection
@subsection Сборщик Мусора

Как объяснено выше, тип @code{SCM} может представлять все занчения Scheme.
Некоторые значения полностью содержаться в значениях @code{SCM} (такие как
небольшие целые числа), но для других значений требуется дополнительное
хранилище в куче(например, строки и векторы). Это дополнительное хранилище
управляется автоматически Guile.  Вам не нужно явно освобождать его. когда
значение @code{SCM} больше не используется.

Необходимо гарантировать две вещи, чтобы Guile мог управлять хранилищем
автоматически: он должен знать обо всех блоках памяти, которые когда либо
были выделены для значений Scheme, и он должен знать обо всех значениях
Scheme которые еще используются. Учитывая эти знания, Guile может переодически
освобождать все блоки, которые были выделены, но не используются никакими
активными значениями Scheme. Эта деятельность называется сборкой мусора
(@dfn{garbage collection}).

Сборщик мусора Guile автоматически обнаружит ссылки на объекты @code{SCM}
которые возникают в глобальных переменных, статических разделах данных,
аргументах функции или локальных переменных в стеках Си и Scheme и
значения в машинных регистрах. Другие ссылки на объекты @code{SCM},
такие как в других произвольных структурах в Си куче которая содержит
поля типа @code{SCM}, могут быть видимы сборщику мусора, вызовом функций
@code{scm_gc_protect_object} или  @code{scm_permanent_object}.  В совокупности
эти знания образуют ``корневой набор'' сбора мусора; любое значение в куче, 
которое прямо или косвенно ссылается на члена корневого набора сохраняется,
и все остальные объекты имеют право на возврат.

В Guile, сбор мусора имеет две логические фазы: фазу пометки(@dfn{mark
phase}), в которой сборщик мусора обнаруживает набор всех живых объектов
и фазу уборки(@dfn{sweep phase}), в которой сборщик мусора возвращает
ресурсы системе, связанные с мертвыми объектами. Фаза пометки приостанавливает
программу и отслеживает все ссылки на объекты @code{SCM} начиная с корневого
набора. Фаза уборки фактически выполняется вместе с основной программой,
поэтапно востанавливая память по мере необходимости.

В фазе пометки, сборщик мусора отслеживает стек Scheme и кучу в
точности( @dfn{precisely}). Поскольку стек и куча Scheme управляются
Guile, Guile может точно знать, где в этих структурах данных сборщик
может найти сслылки на другие объекты кучи. Однако это не так,
для указателей в Си стеке и статическом сегменте данных Си.  Вместо
того чтобы требовать от пользователей необоходимости сообщать Guile
обо всех переменных в Си, которые могут указывать на объекты кучи,
Guile последовательно проверяет Си стек и статический сегмент данных
(@dfn{conservatively}).  Т.е., Guile просто проверяет каждое слово
Си стека и любую глобальную переменную Си в качестве потенциальной
ссылки на кучу Scheme@footnote{Обратите внимание, что Guile не сканирует
Си кучу для поиска ссылок на объект @code{SCM} из памяти сегмента, выделенного
с помощью @code{malloc}. необходимо использовать некоторые другие средства
для сохранения объекта @code{SCM} живым.  @xref{Garbage Collection
Functions}.}.  Любое значение, которое выглядит как указатель на объект,
управляемый сборщиком мусора рассматривается например, является ли оно
ссылкой или нет. Таким образом, сканирование стека Си и сегмента статических
данных гарантированно найдет все фактические сслыки, но оно также может
найти слова которые только случайно выглядят как ссылки.  Эти ``ложные
срабатывания'' могут сохранять объекты @code{SCM} живыми, котоыре иначе бы
считались мертвыми. Хотя это может повлечь потерю памяти, сохранять объект
дольше, чем это нужно, это не так страшно. Вот почему эта техника называется
``консревативная сборка мусора''.  На практике потерянная память, не проблема,
поскольку статическое множество Си корней почти вегда конечное и малое, 
учитывая что стек Scheme отделен от Си стека.

Стек каждого потока сканируется таким образом, а регистры процессора и
всех други мест памяти, где могут появиться локальные переменные или
параметры функции также включены в это сканирование.

Следствием консервативного сканирования является то, что вы можете просто
объявить локальные переменные и параметры функций типа @code{SCM} и
убедиться что сборщик мусора не освободит соответствующие объекты.

Однако локальная переменная или параметр защищены только при условиии,
что они находятся реально в стеке(или в каком либо регистре). В качесте
оптимизации компилятор Си может повторно использовать их местоположение
для другого значения, и объект @code{SCM} больше не будет защищен от 
удаления.  Как обычно, это приводит к верному поведению: компилятор
перезаписывает ссылку, когда она больше не требуется, и таким образом,
объект становиться незащищенным, когда ссылка исчезает, что нам и надо.

Однако существуют ситуации, когда объект @code{SCM} должен существовать
дольше, чем ссылка на него из локальной переменной или параметра функции.
Это происходит например, когда вы извлекаете некоторый указатель из
внешнего объекта и работаете с этим указателем. Ссылка на внешний
объект @code{SCM} может быть мертва после того как указатель был извлечен,
но сам указатель(и указатель на память) все еще испльзуется и следовательно
внешний объект должен быть защищен. Компилятор не знает об этой связке и
может перезаписать ссылка @code{SCM} слишком рано.

Чтобы обойти эту проблему, вы можете использовать @code{scm_remember_upto_here_1}
и его аналоги.  Это заставить сохранить ссылку.  @xref{Foreign Object Memory Management}.

@node Control Flow
@subsection Управление потоком выполнения программы

Scheme имеет более общий вид потока выполнения программы, чем Си, как локально,
так и не локально.

Управление локальным потоком выполнения включает в себя такие вещи, как
переходы(gotos), циклы(loops), вызовы функций(calling) и возвраты
из них(returning). Нелокальный поток выполнения относится к ситуациям,
в которых программа перескакивает через один или несколько уровней
активации функций без использования обычных операций вызова(call) или 
возврата(return).

Примитивным средством Си для локального управления потоком выполнения
является операторы  @code{goto} вместе с  @code{if}.  Циклы выполняющиеся
с помощью конструкций @code{for}, @code{while} и @code{do} могут быть
переписаны с помощью операторов @code{goto} и @code{if}.  В Scheme, 
примитивным средством для управления локальным потоком выполнения является
вызов функции(@emph{function call}) (вместе с оператором @code{if}).
Таким образом, повторение некоторых вычислений в цикле в конечном счете
реализуется функцией которая вызывает сама себя, то есть рекурсией.

Этот подход теоретически более сильный, поскольку формально рассуждать
о рекурсии, более проще чем о переходах(gotos).  В Си, использование
рекурсии исключительно не практично, т.к. она быстро съедает весь стек.
В Scheme, однако это практично: вызовы функций, которые появляются в 
хвостовой позиции(@dfn{tail position}) не используют дополнительное
пространство в стеке(@pxref{Tail Calls}).

Вызов функции находиться в хвостовой позиции, когда это последнее дейтсвия, 
которое выполняет вызывающая функция. Значение, возвращаемое вызываемой
функцией немедленно возвращается из вызывающей функции. В следующем
примере, вызов  @code{bar-1} находиться в хвостовой позиции, а вызов
@code{bar-2} нет.  (Однако вызов @code{1-} в @code{foo-2} находиться
в хвостовой позиции.)

@lisp
(define (foo-1 x)
  (bar-1 (1- x)))

(define (foo-2 x)
  (1- (bar-2 x)))
@end lisp

Таким образом, вы получаете чистую рекурсию только в хвостовой позиции,
такая рекурсия будет использовать постоянное пространство стека и  будет
такой же хорошей как цикл, построенный из переходов gotos.

Scheme предлагает несколько синтаксических абстракций (@code{do} и @dfn{named}
@code{let}), которые создают циклы намного легче.

Но только функции Scheme могут вызывать другие функции в хвостовой позиции:
Си функции этого не могут. Это имеет значение, если у вас есть, скажем, две
функции, которые рекурсивно вызывают друг друга, образуя общий цикл. Следующий
(нереалиситчный) пример показывает как можно определить, является ли неотритцательное
целое число @var{n} четным или нечетным.

@lisp
(define (my-even? n)
  (cond ((zero? n) #t)
        (else (my-odd? (1- n)))))

(define (my-odd? n)
  (cond ((zero? n) #f)
        (else (my-even? (1- n)))))
@end lisp

Поскольку вызовы @code{my-even?} и @code{my-odd?} находятся в хвостовой
позиции, эти две процедуры могут применяться к произвольно большим целым,
не переполняя стек. (Конечно, они все равно займут много времени.)

Однако, когда одна или обе из этих двух процедур будут переписаны на Си,
они не смогут больше вызывать своего компаньона в хвостовой позиции
(поскольку Си не имеет этого понятия).  Вам необходимо учитывать это
соображение при принятии решения о том, какие части вашей программы
писать на Scheme а какие на Си.

В дополнение к вызовам функций и возврату из них, программа Scheme
также может выходить из функций не локально, так что поток выполения
возвращается непосредственно на внешний уровень. Это означает, что 
некотоыре функции могут вообще не иметь возврата.

Более того, невозможно не только перейти на некоторый внешний уровень
контроля,  Scheme программа может также перепрыгнуть назад в середину
функции и повторно выйти. Это может вызвать возврат из некоторых функций
более одного раза.

В общем, эти не локальные переходы выполняются путем вызова
продолжений(@dfn{continuations}), которые ранее были перехвачены
с использованием @code{call-with-current-continuation}.  Guile также
предлагает ограниченный набор функций, @code{catch} и @code{throw}, котоыре
могут использоваться для нелокальных выходов. Это ограничение делает их
более эффективными. Отчет об ошибках (с функцией @code{error}) реализован
путем вызова например @code{throw}.  Функции @code{catch} и @code{throw} 
входят в тему исключений(@dfn{exceptions}).

Поскольку функции Scheme могут вызывать Си функции и наоборот, код Си
может более широко управлять потоком выполнения  Scheme.  Возможно
Си функция никогда не возвращается, или возвращается более одного раза.
Хотя Си пердлагает @code{setjmp} и @code{longjmp} для нелокальных выходов.,
это все еще необычная вещь для кода Си. Напротив, нелокальные выходы
очень распространены в  Scheme, в основном для сообщения об ошибках.

Вы должны быть готовыми к нелокальным скачкам в потоке выполнения всякий
раз, когда вы используете функции из @code{libguile}: лучше предположить,
что любая функция @code{libguile} может выдать сигнал ошибки ли запустить
обработки сигнала (который, в свою очередь, может выполнять произвольные
действия).

Часто бывает необходимо предпринять действия по очистке, когда управление
покидает функцию нелокально. Кроме того, когда управление возвращается
нелокально, могут потребоваться некоторые действия по настройке. Например,
функция Scheme @code{with-output-to-port} нуждается в изменении глобального
состояния, так что @code{current-output-port} вернул порт переданный
@code{with-output-to-port}.  Глобальный выходной порт должен быть сброшен
до своего предыдущего значения когда @code{with-output-to-port} возвращется
нормально или когда она возвращается не локально.  Аналогично, порт необходимо
установить снова, когда управление возващается нелокально.

Код Scheme может использовать функцию @code{dynamic-wind} для настройки
и сброса глобальных настроек.  Си код может использовать соответствующую
функцию @code{scm_internal_dynamic_wind} или пару 
@code{scm_dynwind_begin}/@code{scm_dynwind_end} вместе с подходящими
'dynwind действиями' (@pxref{Dynamic Wind}).

Вместо того, чтобы справляться с нелокальным потоком управления, вы также
можете предотвратить его, установив барьер продолжения(@emph{continuation barrier}),
@xref{Continuation Barriers}.  Например, функция @code{scm_c_with_continuation_barrier},
гарантированно возвращается ровно один раз.

@node Asynchronous Signals
@subsection Асинхронные Сигналы

Вы не можете вызывать функции libguile из обработчиков POSIX сигналов, но
вы можете зарегистрировать Scheme обработчики для POSIX сигналов, таких как
@code{SIGINT}.  Эти обработчики не запускаются во время фактической доставки
сигнала. Вместо этого они запускаются, когда программа(точнее поток который
зарегистрировал обработчик) достигает следующей безопасной точки
(@emph{safe point}).

У самих функций libguile есть много таких безопасных точек. Следовательно,
вы должны быть готовы к произвольным действиям при вызове функции
libguile.  Например, даже @code{scm_cons} может содержать безопасную точку,
и когда обработчик сигнала ожидает для вашего потока, вызов @code{scm_cons}
будет запускать этот обработчик, и все может произойти, включая нелокальный
выход, хотя сам @code{scm_cons} обычно так не делает.

Если вы не хотите разрешать работу асинхронных обработчиков сигналов, вы можете
временно заблокировать их с помощью например @code{scm_dynwind_block_asyncs}
@xref{Asyncs}.

Поскольку обработка сигналов в Guile зависит от безопасных точек, вам
необходимо убедиться, что ваши функции действительно предлагают их в
достаточном количестве. Обычно, вызов функции libguile в обычном режиме,
это все что необходимо. Но когда поток можт долгое время находиться
в секции кода, которая не вызывает функций libguile, полезно влючать
в код явные безопасные точки. Это позволит, например, пользователю
прервать ваш код с помощью @key{C-c}.

Вы можете сделать это с помощью макроса @code{SCM_TICK}.  Этот макрос
синтаксически является выражением. То есть, вы можете использовать его
так:

@example
while (1)
  @{
    SCM_TICK;
    do_some_work ();
  @}
@end example

Частое выполнение безопасной точки еще более важно в многопоточных
программах, @xref{Multi-Threading}.

@node Multi-Threading
@subsection МногоПоточность

Guile можно использовать в многопоточных программах, так же как и в
однопоточных.

Каждый поток, который хочет использовать функции из libguile, должен
поместить себя в режим @emph{guile mode} и должен следовать нескольким
правилам. Если он не хочет соблюдать эти правила в определенных ситуациях,
поток может покинуть режим guile (но больше, конечно, не сможет использовать
функции libguile в это время).

Поток входит в режим guile вызывая  @code{scm_with_guile},
@code{scm_boot_guile}, или @code{scm_init_guile}.  Как поясняется в справочной
документации для этих функций, Guile тогда узнает о границах стека потока и
может защитить значения @code{SCM} сохраненные в локальных переменных. Когда
поток впервые попадает в режим guile, он получает представление Scheme и например,
список @code{all-threads}.

Потоки в режиме guile могут блокироваться (например., выполняя блокирующий
I/O) не вызывая никаких проблем@footnote{В Guile 1.8, блокировка потока в
режиме guile прдотвращала сборку мусора. Таким образом приходилось покидать
режим guile когда он мог блокироваться. Это больше не нужно в Guile 2.@var{x}.};
временно покидать режим guile с @code{scm_without_guile} перед блокировкой немного
улучшая производительность GC. Для некоторых общих операций блокировки,
Guile предоставляет удобные функции. Например, если вы хотите заблокировать мьютексы
pthread в режиме guile, вы можете воспользоваться @code{scm_pthread_mutex_lock} который
похож на @code{pthread_mutex_lock} за исключением того, что он покидает режим guile 
при блокировке.

Все функции libguile (должны быть) надежны перед лицом нескольких потоков
использующих их одновременно. Это означает, что нет никаких рисков для 
внутренней структуры данных libguile стать поврежденными таким образом,
что процесс завершиться крахом.

Тем не менее, программа может по прежнему давать бессмысленные результаты.
Принимая  хэш-таблицу например, Guile гарантирует, что вы можете использовать
ее из нескольких потоков одновременно и хеш-таблица всегда будет оставаться
допустимой хэш-таблицей и Guile не даст сбой при доступе к ней. Однако это
не гарантирует, что вставка в него одновременно из двух потоков будет давать
полезные результаты: может произойти только одна вставка, ни одна из вставок
не может произойти, или таблица вообще может быть изменена совершенно произвольно.
(Она все равно будет действительной хеш-таблицей, но не той, которой вы могли
ожидать.)  Guile также может сигнализировать об ошибке когда он обнаруживает
состояние гонки.

Таким образом, вам нужно добавлять дополнительную синхронизацию, когда 
несколько потоков хотят использовать одну хеш-таблицу или любой другой
изменяемый объект Scheme.

При написании кода используемого с libguile, вы должны попытаться сделать
его надежным. Пример, который преобразует список в вектор, поможет это
проилюстрироать. Вот правильная версия:

@example
SCM
my_list_to_vector (SCM list)
@{
  SCM vector = scm_make_vector (scm_length (list), SCM_UNDEFINED);
  size_t len, i;

  len = scm_c_vector_length (vector);
  i = 0;
  while (i < len && scm_is_pair (list))
    @{
      scm_c_vector_set_x (vector, i, scm_car (list));
      list = scm_cdr (list);
      i++;
    @}

  return vector;
@}
@end example

Прежде всего следует отметить, что хранение в местоположении @code{SCM} 
одновременно из нескольких потоков гарантирует надежность: вы не знаете,
какое значение выиграет, но оно будет в любом случаее действительным
значением @code{SCM}.

Но нет никакой гарантии, что список на который ссылается переменная @var{list}
не изменяется в другом потоке, в то время когда по нему проходит цикл итерации.
Таким образом, копируя свои элементы в вектор, список может быть длиннее или короче.
По этой причине цикл должен проверять, что он не перегрузит вектор и что он не 
выйдет за рамки списка. В противном случае @code{scm_c_vector_set_x} вызовет
ошибку, если индекс будет вне допустимого диапазона, а @code{scm_car} и @code{scm_cdr}
вызовет ошибку если значение не будет парой.

Безопасно использовать @code{scm_car} и @code{scm_cdr} с локальной
переменной @var{list}, когда будет известно что переменная содержит пару.
Содержание пары может измениться спонтанно, но это всегда будет действительная
пара(и локальная переменная, конечно, не будет спонтанно указывать на другой
объект Scheme).

Аналогично, вектор, такой как тот, который возвращается @code{scm_make_vector}
всегда гарантированно сохраняет туже длину, что бы было безопасно использовать
только scm_c_vector_length и сохранить результат.  (В этом примере вектор(@var{vector})
является безопасным, так как он является новым объектом, и нет другого потока который
может знать о нем, до тех пор пока он не будет возвращен из @code{my_list_to_vector}.)

Конечно, поведение @code{my_list_to_vector} субоптимально когда список
(@var{list}) действительно асинхронно удлинняется или укорачивается в 
другом потоке. Но он рабочий: он всегда будет возвращать действительный
вектор. Этот вектор может быть короче чем ожидалось, или его последние
элементы будут не указаны, но это действительный вектор, и если программа
хочет исключить эти случаи, она должна избегать асинхронного изменения 
списка.

Вот еще одна правильная версия:

@example
SCM
my_pedantic_list_to_vector (SCM list)
@{
  SCM vector = scm_make_vector (scm_length (list), SCM_UNDEFINED);
  size_t len, i;

  len = scm_c_vector_length (vector);
  i = 0;
  while (i < len)
    @{
      scm_c_vector_set_x (vector, i, scm_car (list));
      list = scm_cdr (list);
      i++;
    @}

  return vector;
@}
@end example

Эта версия основана на проверке ошибок @code{scm_car} и @code{scm_cdr}.
Когда список сокращается(т.е когда список( @var{list}) содержит не пары),
 @code{scm_car} выдает ошибку. В этом случае предпочтительнее просто
вернуть полуинициализированный вектор.

API для доступа к векторам и массивам различных типов из Си имеет
несколько иной подход к обеспечению потоковой устойчивости.  Чтобы 
получить необработанную(сырую) память, в которой храняться элементы
массива, вам нужно зарезервировать этот массив(@emph{reserve}), если
вам нужна необработанная память. В течении времени хранения массива, 
его элементы могут спонтанно изменять свои значения, но сама память
и другие вещи, такие как размер массива, гарантированно остаются
фиксированными. Любая операция, которая изменяет эти параметры массива,
который в настоящее время зарезервирован, будет сигнализировать об ошибке.
Чтобы измежать этих ошибок, программа должна, конечно иметь механизмы
синхронизации. Как вы можете видеть, сам Guile беспокоиться о надежности,
а не о правильности: без правильной синхронизации ваша программа скорее всего
не будет правильной, но худшим последствием будет сообщение об ошибке.

Реальная потоко-безопасность часто требует, чтобы критический раздел кода
выполнялся в определенной ограничивающей манере. Общим требованием является
то, что в раздел кода не входит второй поток управления во то время когда он
уже выполняется. Блокировка мьютекса в этом разделе обеспечивает, что
никакаой другой поток не начнет ее выполнять, блокировка асинхронности(asyncs)
гарантирует блокировку асинхронного кода снова входящего в раздел текущего
потока, а проверка ошибок мьютексов Guile гарантирует, что ошибка сигнализируется,
когда текущий поток случайно возвращается в критический раздел через рекурсивные
вызовы функций.

Guile предоставляет два механизма для поддержки критических разеделов, как
описано выше. Вы можете использовать макросы @code{SCM_CRITICAL_SECTION_START}
и @code{SCM_CRITICAL_SECTION_END} для очень простых разделов; или использовать
контекст dynwind вместе с вызовом @code{scm_dynwind_critical_section}.

Макросы работают надежно только для критических секций, которые гарантированно
не содержат нелокальный выход. Они также не обнаруживают случайный повторный
вход в текущем потоке. Таким образом, вы, вероятно должны использовать их только
для разделения критических разделов, которые не содержат вызовов функций
libguile или других внешних функций, которые могут выполнять сложные вещи.

С другой стороны, функция @code{scm_dynwind_critical_section} будет правильно
решать работу с нелокальными выходами, поскольку они требуют контекста dynwind.
Кроме того, используя отдельный мьютекс для каждого критического участка он может
обнаруживать случайные повторные попытки входа в критическую секцию.