#
# NuINu <don't@send.my>, 2019.
#
#. extracted from /home/bear/work/guile/doc/guile/en/scheme-using.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-07 12:37+0300\n"
"PO-Revision-Date: 2019-03-04 10:05+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C) 2006, 2010, 2011, 2012, 2013\n"
"@c   Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:9
msgid ""
"@node Using Guile Interactively\n"
"@section Using Guile Interactively"
msgstr ""
"@node Using Guile Interactively\n"
"@section Интерактивное Использование Guile"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:15
msgid ""
"When you start up Guile by typing just @code{guile}, without a\n"
"@code{-c} argument or the name of a script to execute, you get an\n"
"interactive interpreter where you can enter Scheme expressions, and\n"
"Guile will evaluate them and print the results for you.  Here are some\n"
"simple examples."
msgstr ""
"Когда вы запускаете Guile, просто набирая @code{guile}, без аргумента\n"
"@code{-c} или имени скрипта для выполнения, вы получаете интерактивный\n"
"интерпретатор, где вы можете вводить выражения Scheme, и \n"
"Guile вычислит их и распечатает результаты для вас. Вот несколько простых\n"
"примеров."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:25
msgid ""
"@lisp\n"
"scheme@@(guile-user)> (+ 3 4 5)\n"
"$1 = 12\n"
"scheme@@(guile-user)> (display \"Hello world!\\n\")\n"
"Hello world!\n"
"scheme@@(guile-user)> (values 'a 'b)\n"
"$2 = a\n"
"$3 = b\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:31
msgid ""
"@noindent\n"
"This mode of use is called a @dfn{REPL}, which is short for\n"
"``Read-Eval-Print Loop'', because the Guile interpreter first reads the\n"
"expression that you have typed, then evaluates it, and then prints the\n"
"result."
msgstr ""
"@noindent\n"
"Этот режим использования называется @dfn{REPL}, что является сокращением от\n"
"(Читать-Выполнять-Печатать в Цикле) ``Read-Eval-Print Loop'', потому что "
"Guile\n"
"интерпретатор сначала читает набранное вами выражение, заем вычисляет его, \n"
"а затем печатает результат."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:36
msgid ""
"The prompt shows you what language and module you are in. In this case, the\n"
"current language is @code{scheme}, and the current module is\n"
"@code{(guile-user)}. @xref{Other Languages}, for more information on "
"Guile's\n"
"support for languages other than Scheme."
msgstr ""
"В подсказке отображается язык и модуль, в котором вы находитесь. В нашем "
"случае,\n"
"текущий язык это @code{scheme}, и текущий модуль это\n"
"@code{(guile-user)}. @xref{Other Languages}, для получения дополнительной "
"информации о\n"
"поддерживаемых Guile языках отличных от Scheme."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:45
msgid ""
"@menu\n"
"* Init File::\n"
"* Readline::                    \n"
"* Value History::              \n"
"* REPL Commands::               \n"
"* Error Handling::              \n"
"* Interactive Debugging::       \n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:49
msgid ""
"@node Init File\n"
"@subsection The Init File, @file{~/.guile}"
msgstr ""
"@node Init File\n"
"@subsection Файл инициализации, @file{~/.guile}"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:54
msgid ""
"@cindex .guile\n"
"When run interactively, Guile will load a local initialization file from\n"
"@file{~/.guile}.  This file should contain Scheme expressions for\n"
"evaluation."
msgstr ""
"@cindex .guile\n"
"При интерактивном запуске, Guile загружает локальный файл инициализации из\n"
"@file{~/.guile}.  Этот файл должен содержать выражения  Scheme для "
"выполнения."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:58
msgid ""
"This facility lets the user customize their interactive Guile\n"
"environment, pulling in extra modules or parameterizing the REPL\n"
"implementation."
msgstr ""
"Это средство позволяет пользователю настраивать свою интерактивную\n"
"среду Guile, добавляя дополнительные модули или параметризацию\n"
"реализации REPL."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:61
msgid ""
"To run Guile without loading the init file, use the @code{-q}\n"
"command-line option."
msgstr ""
"Чтобы запустить Guile без загрузки файла инициализации используйте параметр\n"
"командной строки @code{-q}."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:65
msgid ""
"@node Readline\n"
"@subsection Readline"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:71
msgid ""
"To make it easier for you to repeat and vary previously entered\n"
"expressions, or to edit the expression that you're typing in, Guile\n"
"can use the GNU Readline library.  This is not enabled by default\n"
"because of licensing reasons, but all you need to activate Readline is\n"
"the following pair of lines."
msgstr ""
"Чтобы проще было повторять и изменять ранее введенные выражения и "
"редактировать\n"
"набранные выражения в Guile можно использовать библиотеку GNU Readline.\n"
"Эта библиотека не включена по умолчанию, по причинам лицензирования, но "
"все \n"
"что вам нужно сделать для активации Readline, это набрать следующую пару \n"
"строк."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:76
msgid ""
"@lisp\n"
"scheme@@(guile-user)> (use-modules (ice-9 readline))\n"
"scheme@@(guile-user)> (activate-readline)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:80
msgid ""
"It's a good idea to put these two lines (without the\n"
"@code{scheme@@(guile-user)>} prompts) in your @file{.guile} file.\n"
"@xref{Init File}, for more on @file{.guile}."
msgstr ""
"Рекомендуется поместить эти две строки (без приглашений\n"
"@code{scheme@@(guile-user)>}) в ваш файл @file{.guile}.\n"
"@xref{Init File}, для получения дополнительной информации о @file{.guile}."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:84
msgid ""
"@node Value History\n"
"@subsection Value History"
msgstr ""
"@node Value History\n"
"@subsection История Значений(Value)"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:91
msgid ""
"Just as Readline helps you to reuse a previous input line, @dfn{value\n"
"history} allows you to use the @emph{result} of a previous evaluation in\n"
"a new expression.  When value history is enabled, each evaluation result\n"
"is automatically assigned to the next in the sequence of variables\n"
"@code{$1}, @code{$2}, @dots{}.  You can then use these variables in\n"
"subsequent expressions."
msgstr ""
"Подобно тому как Readline помогает вам повторно использовать предыдущую\n"
"строку ввода, история значений(@dfn{value history}) позволяет вам "
"использовать\n"
"результаты @emph{result} предедыдущих вычислений в новых выражениях.\n"
"Когда история значений включена, каждый результат вычисления автоматически\n"
"присваивается следующей переменной в последовательности переменных\n"
"@code{$1}, @code{$2}, @dots{}.  Вы можете использовать эти переменные в "
"последующих\n"
"выражениях."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:102
msgid ""
"@lisp\n"
"scheme@@(guile-user)> (iota 10)\n"
"$1 = (0 1 2 3 4 5 6 7 8 9)\n"
"scheme@@(guile-user)> (apply * (cdr $1))\n"
"$2 = 362880\n"
"scheme@@(guile-user)> (sqrt $2)\n"
"$3 = 602.3952191045344\n"
"scheme@@(guile-user)> (cons $2 $1)\n"
"$4 = (362880 0 1 2 3 4 5 6 7 8 9)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:106
msgid ""
"Value history is enabled by default, because Guile's REPL imports the\n"
"@code{(ice-9 history)} module. Value history may be turned off or on within "
"the\n"
"repl, using the options interface:"
msgstr ""
"История значений включена по умолчанию, поскольку Guile REPL импортирует "
"модуль\n"
"@code{(ice-9 history)}. История значений может быть отключена или включена "
"в\n"
"repl, используя опции интерфейса:"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:115
msgid ""
"@lisp\n"
"scheme@@(guile-user)> ,option value-history #f\n"
"scheme@@(guile-user)> 'foo\n"
"foo\n"
"scheme@@(guile-user)> ,option value-history #t\n"
"scheme@@(guile-user)> 'bar\n"
"$5 = bar\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:120
msgid ""
"Note that previously recorded values are still accessible, even if value "
"history\n"
"is off. In rare cases, these references to past computations can cause Guile "
"to\n"
"use too much memory. One may clear these values, possibly enabling garbage\n"
"collection, via the @code{clear-value-history!} procedure, described below."
msgstr ""
"Обратите внимание, что ранее записанные значения по прежнему доступны, даже "
"если\n"
"история значений отключена. В редких случаях эти ссылки на прошлые "
"вычисления могут\n"
"привести к тому, что Guile будет использовать слишком много памяти. Можно "
"очистить эти\n"
"значения, возможно включив сборку мусора, через процедуру @code{clear-value-"
"history!},\n"
"описанную ниже."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:122
msgid "The programmatic interface to value history is in a module:"
msgstr "Программный интерфейс для истории значений находится в модуле:"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:126
msgid ""
"@lisp\n"
"(use-modules (ice-9 history))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:130
msgid ""
"@deffn {Scheme Procedure} value-history-enabled?\n"
"Return true if value history is enabled, or false otherwise.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} value-history-enabled?\n"
"Возвращает истину, если история значений включена, или ложь в противном "
"случае.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:134
msgid ""
"@deffn {Scheme Procedure} enable-value-history!\n"
"Turn on value history, if it was off.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} enable-value-history!\n"
"Включает запись истории значений, если она выключена.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:138
msgid ""
"@deffn {Scheme Procedure} disable-value-history!\n"
"Turn off value history, if it was on.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} disable-value-history!\n"
"Выключает запись истории значений, если она включена.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:143
msgid ""
"@deffn {Scheme Procedure} clear-value-history!\n"
"Clear the value history. If the stored values are not captured by some "
"other\n"
"data structure or closure, they may then be reclaimed by the garbage "
"collector.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} clear-value-history!\n"
"Очищает историю значений. Если сохраненные значения не фиксируются другими "
"структурами\n"
"данных или замыканиями, они могут быть затем утилизированы сборщиком "
"мусора.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:147
msgid ""
"@node REPL Commands\n"
"@subsection REPL Commands"
msgstr ""
"@node REPL Commands\n"
"@subsection Команды REPL"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:153
msgid ""
"@cindex commands\n"
"The REPL exists to read expressions, evaluate them, and then print their\n"
"results. But sometimes one wants to tell the REPL to evaluate an\n"
"expression in a different way, or to do something else altogether. A\n"
"user can affect the way the REPL works with a @dfn{REPL command}."
msgstr ""
"@cindex commands\n"
"REPL существует чтобы читать выражения, вычислять их и распечатывать их \n"
"результы. Но иногда кто-то хочет сказать REPL, что бы он оценивал выражение\n"
"по другому или сделал что-то вообще. Пользователь может повлиять на работу\n"
"REPL с помощью команд REPL (@dfn{REPL command})."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:156
msgid ""
"The previous section had an example of a command, in the form of\n"
"@code{,option}."
msgstr ""
"В предыдущем разделе был приведен пример команды, в виде\n"
"@code{,option}."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:160
msgid ""
"@lisp\n"
"scheme@@(guile-user)> ,option value-history #t\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:166
msgid ""
"@noindent\n"
"Commands are distinguished from expressions by their initial comma\n"
"(@samp{,}). Since a comma cannot begin an expression in most languages,\n"
"it is an effective indicator to the REPL that the following text forms a\n"
"command, not an expression."
msgstr ""
"@noindent\n"
"Команды отличаются от выражений наличием в них начальной запятой\n"
"(@samp{,}). С запятой не может начинаться выражение в большинстве языков, "
"это\n"
"эффективный показатель для REPL что следующий текст формирует команду, \n"
"а не выражение.\n"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:170
msgid ""
"REPL commands are convenient because they are always there. Even if the\n"
"current module doesn't have a binding for @code{pretty-print}, one can\n"
"always @code{,pretty-print}."
msgstr ""
"Команды REPL удобны, потому что они всегда есть. Даже если текущий модуль "
"не \n"
"имеет привязки для @code{pretty-print}, всегда можно сделать @code{,pretty-"
"print}."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:174
msgid ""
"The following sections document the various commands, grouped together\n"
"by functionality. Many of the commands have abbreviations; see the\n"
"online help (@code{,help}) for more information."
msgstr ""
"В следующих разделах описаны различные команды, сгруппированные по \n"
"функциональности. Многие команды имеют сокращения; см. онлайн-справку\n"
"(@code{,help}) для получения дополнительной информации."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:185
msgid ""
"@menu\n"
"* Help Commands::               \n"
"* Module Commands::             \n"
"* Language Commands::           \n"
"* Compile Commands::            \n"
"* Profile Commands::            \n"
"* Debug Commands::              \n"
"* Inspect Commands::            \n"
"* System Commands::             \n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:188
msgid ""
"@node Help Commands\n"
"@subsubsection Help Commands"
msgstr ""
"@node Help Commands\n"
"@subsubsection Команды помощи(Help)"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:193
msgid ""
"When Guile starts interactively, it notifies the user that help can be\n"
"had by typing @samp{,help}. Indeed, @code{help} is a command, and a\n"
"particularly useful one, as it allows the user to discover the rest of\n"
"the commands."
msgstr ""
"Когда Guile запускается в интерактивном режиме, он уведомляет пользователя\n"
"о том, что справку можно получить набрав @samp{,help}. Действительно, "
"@code{help}\n"
"это команда особенно полезная, поскольку позволяет пользователю обнаружить "
"остальные\n"
"команды."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:196
msgid ""
"@deffn {REPL Command} help [@code{all} | group | @code{[-c]} command]\n"
"Show help."
msgstr ""
"@deffn {REPL Command} help [@code{all} | group | @code{[-c]} command]\n"
"Показывает справку(помощь)."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:200
msgid ""
"With one argument, tries to look up the argument as a group name, giving\n"
"help on that group if successful. Otherwise tries to look up the\n"
"argument as a command, giving help on the command."
msgstr ""
"С одним аругментом, пытается найти аргумент как имя группы, давая помощь "
"если\n"
"это группа. В противном случае, пытается найти аргумент в качестве команды, "
"давая\n"
"помощь если это команда."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:203
msgid ""
"If there is a command whose name is also a group name, use the @samp{-c\n"
"@var{command}} form to give help on the command instead of the group."
msgstr ""
"Если есть команда, имя которой также является именем группы, используйте\n"
"фаорму @samp{-c @var{command}} для получения помощи по команде, а не по "
"группе."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:207
msgid ""
"Without any argument, a list of help commands and command groups\n"
"are displayed.\n"
"@end deffn"
msgstr ""
"Без каких либо аргументов отображается список команд справки и\n"
"групп команд.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:210
msgid ""
"@deffn {REPL Command} show [topic]\n"
"Gives information about Guile."
msgstr ""
"@deffn {REPL Command} show [topic]\n"
"Дает информацию о Guile."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:214
msgid ""
"With one argument, tries to show a particular piece of information;\n"
"currently supported topics are `warranty' (or `w'), `copying' (or `c'),\n"
"and `version' (or `v')."
msgstr ""
"С одним аргументом, пытается показать конкретную часть информации; в "
"настоящее\n"
"время поддеживаются темы: гарантии(`warranty') (или `w'), \"копирование"
"\"(`copying') \n"
"(или `c') и версия(`version') (или `v')."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:217
msgid ""
"Without any argument, a list of topics is displayed.\n"
"@end deffn"
msgstr ""
"Без каких либо аргументов отображает список тем.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:221
msgid ""
"@deffn {REPL Command} apropos regexp\n"
"Find bindings/modules/packages.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} apropos regexp\n"
"Ищет привязки/модули/пакеты\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:225
msgid ""
"@deffn {REPL Command} describe obj\n"
"Show description/documentation.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} describe obj\n"
"Показывает описание(description)/документацию(documentation).\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:228
msgid ""
"@node Module Commands\n"
"@subsubsection Module Commands"
msgstr ""
"@node Module Commands\n"
"@subsubsection Команды Модулей"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:232
msgid ""
"@deffn {REPL Command} module [module]\n"
"Change modules / Show current module.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} module [module]\n"
"Изменяет текущий модуль / Показывает текущий модуль.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:236
msgid ""
"@deffn {REPL Command} import module @dots{}\n"
"Import modules / List those imported.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} import module @dots{}\n"
"Импортирует модуль / Показывает список имротрированных модулей(текущим "
"модулем).\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:240
msgid ""
"@deffn {REPL Command} load file\n"
"Load a file in the current module.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} load file\n"
"Загружает файл в текущий модуль.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:244
msgid ""
"@deffn {REPL Command} reload [module]\n"
"Reload the given module, or the current module if none was given.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} reload [module]\n"
"Перезагружает  данный модуль или текущий модуль, если он не был указан.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:248
msgid ""
"@deffn {REPL Command} binding\n"
"List current bindings.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} binding\n"
"Список текущих привязок.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:255
msgid ""
"@deffn {REPL Command} in module expression\n"
"@deffnx {REPL Command} in module command arg @dots{}\n"
"Evaluate an expression, or alternatively, execute another meta-command\n"
"in the context of a module.  For example, @samp{,in (foo bar) ,binding}\n"
"will show the bindings in the module @code{(foo bar)}.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} in module expression\n"
"@deffnx {REPL Command} in module command arg @dots{}\n"
"Вычисляет выражение, или альтернативно, выполняет другую мета-команду в\n"
"контексте модуля.  Например, @samp{,in (foo bar) ,binding}\n"
"показывает привязки в модуле @code{(foo bar)}. а так интереснее: \n"
"@samp{,in (value-history) ,binding}\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:258
msgid ""
"@node Language Commands\n"
"@subsubsection Language Commands"
msgstr ""
"@node Language Commands\n"
"@subsubsection Команды Языка"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:262
msgid ""
"@deffn {REPL Command} language language\n"
"Change languages.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} language language\n"
"Изменяет текущий язык.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:265
msgid ""
"@node Compile Commands\n"
"@subsubsection Compile Commands"
msgstr ""
"@node Compile Commands\n"
"@subsubsection Команды Компиляции"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:269
msgid ""
"@deffn {REPL Command} compile exp\n"
"Generate compiled code.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} compile exp\n"
"Создает скомпилированный код выражения.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:273
msgid ""
"@deffn {REPL Command} compile-file file\n"
"Compile a file.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} compile-file file\n"
"Компилирует файл.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:277
msgid ""
"@deffn {REPL Command} expand exp\n"
"Expand any macros in a form.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} expand exp\n"
"Расширяет макрос в форму Scheme(а возможно и другого языка).\n"
"@samp{,expand (define-once a 3)}\n"
"или\n"
" @samp{,expand (when (defined? a) (display \"a defined!!!\"))}\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:281
msgid ""
"@deffn {REPL Command} optimize exp\n"
"Run the optimizer on a piece of code and print the result.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} optimize exp\n"
"Запускает оптимизатор на куске кода и распечатывает результат.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:285
msgid ""
"@deffn {REPL Command} disassemble exp\n"
"Disassemble a compiled procedure.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} disassemble exp\n"
"Дизассемблирует скомпилированную процедуру.\n"
"@samp{(define a (lambda () (display \"Test disassm\\n\")))\n"
",disassemble a}\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:289
msgid ""
"@deffn {REPL Command} disassemble-file file\n"
"Disassemble a file.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} disassemble-file file\n"
"Дизассемблирует файл.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:292
msgid ""
"@node Profile Commands\n"
"@subsubsection Profile Commands"
msgstr ""
"@node Profile Commands\n"
"@subsubsection Команды профилирования(измерения скорости работы)"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:296
msgid ""
"@deffn {REPL Command} time exp\n"
"Time execution.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} time exp\n"
"Выдает время выполнения выражения.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:304
msgid ""
"@deffn {REPL Command} profile exp [#:hz hz=100] @\n"
"  [#:count-calls? count-calls?=#f] [#:display-style display-style=list]\n"
"Profile execution of an expression.  This command compiled @var{exp} and\n"
"then runs it within the statprof profiler, passing all keyword options\n"
"to the @code{statprof} procedure.  For more on statprof and on the the\n"
"options available to this command, @xref{Statprof}.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} profile exp [#:hz hz=100] @\n"
"  [#:count-calls? count-calls?=#f] [#:display-style display-style=list]\n"
"Профилирование выполнения выражения.  Эта команда компилирует выражение "
"@var{exp}\n"
"и затем запускае его в профилировщике statprof, передавая все ключевые слова "
"в процедуру\n"
"@code{statprof}.  Подробнее о statprof и доступных опциях для этой команды\n"
"смотри  @xref{Statprof}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:307
msgid ""
"@deffn {REPL Command} trace exp [#:width w] [#:max-indent i]\n"
"Trace execution."
msgstr ""
"@deffn {REPL Command} trace exp [#:width w] [#:max-indent i]\n"
"Трассировка исполнения"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:313
msgid ""
"By default, the trace will limit its width to the width of your\n"
"terminal, or @var{width} if specified.  Nested procedure invocations\n"
"will be printed farther to the right, though if the width of the\n"
"indentation passes the @var{max-indent}, the indentation is abbreviated.\n"
"@end deffn"
msgstr ""
"По умолчанию, trace ограничена шириной вашего терминала, или указанием\n"
" @var{width} если он определен.  Вложенные вызовы процедур будут печататься\n"
"дальше в право, хотя если ширина отступа соответствует  @var{max-indent}, \n"
"максимальный отступ сокращается.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:316
msgid ""
"@node Debug Commands\n"
"@subsubsection Debug Commands"
msgstr ""
"@node Debug Commands\n"
"@subsubsection Команды Отладки"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:319
msgid ""
"These debugging commands are only available within a recursive REPL;\n"
"they do not work at the top level."
msgstr ""
"Эти команды отладки доступын только в рамках рекурсивного REPL;\n"
"они не работают на верхнем уровне."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:322
msgid ""
"@deffn {REPL Command} backtrace [count] [#:width w] [#:full? f]\n"
"Print a backtrace."
msgstr ""
"@deffn {REPL Command} backtrace [count] [#:width w] [#:full? f]\n"
"Печатает обратную трассу(стек вызовов)."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:326
msgid ""
"Print a backtrace of all stack frames, or innermost @var{count} frames.\n"
"If @var{count} is negative, the last @var{count} frames will be shown.\n"
"@end deffn"
msgstr ""
"Выводит обратную трассу всех кадров стека, или верхние @var{count} кадров.\n"
"Если @var{count} отритцательный, будут показаны последние @var{count} "
"кадров.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:329
msgid ""
"@deffn {REPL Command} up [count]\n"
"Select a calling stack frame."
msgstr ""
"@deffn {REPL Command} up [count]\n"
"Выбирает кадр стека вызова."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:333
msgid ""
"Select and print stack frames that called this one.\n"
"An argument says how many frames up to go.\n"
"@end deffn"
msgstr ""
"Выбирает и распечатывает кадры стека, которые вызвали это.\n"
"Аргумент говорит, сколько кадров надо пройти вверх.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:336
msgid ""
"@deffn {REPL Command} down [count]\n"
"Select a called stack frame."
msgstr ""
"@deffn {REPL Command} down [count]\n"
"Выбирает кадр стека вызовов."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:340
msgid ""
"Select and print stack frames called by this one.\n"
"An argument says how many frames down to go.\n"
"@end deffn"
msgstr ""
"Выбирает и распечатывает кадры стека, которые вызвали это.\n"
"Аргумент говорит, сколько кадров надо пройти вниз.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:343
msgid ""
"@deffn {REPL Command} frame [idx]\n"
"Show a frame."
msgstr ""
"@deffn {REPL Command} frame [idx]\n"
"Показывает кадр."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:347
msgid ""
"Show the selected frame.  With an argument, select a frame by index,\n"
"then show it.\n"
"@end deffn"
msgstr ""
"Показывает выбранный кадр.  С аргументом, выбирает кадр по индексу,\n"
"а затем показывает его.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:350
msgid ""
"@deffn {REPL Command} locals\n"
"Show local variables."
msgstr ""
"@deffn {REPL Command} locals\n"
"Показывает локальные переменные."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:353
msgid ""
"Show locally-bound variables in the selected frame.\n"
"@end deffn"
msgstr ""
"Показывает локально связанные переменные в выбранном кадре.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:357
msgid ""
"@deffn {REPL Command} error-message\n"
"@deffnx {REPL Command} error\n"
"Show error message."
msgstr ""
"@deffn {REPL Command} error-message\n"
"@deffnx {REPL Command} error\n"
"Показывает сообщение об ошибке."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:361
msgid ""
"Display the message associated with the error that started the current\n"
"debugging REPL.\n"
"@end deffn"
msgstr ""
"Отображает сообщение, связанное с ошибкой с которой началась текущая\n"
"сессия отладки REPL.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:364
msgid ""
"@deffn {REPL Command} registers\n"
"Show the VM registers associated with the current frame."
msgstr ""
"@deffn {REPL Command} registers\n"
"Показывает регистры VM свяазнные с текущим кадром."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:367
msgid ""
"@xref{Stack Layout}, for more information on VM stack frames.\n"
"@end deffn"
msgstr ""
"@xref{Stack Layout}, для получения дополнительной информации о кадрах\n"
"стека VM.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:373
msgid ""
"@deffn {REPL Command} width [cols]\n"
"Sets the number of display columns in the output of @code{,backtrace}\n"
"and @code{,locals} to @var{cols}.  If @var{cols} is not given, the width\n"
"of the terminal is used.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} width [cols]\n"
"Устанавливает количество отображаемых столбцов в выходных данных @code{,"
"backtrace}\n"
"и @code{,locals} в значение  @var{cols}.  Если @var{cols} не указан, "
"используется\n"
"ширина терминала.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:375
msgid "The next 3 commands work at any REPL."
msgstr "Следующие 3 команды работают в любом REPL."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:379
msgid ""
"@deffn {REPL Command} break proc\n"
"Set a breakpoint at @var{proc}.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} break proc\n"
"Установить точку останова на процедуре @var{proc}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:383
msgid ""
"@deffn {REPL Command} break-at-source file line\n"
"Set a breakpoint at the given source location.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} break-at-source file line\n"
"Установить точку останова в указанном местоположении исходного файла.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:389
msgid ""
"@deffn {REPL Command} tracepoint proc\n"
"Set a tracepoint on the given procedure. This will cause all calls to\n"
"the procedure to print out a tracing message. @xref{Tracing Traps}, for\n"
"more information.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} tracepoint proc\n"
"Устанавливает точку трассировки для данной процедуры. Это приведет к тому, "
"что\n"
"все вызовы процедуры распечатают сообщение трассировки. @xref{Tracing "
"Traps}, \n"
"для получения дополнительной информации.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:394
msgid ""
"The rest of the commands in this subsection all apply only when the\n"
"stack is @dfn{continuable} --- in other words when it makes sense for\n"
"the program that the stack comes from to continue running.  Usually this\n"
"means that the program stopped because of a trap or a breakpoint."
msgstr ""
"Все остальные команды данной подсекции применяются только тогда, когда стек\n"
"является продолжаемым (@dfn{continuable}) --- другими словами, когда для "
"программы\n"
"стек которой получен возможно продолжить работу.  Обычно это означает, что\n"
"программа остановлена из за прерывания или точки останова."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:398
msgid ""
"@deffn {REPL Command} step\n"
"Tell the debugged program to step to the next source location.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} step\n"
"Говорит отлаживаемой программе перейти к следующему положению в исходнике.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:403
msgid ""
"@deffn {REPL Command} next\n"
"Tell the debugged program to step to the next source location in the\n"
"same frame.  (See @ref{Traps} for the details of how this works.)\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} next\n"
"Говорит отлаживаемой программе перейти к следуюещему положению в исходнике "
"в\n"
"том же кадре стека (См. @ref{Traps} для получения детальной информации как "
"это работает.)\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:409
msgid ""
"@deffn {REPL Command} finish\n"
"Tell the program being debugged to continue running until the completion\n"
"of the current stack frame, and at that time to print the result and\n"
"reenter the REPL.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} finish\n"
"Говорит отлаживаемой программе, что бы она продолжала работать до завершения "
"текущего\n"
"кадра стека, после чего распечатать результат и повторнно войти в REPL.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:413
msgid ""
"@node Inspect Commands\n"
"@subsubsection Inspect Commands"
msgstr ""
"@node Inspect Commands\n"
"@subsubsection Проверяющие(Инспектирующие) Команды"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:417
msgid ""
"@deffn {REPL Command} inspect exp\n"
"Inspect the result(s) of evaluating @var{exp}.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} inspect exp\n"
"Проверяет результат вычисления  @var{exp}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:421
msgid ""
"@deffn {REPL Command} pretty-print exp\n"
"Pretty-print the result(s) of evaluating @var{exp}.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} pretty-print exp\n"
"Достаточно красиво печатает результат вычисления выражения @var{exp}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:424
msgid ""
"@node System Commands\n"
"@subsubsection System Commands"
msgstr ""
"@node System Commands\n"
"@subsubsection Системные команды"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:428
msgid ""
"@deffn {REPL Command} gc\n"
"Garbage collection.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} gc\n"
"Сборка мусора.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:432
msgid ""
"@deffn {REPL Command} statistics\n"
"Display statistics.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} statistics\n"
"Отображение статистики.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:439
msgid ""
"@deffn {REPL Command} option [name] [exp]\n"
"With no arguments, lists all options.  With one argument, shows the\n"
"current value of the @var{name} option.  With two arguments, sets the\n"
"@var{name} option to the result of evaluating the Scheme expression\n"
"@var{exp}.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} option [name] [exp]\n"
"Без аргументов, перечисляет все варианты.  С одним аргументом, показывает\n"
"текущее значение опции с именем @var{name}.  С двумя аргументами, "
"устанавливает\n"
"для опции с именем @var{name} результат вычисления Scheme выражения\n"
"@var{exp}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:443
msgid ""
"@deffn {REPL Command} quit\n"
"Quit this session.\n"
"@end deffn"
msgstr ""
"@deffn {REPL Command} quit\n"
"Выходит из сессии.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:445
msgid "Current REPL options include:"
msgstr "Текущие опции REPL включают:"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:468
msgid ""
"@table @code\n"
"@item compile-options\n"
"The options used when compiling expressions entered at the REPL.\n"
"@xref{Compilation}, for more on compilation options.\n"
"@item interp\n"
"Whether to interpret or compile expressions given at the REPL, if such a\n"
"choice is available.  Off by default (indicating compilation).\n"
"@item prompt\n"
"A customized REPL prompt.  @code{#f} by default, indicating the default\n"
"prompt.\n"
"@item print\n"
"A procedure of two arguments used to print the result of evaluating each\n"
"expression.  The arguments are the current REPL and the value to print.\n"
"By default, @code{#f}, to use the default procedure.\n"
"@item value-history\n"
"Whether value history is on or not.  @xref{Value History}.\n"
"@item on-error\n"
"What to do when an error happens.  By default, @code{debug}, meaning to\n"
"enter the debugger.  Other values include @code{backtrace}, to show a\n"
"backtrace without entering the debugger, or @code{report}, to simply\n"
"show a short error printout.\n"
"@end table"
msgstr ""
"@table @code\n"
"@item compile-options\n"
"Параметры используемые при компиляции введенных выражений в REPL.\n"
"@xref{Compilation}, для подробной информации о опциях компиляции.\n"
"@item interp\n"
"Следует ли интерпретировать или компилировать выражения предоставляемые\n"
"REPL, если такой выбор доступен.  По умолчанию Off (indicating "
"compilation).\n"
"@item prompt\n"
"Настроенное приглашение REPL.  @code{#f} по умолчанию, указывает на "
"приглашение\n"
"по умолчанию.\n"
"@item print\n"
"Процедура с двумя аргументами используемая для печати результата вычисления "
"каждого\n"
"выражения. Аргументы это текущий REPL и печатаемое значение.\n"
"По умолчанию, @code{#f}, использовать процедуру по умолчанию.\n"
"@item value-history\n"
"Включена ли история значений или нет.  @xref{Value History}.\n"
"@item on-error\n"
"Что делать при возникновении ошибки.  По умолчанию, @code{debug}, то есть\n"
"вход в отладчик.  Другие значения включают @code{backtrace}, для показа\n"
"трассировки стека без входа в отладчик, или @code{report}, просто выводит\n"
"сообщение об ошибке.\n"
"@end table"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:471
msgid ""
"Default values for REPL options may be set using\n"
"@code{repl-default-option-set!} from @code{(system repl common)}:"
msgstr ""
"Значения по умолчанию для опций REPL могут быть установлены использованием\n"
"@code{repl-default-option-set!} из @code{(system repl common)}:"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:476
msgid ""
"@deffn {Scheme Procedure} repl-default-option-set! key value\n"
"Set the default value of a REPL option.  This function is particularly\n"
"useful in a user's init file.  @xref{Init File}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} repl-default-option-set! key value\n"
"Устанавливает значения по умолчанию опций REPL.  Эта функция особенно "
"полезна в файле\n"
"инициализации пользователя.  @xref{Init File}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:480
msgid ""
"@node Error Handling\n"
"@subsection Error Handling"
msgstr ""
"@node Error Handling\n"
"@subsection Обработка ошибок"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:483
msgid ""
"When code being evaluated from the REPL hits an error, Guile enters a\n"
"new prompt, allowing you to inspect the context of the error."
msgstr ""
"Когда в коде выполняющимся из REPL обнаруживаеся ошибка, Guile вводит новое\n"
"приглашение, позволяя вам проверить контекст ошибки."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:491
msgid ""
"@lisp\n"
"scheme@@(guile-user)> (map string-append '(\"a\" \"b\") '(\"c\" #\\d))\n"
"ERROR: In procedure string-append:\n"
"ERROR: Wrong type (expecting string): #\\d\n"
"Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.\n"
"scheme@@(guile-user) [1]>\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:495
msgid ""
"The new prompt runs inside the old one, in the dynamic context of the\n"
"error.  It is a recursive REPL, augmented with a reified representation\n"
"of the stack, ready for debugging."
msgstr ""
"Новое приглашение запускается внутри старого, в динамическом контексте\n"
"ошибки. Это рекурсивный REPL, дополненный усовершенствованным представлением "
"стека,\n"
"готовым к отладке."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:498
msgid ""
"@code{,backtrace} (abbreviated @code{,bt}) displays the Scheme call\n"
"stack at the point where the error occurred:"
msgstr ""
"@code{,backtrace} (abbreviated @code{,bt}) отображает стек вызовов Scheme\n"
"в точке, где произошла ошибка:"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:504
msgid ""
"@lisp\n"
"scheme@@(guile-user) [1]> ,bt\n"
"           1 (map #<procedure string-append _> (\"a\" \"b\") (\"c\" #\\d))\n"
"           0 (string-append \"b\" #\\d)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:510
msgid ""
"In the above example, the backtrace doesn't have much source\n"
"information, as @code{map} and @code{string-append} are both\n"
"primitives. But in the general case, the space on the left of the\n"
"backtrace indicates the line and column in which a given procedure calls\n"
"another."
msgstr ""
"В приведенном выше примере, обратная трассировка(backtrace) не имеет\n"
"информации об исходном тексте обоих примитивов @code{map} и @code{string-"
"append}.\n"
"Но в общем случае пространство слева, от backtrace указывает строку и "
"столбец,\n"
"в которых данная процедура вызывает другую."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:514
msgid ""
"You can exit a recursive REPL in the same way that you exit any REPL:\n"
"via @samp{(quit)}, @samp{,quit} (abbreviated @samp{,q}), or\n"
"@kbd{C-d}, among other options."
msgstr ""
"Вы можете выйти из рекусрсивного REPL так же как вы выходите из любого "
"REPL:\n"
"через @samp{(quit)}, @samp{,quit} (сокращенно @samp{,q}), или\n"
"другой вариант @kbd{C-d}."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:518
msgid ""
"@node Interactive Debugging\n"
"@subsection Interactive Debugging"
msgstr ""
"@node Interactive Debugging\n"
"@subsection Интерактивная Отладка"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:522
msgid ""
"A recursive debugging REPL exposes a number of other meta-commands that\n"
"inspect the state of the computation at the time of the error. These\n"
"commands allow you to"
msgstr ""
"Рекурсивный отладочный REPL представляет ряд других метакоманд, которые "
"проверяют\n"
"состояние вычислений на момент ошибки. Эти команды позовляют вам"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:526
msgid ""
"@itemize @bullet\n"
"@item\n"
"display the Scheme call stack at the point where the error occurred;"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"отобразить стек вызовов Scheme в точке, где произошла ошибка;"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:530
msgid ""
"@item\n"
"move up and down the call stack, to see in detail the expression being\n"
"evaluated, or the procedure being applied, in each @dfn{frame}; and"
msgstr ""
"@item\n"
"перемещаться вверх и вниз по стеку вызовов, чтобы детально увидеть "
"вычисляемое\n"
"выражение или применяемую процедуру в каждом кадре(@dfn{frame}); а также"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:535
msgid ""
"@item\n"
"examine the values of variables and expressions in the context of each\n"
"frame.\n"
"@end itemize"
msgstr ""
"@item\n"
"изучить значения переменных и выражений в контексте каждого фрейма(кадра "
"стека).\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:540
msgid ""
"@noindent\n"
"@xref{Debug Commands}, for documentation of the individual\n"
"commands. This section aims to give more of a walkthrough of a typical\n"
"debugging session."
msgstr ""
"@noindent\n"
"@xref{Debug Commands}, для документации по отдельным командам.\n"
"Этот раздел призван дать более детальное описание типичного сеанса отладки."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:544
msgid ""
"First, we're going to need a good error. Let's try to macroexpand the\n"
"expression @code{(unquote foo)}, outside of a @code{quasiquote} form,\n"
"and see how the macroexpander reports this error."
msgstr ""
"Первым делом, нам понадобиться \"хорошая\" ошибка. Давайте попробуем "
"macroexpand\n"
"- расширить выражение @code{(unquote foo)}, за пределами формы "
"@code{quasiquote},\n"
"и посмотрим, как макрорасширитель сообщит об этой ошибке."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:552
msgid ""
"@lisp\n"
"scheme@@(guile-user)> (macroexpand '(unquote foo))\n"
"ERROR: In procedure macroexpand:\n"
"ERROR: unquote: expression not valid outside of quasiquote in (unquote foo)\n"
"Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.\n"
"scheme@@(guile-user) [1]>\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:556
msgid ""
"The @code{backtrace} command, which can also be invoked as @code{bt},\n"
"displays the call stack (aka backtrace) at the point where the debugger\n"
"was entered:"
msgstr ""
"Команда @code{backtrace}, которая также может быть вызвана как @code{bt},\n"
"отображает стек вызовов (иначе читается как backtrace) в том месте, где \n"
"управление процессом вычисления перешло к отладчику:"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:566
msgid ""
"@lisp\n"
"scheme@@(guile-user) [1]> ,bt\n"
"In ice-9/psyntax.scm:\n"
"  1130:21  3 (chi-top (unquote foo) () ((top)) e (eval) (hygiene #))\n"
"  1071:30  2 (syntax-type (unquote foo) () ((top)) #f #f (# #) #f)\n"
"  1368:28  1 (chi-macro #<procedure de9360 at ice-9/psyntax.scm...> ...)\n"
"In unknown file:\n"
"           0 (scm-error syntax-error macroexpand \"~a: ~a in ~a\" # #f)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:571
msgid ""
"A call stack consists of a sequence of stack @dfn{frames}, with each\n"
"frame describing one procedure which is waiting to do something with the\n"
"values returned by another. Here we see that there are four frames on\n"
"the stack."
msgstr ""
"Стек вызовов состоит из последовательности кадров стека(@dfn{frames}), "
"причем\n"
"каждый кадр описывает одну процедуру, которая ждет, чтобы чтото сделать со\n"
"значениями, возвращаемыми другой процедурой. Здесь мы видим, что в стеке\n"
"четыре кадра."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:575
msgid ""
"Note that @code{macroexpand} is not on the stack -- it must have made a\n"
"tail call to @code{chi-top}, as indeed we would find if we searched\n"
"@code{ice-9/psyntax.scm} for its definition."
msgstr ""
"Обратите внимание, что @code{macroexpand} нет в стеке --- в действительности "
"он\n"
"выполняет хвостовой вызов @code{chi-top}, это можно найти в его определении "
"в\n"
"@code{ice-9/psyntax.scm}."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:583
msgid ""
"When you enter the debugger, the innermost frame is selected, which\n"
"means that the commands for getting information about the ``current''\n"
"frame, or for evaluating expressions in the context of the current\n"
"frame, will do so by default with respect to the innermost frame.  To\n"
"select a different frame, so that these operations will apply to it\n"
"instead, use the @code{up}, @code{down} and @code{frame} commands like\n"
"this:"
msgstr ""
"Когда вы входите в отладчик, выбирается самый внутренний кадр, что "
"означает,\n"
"что команды для  получения информации о текущем кадре (``current''\n"
"frame), или для  вычисления выражений в контексте текущего кадра, будут\n"
"делать это по умолчанию относительно самого внутреннего кадра.  Чтобы\n"
"выбрать другой кадр и применить к нему эти операции, используйте команды:\n"
"@code{up}, @code{down} и @code{frame} вот так:"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:595
msgid ""
"@lisp\n"
"scheme@@(guile-user) [1]> ,up\n"
"In ice-9/psyntax.scm:\n"
"  1368:28  1 (chi-macro #<procedure de9360 at ice-9/psyntax.scm...> ...)\n"
"scheme@@(guile-user) [1]> ,frame 3\n"
"In ice-9/psyntax.scm:\n"
"  1130:21  3 (chi-top (unquote foo) () ((top)) e (eval) (hygiene #))\n"
"scheme@@(guile-user) [1]> ,down\n"
"In ice-9/psyntax.scm:\n"
"  1071:30  2 (syntax-type (unquote foo) () ((top)) #f #f (# #) #f)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:598
msgid ""
"Perhaps we're interested in what's going on in frame 2, so we take a\n"
"look at its local variables:"
msgstr ""
"Возможно, нам интересно, что происходит во втором кадре, поэтому мы "
"посмотрим\n"
"его локальные переменные:"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:617
msgid ""
"@lisp\n"
"scheme@@(guile-user) [1]> ,locals\n"
"  Local variables:\n"
"  $1 = e = (unquote foo)\n"
"  $2 = r = ()\n"
"  $3 = w = ((top))\n"
"  $4 = s = #f\n"
"  $5 = rib = #f\n"
"  $6 = mod = (hygiene guile-user)\n"
"  $7 = for-car? = #f\n"
"  $8 = first = unquote\n"
"  $9 = ftype = macro\n"
"  $10 = fval = #<procedure de9360 at ice-9/psyntax.scm:2817:2 (x)>\n"
"  $11 = fe = unquote\n"
"  $12 = fw = ((top))\n"
"  $13 = fs = #f\n"
"  $14 = fmod = (hygiene guile-user)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:620
msgid ""
"All of the values are accessible by their value-history names\n"
"(@code{$@var{n}}):"
msgstr ""
"Все значения доступны по именам истории значений\n"
"(@code{$@var{n}}):"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:625
msgid ""
"@lisp\n"
"scheme@@(guile-user) [1]> $10\n"
"$15 = #<procedure de9360 at ice-9/psyntax.scm:2817:2 (x)>\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:627
msgid "We can even invoke the procedure at the REPL directly:"
msgstr "Мы даже можем напрямую вызвать процедуру в REPL:"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:634
msgid ""
"@lisp\n"
"scheme@@(guile-user) [1]> ($10 'not-going-to-work)\n"
"ERROR: In procedure macroexpand:\n"
"ERROR: source expression failed to match any pattern in not-going-to-work\n"
"Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:637
msgid ""
"Well at this point we've caused an error within an error. Let's just\n"
"quit back to the top level:"
msgstr ""
"И в этой точке, мы вызвали ошибку внутри ошибки. Давайте просто вернемся на\n"
"верхний уровень(к стеку первой ошибки):"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:643
msgid ""
"@lisp\n"
"scheme@@(guile-user) [2]> ,q\n"
"scheme@@(guile-user) [1]> ,q\n"
"scheme@@(guile-user)> \n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:646
msgid ""
"Finally, as a word to the wise: hackers close their REPL prompts with\n"
"@kbd{C-d}."
msgstr ""
"Наконец: как совет для мудрых, хакеры закрывают свои приглашения REPL с "
"помощью\n"
"@kbd{C-d}."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:650
msgid ""
"@node Using Guile in Emacs\n"
"@section Using Guile in Emacs"
msgstr ""
"@node Using Guile in Emacs\n"
"@section Использование Guile в Emacs"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:659
msgid ""
"@cindex Emacs\n"
"Any text editor can edit Scheme, but some are better than others.  Emacs\n"
"is the best, of course, and not just because it is a fine text editor.\n"
"Emacs has good support for Scheme out of the box, with sensible\n"
"indentation rules, parenthesis-matching, syntax highlighting, and even a\n"
"set of keybindings for structural editing, allowing navigation,\n"
"cut-and-paste, and transposition operations that work on balanced\n"
"S-expressions."
msgstr ""
"@cindex Emacs\n"
"Любой текстовый редактор может редактировать код Scheme, но некоторые\n"
"лучше чем другие.  Emacs -- конечно лучший, и не только потому, что это\n"
"хороший текстовый редактор. Emacs хорошо поддерживает Scheme сразу после\n"
"установки, с разумными правилами отступов, сопоставлением скобок, "
"подсветкой\n"
"синтаксиса, и даже набором сочетаний горячих клавишь для структурного \n"
"редактирования, позволяющего осуществлять навигацию, вырезать и вставлять,\n"
"и выполнять операции транспонирования, которые работают на сбалансированных\n"
"S-выражениях."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:662
msgid ""
"As good as it is, though, two things will vastly improve your experience\n"
"with Emacs and Guile."
msgstr ""
"Как бы то нибыло, две вещи значительно улучшат ваш опыт работы с\n"
"Emacs и Guile."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:669
msgid ""
"@cindex Paredit\n"
"The first is Taylor Campbell's\n"
"@uref{http://www.emacswiki.org/emacs/ParEdit, Paredit}.  You should not\n"
"code in any dialect of Lisp without Paredit.  (They say that\n"
"unopinionated writing is boring---hence this tone---but it's the\n"
"truth, regardless.)  Paredit is the bee's knees."
msgstr ""
"@cindex Paredit\n"
"Первой является  @uref{http://www.emacswiki.org/emacs/ParEdit, Paredit}\n"
"от Taylor Campbell-а.  Вы не должны кодировать на любом диалекте Lisp\n"
"без Paredit.  (Они говорят, что неуверенно, писать скучно, отсюда этот тон,\n"
"но не зависимо от этого)  Paredit это пчела в колене.(фигня какая то, "
"непереводимая\n"
"игра английских слов)"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:682
msgid ""
"@cindex Geiser\n"
"The second is\n"
"@iftex\n"
"Jos@'e\n"
"@end iftex\n"
"@ifnottex\n"
"José\n"
"@end ifnottex\n"
"Antonio Ortega Ruiz's\n"
"@uref{http://www.nongnu.org/geiser/, Geiser}.  Geiser complements Emacs'\n"
"@code{scheme-mode} with tight integration to running Guile processes via\n"
"a @code{comint-mode} REPL buffer."
msgstr ""
"@cindex Geiser\n"
"Второй это\n"
"@iftex\n"
"Jos@'e\n"
"@end iftex\n"
"@ifnottex\n"
"José\n"
"@end ifnottex\n"
"Antonio Ortega Ruiz's\n"
"@uref{http://www.nongnu.org/geiser/, Geiser}.  Geiser дополняет режимы  "
"Emacs'\n"
"@code{scheme-mode} тесной интеграцией с запущенным Guile процессом через\n"
"a @code{comint-mode} буфер REPL."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:685
msgid ""
"Of course there are keybindings to switch to the REPL, and a good REPL\n"
"environment, but Geiser goes beyond that, providing:"
msgstr ""
"Конечно, есть комбинации горячих клавиш для переключения в REPL, и среда\n"
"REPL хороша, но Geiser выходит за рамки этого, обеспечивая:"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:713
msgid ""
"@itemize @bullet\n"
"@item\n"
"Form evaluation in the context of the current file's module.\n"
"@item\n"
"Macro expansion.\n"
"@item\n"
"File/module loading and/or compilation.\n"
"@item\n"
"Namespace-aware identifier completion (including local bindings, names\n"
"visible in the current module, and module names).\n"
"@item\n"
"Autodoc: the echo area shows information about the signature of the\n"
"procedure/macro around point automatically.\n"
"@item\n"
"Jump to definition of identifier at point.\n"
"@item\n"
"Access to documentation (including docstrings when the implementation\n"
"provides it).\n"
"@item\n"
"Listings of identifiers exported by a given module.\n"
"@item\n"
"Listings of callers/callees of procedures.\n"
"@item\n"
"Rudimentary support for debugging and error navigation.\n"
"@item\n"
"Support for multiple, simultaneous REPLs.\n"
"@end itemize"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"Вычисление формы в контексте модуля текущего файла.\n"
"@item\n"
"Макрорасширение.\n"
"@item\n"
"Загрузку файла/модуля и/или его компиляцию.\n"
"@item\n"
"Завершение идентификатора с учетом пространства имен(включая локальные\n"
"привязки, имена, видимые в текущем модуле и имена модулей)\n"
"@item\n"
"Autodoc: область эха показывает информацию о сигнатуре процедуры/макроса "
"вокруг\n"
"текущей точки - автоматически.\n"
"@item\n"
"Переход к определению текущего идентификатора.\n"
"@item\n"
"Доступ к документации (включая docstrings когда их обеспечивает "
"реализация).\n"
"@item\n"
"Списки идентификаторов, экспортируемых данным модулем.\n"
"@item\n"
"Список вызывающих/вызываемых процедур.\n"
"@item\n"
"Зачаточную поддержку для отладки и отслеживания ошибки.\n"
"@item\n"
"Одновременную поддержку нескольких REPL.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:716
msgid ""
"See Geiser's web page at @uref{http://www.nongnu.org/geiser/}, for more\n"
"information."
msgstr ""
"См веб страницу Geiser @uref{http://www.nongnu.org/geiser/}, для получения\n"
"подробной информации."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:720
msgid ""
"@node Using Guile Tools\n"
"@section Using Guile Tools"
msgstr ""
"@node Using Guile Tools\n"
"@section Использование Инструментов Guile"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:728
msgid ""
"@cindex guild\n"
"@cindex guile-tools\n"
"@cindex wizards\n"
"Guile also comes with a growing number of command-line utilities: a\n"
"compiler, a disassembler, some module inspectors, and in the future, a\n"
"system to install Guile packages from the internet.  These tools may be\n"
"invoked using the @code{guild} program."
msgstr ""
"@cindex guild\n"
"@cindex guile-tools\n"
"@cindex wizards\n"
"Guile также поставляется с растущим числом утилит командной строки: "
"компилятор,\n"
"дизассемблер, некоторые модули инспекторы, и в будущем, система для "
"установки\n"
"пакетов Guile из интернета.  Эти инструменты могут быть вызваны с помощью\n"
"программы the @code{guild}."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:733
msgid ""
"@example\n"
"$ guild compile -o foo.go foo.scm\n"
"wrote `foo.go'\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:741
msgid ""
"This program used to be called @code{guile-tools} up to\n"
"Guile version 2.0.1, and for backward\n"
"compatibility it still may be called as such.  However we changed the\n"
"name to @code{guild}, not only because it is pleasantly shorter and\n"
"easier to read, but also because this tool will serve to bind Guile\n"
"wizards together, by allowing hackers to share code with each other\n"
"using a CPAN-like system."
msgstr ""
"Эта программа раньше называлась @code{guile-tools} вплоть до версии\n"
"Guile 2.0.1, и для обратной совместимости ее еще можно назвать таковой.\n"
"Однако мы изменили название на @code{guild}, не только потому что оно\n"
"приятно короче и легче читается, но и потому, что этот инструмент будет\n"
"служить чтобы связать мастеров Guile вместе, позволяя хакерам обмениваться\n"
"кодом друг с другом, используя CPAN-подобную систему."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:743
msgid "@xref{Compilation}, for more on @code{guild compile}."
msgstr ""
"@xref{Compilation}, для получения дополнительной информации о @code{guild "
"compile}."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:746
msgid ""
"A complete list of guild scripts can be had by invoking @code{guild\n"
"list}, or simply @code{guild}."
msgstr ""
"Полный список guild скриптов можно получить, вызвав @code{guild list}, \n"
"или просто @code{guild}."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:750
msgid ""
"@node Installing Site Packages\n"
"@section Installing Site Packages"
msgstr ""
"@node Installing Site Packages\n"
"@section Установка  Местных(Site) Пакетов"

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:756
msgid ""
"@cindex site\n"
"@cindex site path\n"
"@cindex load path\n"
"@findex %site-dir\n"
"@findex %site-ccache-dir"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:761
msgid ""
"At some point, you will probably want to share your code with other\n"
"people.  To do so effectively, it is important to follow a set of common\n"
"conventions, to make it easy for the user to install and use your\n"
"package."
msgstr ""
"В какой-то, момент вы возможно, захотите поделиться своим кодом с другими "
"людьми.\n"
"Чтобы это сделать, важно следовать ряду общих соглашений, чтобы облегчить\n"
"пользователям процесс установки и использования вашего пакета."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:768
msgid ""
"The first thing to do is to install your Scheme files where Guile can\n"
"find them.  When Guile goes to find a Scheme file, it will search a\n"
"@dfn{load path} to find the file: first in Guile's own path, then in\n"
"paths for @dfn{site packages}.  A site package is any Scheme code that\n"
"is installed and not part of Guile itself.  @xref{Load Paths}, for more\n"
"on load paths."
msgstr ""
"Первое, что нужно сделать, это установить файлы Scheme, туда где Guile \n"
"сможет их найти.  Когда Guile отправляется на поиск файлов Scheme, он ищет\n"
"используя путь загрузки(@dfn{load path}) для поиска файла: сначала по\n"
"собственному Guile пути, затем в пути для местных пакетов(@dfn{site "
"packages}).\n"
"Местный пакет это любой код Scheme, который установлен, и не является "
"частью\n"
"самого Guile.  @xref{Load Paths}, для получения дополнительной информации о\n"
"путях загрузки."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:776
msgid ""
"There are several site paths, for historical reasons, but the one that\n"
"should generally be used can be obtained by invoking the\n"
"@code{%site-dir} procedure.  @xref{Build Config}.  If Guile\n"
"@value{EFFECTIVE-VERSION} is installed on your system in @code{/usr/},\n"
"then @code{(%site-dir)} will be\n"
"@code{/usr/share/guile/site/@value{EFFECTIVE-VERSION}}.  Scheme files\n"
"should be installed there."
msgstr ""
"Есть несколько местных путей(site paths), по историческим причинам, но тот "
"который\n"
"обычно должен быть использован можно получить вызвав процедуру\n"
"@code{%site-dir}.  @xref{Build Config}.  Если Guile\n"
"@value{EFFECTIVE-VERSION} установлен в вашей системе в @code{/usr/},\n"
"то @code{(%site-dir)} будет\n"
"@code{/usr/share/guile/site/@value{EFFECTIVE-VERSION}}.  Файлы Scheme "
"должны\n"
"быть установлены там."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:783
msgid ""
"If you do not install compiled @code{.go} files, Guile will compile your\n"
"modules and programs when they are first used, and cache them in the\n"
"user's home directory.  @xref{Compilation}, for more on\n"
"auto-compilation.  However, it is better to compile the files before\n"
"they are installed, and to just copy the files to a place that Guile can\n"
"find them."
msgstr ""
"Если вы не установили скомпилированные @code{.go} файллы, Guile "
"скомпилирует\n"
"ваши модули и программы когда они будут впервые использованы, и кеширует их "
"в\n"
"домашнем каталоге пользователя. @xref{Compilation}, для получения "
"дополнительной\n"
"информации о авто-компиляции.  Тем не менее, лучше скомпилировать файлы до "
"их установки,\n"
"и просто скопировать файлы в то место, где Guile сможет их найти."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:793
msgid ""
"As with Scheme files, Guile searches a path to find compiled @code{.go}\n"
"files, the @code{%load-compiled-path}.  By default, this path has two\n"
"entries: a path for Guile's files, and a path for site packages.  You\n"
"should install your @code{.go} files into the latter directory, whose\n"
"value is returned by invoking the @code{%site-ccache-dir} procedure.  As\n"
"in the previous example, if Guile @value{EFFECTIVE-VERSION} is installed\n"
"on your system in @code{/usr/}, then @code{(%site-ccache-dir)} site\n"
"packages will be\n"
"@code{/usr/lib/guile/@value{EFFECTIVE-VERSION}/site-ccache}."
msgstr ""
"Как и в случае с файлами Scheme, Guile ищет путь для поиска "
"скомпилированных\n"
"файлов @code{.go} используя путь @code{%load-compiled-path}.  По умолчанию "
"этот\n"
"путь содержит две записи: путь для Guile файлов и путь для местных(site) "
"пакетов.\n"
"Вы должны установить ваши файлы @code{.go} в последний каталог, значение "
"которого\n"
"возвращается путем вызова процедуры @code{%site-ccache-dir}.  Как и в "
"предыдущем\n"
"примере, если Guile @value{EFFECTIVE-VERSION} установлен в вашей системе в "
"каталог\n"
"@code{/usr/}, тогда @code{(%site-ccache-dir)} содержащая путь к местным "
"пакетам\n"
"будет @code{/usr/lib/guile/@value{EFFECTIVE-VERSION}/site-ccache}."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:798
msgid ""
"Note that a @code{.go} file will only be loaded in preference to a\n"
"@code{.scm} file if it is newer.  For that reason, you should install\n"
"your Scheme files first, and your compiled files second.  @xref{Load\n"
"Paths}, for more on the loading process."
msgstr ""
"Обратите внимание, что файл @code{.go} будет загружен только вместо файла\n"
"@code{.scm} если тот не новее.  По этой причине, вы должны сначала "
"установить файлы\n"
"Scheme, а потом ваши скомпилированные файлы.  @xref{Load\n"
"Paths}, для получения дополнительной информации о процессе загрузки."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:805
msgid ""
"Finally, although this section is only about Scheme, sometimes you need\n"
"to install C extensions too.  Shared libraries should be installed in\n"
"the @dfn{extensions dir}.  This value can be had from the build config\n"
"(@pxref{Build Config}).  Again, if Guile @value{EFFECTIVE-VERSION} is\n"
"installed on your system in @code{/usr/}, then the extensions dir will\n"
"be @code{/usr/lib/guile/@value{EFFECTIVE-VERSION}/extensions}."
msgstr ""
"Наконец, хотя этот раздел посвящен только Scheme, иногда вам необходимо "
"устанавливать\n"
"и расширения Си.  Разделяемые(общие) библиотеки должны быть установлены в "
"директории\n"
"@dfn{extensions dir}.  Это значение можно узнать из конфигурации сборки.\n"
"(@pxref{Build Config}).  Опять же, если Guile @value{EFFECTIVE-VERSION} "
"установлен\n"
"в вашей системе в @code{/usr/}, тогда директория для расширений будет\n"
"@code{/usr/lib/guile/@value{EFFECTIVE-VERSION}/extensions}."

#: /home/bear/work/guile/doc/guile/en/scheme-using.texi:809
msgid ""
"@c Local Variables:\n"
"@c TeX-master: \"guile.texi\"\n"
"@c End:"
msgstr ""
