@c -*-texinfo-*-
@c This is part of the GNU Guile Reference Manual.
@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2012
@c   Free Software Foundation, Inc.
@c See the file guile.texi for copying conditions.

@node Hello Scheme!
@chapter Hello Scheme!

В этой главе мы введем основные понятия, лежащие в основе элегантности
и силы языка Scheme.

Читатели, которые уже владеют базовым знанием Scheme, могут с радостью
поропустить данную главу. Однако для читателей, которые являются новичками
в этом языке, следующие обсуждения по данным, процедурам, выражениям и
замыканиям, предназначенны для обеспечения минимального уровня понимания
Scheme, которое более или менее подразумевается в последующих главах.

Стиль этого вводного материала стоит на полпути между точностью R5RS и
дискурсивностью существующих обучающих программ Scheme.  Мы укажем
на полезные ресурсы по Scheme в интернете, см @ref{Further Reading}.


@menu
* About Data::                  Latent typing, types, values and variables.
* About Procedures::            The representation and use of procedures.
* About Expressions::           All kinds of expressions and their meaning.
* About Closure::               Closure, scoping and environments.
* Further Reading::             Where to find out more about Scheme.
@end menu

@node About Data
@section Типы данных, Значения и Переменные

В этом разделе обсуждается представление типо данных и значений, что означает
для Scheme быть скрыто-типизированным языком, и роль переменных. В заключении
Мы заключим введение в синтаксис Scheme определением новых переменных и 
изменением значений существующей переменной.

@menu
* Latent Typing::               Scheme as a "latently typed" language.
* Values and Variables::        About data types, values and variables.
* Definition::                  Defining variables and setting their values.
@end menu

@node Latent Typing
@subsection Скрытая типизация

Термин @dfn{скрытая типизация} используется для описания компьютерного языка,
такого как Scheme, дл которого вы не можете, в общем случаее, просто взглянув
на исходный код программы, определить, какой тип данных будет связан с 
конкретной переменной или с результатом конкретного выражения.

Иногда, конечно, вы @emph{можете} указать из кода, какой тип будет у
выражения. Если у  вас есть строка программы, в которой устанавливается
значение переменной @code{x} в числовое значение равное 1, вы можете быть
уверенными, что сразу после выполнения этой строки(при отсутствии
многопоточности), @code{x} примет числовое значение 1.  Или если вы пишите
процедуру, которая разработана чтобы объединить две строки, вполне вероятно,
что остальная часть вашего приложения будет всегда ссылаться на эту процедуру
с двумя строковыми параметрами, и вполне вероятно что эта процедура будет
работать не правильно, если ее вызывать с параметрами, которые не являются
одновременно оба строками.

Тем не менее, дело в том, что в Scheme нет ниего, что регулирует
тип параметров процедур, что может потребовать, чтобы параметры
процедуры были строками, или чтобы  @code{x} всегда содержало числовое
значение, и нет способа объявить в вашей программе, что такие ограничения
всегда должны выполняться. В тоже время, нет способа объявить ожидаемый
тип возращаемого процедурой значения.

Вместо этого типы переменных и выражений известны --- в общем --- только
во время выполнения. Если вам нужно в какой-то момент проверить, что
значение имеет ожидаемый тип, Scheme предоставляет процедуру времени 
выполнения, которую вы можете использовать для этого. Но в равной степени,
это может быть справедливо для двух отдельных вызовов той же процедуры для
указания аргументов с разными типами и для возврата значений разных
типов.

В следующем подразделе объясняется, что это означает на практике, 
способы для программ Scheme использовать типы данных, значения и
переменные.

@node Values and Variables
@subsection Значения и Переменные

Scheme предоставляет множество типов данных, которые можно использовать
для представления ваших данных. Примитивные типы, включают символы,
строки, числа и процедуры. Составные типы, которые позволяют сгруппировать
примитивные типы и составные значения, включают в себя списки, пары, векторы
и многомерные массивы. Кроме того, Guile позволяет приложениям определять
свои собственные типы данных, имеющие тот же статус, что и встроенные
стандартные типы Scheme.

По мере запуска Scheme программ, значения всех типов появляются и исчезают.
Иногда значения хранятся в переменных, но чаще они легко передаются как 
результат из одного вычисления, в качестве одного из параметров, для
следующего.

Рассмотрим пример. Строковое значение создается, потому что интерпретатор
читает литералы строк из исходного кода вашей программы. Затем в результате
создается числовое значение вычисления длины строки. Второее числовое
значение создается путем удвоения рассчитанной длины. Наконец, программа
создает список с двумя элементами - удвоенной длиной и самой исходной
строкой - и сохраняет этот список в программной переменной.

Все используемые здесь значения --- фактически, все значения в
Scheme -- имеют свой тип. Другими словами, каждое значение
``знает,'' во время выполнения, какое значение оно имеет.  
Число, строка, список или что угодно.

С другой стороны, переменная не имеет фиксированного типа. Переменная
@code{x}, скажем -- это просто имя местоположения -- поле, в котором
вы можете сохранить любое значение Scheme. Та же самая переменная в 
программе может содержать число в один момент, скисок процедур в 
следующий момент, а затем пару строк. ``Тип'' переменной --- насколько
эта идея имеет смысл --- это просто тип любого значения, которое хранит
переменная в определенный момент времени.

@node Definition
@subsection Определение и Установка Переменных

Чтобы определить новую переменную, используйте синтаксис @code{define} 
Scheme следующим образом:

@lisp
(define @var{variable-name} @var{value})
@end lisp

Оно создает новую переменную с именем @var{variable-name} и сохраняет
в ней значение @var{value} --- начальное значение переменной. Например:

@lisp
;; Make a variable `x' with initial numeric value 1.
(define x 1)

;; Make a variable `organization' with an initial string value.
(define organization "Free Software Foundation")
@end lisp

(В Scheme, точка с запятой означает начало коментария, который продолжается
до конца линии. Так начинающиеся строки с  @code{;;} являются коментариями.)

Изменение значения уже существующей переменной очень похоже,
за исключением того что синтаксис @code{define} заменяется
в Scheme синтаксисом @code{set!}, вот так:

@lisp
(set! @var{variable-name} @var{new-value})
@end lisp

Помните, что переменные не имеют фиксиксированных типов, поэтому новое
значение @var{new-value} может иметь полностью другой тип, чем тот который был ранее
сохранен в переменной названной @var{variable-name}. Поэтому оба следующих примера
являются правильными.

@lisp
;; Change the value of `x' to 5.
(set! x 5)

;; Change the value of `organization' to the FSF's street number.
(set! organization 545)
@end lisp

В этих примерах, @var{value} и @var{new-value} являются буквально числовыми
и строковыми значениями. В целом, однако, @var{value} и @var{new-value}
могут быть любыми выражениями Scheme.  Хотя мы еще не рассматривали формы,
которые могут принимать выражения Scheme (@pxref{About Expressions}), вы
вероятно, можете догадаться, что делает следующий  @code{set!} например
does@dots{}

@lisp
(set! x (+ x 1))
@end lisp

(Примечание: это не полное описание @code{define} и @code{set!},
потому что нам нужно ввести некоторые другие аспекты Scheme
до того, как недостающие части могут быть заполнены. Если, однако
вы уже знакомы со структурой Scheme, вам может понравиться читать
эти недостающие части сразу, перескакивая вперед по следующим ссылкам.

@itemize @bullet
@item
@ref{Lambda Alternatives}, что бы прочитать об альтернативной форме
синтаксиса @code{define}, который можно использовать при определении
новых процедур.

@item
@ref{Procedures with Setters}, чтобы прочитать об альтернативной форме
сиснтаксиса @code{set!}, который помогает с изменением единственного значения
в глубине составной структуры данных.)

@item
@xref{Internal Definitions}, чтобы прочитать об использовании @code{define}
другого чем на высшем уровне программы Scheme, включая обсуждение того, как
оно работает, чтобы использовать @code{define} а не @code{set!} для изменения
значения существующей переменной.
@end itemize

@node About Procedures
@section Представление и Использование Процедур

В этом разделе описываются основы использования и создания процедур Scheme.
В нем обсуждается предоставление процедур как еще один вид значения Scheme,
и показывает, как строиться вызов процедур. Затем мы объясняем, как
@code{лямбда(lambda)} используется для создания новых процедур и в заключении
представляем различные сокращенные формы @code{define}, которые можно 
использовать, вместо того, чтобы писать явное @code{lambda} выражение.

@menu
* Procedures as Values::        Procedures are values like everything else.
* Simple Invocation::           How to write a simple procedure invocation.
* Creating a Procedure::        How to create your own procedures.
* Lambda Alternatives::         Other ways of writing procedure definitions.
@end menu

@node Procedures as Values
@subsection Процедуры как Значения

Одно из великих упрощений Scheme заключается в том, что процедура ---
это еще один тип значения,  и эти значения---процедуры могут быть
переданы и сохранены в переменных точно также как, например строики и
списки. Когда мы говорим о встроенной стандартной процедуре Scheme,
такой как @code{open-input-file}, на самом деле мы имеем в виду, что
существует предопределенная переменная верхнего уровня, называемая
@code{open-input-file}, значением которой является процедура, которая
реализует то что говорит  R5RS о том что должна делать функция
@code{open-input-file}.

Обратите внимание, что это сильно отличается от многих диалектов Lisp ---
включая Emacs Lisp --- в котором программа может использовать одно и тоже
имя с двумя совершенно отдельными значениями: одно значение идентифицирует
функцию Lisp, другое значение идентифицирует переменную Lisp, значение 
которой не имеет ничего общего с с функцией, которая связана с первой
переменной. В этих диалектах, функции и переменные, как гворят, живут
в разных пространствах имен(@dfn{namespaces}).

С другой стороны, в Scheme, все имена принадлежат единому пространству
имен, а переменные которые идентифицируют эти имена, могут содержать
любое значение Scheme, включая процедурные значения.

Одним из последствий идеи ``процедуры как значения'' является то, что
если вам не нравиться стандартное имя процедуры Scheme, вы можете 
изменить его.

Например, @code{call-with-current-continuation} является очень важной
стандартной процедурой Scheme, но она также имеет очень длинное имя!
Таким образом, многие программисты используют следующий прием, назначить
значение процедуры переменной с более удобным именем, например 
@code{call/cc}.

@lisp
(define call/cc call-with-current-continuation)
@end lisp

Понятно, как это работает. Определение создает новую перменную @code{call/cc},
и затем устанавливает ее значение в значение переменной 
@code{call-with-current-continuation}; значение последней --- это процедура, 
которая реализует поведение, которое R5RS определеяет в соответствии с
именем ``call-with-current-continuation''.  Таким образом @code{call/cc} 
сохраняет это значение.

Теперь, когда @code{call/cc} содержит требуемое значение процедуры, вы
можете использовать переменную с именем @code{call-with-current-continuation} 
для совершенно другой цели или просто изменить ее значение, чтобы вы
получили сообщение об ошибке, если вы случайно используете 
@code{call-with-current-continuation} как процедуру в вашей программе, не
вызов @code{call/cc}.  Например:

@lisp
(set! call-with-current-continuation "Not a procedure any more!")
@end lisp

Или вы могли бы просто оставить @code{call-with-current-continuation} как было.
Это прекрасно для более чем одной переменной удерживать одно и тоже значение
процедуры.

@node Simple Invocation
@subsection Простой Вызов Процедур

Вызов процедур в Scheme записывается следующим образом:

@lisp
(@var{procedure} [@var{arg1} [@var{arg2} @dots{}]])
@end lisp

В этом выражении, @var{procedure} может быть любым выражением Scheme, значение
которого является процедурой.  Чаще всего, однако, процедура --- это просто имя
переменной, значением которой является процедура.

Например, @code{string-append} --- это стандартная процедура  Scheme,
задача которой объединить все аргументы, которые, как ожидается, будут
строками, в единую строку. Таким образом, выражение

@lisp
(string-append "/home" "/" "andrew")
@end lisp

@noindent
является вызовом процедуры, результатом действия которой будет строковое значение
@code{"/home/andrew"}.

Аналогично, @code{string-length} является стандартной процедурой Scheme которая 
возвращает длину передаваемого ей аргумента-строки, поэтому

@lisp
(string-length "abc")
@end lisp

@noindent
является вызовом процедуры, результатом которого является числовое
значение 3.

Каждый из параметров в вызове процедуры может быть любым выражением
Scheme. Поскольку вызов процедуры сам по себе является выражением,
мы можем свести эти два примера вместе, получив:

@lisp
(string-length (string-append "/home" "/" "andrew"))
@end lisp

@noindent
--- вызов процедуры, результатом которого является числовое значение 12.

(Вам может быть интересно, что произойдет, если два примера будут объединены
другим способом. Если мы это сделаем так, мы создадим синтаксически верное
выражение вызова:

@lisp
(string-append "/home" (string-length "abc"))
@end lisp

@noindent
но когда это выражение выполниться, оно вызовет ошибку, так как результат
@code{(string-length "abc")} это числовое значение, а @code{string-append}
не предназанчена для приема числовых значений как одного из типов 
аргументов.)

@node Creating a Procedure
@subsection Создание и использование новых Процедур

Scheme имеет множество стандартных процедур, и Guile предоставляет все
эти возможности с помощью предопределений переменных верхнего уровняp.
Все эти стандартные процедуры описаны в следующих главах этого
справочного руководства.

Однако, очень скоро, вы захотите создать новые процедуры, которые
инкапсулируют функциональные аспекты ваших собственных приложений.
Для этого вы можете испльзовать знаменитый синтаксис - лямбда
@code{lambda}.

Например, значением следующего выражения Scheme

@lisp
(lambda (name address) @var{expression} @dots{})
@end lisp

@noindent
является новой процедурой, которая принимает два аргумента
@code{name} и @code{address}.  Поведение новой процедуры определяется
последовательностью выражений@var{expression} в теле определения 
процедуры. (Как правило, эти выражения @var{expression} каким-то 
образом используют аргументы, иначе не было бы смысла передавать их
в процедуру)  При вызове новая процедура возвращает значение, которое
является значением последнего выражения в теле процедуры.

Чтобы сделать пример более конкретным, давайте предположим, что оба
аргумента -- это две строки, и что целью этой процедуры является
формирование объединенной строки, которая включает в себя эти
аргументы. Тогда полное лямбда выражение может выглядеть так:

@lisp
(lambda (name address)
  (string-append "Name=" name ":Address=" address))
@end lisp

В предыдущем разделе мы отметили, что процедурой при вызове процедуры
может быть любое выражени Scheme возвращающее значение типа процедуры.
Но это точно то, что возвращает лямбда выражение! Таким образом, мы
можем использовать лямбда-выражение непосредственно в месте вызова
процедуры, например:

@lisp
((lambda (name address)
   (string-append "Name=" name ":Address=" address))
 "FSF"
 "Cambridge") 
@end lisp

@noindent
Это допустимое выражение вызова процедуры и его резальтатом является строка:

@lisp
"Name=FSF:Address=Cambridge"
@end lisp

Однако более частым является сохранение значения процедуры в переменной ---

@lisp
(define make-combined-string
  (lambda (name address)
    (string-append "Name=" name ":Address=" address)))
@end lisp

@noindent
--- и затем использование имени переменной в вызове процедуры:

@lisp
(make-combined-string "FSF" "Cambridge") 
@end lisp

@noindent
Что имеет точно такой же результат.

Важно отметить, что процедуры, созданные с использванием @code{lambda}, имеют
точно такой же статус как и стандартные встроенные процедуры Scheme и могут
быть вызваны, переданы и сохранены в переменные точно так же.

@node Lambda Alternatives
@subsection Альтернативы лямбда(lambda)

Поскольку в программах Scheme так часто возникает необходимость
создать процедуру, а затем сохранить ее в переменной есть альтернативная
форма синтаксиса @code{define}, которая позволяет вам это сделать.

Форма выражения @code{define}

@lisp
(define (@var{name} [@var{arg1} [@var{arg2} @dots{}]])
  @var{expression} @dots{})
@end lisp

@noindent
точно эквивалентна более длинной форме:

@lisp
(define @var{name}
  (lambda ([@var{arg1} [@var{arg2} @dots{}]])
    @var{expression} @dots{}))
@end lisp

Так, например, определение @code{make-combined-string} в предыдущем подразделе
может быть написано так:

@lisp
(define (make-combined-string name address)
  (string-append "Name=" name ":Address=" address))
@end lisp

Такое определение процедуры создает процедуру, котрая требует точно 
ожидаемого количества аргументов. Существуют еще две формы лямбда-
выражений, которые создают процедуры, которые могут принимать 
переменное количество аргументов:

@lisp
(lambda (@var{arg1} @dots{} . @var{args}) @var{expression} @dots{})

(lambda @var{args} @var{expression} @dots{})
@end lisp

@noindent
Соотвествующие формы альтернативного синтаксиса @code{define} определяют:

@lisp
(define (@var{name} @var{arg1} @dots{} . @var{args}) @var{expression} @dots{})

(define (@var{name} . @var{args}) @var{expression} @dots{})
@end lisp

@noindent
Подробнее о том, как работают эти формы, см. @xref{Lambda}.

Для Guile 2.0, Guile предоствляет расширение для определения синтксиса,
которое позволяет вам вставлять предыдущее расширение до произвольной
глубины. По умолчанию это расширение больше не предоставляется, и вместо
этого были перенесены в раздел: @ref{Curried Definitions}

(Можно утверждать, что альтернативные формы @code{define} довольно
запутывают, осоебнно для новичков в языке Scheme, поскольку они
скрывают как роль @code{lambda}, так и тот факт, что процедуры - это
значения, которые храняться в переменных так же, как и любой другой
тип данных. С другой стороны, они очень удобны,  они также являются
хорошим примером других мощных возможностей Scheme: возможность
определить произвольные синтаксические преобразования во время работы,
которые могут быть применены для последующего чтения ввода.

@node About Expressions
@section Выражения и Вычисления

До сих пор мы встречали выражения, которые выполняют такие вещи, как
выражения @code{define}, которые создают и инициализируют новые 
переменные, и мы также говорили о выражениях, которые имеют значение
@emph{values}, например значение выражения выозова процедуры:

@lisp
(string-append "/home" "/" "andrew")
@end lisp

@noindent
но мы еще не уточнили, что вызывает выражение, подобное вызову этой
процедуры, сокращающееся до значения ``value'' возвращаемого после
вызова процедуры, или как обработка таких выражений относится к 
выполнению программы Scheme в целом.

В этом разделе разъясняется, что мы подразумеваем под значением
выражения, вводя идею Вычисления@dfn{evaluation}.  В нем обсуждаются
побочные эффекты, которые могут быть при вычиселении, объясняется, 
как вычисляются каждое из различных выражений Scheme и описываются
поведение и использование Guile REPL как механизма изучения
вычислений. Раздел завершается очень кратким изложением общих
синтаксических выражений Scheme.

@menu
* Evaluating::                  How a Scheme program is executed.
* Tail Calls::                  Space-safe recursion.
* The REPL::                    Interacting with the Guile interpreter.
* Syntax Summary::              Common syntactic expressions -- in brief.
@end menu

@node Evaluating
@subsection Вычисление Выражений и Выполнение Программ

В Scheme, процесс выполнения выражения известен как Вычисление
(точный перевод Оценка)@dfn{evaluation}.  Вычисление имеет два
вида результата:

@itemize @bullet
@item
Значение@dfn{value} вычисленного выражения

@item
побочные эффекты@dfn{side effects} вычисления, которые состоят из любых
эффектов вычисления выражения которые не представлены значением.
@end itemize

Из выражений, которые мы встречали до сих пор, выражения @code{define} и
@code{set!} имеют сторонние эффекты --- создание или изменение переменной
--- не отражающиеся на значении выражения; выражение @code{lambda} имеет
значение --- новая построенная процедура --- но не имеет побочных эффектов;
процедура выражения вызова, как правило имеет либо значение, либо побочный
эффект, либо и то, и другое.

Заманчиво пытаться более интуитивно определить, что мы подразумеваем
под значением ``value'' и сторонним эффектом``side effects'', и какова
разница между ними. В целом, это чрезвычайно сложно. Это даже не нужно;
вместо этого мы с радостью можем определить поведение программы Scheme
указав, как Scheme выполняет программу в целом, а затем описать значения
и побочные эффекты вычилслений для каждого типа выражений индивидуально.

@noindent
Итак, некоторые@footnote{Это определение является приблизительным.
Полную и детальную информацию, см. @ref{Formal syntax and semantics,R5RS
syntax,,r5rs,The Revised(5) Report on the Algorithmic Language
Scheme}.} определения @dots{}

@itemize @bullet

@item
Программа Scheme состоит из последовательности выражений.

@item
Интерпретатор Scheme выполняет программу, вычисляя эти выражения по порядку
по одному.

@item
Выражение может быть

@itemize @bullet
@item
частью литеральных данных, таких как число @code{2.3} или строка
@code{"Hello world!"}
@item
именем переменной
@item
выражением вызова процедуры
@item
одним из специальных синтаксических выражений Scheme.
@end itemize
@end itemize

@noindent
В последующих разделах описывается, как вычисляется каждый из типов выражений.

@menu
* Eval Literal::                Evaluating literal data.
* Eval Variable::               Evaluating variable references.
* Eval Procedure::              Evaluating procedure invocation expressions.
* Eval Special::                Evaluating special syntactic expressions.
@end menu

@node Eval Literal
@subsubsection Вычисление Литеральных Данных

Когда вычисляется выражение состоящее из литеральных данных, значение выражения
представляет собой просто значение того, что описывает это выражение. Вычисление
литерального выражения данных не имеет побочных эффектов.

@noindent
Так, например, 

@itemize @bullet
@item
значение выражения @code{"abc"} представляет собой строковое значение
@code{"abc"}

@item
вычисление выражения @code{3+4i} является значением комплексноым числом 3 + 4i

@item
вычисление выражения @code{#(1 2 3)} представляет собой значение трехэлементный
вектор, содержащий числовые значения 1, 2 и 3.
@end itemize

Для любого типа данных, который может быть выражен литералами подобно
указанным выше, существует синтаксис записи выражений литеральных данных.
Другими словами, то что вам нужно записать в свой код для указания
литерального значения этого типа --- известно как синтаксис чтения
типа данных@dfn{read syntax}.  Это руководство указывает синтаксис
чтения для каждого такого типа данных в разделе, который описывает
эти типы данных.

Некоторые типы данных не имеют синтаксиса чтения. Процедуры, например,
не могут быть выражены литеральными данными; они должны быть созданы
с использованием выражения лямбда @code{lambda}(@pxref{Creating a Procedure}) 
или неявного использования короткой формы @code{define} (@pxref{Lambda Alternatives}).

@node Eval Variable
@subsubsection Вычисление ссылок на переменные

Когда вычисляется выражение, состоящее просто из имени переменной,
значение выражения представляет собой значение именованной
переменной. Вычисление выражения ссылки переменной не имеет
побочных эффектов.

Так, после

@lisp
(define key "Paul Evans")
@end lisp

@noindent
значение выражения @code{key} это строковое значение  @code{"Paul
Evans"}.  Если @var{key} изменить, с помощью:

@lisp
(set! key 3.74)
@end lisp

@noindent
значение выражения @code{key} будет числовым значением 3.74.

Если нет переменной с указанным именем, вычисление выражения ссылки
на переменную сообщит об ошибке.

@node Eval Procedure
@subsubsection Вычисление выражения Вызова Процедуры

Здесь начинаются интересные вычисления!  Как уже отмечалось, выражение 
вызова процедуры имеет вид:

@lisp
(@var{procedure} [@var{arg1} [@var{arg2} @dots{}]])
@end lisp

@noindent
где @var{procedure} должна быть выражением, значением которого, когда
производиться вычисление, является процедурой.

Вычисление выражения вызова процедуры продолжается дальше:

@itemize @bullet
@item
вычисляются индивидуально выражения @var{procedure}, @var{arg1},
@var{arg2}, и т.д.

@item
выполняется вызов процедуры, которая является значением вычисления
выражения @var{procedure} со списком значений полученных из вычисления
@var{arg1}, @var{arg2} и т.д. в качестве параметров.
@end itemize

Для процедуры, определенной в Scheme, ``вызов процедуры со списком значений
как ее параметров'' означает привязку значений к формальным параметрам
процедуры, а затем вычислением последовательности выражений составляющих
тело процедуры. Значение выражения вызова процедуры --- это значение
последнего вычисленного выражения в процедуре. Побочные эффекты вызова
процедуры -- это сочетание побочных эффектов последовательности вычислений
выражаний в теле процедуры.

Для встроенных процедур значение и побочные эффекты вызова процедуры
лучше всего описаны в документации по этой процедуре.

Обратите внимание, что побочные эффекты вычисления выражения вызова 
процедуры заключаются не только в побочных эффектах вызова процедуры,
но и в любых побочных эффектах предшествующих вычислению выражений 
@var{procedure}, @var{arg1}, @var{arg2}, и т.д.

Чтобы проилюстрировать это, давайте снова посмотрим на выражение
вызова процедуры:

@lisp
(string-length (string-append "/home" "/" "andrew"))
@end lisp

В самом внешнем выражении, @var{procedure}  @code{string-length} и аргументом
@var{arg1} равным @code{(string-append "/home" "/" "andrew")}.

@itemize @bullet
@item
Вычисление @code{string-length}, с переданной в процедуру переменной,
позволяет процедуре реализовать поведение для ``string-length''.

@item
Вычисление @code{(string-append "/home" "/" "andrew")}, которая
является вызовом другой процедуры, означает вычисление каждого:

@itemize @bullet
@item
@code{string-append}, выражение дает значение процедуры, которая реализует
поведение для ``string-append''

@item
@code{"/home"}, выражение которое дает строковое значение @code{"/home"}

@item
@code{"/"}, выражение дает строковое значение @code{"/"}

@item
@code{"andrew"}, выражение которое дает строковое значениe @code{"andrew"}
@end itemize

и затем вызвает значение procedure со списком строковых значений в качестве
своих аргументов.  Результирующее значение предстваляет собой однострочное
значение, которое является конкатенацией всех аргументов, а именно
@code{"/home/andrew"}.
@end itemize

При вычислении внешнего выражения интерпретатор теперь может вызвать
значение процедуры, полученное из  @var{procedure} со значением
полученным из @var{arg1} в качестве аргумента. Результирующее значение
представляет собой длину строки аргумента, которой является число 12.

@node Eval Special
@subsubsection Вычисление Специальных Синтаксических Выражений

Когда вычисляется выражение вызова процедуры, процедура и все аргументы
выражения должны быть вычислены до до вызова процедуры. Специальные
синтаксические выражения являются особенными, поскольку они могут
манипулировать своими аргументами в невычисленной форме и могут выбирать,
следует ли вычислять некоторые или все аргументы выражения.

Зачем это необходимо?  Рассмотрим фрагмент программы, который запрашивает
у пользователя, удаление файла; а затем удаляет его если пользователь
ответил да.

@lisp
(if (string=? (read-answer "Should I delete this file?")
              "yes")
    (delete-file file))
@end lisp

Если внешнее выражение @code{(if @dots{})} здесь бы было выражением
вызова процедуры, выражение @code{(delete-file file)}, чей побочный
эффект состоит в том, чтобы фактически удалить файл, было бы
вычислено до вычисления процедуры @code{if}!  Ясно, что это бесполезно
 --- целая позиция в выражении @code{if} называемая следствием(@dfn{consequent})
вычисляется только только тогда, когда условие выражения @code{if} является
истинным(``true'').

Поэтому @code{if} должен быть специальным синтаксисом, а не процедурой.
Другие специальные синтаксисы, с которыми мы уже встречались:
 @code{define}, @code{set!} и @code{lambda}.  @code{define} и @code{set!}
являются синтаксисами поскольку им надо знать имя@emph{name} переменной, 
которое задается в качестве первого аргумента в выражениях  @code{define}
или @code{set!}, а не значение этой переменной.  @code{lambda} это синтаксис,
потому что не сразу оценивает выражения, определяющие тело процедуры;
вместо этого он создает процедуру объект, которая включает эти выражения,
чтобы их можно было вычислить в будущем, когда будет вызвана эта процедура.

Правила вычисления каждого специального синтаксического выражения идивидуальны
для каждого специального синтаксиса. Для краткого описания стандартного
специального синтаксиса см. @xref{Syntax Summary}.

@node Tail Calls
@subsection Хвостовые вызовы
@cindex tail calls
@cindex recursion

Scheme  ``оптимизирует хвостовую рекурсию'', что означает, что 
хвостовые вызовы или рекурсии из определенных контекстов не потребляют
пространство стека или других ресурсов и поэтому могут использовать
произвольно большие данные или для произвольно больших вычислений.
Рассмотрим например,

@example
(define (foo n)
  (display n)
  (newline)
  (foo (1+ n)))

(foo 1)
@print{}
1
2
3
@dots{}
@end example

@code{foo} печатает числа бесконечно, начиная с данного @var{n}.
Она реализуется путем печати @var{n} затем рекурсивно вызывает себя
для печати @math{@var{n}+1} и т.д.  Эта рекурсия содержит хвостовой
вызов, и в Scheme подобные хвостовые вызовы могут быть сделаны
без ограничений.

Или рассмотрим случай когда возвращается значение, из SRFI-1 вариант 
функции @code{last} (@pxref{SRFI-1 Selectors}) возвращающей последний 
элемент списка,

@example
(define (my-last lst)
  (if (null? (cdr lst))
      (car lst)
      (my-last (cdr lst))))

(my-last '(1 2 3)) @result{} 3      
@end example

Если список содержит более одного элемента, @code{my-last} применяется
к  @code{cdr}.  Эта рекурсия является хвостовым вызовом, после него нет
кода, а возвращаемое значение является возвращаемым значением этого
вызова. В Scheme эту функцию можно использовать для аргумента с произвольно
длинным списком.

@sp 1
Правильный хвостовой вызов доступен только из определенных контекстов, 
а именно следующие специальные формы позиций,

@itemize @bullet
@item
@code{and} --- последнее выражение

@item
@code{begin} --- последнее выражение

@item
@code{case} --- последнее выражение в каждом пункте

@item
@code{cond} --- последнее выражение в каждом пункте, а вызов процедуры
@code{=>} это хвостовой вызов

@item
@code{do} --- последний результат выражения

@item
@code{if} --- ``истина(true)'' и ``ложь(false)'' выражения "ног"

@item
@code{lambda} --- последнее выражение в теле

@item
@code{let}, @code{let*}, @code{letrec}, @code{let-syntax},
@code{letrec-syntax} --- последнее выражение в теле

@item
@code{or} --- последнее выражение
@end itemize

@noindent
Следующие основные функции выполняют хвостовой вызов,

@itemize @bullet
@item
@code{apply} --- хвостовой вызов к данной процедуре

@item
@code{call-with-current-continuation} --- хвостовой вызов процедуры принимающей 
новое продолжение(continuation)

@item
@code{call-with-values} --- хвостовой вызов процедуры получающей
значения

@item
@code{eval} --- хвостовой вызов вычисления формы

@item
@code{string-any}, @code{string-every} --- хвостовой вызов предиката
на последнем символе( если эта точка достижима)
@end itemize

@sp 1
Выше приведенны основные функции и специальные формы.  Хвостовой вызов
в других модулях описан в соответствующей документации, например SRFI-1
@code{any} и @code{every} (@pxref{SRFI-1 Searching}).

Следует отметить, что существует много мест, которые потенциально могут
быть хвостовыми вызовами, например последний вызов в @code{for-each}, но
только те из них гарантированы которые имеют явное описание.

@node The REPL
@subsection Использование Guile REPL

Если вы запустите Guile без указания конкретной программы для выполнения,
Guile входит в стандартный цикл Чтение-Выполнение-Печать(Read Evaluate 
Print Loop или коротко @dfn{REPL}). В этом режиме, Guile неоднократно 
читает выражения Scheme, которые вводит пользователь, вычисляет их
и печатает результирующие значения.

REPL --- полезный механизм для изучения описанного поведения вычислений
описанного в предыдущем разделе. Если вы набираете @code{string-append},
например, REPL отвечает @code{#<primitive-procedure string-append>}, 
илюстрирующая взаимосвязь между переменными @code{string-append} и
процедурой, хранящейся в этой переменной.


В этом руководстве, обозначение @result{} используется для обозначения
результа вычисления ``evaluates to''.  Где бы вы не увидели пример
формы:

@lisp
@var{expression}
@result{}
@var{result}
@end lisp

@noindent
не стесняйтесь попробовать себя, набрав выражение в REPL
и проверить, что он выдает ожидаемый результат.

@node Syntax Summary
@subsection Итоги о Общем Синтаксисе

В этом подразделе перечислены наиболее часто используемые синтаксические 
выражения Scheme, настолько простые, что как только вы их увидите
вы сможете разпознать общий специальный синтакс. Для полного описания
каждого из этих синтаксисов дана соответствующая гиперссылка.

@code{lambda} (@pxref{Lambda}) используется для создания объектов процедур.

@code{define} (@pxref{Top Level}) используется для создания новой переменной
и установки ее первоначального значения.

@code{set!} (@pxref{Top Level}) используется для изменения значения существующей
переменной.

@code{let}, @code{let*} и @code{letrec} (@pxref{Local Bindings})
создают внутреннюю лексическую среду для вычисления последовательности
выражений, в которой задано множество локальных переменных связываемых
со множеством значений соответствующего набора выражений.  Для введения
в окружение(среду), см. @xref{About Closure}.

@code{begin} (@pxref{begin}) выполняет последовательность вражений в порядке
их следования и возвращаетж последнее выражение. Обратите внимание, что 
это не тоже самое, что процедура которая возвращает совй последний аргумент,
потому что оценка выражения вызова процедуры не гарантирует вычисления
аргументов в порядке их следования.

@code{if} and @code{cond} (@pxref{Conditionals}) обеспечивают условное вычисление
выражений аргументов в зависимости от того, является ли результатом
вычисления условия истина или ложь.

@code{case} (@pxref{Conditionals}) обеспечивают условное вычисление
выражений аргументов в зависимости от того, совпадает ли переменная
условия с одной из заданных групп значений.

@code{and} (@pxref{and or}) выполняет последовательность выраженей в порядке
их следования, пока не останется никаких выражений, или в одном из них результом 
будет значение ``false''.

@code{or} (@pxref{and or})выполняет последовательность выражений в 
порядке их следования, пока не останется выражений или в одном из них
результатом не будет значение ``true''.

@node About Closure
@section Концепция Замыкания

@cindex closure

Концепция замыкания @dfn{closure} состоит в том, что выражение лямбда
захватывает``captures'' свяазнные переменные лексической области в точке,
где определяется лямбда выражение. Процедура создания лямбда выражений,
может ссылаться или изменять захваченные связанные переменные, но значение
этих связанных переменных будет сохраняться между вызовами процедур.

В этом разделе более подробно рассматриваются  и анализируются
различные аспекты этой идеи.

@menu
* About Environments::          Names, locations, values and environments.
* Local Variables::             Local variables and local environments.
* Chaining::                    Environment chaining.
* Lexical Scope::               The meaning of lexical scoping.
* Closure::                     Explaining the concept of closure.
* Serial Number::               Example 1: a serial number generator.
* Shared Variable::             Example 2: a shared persistent variable.
* Callback Closure::            Example 3: the callback closure problem.
* OO Closure::                  Example 4: object orientation.
@end menu

@node About Environments
@subsection Имена, Местоположение, Значения и Среды

@cindex location
@cindex environment
@cindex vcell
@cindex top level environment
@cindex environment, top level

Ранее мы говорили, что имя переменной в программе Scheme связано
с местоположением в котором может храниться любое значение Scheme.
(Кстати, термин ``vcell'' часто используется в кругах Lisp и Scheme
в качестве альтернативы местоположению``location''.)  Таким образом
когда мы говорим о ``создании переменной'', фактически мы устанавливаем
связь между именем или идентификатором, который используется программным
кодом Scheme, и местоположением переменной которое относиться к этому
имени. Хотя значение, которое храниться в этом местоположении,
может измениться, место,на которое ссылается данное имя,
всегда одно и тоже.

Мы можем проилюстрировать это, разбив синтаксис определения
@code{define} на три части: @code{define}

@itemize @bullet
@item
создает новое местоположение

@item
устанавливает связь между этим местоположением и именем, обозначенным
как первый аргумент выражения @code{define}

@item
сохраняет в этом местоположении, значение, полученное путем вычисления
второго аргумента выражения @code{define}.
@end itemize

Набор ассоциаций между именами и местоположениями называется окружением
(средой)@dfn{environment}.  Когда вы создаете переменную верхнего уровня
в программе, используя @code{define}, ассоциация имя-местоположение для
этой переменной добавляется в окружение ``верхнего уровня''.  Кроме того,
окружение ``верхнего уровня'' включает ассоциации имя-местоположение для
всех процедур предоставляемых стандартной Scheme.

Также возможно создавать среды, отличные от верхнего уровня, и создавать
связанные переменные или ассоциации имя-местоположение в этих средах. Эта
способность является ключевым инградиентом в концепции замыкания; В следующем
подразделе показывается как это делается.

@node Local Variables
@subsection Локальные Переменные и Окружающая Среда

@cindex local variable
@cindex variable, local
@cindex local environment
@cindex environment, local

Мы видели, как создавать переменные верхнего уровня с помощью синтаксиса
@code{define} см. (@pxref{Definition}).  Часто бывает полезно создавать
переменные, которые были бы ограничены в своем конексте, как правило,
частью тела процедуры. В Scheme это делается с использованием синтаксиса
@code{let}, или его модифицированной формы @code{let*} или @code{letrec}.
Эти синтаксисы описаны полностью дальше в руководстве см. (@pxref{Local Bindings}).
Здесь наша цель - проилюстрировать их использование, чтобы мы могли видеть,
как работают локальные переменные.

Например, следующий код использует локальную перменную @code{s}, чтобы
упростить вычисление площади треугоальника по трем сторонам.

@lisp
(define a 5.3)
(define b 4.7)
(define c 2.8)

(define area
  (let ((s (/ (+ a b c) 2)))
    (sqrt (* s (- s a) (- s b) (- s c)))))
@end lisp

Эфектом от выражения @code{let} является создание новой окружающей среды и
в рамках этой среды устанавливается связь межуд именем @code{s}
и новым местоположением, начальное значение которого получено вычислением
@code{(/ (+ a b c) 2)}.  Выражения в теле @code{let}, а именно 
@code{(sqrt (* s (- s a) (- s b) (- s c)))}, затем вычисляются в 
контексте новой окружающей среды и значение последнего вычисленного
выражения становяться значением всего выражения @code{let}, и следовательно,
значением всей вычисленной переменной  @code{area}.

@node Chaining
@subsection Цепочка Окружений

@cindex shadowing an imported variable binding
@cindex chaining environments

В примере предыдущего подраздела мы скрыли важный момент. Тело выражения
@code{let} в этом примере, относится не только к локальной переменной @code{s},
но также к переменным верхнего уровня @code{a}, @code{b}, @code{c} и @code{sqrt}.
(@code{sqrt} стандартная процедура Scheme для вычисления квадратного корня.)
Если тело выражения @code{let} вычислятеся в контексте локальной среды @code{let},
как  вычислитель получает значения этих переменных верхнего уровня?

Ответ заключается в том. что локальная среда, созданная автоматически
выражением @code{let} содержит ссылку на среду его содержащую - 
в данном случае, среду верхнего уровня --- и интерпрететор Scheme
автоматически ищет связанные переменные в среде верхнего уровня, 
если он не находит их в локальном окружении.  В более общем
плане, каждая среда, за исключением верхнего уровня, имеет ссылку на
содержащую ее среду, а интерпретатор осущетствляет обратный поиск
по цепочке окружений из локального уровня до верхнего уровня, пока
не найдет связанную переменную для требуемого идентификатора или
не пройдет всю цепь.

Это описание также определяет, что происходит, когда имеется более
одной переменной связанных с одинаковым имеменем. предположим, что
(продолжая пример предыдущего подраздела) уже существовала пермеменная
верхнего уровня @code{s} созданная выражением:

@lisp
(define s "Some beans, my lord!")
@end lisp

Тогда и среда верхнего уровня, и среда локального @code{let} будут содержать
связанные значения с именем @code{s}.  При вычислении кода внутри тела
@code{let}, интерпретатор смотрит сначала локальную среду @code{let}, и
поэтому находит привязку для @code{s} созданную синтаксисом @code{let}
Несмотря на то, что среда имеет ссылку на среду верхнего уровня, которая
также имеет связанную переменную с именем @code{s}, интерпретатор не
доходт до того чтобы искать ее там. При вычислении кода вне тела @code{let},
интерпретатор ищет имена переменных в среде верхнего уровня, поэтому
имя переменной @code{s} относится к переменной верхнего уровня.

Говорят, что внутри тела @code{let}, связывание для переменной @code{s} в
локальной среде скрывает @dfn{shadow} связанную переменную @code{s} в
среде верхнего уровня.

@node Lexical Scope
@subsection Лексическая Область видимости

Правила, которые мы только что описали --- это детали того, как Scheme 
реализует ``лексическую область видимости''.  В этом подразделе делается
краткое введение, чтобы объяснить, что означает лексическая область
видимости вообще и представляется пример не лексической области видимости.

``Лексическая область видимости'' в целом --- это идея о том, что

@itemize @bullet
@item
идентификатор в определенном месте в программе ``всегда'' ссылается на одно и
тоже местоположение переменной --- где ``всегда'' означает ``каждый раз, когда
выполняется содержащее его выражение'', и что

@item
местоположение переменной, на которое она ссылается, может быть определено
статическим исследованием контекста исходного кода, в котором отображается
этот идентификатор, без необходимости рассматривать поток исполнения
программы в целом.
@end itemize

На практике лексическая область видимости является нормой для большинства
языков программирования и, вероятно, соответствует тому, что вы интуитивно
считаете ``нормальным''.  Вы даже может быть задаться вопросмо, как может
возникнуть иная ситуация и чем она может быть полезна.  Поэтому мы 
продемонстрируем возможную ситуацию иной области видимости и сравним
ее с лексической областью видимости. В следующем разделе представлен
пример нелексической области видимости и подробно рассматривается как
его поведение отличается от соответствующего кода с лексической областью
видимости.

@menu
* Scoping Example::             An example of non-lexical scoping.
@end menu

@node Scoping Example
@subsubsection Пример не Лексической области видимости

Чтобы продемонстрировать, что нелексическая область видимости существует
и может быть полезна, мы приводим следующий пример из языка Emacs Lisp, 
который является языком с ``динамической областью видмости''.

@lisp
(defvar currency-abbreviation "USD")

(defun currency-string (units hundredths)
  (concat currency-abbreviation
          (number-to-string units)
          "."
          (number-to-string hundredths)))

(defun french-currency-string (units hundredths)
  (let ((currency-abbreviation "FRF"))
    (currency-string units hundredths)))
@end lisp

Здесь нужно сосредоточиться на вопросе: что означает идентификатор
@code{currency-abbreviation} в функции @code{currency-string}?
Ответ в Emacs Lisp заключается в том, что все связанные переменные
переходят в единый стек, и @code{currency-abbreviation} означается 
как верхняя привязка из этого стека, которая имеет название 
``currency-abbreviation''.  Связывание, которое создается формой 
@code{defvar} с значением @code{"USD"}, имеет значение только в том
случае, если ни один операто из кода, который вызвал @code{currency-string}
не переопределит ``currency-abbreviation''.

Вторая функция @code{french-currency-string} работает точно так используя
это поведение.  Она создает новую привязку для имени ``currency-abbreviation''
которая переопределяет ту, которая была установлена формой @code{defvar}.

@lisp
;; Замечание!!! Выполнение Emacs Lisp, а не Scheme!
(french-currency-string 33 44)
@result{}
"FRF33.44"
@end lisp

Теперь давайте посмотрим на соотвествующий код, выполняющийся
в соответствии с лекической областью видимостью в Scheme:

@lisp
(define currency-abbreviation "USD")

(define (currency-string units hundredths)
  (string-append currency-abbreviation
                 (number->string units)
                 "."
                 (number->string hundredths)))

(define (french-currency-string units hundredths)
  (let ((currency-abbreviation "FRF"))
    (currency-string units hundredths)))
@end lisp

Согласно правилам лексической области видимости, имя 
@code{currency-abbreviation} в @code{currency-string} ссылается на
местоположение переменной в самом ближайшем окружении к точке кода,
который выполняет связываение для @code{currency-abbreviation}, данное
расположение переменной задано на верхнем уровне окружения выражением:
@code{(define currency-abbreviation @dots{})}.

Поэтому в Scheme, процедура @code{french-currency-string} не будет
работать должным образом.  Связываение переменных создаваемое для
``currency-abbreviation'' является чисто локальным кодом, который
формирует тело выражения @code{let}.  Поскольку этот код напрямую
не использует имя ``currency-abbreviation'' нигде, это связывание
бессмысленно.

@lisp
(french-currency-string 33 44)
@result{}
"USD33.44"
@end lisp

Это ставит вопрос, как поведение Emacs Lisp может быть реализовано на
Scheme.  В общем, это вопрос дизайна, ответ на которй зависит от адресата.
В даном случае, лучшим ответом могбы быть тот, что  @code{currency-string} 
должна принимать необязательный третий аргумент.  Этот третий аргумент,
если он представлен, интерпретируется как абревиатура валюты, которая отменяет
значение по умолчанию.

Можно изменить @code{french-currency-string} чтобы она изменяла основную
@code{currency-string}, но эти изменения не будут элегантными и 
устойчивыми к прерываниям, которые могут преревести 
@code{currency-abbreviation} в некорректное состояние:

@lisp
(define (french-currency-string units hundredths)
  (set! currency-abbreviation "FRF")
  (let ((result (currency-string units hundredths)))
    (set! currency-abbreviation "USD")
    result))
@end lisp

Ключевым моментом здесь является то, что код не создает никакой локальной
привязки для идентификатора @code{currency-abbreviation}, так что все изменения
относятся к пермеменной верхнего уровня.

@node Closure
@subsection Замыкания

Рассмотрим выражение a @code{let}, которое не содержит никаких
@code{lambda}s:

@lisp
(let ((s (/ (+ a b c) 2)))
  (sqrt (* s (- s a) (- s b) (- s c))))
@end lisp

@noindent
Когда интерпретатор Scheme вычисляет это, он

@itemize @bullet
@item
создает новую окружающую среду со ссылкой на среду, которая была до
того как ему встретилось выражение @code{let}

@item
создает связанную пермеменную для @code{s} в новом окружении, со значением
задаваемым выражением @code{(/ (+ a b c) 2)}

@item
вычисляет выражение в теле @code{let} в контексте нового локального
окружения и запоминает значение  @code{V}, последнего выполненого выражения.

забывает локальное окружение.

@item
продолжает выполнять выражения, содержащее @code{let}, используя
значение @code{V} как значение выражения @code{let}, в контексте
содержащей его среды.
@end itemize

После того, как выражение @code{let} было вычислено, созданная локальная
среда просто забывается, и пропадает доступ ко всем связанным в нем переменным.
Если один и тот же код будет снова выполнен, он будет повторять те же шаги,
создавая вторую новую локальную среду, не с связанную с первой, а затем
снова забывая о ней.

Однако, если тело @code{let} содержит  @code{lambda} выражение, то локальная
среда не является забытой.  Вместо этого, она становиться связанной с 
процедурой, созданной @code{lambda} выражением, и востанавливается каждый
раз, когда вызывается эта процедура. В деталях это работает следующим образом...

@itemize @bullet
@item
Когда интерпретатор Scheme вычисляет @code{lambda} выражение, чтобы
создать процедурный объект, он сохраняет текущую среду как часть
определения процедуры.

@item
Затем, всякий раз, когда процедура вызывается, интерпретатор восстанавливает 
среду которая храниться в определении процедуры и вычисляет тело процедуры
в пределах контекста этой среды.
@end itemize

В результате тело процедуры вычисляется в контексте среды которая
была актуальна, когда эта процедура создавалась.

Это и есть то что мы называем замыкание @dfn{closure}.  В следущих
нескольких подразделах представлены примеры, которые исследуют
полезность этой концепции.

@node Serial Number
@subsection Пример 1: Генератор последовательности чисел

В этом примере используется замыкание для создания процедуры которая
является внутренней для данной процедуры, как локальная переменная, но
значение которой сохраняется между вызовами процедур.

@lisp
(define (make-serial-number-generator)
  (let ((current-serial-number 0))
    (lambda ()
      (set! current-serial-number (+ current-serial-number 1))
      current-serial-number)))

(define entry-sn-generator (make-serial-number-generator))

(entry-sn-generator)
@result{}
1

(entry-sn-generator)
@result{}
2
@end lisp

Когда вызывается @code{make-serial-number-generator}, он создает локальную
среду со связанной переменной с именем @code{current-serial-number} начальное
значение которой равно 0, в этой среде создается процедура. Локальная среда
храниться в созданном объекте процедуры и поэтому сохраняется на протяжении
жизни созданной процедуры.

Каждый раз, когда вызывается созданная процедура, она увеличивает значение
связанной переменной @code{current-serial-number} в захваченной среде,
а затем возвращает текущее значение.

Обратите внимание, что @code{make-serial-number-generator} можно вызвать
снова, чтобы создать второй генератор последовательных чисел, который
независит от первого. Каждый новый вызов @code{make-serial-number-generator}
создает новую локальную среду @code{let} и возвращает новый объект процедуры
ассоциированный с этой средой.

@node Shared Variable
@subsection Пример 2: Общая статическая переменная.

В этом примере используется замыкание, чтобы создать две процедуры
@code{get-balance} и @code{deposit}, которые обращаются к одной
и той же локальной среде, чтобы обеспечить доступ к связанной
перменной @code{balance} определенной внутри это локальной среды.
Значение этой связанной переменной сохраняется между вызовами
этих процедур.

Обратите внимание, что связанная перемеменная @code{balance} является
частной для этих двух процедур: она на прямую не доступна для любого
другого кода. Доступ к ней можно получить косвенно только через
@code{get-balance} или @code{deposit}, как это показано
в процедуре @code{withdraw}.

@lisp
(define get-balance #f)
(define deposit #f)

(let ((balance 0))
  (set! get-balance
        (lambda ()
          balance))
  (set! deposit
        (lambda (amount)
          (set! balance (+ balance amount))
          balance)))

(define (withdraw amount)
  (deposit (- amount)))

(get-balance)
@result{}
0

(deposit 50)
@result{}
50

(withdraw 75)
@result{}
-25
@end lisp

Важная деталь здесь заключается в том, что должны быть установлены
переменные @code{get-balance} и  @code{deposit} определенные 
на верхнем уровне с помощью @code{define}, а затем установлены
с помощью @code{set!} внутри тела @code{let}. Использование 
@code{define} внутри тела  @code{let} работать не будет: это
создало бы связанные переменные внутри локальной среды @code{let}, 
которая будет недоступной на верхнем уровне.

@node Callback Closure
@subsection Пример 3: Проблема замыкания обратного вызова

Часто используемая модель программирования для библиотечного кода ---
позволить приложению регистрировать функции обратного вызова для библиотеки
вызываемые при возникновении определенного события. Для приложения
зачастую полезно выполнить несколько таких регистраций, используя одну
и туже функцию обратного вызова, для например если несколько похожих
событий библиотеки могут обрабатываться с использованием одного и того
же кода приложения, но тогда возникает необходимость различать вызовы
функций обратного вызова, которые связаны  с одной регистрацией
обратного вызова, от тех которые связаны с другой регистрацией
обратного вызова.

В языках, не имеющих возможности динамически создавать функции, эта
проблема обычно решается путем передачи параметра @code{user_data}
при регистрации вызова и включения значения этого параметра в качестве
одного из параметров функции обратного вызова. Вот пример объявления
с использованием этого решения на Си:

@example
typedef void (event_handler_t) (int event_type,
                                void *user_data);

void register_callback (int event_type,
                        event_handler_t *handler,
                        void *user_data);
@end example

В Scheme, замыкание может использоваться для достижения такой же функциональности,
не используя библиотечный код для хранения пользовательских данных @code{user-data}
для регистрации обратного вызова.

@lisp
;; In the library:

(define (register-callback event-type handler-proc)
  @dots{})

;; In the application:

(define (make-handler event-type user-data)
  (lambda ()
    @dots{}
    <code referencing event-type and user-data>
    @dots{}))

(register-callback event-type
                   (make-handler event-type @dots{}))
@end lisp

Что касается библиотеки, @code{handler-proc} это процедура без аргументов,
и все что нужно сделать библиотеке, это вызвать его когда произойдет
соответствующее событие. В приложения однако, однако процедура обработчика
использует замыкание для захвата среды, которая включает в себя весь 
контекст, который требуется коду обработчика ---
@code{event-type} и @code{user-data} --- для правильной обработки
события.

@node OO Closure
@subsection Пример 4: Объектная Ориентация

Замыкание --- это захыват среды, содержащей постоянные связанные 
переменные, внутри определения процедуры или набора связанных процедур.
Это довольно похоже на идею в некоторых объектно-ориентированных языках,
инкапсуляции набора связанных переменных внутри ``объекта'', вместе с
набором ``методов'' которые работают с инкапсулированными данными.
Следующий пример показывает, как замыкание можно использовать для
эмуляции идеи объектов, методов и инкапусуляции в Scheme.

@lisp
(define (make-account)
  (let ((balance 0))
    (define (get-balance)
      balance)
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (withdraw amount)
      (deposit (- amount)))

    (lambda args
      (apply
        (case (car args)
          ((get-balance) get-balance)
          ((deposit) deposit)
          ((withdraw) withdraw)
          (else (error "Invalid method!")))
        (cdr args)))))
@end lisp

Каждый вызов @code{make-account} создает и возвращает новую процедуру,
созданную выражением в коде примера, который начинается с: ``(lambda
args''.

@lisp
(define my-account (make-account))

my-account
@result{}
#<procedure args>
@end lisp

Эта процедура действует как объект учетная запись(СЧЕТ) с методами
@code{get-balance}, @code{deposit} и @code{withdraw}.  Чтобы применить
один из методов к текущему СЧЕТу, вы вызываете процедуру с помощью
символа указывая требуемый метод в качестве первого параметра, за которым
следуют любые другие параметры, которые требуются этому методу.

@lisp
(my-account 'get-balance)
@result{}
0

(my-account 'withdraw 5)
@result{}
-5

(my-account 'deposit 396)
@result{}
391

(my-account 'get-balance)
@result{}
391
@end lisp

Обратите внимание, в этом примере, как текущий баланс, так и вспомогательные
процедуры @code{get-balance}, @code{deposit} и @code{withdraw}, используемые
для реализации методов работающих с внутренним балансом, храняться в переменных
связанных в закрытой локальной среде, захваченной выражением @code{lambda},
которе создает процедуру-объект --- СЧЕТ.

@c Local Variables:
@c TeX-master: "guile.texi"
@c End: