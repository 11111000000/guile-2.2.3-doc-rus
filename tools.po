#. extracted from /home/bear/work/guile/doc/guile/en/tools.texi
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-07 12:37+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 2.2.5\n"

#: /home/bear/work/guile/doc/guile/en/tools.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2011, 2014\n"
"@c   Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:10
msgid ""
"@page\n"
"@node Miscellaneous Tools\n"
"@chapter Miscellaneous Tools"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:15
msgid ""
"Programming is more fun with a good tools.  This chapter describes snarfing\n"
"tools, and the @code{guild} program which can be used to invoke the rest\n"
"of the tools (which are self-documenting).  Some of these are used in Guile\n"
"development, too.  Imagine that!"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:20
msgid ""
"@menu\n"
"* Snarfing::                    Grepping the source in various ways.\n"
"* Executable Modules::          Modules callable via guild.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:25
msgid ""
"@c "
"---------------------------------------------------------------------------\n"
"@node Snarfing\n"
"@section Snarfing\n"
"@cindex snarfing"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:32
msgid ""
"Because it's easier to maintain documentation, code, and other metainfo in "
"one\n"
"source file than in many files, there have evolved many methods for "
"grepping\n"
"source to lift and separate these kinds of info, in the process generating\n"
"docs or fragments of source or what have you.  This is known generally as\n"
"@dfn{snarfing}, which comes from the verb ``to snarf'', here meaning ``to\n"
"unceremoniously extract information from a somewhat unwilling source.''"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:37
msgid ""
"This section documents the installed program @code{guile-snarf} which does\n"
"@dfn{init snarfing}, and also touches upon guile's doc snarfing process "
"which\n"
"is not yet finalized (i.e., doc snarfing programs are not installed at this\n"
"time)."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:42
msgid ""
"@menu\n"
"* Init Snarfing with guile-snarf::      Exposing C subrs and friends to "
"Scheme.\n"
"* Doc Snarfing::                        Generating GDFv2 or texi from source."
"\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:50
msgid ""
"@c "
"---------------------------------------------------------------------------\n"
"@node Init Snarfing with guile-snarf\n"
"@subsection Init Snarfing with guile-snarf\n"
"@c NOTE: This node and two subnodes are adapted from ../sources/snarf.texi.\n"
"@cindex snarfing, init\n"
"@cindex primitive functions\n"
"@cindex subrs, defining"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:60
msgid ""
"When writing C code for use with Guile, you typically define a set of C\n"
"functions, and then make some of them visible to the Scheme world by\n"
"calling the @code{scm_c_define_gsubr} function; a C function published in\n"
"this way is called a @dfn{subr}.  If you have many subrs to publish, it\n"
"can sometimes be annoying to keep the list of calls to\n"
"@code{scm_c_define_gsubr} in sync with the list of function definitions.\n"
"Frequently, a programmer will define a new subr in C, recompile the\n"
"application, and then discover that the Scheme interpreter cannot see\n"
"the subr, because of a missed call to @code{scm_c_define_gsubr}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:67
msgid ""
"Guile provides the @code{guile-snarf} command to manage this problem.\n"
"Using this tool, you can keep all the information needed to define the\n"
"subr alongside the function definition itself; @code{guile-snarf} will\n"
"extract this information from your source code, and automatically\n"
"generate a file of calls to @code{scm_c_define_gsubr} which you can\n"
"@code{#include} into an initialization function."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:73
msgid ""
"@menu\n"
"* How guile-snarf works::           Using @code{guile-snarf}, with example.\n"
"* Macros guile-snarf recognizes::   How to mark up code for @code{guile-"
"snarf}.\n"
"* Writing your own snarfing macros:: How to define new things to snarf.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:79
msgid ""
"@c "
"---------------------------------------------------------------------------\n"
"@node How guile-snarf works\n"
"@subsubsection How guile-snarf works\n"
"@cindex guile-snarf invocation\n"
"@cindex guile-snarf example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:81
msgid "Usage: guile-snarf [-o @var{outfile}] [@var{cpp-args} ...]"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:87
msgid ""
"The @code{guile-snarf} program will extract initialization actions to\n"
"@var{outfile} or to standard output when no @var{outfile} has been\n"
"specified or when @var{outfile} is @code{-}.  The C preprocessor is\n"
"called with @var{cpp-args} (which usually include an input file) and\n"
"the output is filtered to extract the initialization actions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:90
msgid ""
"If there are errors during processing, @var{outfile} is deleted and the\n"
"program exits with non-zero status."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:94
msgid ""
"During snarfing, the pre-processor macro @code{SCM_MAGIC_SNARFER} is\n"
"defined.  You could use this to avoid including snarfer output files\n"
"that don't yet exist by writing code like this:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:100
msgid ""
"@smallexample\n"
"#ifndef SCM_MAGIC_SNARFER\n"
"#include \"foo.x\"\n"
"#endif\n"
"@end smallexample"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:103
msgid ""
"If the environment variable @code{CPP} is set, use its value instead of the\n"
"C pre-processor determined at Guile configure-time."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:106
msgid ""
"@xref{Macros guile-snarf recognizes}, for a list of the special (some would\n"
"say magic) cpp macros you can use, including the list of deprecated macros."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:109
msgid ""
"For example, here is how you might define a new subr called\n"
"@code{clear-image}, implemented by the C function @code{clear_image}:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:113
msgid ""
"@example\n"
"@group\n"
"#include <libguile.h>"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:122
msgid ""
"SCM_DEFINE (clear_image, \"clear-image\", 1, 0, 0,\n"
"            (SCM image),\n"
"            \"Clear the image.\")\n"
"#define FUNC_NAME s_clear_image\n"
"@{\n"
"  /* C code to clear the image in @code{image}... */\n"
"@}\n"
"#undef FUNC_NAME"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:130
msgid ""
"void\n"
"init_image_type ()\n"
"@{\n"
"#include \"image-type.x\"\n"
"@}\n"
"@end group\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:136
msgid ""
"The @code{SCM_DEFINE} declaration says that the C function\n"
"@code{clear_image} implements a Scheme subr called @code{clear-image},\n"
"which takes one required argument (of type @code{SCM} and named\n"
"@code{image}), no optional arguments, and no rest argument.  @xref{Doc\n"
"Snarfing}, for info on the docstring."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:142
msgid ""
"This works in concert with @code{FUNC_NAME} to also define a static\n"
"array of characters named @code{s_clear_image}, initialized to the\n"
"string \"clear-image\".  The body of @code{clear_image} may use the array\n"
"in error messages, instead of writing out the literal string; this may\n"
"save string space on some systems."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:145
msgid ""
"Assuming the text above lives in a file named @file{image-type.c}, you will\n"
"need to execute the following command to prepare this file for compilation:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:149
msgid ""
"@example\n"
"guile-snarf -o image-type.x image-type.c\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:152
msgid ""
"This scans @file{image-type.c} for @code{SCM_DEFINE}\n"
"declarations, and writes to @file{image-type.x} the output:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:156
msgid ""
"@example\n"
"scm_c_define_gsubr (s_clear_image, 1, 0, 0, (SCM (*)() ) clear_image);\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:160
msgid ""
"When compiled normally, @code{SCM_DEFINE} is a macro which expands to\n"
"a declaration of the @code{s_clear_image} string and the function\n"
"header for @code{clear_image}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:166
msgid ""
"Note that the output file name matches the @code{#include} from the\n"
"input file.  Also, you still need to provide all the same information\n"
"you would if you were using @code{scm_c_define_gsubr} yourself, but you\n"
"can place the information near the function definition itself, so it is\n"
"less likely to become incorrect or out-of-date."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:169
msgid ""
"If you have many files that @code{guile-snarf} must process, you should\n"
"consider using a fragment like the following in your Makefile:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:176
msgid ""
"@example\n"
"snarfcppopts = $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS)\n"
".SUFFIXES: .x\n"
".c.x:\n"
"\tguile-snarf -o $@@ $< $(snarfcppopts)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:179
msgid ""
"This tells make to run @code{guile-snarf} to produce each needed\n"
"@file{.x} file from the corresponding @file{.c} file."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:185
msgid ""
"The program @code{guile-snarf} passes its command-line arguments\n"
"directly to the C preprocessor, which it uses to extract the\n"
"information it needs from the source code. this means you can pass\n"
"normal compilation flags to @code{guile-snarf} to define preprocessor\n"
"symbols, add header file directories, and so on."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:191
msgid ""
"@c "
"---------------------------------------------------------------------------\n"
"@node Macros guile-snarf recognizes\n"
"@subsubsection Macros guile-snarf recognizes\n"
"@cindex guile-snarf recognized macros\n"
"@cindex guile-snarf deprecated macros"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:194
msgid ""
"Here are the macros you can use in your source code from which\n"
"@code{guile-snarf} can construct initialization code:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:198
msgid ""
"@example\n"
"/* procedures */\n"
"SCM_DEFINE (FNAME, PRIMNAME, REQ, OPT, VAR, ARGLIST, DOCSTRING)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:201
msgid ""
"SCM_PROC (RANAME, STR, REQ, OPT, VAR, CFN)\n"
"SCM_REGISTER_PROC (RANAME, STR, REQ, OPT, VAR, CFN)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:203
msgid "SCM_GPROC (RANAME, STR, REQ, OPT, VAR, CFN, GF)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:207
msgid ""
"/* everything else */\n"
"SCM_SYMBOL (c_name, scheme_name)\n"
"SCM_GLOBAL_SYMBOL (c_name, scheme_name)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:210
msgid ""
"SCM_KEYWORD (c_name, scheme_name)\n"
"SCM_GLOBAL_KEYWORD (c_name, scheme_name)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:213
msgid ""
"SCM_VARIABLE (c_name, scheme_name)\n"
"SCM_GLOBAL_VARIABLE (c_name, scheme_name)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:217
msgid ""
"SCM_VARIABLE_INIT (c_name, scheme_name, init_val)\n"
"SCM_GLOBAL_VARIABLE_INIT (c_name, scheme_name, init_val)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:231
msgid ""
"@c i like things dense, but maybe someone else will reformat this\n"
"@c into an easier-to-read list.  also, all-upcase to me is a form\n"
"@c of quoting, so @var{} is not necessary there. --ttn\n"
"REQ and OPT are numbers indicating required and optional argument\n"
"counts, respectively; VAR is a number that, if non-zero, means the\n"
"function will accept any remaining arguments as a list; DOCSTRING is a\n"
"string (use @code{\\n"
"\\} at eol for multi-line); FNAME is a C-language\n"
"identifier, CFN and GF and @var{c_name} likewise; PRIMNAME is a string\n"
"denoting the name available to Scheme code, STR and @var{scheme_name}\n"
"likewise; RANAME is the name of the static string (must match that\n"
"declared by the associated definition of cpp macro @var{FUNC_NAME});\n"
"ARGLIST is an argument list (in parentheses); and lastly, @var{init_val}\n"
"is a expression suitable for initializing a new variable."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:237
msgid ""
"For procedures, you can use @code{SCM_DEFINE} for most purposes.  Use\n"
"@code{SCM_PROC} along with @code{SCM_REGISTER_PROC} when you don't\n"
"want to be bothered with docstrings.  Use @code{SCM_GPROC} for generic\n"
"functions (@pxref{Creating Generic Functions}).  All procedures are\n"
"declared with return type @code{SCM}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:241
msgid ""
"For everything else, use the appropriate macro (@code{SCM_SYMBOL} for\n"
"symbols, and so on).  Without \"_GLOBAL_\", the declarations are\n"
"@code{static}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:246
msgid ""
"All these macros should be used at top-level, outside function bodies.\n"
"Also, it's a good idea to define @var{FUNC_NAME} immediately after using\n"
"@code{SCM_DEFINE} (and similar), and then the function body, and then\n"
"@code{#undef FUNC_NAME}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:250
msgid ""
"@xref{How guile-snarf works}, and also libguile source, for examples.\n"
"@xref{Subrs}, for details on argument passing and how to write C\n"
"functions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:254
msgid ""
"@c "
"---------------------------------------------------------------------------\n"
"@node Writing your own snarfing macros\n"
"@subsubsection Writing your own snarfing macros"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:258
msgid ""
"When you want to use the general snarfing mechanism, but none of the\n"
"provided macros fits your need, you can use the macro\n"
"@code{SCM_SNARF_INIT}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:260
msgid "For example, the @code{SCM_SYMBOL} macro can be defined like this:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:266
msgid ""
"@example\n"
"#define SCM_SYMBOL(c_name, scheme_name) \\\n"
"static SCM c_name \\\n"
"SCM_SNARF_INIT(c_name = scm_permanent_object (scm_str2symbol (scheme_name)))"
"\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:272
msgid ""
"@defmac SCM_SNARF_INIT (code)\n"
"When processed normally, @code{SCM_SNARF_INIT} expands to nothing;\n"
"when processed by the snarfer, it causes @var{code} to be included in\n"
"the initialization action file, followed by a semicolon.\n"
"@end defmac"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:276
msgid ""
"@c "
"---------------------------------------------------------------------------\n"
"@node Doc Snarfing\n"
"@subsection Doc Snarfing"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:282
msgid ""
"In addition to init snarfing (@pxref{Init Snarfing with guile-snarf}),\n"
"the libguile sources are also subject to doc snarfing, by programs that\n"
"are included in the distribution (but not installed at this time).  The\n"
"output is the file @file{guile-procedures.txt} which is installed, and\n"
"subsequently used by module @code{(ice-9 documentation)}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:284
msgid ""
"Here is a list of what does what according to @file{libguile/Makefile.am}:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:292
msgid ""
"@itemize\n"
"@item guile-snarf-docs runs cpp defining SCM_MAGIC_SNARF_DOCS\n"
"@item guile_filter_doc_snarfage parses guile-snarf-docs output to produce ."
"doc\n"
"@item ../scripts/snarf-check-and-output-texi makes guile.texi\n"
"@item ../scripts/snarf-check-and-output-texi makes guile-procedures.txt\n"
"@item guile-func-name-check checks source snarf-syntax integrity (optional?)"
"\n"
"@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:295
msgid ""
"Note that for guile-1.4, a completely different approach was used!  All "
"this\n"
"is rather byzantine, so for now @emph{NO} doc snarfing programs are "
"installed."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:297
msgid "[fixme: Document further once doc snarfing is tamed somewhat. --ttn]"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:306
msgid ""
"@c "
"---------------------------------------------------------------------------\n"
"@node Executable Modules\n"
"@section Executable Modules\n"
"@cindex guild\n"
"@cindex guile-tools\n"
"@cindex modules, executable\n"
"@cindex executable modules\n"
"@cindex scripts"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:312
msgid ""
"When Guile is installed, in addition to the @code{(ice-9 FOO)} modules, a "
"set\n"
"of @dfn{guild modules} @code{(scripts BAR)} is also installed.  Each is\n"
"a regular Scheme module that has some additional packaging so that it can "
"be\n"
"used by guild, from the shell.  For this reason, we sometimes use the\n"
"term @dfn{script} in this context to mean the same thing."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:317
msgid ""
"As a convenience, the @code{guild} wrapper program is installed along with\n"
"@code{guile}; it knows where a particular module is installed and calls it\n"
"passing its args to the program.  The result is that you need not augment "
"your\n"
"@code{PATH}.  Usage is straightforward:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:322
msgid ""
"@example\n"
"guild --help\n"
"guild --version\n"
"guild [OPTION] PROGRAM [ARGS ...]"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:329
msgid ""
"If PROGRAM is \"list\" or omitted, display contents of scripts dir, "
"otherwise\n"
"PROGRAM is run w/ ARGS.  Options (only one of which may be used at a time):\n"
" --scriptsdir DIR    -- Look in DIR for scripts\n"
" --guileversion VERS -- Look in $pkgdatadir/VERS/scripts for scripts\n"
" --source            -- Display PROGRAM source (ignore ARGS) to stdout\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:332
msgid ""
"The modules are self-documenting.  For example, to see the documentation "
"for\n"
"@code{lint}, use one (or both) of the shell commands:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:337
msgid ""
"@example\n"
"guild display-commentary '(scripts lint)'\n"
"guild --source lint\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:340
msgid ""
"The rest of this section describes the packaging that goes into creating an\n"
"executable module.  Feel free to skip to the next chapter."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:342
msgid "@subsection Writing Executable Modules"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:344
msgid "@c adapted from scripts/README"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:346
msgid "See template file @code{PROGRAM} for a quick start."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:348
msgid "Programs must follow the @dfn{guild} convention, documented here:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:350
msgid "@itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:355
msgid ""
"@item\n"
"The module name must be \"(scripts PROGRAM)\".  A procedure named PROGRAM w/"
"\n"
"signature \"(PROGRAM . args)\" must be exported.  Basically, use some "
"variant\n"
"of the form:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:360
msgid ""
"@example\n"
"(define-module (scripts PROGRAM)\n"
"  #:export (PROGRAM))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:362
msgid "Feel free to export other definitions useful in the module context."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:365
msgid ""
"@item\n"
"There must be the alias:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:369
msgid ""
"@example\n"
"(define main PROGRAM)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:371
msgid "However, `main' must NOT be exported."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:373
msgid "@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:377
msgid ""
"Following these conventions allows the program file to be used as module\n"
"@code{(scripts PROGRAM)} in addition to being invoked by guild.  Please\n"
"also include a helpful Commentary section w/ some usage info."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/tools.texi:378
msgid "@c tools.texi ends here"
msgstr ""
