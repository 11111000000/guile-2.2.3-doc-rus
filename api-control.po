#
# NuINu <don't@send.my>, 2019.
#
#. extracted from /home/bear/work/guile/doc/guile/en/api-control.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-07 12:36+0300\n"
"PO-Revision-Date: 2019-03-13 16:11+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2009, 2010,\n"
"@c   2011, 2012, 2013, 2014 Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:9
msgid ""
"@node Control Mechanisms\n"
"@section Controlling the Flow of Program Execution"
msgstr ""
"@node Control Mechanisms\n"
"@section Управление потоком выполнения Программы"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:12
msgid ""
"See @ref{Control Flow} for a discussion of how the more general control\n"
"flow of Scheme affects C code."
msgstr ""
"См. @ref{Control Flow} для обсуждения того, как более общий контроль потока\n"
"управления Scheme влияет на Си код."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:29
msgid ""
"@menu\n"
"* begin::                       Sequencing and splicing.\n"
"* Conditionals::                If, when, unless, case, and cond.\n"
"* and or::                      Conditional evaluation of a sequence.\n"
"* while do::                    Iteration mechanisms.\n"
"* Prompts::                     Composable, delimited continuations.\n"
"* Continuations::               Non-composable continuations.\n"
"* Multiple Values::             Returning and accepting multiple values.\n"
"* Exceptions::                  Throwing and catching exceptions.\n"
"* Error Reporting::             Procedures for signaling errors.\n"
"* Dynamic Wind::                Dealing with non-local entrance/exit.\n"
"* Fluids and Dynamic States::   Dynamic scope building blocks.\n"
"* Parameters::                  A dynamic scope facility.\n"
"* Handling Errors::             How to handle errors in C code.\n"
"* Continuation Barriers::       Protection from non-local control flow.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:32
msgid ""
"@node begin\n"
"@subsection Sequencing and Splicing"
msgstr ""
"@node begin\n"
"@subsection Последовательности(Sequencing) и Соедениения(Splicing)"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:36
msgid ""
"@cindex begin\n"
"@cindex sequencing\n"
"@cindex expression sequencing"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:39
msgid ""
"As an expression, the @code{begin} syntax is used to evaluate a sequence\n"
"of sub-expressions in order.  Consider the conditional expression below:"
msgstr ""
"В качестве выражения, синтаксис @code{begin} исползуется для вычисления \n"
"последовательности подвыражений в установленном порядке. Ниже рассмотрим\n"
"условное выражение:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:44
msgid ""
"@lisp\n"
"(if (> x 0)\n"
"    (begin (display \"greater\") (newline)))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:48
msgid ""
"If the test is true, we want to display ``greater'' to the current\n"
"output port, then display a newline.  We use @code{begin} to form a\n"
"compound expression out of this sequence of sub-expressions."
msgstr ""
"Если test истинен, мы отобразим ``greater'' для текущего порта вывода,\n"
"а затем отобразим новую строку.  Мы используем @code{begin} для "
"формирования\n"
"составного выражения из этой последовательности подвыражений."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:55
msgid ""
"@deffn syntax begin expr @dots{}\n"
"The expression(s) are evaluated in left-to-right order and the value of\n"
"the last expression is returned as the value of the\n"
"@code{begin}-expression.  This expression type is used when the\n"
"expressions before the last one are evaluated for their side effects.\n"
"@end deffn"
msgstr ""
"@deffn syntax begin expr @dots{}\n"
"Выражение(я) вычисляются в порядке слева на право и значение последнего\n"
"выражения возвращается как значение выражения @code{begin}.  Этот тип\n"
"выражения используется когда выражения перед последним выражением "
"выражением\n"
"вычисляются из за их \"сторонних эффектов\".\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:58
msgid ""
"@cindex splicing\n"
"@cindex definition splicing"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:63
msgid ""
"The @code{begin} syntax has another role in definition context\n"
"(@pxref{Internal Definitions}).  A @code{begin} form in a definition\n"
"context @dfn{splices} its subforms into its place.  For example,\n"
"consider the following procedure:"
msgstr ""
"Синтаксис @code{begin} играет другую роль в контектсе определений\n"
"(@pxref{Internal Definitions}).  Форма @code{begin} в контексте\n"
"определений объединяет(@dfn{splices}) свои подчиненные формы в одном\n"
"месте. Например, рассмотрим следующую процедуру.:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:69
msgid ""
"@lisp\n"
"(define (make-seal)\n"
"  (define-sealant seal open)\n"
"  (values seal open))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:72
msgid ""
"Let us assume the existence of a @code{define-sealant} macro that\n"
"expands out to some definitions wrapped in a @code{begin}, like so:"
msgstr ""
"Давайте предположим, что существует макрос @code{define-sealant} который\n"
"расширяется до некоторого определения обернутого в @code{begin}, подобно\n"
"этому:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:88
msgid ""
"@lisp\n"
"(define (make-seal)\n"
"  (begin\n"
"    (define seal-tag\n"
"      (list 'seal))\n"
"    (define (seal x)\n"
"      (cons seal-tag x))\n"
"    (define (sealed? x)\n"
"      (and (pair? x) (eq? (car x) seal-tag)))\n"
"    (define (open x)\n"
"      (if (sealed? x)\n"
"          (cdr x)\n"
"          (error \"Expected a sealed value:\" x))))\n"
"  (values seal open))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:93
msgid ""
"Here, because the @code{begin} is in definition context, its subforms\n"
"are @dfn{spliced} into the place of the @code{begin}.  This allows the\n"
"definitions created by the macro to be visible to the following\n"
"expression, the @code{values} form."
msgstr ""
"Здесь, посокльку @code{begin} находиться в контексте определения, его\n"
"подчиненные формы объединены(@dfn{spliced}) внутри @code{begin}.  Это\n"
"позволяет определениям, созданным макросом быть видимыми для последующих\n"
"выражений, формы @code{values}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:101
msgid ""
"It is a fine point, but splicing and sequencing are different.  It can\n"
"make sense to splice zero forms, because it can make sense to have zero\n"
"internal definitions before the expressions in a procedure or lexical\n"
"binding form.  However it does not make sense to have a sequence of zero\n"
"expressions, because in that case it would not be clear what the value\n"
"of the sequence would be, because in a sequence of zero expressions,\n"
"there can be no last value.  Sequencing zero expressions is an error."
msgstr ""
"Это прекрасный момент, но соединение(splicing) и последовательность\n"
"(sequencing) отличаются. Может иметь смысл соединять нулевые формы,\n"
"потому что может иметь смысл иметь ноль внутренних определений перед\n"
"выражениями в процедуре или лексической форме связывания.  Однако не \n"
"имеет смысла иметь последовательность нулевых выражений, потому что\n"
"в этом случае не было бы понятно, какое значение должна иметь \n"
"последовательность, поскольку в последовательности нулевых выражений\n"
"не может быть последнего значения.  Последовательность нулевых\n"
"выражений является ошибкой."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:107
msgid ""
"It would be more elegant in some ways to eliminate splicing from the\n"
"Scheme language, and without macros (@pxref{Macros}), that would be a\n"
"good idea.  But it is useful to be able to write macros that expand out\n"
"to multiple definitions, as in @code{define-sealant} above, so Scheme\n"
"abuses the @code{begin} form for these two tasks."
msgstr ""
"В некотором смысле было бы более элегантно устранить объединение(splicing)\n"
"из языка Scheme, и без макросов (@pxref{Macros}), это было бы хорошей "
"идеей.\n"
"Но полезно иметь возможность писать макросы, которые расширяются до "
"множественных\n"
"определений, как в @code{define-sealant} выше, поэтому Scheme\n"
"злоупотребляет формой @code{begin} для этих двух задач."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:110
msgid ""
"@node Conditionals\n"
"@subsection Simple Conditional Evaluation"
msgstr ""
"@node Conditionals\n"
"@subsection Простое Условное Вычисление"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:117
msgid ""
"@cindex conditional evaluation\n"
"@cindex if\n"
"@cindex when\n"
"@cindex unless\n"
"@cindex case\n"
"@cindex cond"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:123
msgid ""
"Guile provides three syntactic constructs for conditional evaluation.\n"
"@code{if} is the normal if-then-else expression (with an optional else\n"
"branch), @code{cond} is a conditional expression with multiple branches\n"
"and @code{case} branches if an expression has one of a set of constant\n"
"values."
msgstr ""
"Guile предоставляет три синтаксические конструкции для условных вычислений.\n"
"@code{if} это обычное выражение if-then-else (с необязательной ветвью "
"else),\n"
"@code{cond} является условным выражением с множеством ветвей и \n"
"@code{case} выбирающее ветвь, если ключевое выражение имеет значение из "
"набора \n"
"константных значений в ветвях."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:131
msgid ""
"@deffn syntax if test consequent [alternate]\n"
"All arguments may be arbitrary expressions.  First, @var{test} is\n"
"evaluated.  If it returns a true value, the expression @var{consequent}\n"
"is evaluated and @var{alternate} is ignored.  If @var{test} evaluates to\n"
"@code{#f}, @var{alternate} is evaluated instead.  The values of the\n"
"evaluated branch (@var{consequent} or @var{alternate}) are returned as\n"
"the values of the @code{if} expression."
msgstr ""
"@deffn syntax if test consequent [alternate]\n"
"Все аргументы могут быть произвольными выражениями.  Сначала,\n"
"вычисляется @var{test}.  Если он возвращает истинное значение, вычисляется\n"
"выражение @var{consequent}, а @var{alternate} игнорируется.  Если "
"@var{test}\n"
"вычисляется в значение @code{#f}, вычисляется только @var{alternate}.  "
"Значения\n"
"вычисляемой ветви (@var{consequent} или @var{alternate}) возвращаются как "
"значения\n"
"выражения @code{if}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:135
msgid ""
"When @var{alternate} is omitted and the @var{test} evaluates to\n"
"@code{#f}, the value of the expression is not specified.\n"
"@end deffn"
msgstr ""
"Когда @var{alternate} пропущена и @var{test} вычисляется в @code{#f},\n"
"значение выражения не определено.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:142
msgid ""
"When you go to write an @code{if} without an alternate (a @dfn{one-armed\n"
"@code{if}}), part of what you are expressing is that you don't care\n"
"about the return value (or values) of the expression.  As such, you are\n"
"more interested in the @emph{effect} of evaluating the consequent\n"
"expression.  (By convention, we use the word @dfn{statement} to refer to\n"
"an expression that is evaluated for effect, not for value)."
msgstr ""
"Когда вы идете на написание @code{if} без альтернативы (однорукое условие\n"
"@dfn{one-armed @code{if}}), вас не волнует, возвращаемое значение(значения)\n"
"возвращаемые этим выражением. Таким образом, вас больше интересует\n"
"эффект(@emph{effect}) от вычисления последующего(consequent) выражения.\n"
"(По соглашени, мы используем слово оператор(@dfn{statement}) для ссылки на "
"выражение\n"
"которое вычисляется ради эффекта, а не ради значения)."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:147
msgid ""
"In such a case, it is considered more clear to express these intentions\n"
"with these special forms, @code{when} and @code{unless}.  As an added\n"
"bonus, these forms accept multiple statements to evaluate, which are\n"
"implicitly wrapped in a @code{begin}."
msgstr ""
"В таком случае, считается более ясным выразить эти намерения с помощью\n"
"специальных форм @code{when} и @code{unless}.  В качестве дополнительного\n"
"бонуса, эти формы принимают множественные операторы(statements) для "
"вычисления,\n"
"которые неявно обернуты в форму @code{begin}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:152
msgid ""
"@deffn {Scheme Syntax} when test statement1 statement2 ...\n"
"@deffnx {Scheme Syntax} unless test statement1 statement2 ...\n"
"The actual definitions of these forms are in many ways their most clear\n"
"documentation:"
msgstr ""
"@deffn {Scheme Syntax} when test statement1 statement2 ...\n"
"@deffnx {Scheme Syntax} unless test statement1 statement2 ...\n"
"Фактическое определение этих форм во многом является их наиболее\n"
"ясной документацией:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:156
msgid ""
"@example\n"
"(define-syntax-rule (when test stmt stmt* ...)\n"
"  (if test (begin stmt stmt* ...)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:160
msgid ""
"(define-syntax-rule (unless condition stmt stmt* ...)\n"
"  (if (not test) (begin stmt stmt* ...)))\n"
"@end example"
msgstr ""
"(define-syntax-rule (unless test stmt stmt* ...)\n"
"  (if (not test) (begin stmt stmt* ...)))\n"
"@end example"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:165
msgid ""
"That is to say, @code{when} evaluates its consequent statements in order\n"
"if @var{test} is true.  @code{unless} is the opposite: it evaluates the\n"
"statements if @var{test} is false.\n"
"@end deffn"
msgstr ""
"Можно сказать, @code{when} вычисляет последующие операторы по порядку,если\n"
"значение @var{test} истинно.  @code{unless} наоборот: вычисляет операторы "
"если\n"
"занчение @var{test} ложно.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:168
msgid ""
"@deffn syntax cond clause1 clause2 @dots{}\n"
"Each @code{cond}-clause must look like this:"
msgstr ""
"@deffn syntax cond clause1 clause2 @dots{}\n"
"Каждое предложение @code{cond}-clause должно выглядеть так:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:172
msgid ""
"@lisp\n"
"(@var{test} @var{expression} @dots{})\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:175
msgid ""
"where @var{test} and @var{expression} are arbitrary expressions, or like\n"
"this"
msgstr "где  @var{test} и @var{expression} произвольные вывражения, или так"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:179
msgid ""
"@lisp\n"
"(@var{test} => @var{expression})\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:181
msgid "where @var{expression} must evaluate to a procedure."
msgstr "где @var{expression} должно вычислять как процедуру."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:189
msgid ""
"The @var{test}s of the clauses are evaluated in order and as soon as one\n"
"of them evaluates to a true value, the corresponding @var{expression}s\n"
"are evaluated in order and the last value is returned as the value of\n"
"the @code{cond}-expression.  For the @code{=>} clause type,\n"
"@var{expression} is evaluated and the resulting procedure is applied to\n"
"the value of @var{test}.  The result of this procedure application is\n"
"then the result of the @code{cond}-expression."
msgstr ""
"@var{test} предложений вычисляются по порядку, и как только один из них\n"
"вычислит значение истина, вычисляется соответствующие выражения \n"
"@var{expression} по порядку, а значение последнего выражения возвращается\n"
"как значение всего выражения @code{cond}.  Для передложения типа @code{=>},\n"
"вычисляется выражение @var{expression} и результирующая процедура "
"применяется\n"
"к значению @var{test}.  Результат этого приенения процедуры явлляется \n"
"результатом всего выражения @code{cond}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:195
msgid ""
"@cindex SRFI-61\n"
"@cindex general cond clause\n"
"@cindex multiple values and cond\n"
"One additional @code{cond}-clause is available as an extension to\n"
"standard Scheme:"
msgstr ""
"@cindex SRFI-61\n"
"@cindex general cond clause\n"
"@cindex multiple values and cond\n"
"Одно дополнительное предложение @code{cond}-clause доступно как расширение\n"
"стандартной Scheme:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:199
msgid ""
"@lisp\n"
"(@var{test} @var{guard} => @var{expression})\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:209
msgid ""
"where @var{guard} and @var{expression} must evaluate to procedures.\n"
"For this clause type, @var{test} may return multiple values, and\n"
"@code{cond} ignores its boolean state; instead, @code{cond} evaluates\n"
"@var{guard} and applies the resulting procedure to the value(s) of\n"
"@var{test}, as if @var{guard} were the @var{consumer} argument of\n"
"@code{call-with-values}.  If the result of that procedure call is a\n"
"true value, it evaluates @var{expression} and applies the resulting\n"
"procedure to the value(s) of @var{test}, in the same manner as the\n"
"@var{guard} was called."
msgstr ""
"где @var{guard} и @var{expression} должны вычисляться как процедуры.\n"
"Для предложения этого типа, @var{test} может возвращать множественные\n"
"значекния и @code{cond} игнорирует его логическое состояни; вместо\n"
"этого, @code{cond} вычисляет @var{guard} применяя его к результирующим\n"
"значение(я) @var{test}, как если бы @var{guard} была потребителем\n"
"(@var{consumer}) аргументов в @code{call-with-values}.  Если результат\n"
"вызова процедуры возвратит истинное значение, вычисляется выражение\n"
"@var{expression} и результирующая процедура пременяется к значению(ям)\n"
"выражения @var{test}, также как вызывалась процедура @var{guard}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:215
msgid ""
"The @var{test} of the last @var{clause} may be the symbol @code{else}.\n"
"Then, if none of the preceding @var{test}s is true, the\n"
"@var{expression}s following the @code{else} are evaluated to produce the\n"
"result of the @code{cond}-expression.\n"
"@end deffn"
msgstr ""
"Тестом @var{test} последнего предложения @var{clause} может быть символ "
"@code{else}.\n"
"Затем, если ни один из предшествующих тестов @var{test} не равен истине, \n"
"вычисляются выражения @var{expression} следующие за @code{else} и "
"получаемый\n"
"результат будет результатом выражения @code{cond}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:218
msgid ""
"@deffn syntax case key clause1 clause2 @dots{}\n"
"@var{key} may be any expression, and the @var{clause}s must have the form"
msgstr ""
"@deffn syntax case key clause1 clause2 @dots{}\n"
"@var{key} может быть выражением, а @var{clause} должны иметь вид"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:222
msgid ""
"@lisp\n"
"((@var{datum1} @dots{}) @var{expr1} @var{expr2} @dots{})\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:224
msgctxt "/home/bear/work/guile/doc/guile/en/api-control.texi:224"
msgid "or"
msgstr "или"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:228
msgid ""
"@lisp\n"
"((@var{datum1} @dots{}) => @var{expression})\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:230
msgid "and the last @var{clause} may have the form"
msgstr "и последнее @var{clause} может иметь форму"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:234
msgid ""
"@lisp\n"
"(else @var{expr1} @var{expr2} @dots{})\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:236
msgctxt "/home/bear/work/guile/doc/guile/en/api-control.texi:236"
msgid "or"
msgstr "или"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:240
msgid ""
"@lisp\n"
"(else => @var{expression})\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:246
msgid ""
"All @var{datum}s must be distinct.  First, @var{key} is evaluated.  The\n"
"result of this evaluation is compared against all @var{datum} values using\n"
"@code{eqv?}.  When this comparison succeeds, the expression(s) following\n"
"the @var{datum} are evaluated from left to right, returning the value of\n"
"the last expression as the result of the @code{case} expression."
msgstr ""
"Все @var{datum} должны быть разными.  Сначала вычисляется @var{key}.  \n"
"Результат этого вычисления сравнивается со всеми @var{datum} значениями\n"
"используя @code{eqv?}.  Когда сравнение заканчивается успехом, выражения\n"
"следующее за @var{datum} вычисляются слева на право, результирующее "
"значение\n"
"последнего выражения является результатом всего выражения @code{case}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:251
msgid ""
"If the @var{key} matches no @var{datum} and there is an\n"
"@code{else}-clause, the expressions following the @code{else} are\n"
"evaluated.  If there is no such clause, the result of the expression is\n"
"unspecified."
msgstr ""
"Если @var{key} не соответствует ни одному @var{datum} и существует\n"
"предложение @code{else}, вычисляются следующие за @code{else} выражения.\n"
"Если такого предложения нет, результат выражения не определен."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:257
msgid ""
"For the @code{=>} clause types, @var{expression} is evaluated and the\n"
"resulting procedure is applied to the value of @var{key}.  The result of\n"
"this procedure application is then the result of the\n"
"@code{case}-expression.\n"
"@end deffn"
msgstr ""
"Для типа предложений @code{=>}, вычисляется @var{expression} и "
"результирующая\n"
"процедура применяется к занчению @var{key}.  Результат применения этой "
"процедуры\n"
"является результатом всего выражения @code{case}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:261
msgid ""
"@node and or\n"
"@subsection Conditional Evaluation of a Sequence of Expressions"
msgstr ""
"@node and or\n"
"@subsection Условное вычисление последовательности выражений"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:265
msgid ""
"@code{and} and @code{or} evaluate all their arguments in order, similar\n"
"to @code{begin}, but evaluation stops as soon as one of the expressions\n"
"evaluates to false or true, respectively."
msgstr ""
"@code{and} и @code{or} вычисляют все свои аргументы в порядке аналогичном\n"
"@code{begin}, но вычисление останавливается как только одно из выражений\n"
"вычисляется как ложное или истинное, соответственно."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:272
msgid ""
"@deffn syntax and expr @dots{}\n"
"Evaluate the @var{expr}s from left to right and stop evaluation as soon\n"
"as one expression evaluates to @code{#f}; the remaining expressions are\n"
"not evaluated.  The value of the last evaluated expression is returned.\n"
"If no expression evaluates to @code{#f}, the value of the last\n"
"expression is returned."
msgstr ""
"@deffn syntax and expr @dots{}\n"
"Вычисляет выражения формы @var{expr} слева на право и останавливает "
"вычисления\n"
"как только одно из выражений вычисляется в @code{#f} остальные выражения "
"не \n"
"вычисляются; Значение последнего вычисленного выражения возвращается\n"
"Если никакое выражение не вычисляется как @code{#f}, возвращается значение\n"
"последнего выражения."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:275
msgid ""
"If used without expressions, @code{#t} is returned.\n"
"@end deffn"
msgstr ""
"Если используется без выражений, возвращает @code{#t}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:282
msgid ""
"@deffn syntax or expr @dots{}\n"
"Evaluate the @var{expr}s from left to right and stop evaluation as soon\n"
"as one expression evaluates to a true value (that is, a value different\n"
"from @code{#f}); the remaining expressions are not evaluated.  The value\n"
"of the last evaluated expression is returned.  If all expressions\n"
"evaluate to @code{#f}, @code{#f} is returned."
msgstr ""
"@deffn syntax or expr @dots{}\n"
"Вычисляет вывражения формы @var{expr}s слева на право и останавливает\n"
"вычисления как только выражение возвращает истинное значение (т.е. значение\n"
"отличное от @code{#f}); остальные выражения не вычисляются.  Значение\n"
"последнего вычисленного выражения возвращается. Если все выражения "
"вычисляются\n"
"в @code{#f}, возвращается @code{#f}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:285
msgid ""
"If used without expressions, @code{#f} is returned.\n"
"@end deffn"
msgstr ""
"Если используется без выражений, возвращает @code{#f}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:289
msgid ""
"@node while do\n"
"@subsection Iteration mechanisms"
msgstr ""
"@node while do\n"
"@subsection Механизмы Итерации"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:293
msgid ""
"@cindex iteration\n"
"@cindex looping\n"
"@cindex named let"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:298
msgid ""
"Scheme has only few iteration mechanisms, mainly because iteration in\n"
"Scheme programs is normally expressed using recursion.  Nevertheless,\n"
"R5RS defines a construct for programming loops, calling @code{do}.  In\n"
"addition, Guile has an explicit looping syntax called @code{while}."
msgstr ""
"Scheme имеет несколько механизмов итерации, главным образом потому, что\n"
"итерация в программах  Scheme обычно выражается с помощью рекурсии.\n"
"Тем не менее,  R5RS определяет конструкцию для программирования циклов,\n"
"называемый @code{do}.  Кроме того, Guile имеет явный синтаксис цикла,\n"
"называемый @code{while}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:303
msgid ""
"@deffn syntax do ((variable init [step]) @dots{}) (test expr @dots{}) body "
"@dots{}\n"
"Bind @var{variable}s and evaluate @var{body} until @var{test} is true.\n"
"The return value is the last @var{expr} after @var{test}, if given.  A\n"
"simple example will illustrate the basic form,"
msgstr ""
"@deffn syntax do ((variable init [step]) @dots{}) (test expr @dots{}) body "
"@dots{}\n"
"Связывает переменные @var{variable}s и вычисляет тело @var{body} до тех пор "
"пока\n"
"@var{test} не вернет истину.\n"
"Возвращает значение выполнения последнего выражения @var{expr} следующих "
"после @var{test}, \n"
"если они есть.  Простой пример проилюстрирует основную форму,"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:310
msgid ""
"@example\n"
"(do ((i 1 (1+ i)))\n"
"    ((> i 4))\n"
"  (display i))\n"
"@print{} 1234\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:313
msgid ""
"@noindent\n"
"Or with two variables and a final return value,"
msgstr ""
"@noindent\n"
"Или с двумя переменными и возвращаемым окончательным значением,"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:328
msgid ""
"@example\n"
"(do ((i 1 (1+ i))\n"
"     (p 3 (* 3 p)))\n"
"    ((> i 4)\n"
"     p)\n"
"  (format #t \"3**~s is ~s\\n\" i p))\n"
"@print{}\n"
"3**1 is 3\n"
"3**2 is 9\n"
"3**3 is 27\n"
"3**4 is 81\n"
"@result{}\n"
"789\n"
"@end example"
msgstr ""
"@example\n"
"(do ((i 1 (1+ i))\n"
"     (p 3 (* 3 p)))\n"
"    ((> i 4)\n"
"     p)\n"
"  (format #t \"3**~s is ~s\\n\" i p))\n"
"@print{}\n"
"3**1 is 3\n"
"3**2 is 9\n"
"3**3 is 27\n"
"3**4 is 81\n"
"@result{}\n"
"243\n"
"@end example"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:333
msgid ""
"The @var{variable} bindings are established like a @code{let}, in that\n"
"the expressions are all evaluated and then all bindings made.  When\n"
"iterating, the optional @var{step} expressions are evaluated with the\n"
"previous bindings in scope, then new bindings all made."
msgstr ""
"Привязки переменных @var{variable} устанавливаются так же как @code{let}, \n"
"в котором все выражения вычисляются и все привязки выполяются.  При "
"итерации,\n"
"необязательные выражения @var{step} выполняются с предыдущими привязками в\n"
"области видимости, при этом создаются новые привязки."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:338
msgid ""
"The @var{test} expression is a termination condition.  Looping stops\n"
"when the @var{test} is true.  It's evaluated before running the\n"
"@var{body} each time, so if it's true the first time then @var{body}\n"
"is not run at all."
msgstr ""
"Выражение @var{test} является условием завершения. Цикл останавливается\n"
"когда значение выражения @var{test} становиться равным истине.  Оно\n"
"вычисляется каждый раз перед выполнением @var{body}, если в первый раз\n"
"оно вычисляется как истинное, @var{body} не вычисляется вообще."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:343
msgid ""
"The optional @var{expr}s after the @var{test} are evaluated at the end\n"
"of looping, with the final @var{variable} bindings available.  The\n"
"last @var{expr} gives the return value, or if there are no @var{expr}s\n"
"the return value is unspecified."
msgstr ""
"Не обязательные выражения @var{expr} после @var{test} выполняются в конце\n"
"цикла, с последними достпуными привязками переменных @var{variable}.  \n"
"Последнее @var{expr} дает возвращаемое значение, или если нет выражений "
"@var{expr}\n"
"возвращаемое значение неопределено."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:350
msgid ""
"Each iteration establishes bindings to fresh locations for the\n"
"@var{variable}s, like a new @code{let} for each iteration.  This is\n"
"done for @var{variable}s without @var{step} expressions too.  The\n"
"following illustrates this, showing how a new @code{i} is captured by\n"
"the @code{lambda} in each iteration (@pxref{About Closure,, The\n"
"Concept of Closure})."
msgstr ""
"Каждая итерация устанавливает привязки к новым местам для переменных\n"
"@var{variable}, подобно новому @code{let} для каждой итереации.  это\n"
"делается и для  переменных @var{variable} не имеющих выражений @var{step}.\n"
"Следующий пример это илюстрирует, показывая как новыая @code{i} "
"захыватывается\n"
" @code{lambda} на каждой итерации (@pxref{About Closure,, The\n"
"Concept of Closure})."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:361
msgid ""
"@example\n"
"(define lst '())\n"
"(do ((i 1 (1+ i)))\n"
"    ((> i 4))\n"
"  (set! lst (cons (lambda () i) lst)))\n"
"(map (lambda (proc) (proc)) lst)\n"
"@result{}\n"
"(4 3 2 1)\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:366
msgid ""
"@deffn syntax while cond body @dots{}\n"
"Run a loop executing the @var{body} forms while @var{cond} is true.\n"
"@var{cond} is tested at the start of each iteration, so if it's\n"
"@code{#f} the first time then @var{body} is not executed at all."
msgstr ""
"@deffn syntax while cond body @dots{}\n"
"Запускает цикл выполнения форм @var{body} пока выражение @var{cond} \n"
"равно истине. @var{cond} проверяется в начале каждой итерации, так что \n"
"если оно станет @code{#f} в самом начале, то @var{body} не будет \n"
"выполняться вообще."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:369
msgid ""
"Within @code{while}, two extra bindings are provided, they can be used\n"
"from both @var{cond} and @var{body}."
msgstr ""
"С @code{while}, предоставляются две дополнительные привязки, их можно "
"использовать\n"
"как из @var{cond} так и из @var{body}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:373
msgid ""
"@deffn {Scheme Procedure} break break-arg @dots{}\n"
"Break out of the @code{while} form.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} break break-arg @dots{}\n"
"Производит выход из формы @code{while}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:378
msgid ""
"@deffn {Scheme Procedure} continue\n"
"Abandon the current iteration, go back to the start and test\n"
"@var{cond} again, etc.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} continue\n"
"Отменяет текущую итерацию, возвращается в начало и снова выполняет\n"
"проверку @var{cond} и т.д.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:385
msgid ""
"If the loop terminates normally, by the @var{cond} evaluating to\n"
"@code{#f}, then the @code{while} expression as a whole evaluates to\n"
"@code{#f}.  If it terminates by a call to @code{break} with some number\n"
"of arguments, those arguments are returned from the @code{while}\n"
"expression, as multiple values.  Otherwise if it terminates by a call to\n"
"@code{break} with no arguments, then return value is @code{#t}."
msgstr ""
"Если цикл завершается нормально, когда @var{cond} вычисляется в\n"
"@code{#f}, тогда выражение the @code{while} в целом вычисляется как\n"
"@code{#f}.  Если оно завершается вызовом @code{break} с каким либо \n"
"количеством аргументв, эти аргументы возвращаются из выражения "
"@code{while},\n"
"как множественные значения.  В противном случае, если он завершается "
"вызовом\n"
"@code{break} без аргументов, он возвращает значение @code{#t}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:391
msgid ""
"@example\n"
"(while #f (error \"not reached\")) @result{} #f\n"
"(while #t (break)) @result{} #t\n"
"(while #t (break 1 2 3)) @result{} 1 2 3\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:396
msgid ""
"Each @code{while} form gets its own @code{break} and @code{continue}\n"
"procedures, operating on that @code{while}.  This means when loops are\n"
"nested the outer @code{break} can be used to escape all the way out.\n"
"For example,"
msgstr ""
"Каждая форма @code{while} получает свои собственные процедуры @code{break} \n"
"и @code{continue}, работающие на этом @code{while}.  Это означает, что "
"когда\n"
"циклы вложены, внешний @code{break} может быть использован для выхода из \n"
"всех внутренних циклов.\n"
"Например,"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:405
msgid ""
"@example\n"
"(while (test1)\n"
"  (let ((outer-break break))\n"
"    (while (test2)\n"
"      (if (something)\n"
"        (outer-break #f))\n"
"      ...)))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:410
msgid ""
"Note that each @code{break} and @code{continue} procedure can only be\n"
"used within the dynamic extent of its @code{while}.  Outside the\n"
"@code{while} their behaviour is unspecified.\n"
"@end deffn"
msgstr ""
"Обратите внимание, что каждая процедура @code{break} и @code{continue} "
"может\n"
"использоваться только в динамическом пространстве своего @code{while}. \n"
"Вне @code{while} его поведение не определено.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:414
msgid ""
"@cindex named let\n"
"Another very common way of expressing iteration in Scheme programs is\n"
"the use of the so-called @dfn{named let}."
msgstr ""
"@cindex named let\n"
"Другим очень распростарненным способом итерации в программах Scheme "
"является\n"
"использование так называемого Именованного let(@dfn{named let})."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:419
msgid ""
"Named let is a variant of @code{let} which creates a procedure and calls\n"
"it in one step.  Because of the newly created procedure, named let is\n"
"more powerful than @code{do}--it can be used for iteration, but also\n"
"for arbitrary recursion."
msgstr ""
"Именованный let это вариант @code{let}, который создает процедуру и\n"
"вызывает ее за один шаг.  Так как вновь создаваемая процедура, именованного\n"
"let более мощная процедура чем @code{do}-- она может быть использована не "
"только\n"
"для итерации, но и для произвольной рекурсии."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:423
msgid ""
"@deffn syntax let variable bindings body\n"
"For the definition of @var{bindings} see the documentation about\n"
"@code{let} (@pxref{Local Bindings})."
msgstr ""
"@deffn syntax let variable bindings body\n"
"Для определения @var{bindings} смотри документацию по\n"
"@code{let} (@pxref{Local Bindings})."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:425
msgid "Named @code{let} works as follows:"
msgstr "Именованный @code{let} работает следующим образом:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:432
msgid ""
"@itemize @bullet\n"
"@item\n"
"A new procedure which accepts as many arguments as are in @var{bindings}\n"
"is created and bound locally (using @code{let}) to @var{variable}.  The\n"
"new procedure's formal argument names are the name of the\n"
"@var{variables}."
msgstr ""
"@itemize @bullet\n"
"@item\n"
"Создается новая процедура, которая принимает столько аргументов, сколько\n"
"содержиться в @var{bindings} и связываются локально (используя @code{let}) \n"
"к @var{variable}.  Имена формальных аргументов новой процедуры это\n"
"имена переменных @var{variables}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:435
msgid ""
"@item\n"
"The @var{body} expressions are inserted into the newly created procedure."
msgstr ""
"@item\n"
"Выражения @var{body} вставляются во вновь созданную процедуру."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:440
msgid ""
"@item\n"
"The procedure is called with the @var{init} expressions as the formal\n"
"arguments.\n"
"@end itemize"
msgstr ""
"@item\n"
"Процедура вызывается с выражениями @var{init} в качестве формальных \n"
"аргументов.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:443
msgid ""
"The next example implements a loop which iterates (by recursion) 1000\n"
"times."
msgstr ""
"В следующем примере реализован цикл который повоторяется (рекурсивно) 1000\n"
"раз."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:453
msgid ""
"@lisp\n"
"(let lp ((x 1000))\n"
"  (if (positive? x)\n"
"      (lp (- x 1))\n"
"      x))\n"
"@result{}\n"
"0\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:461
msgid ""
"@node Prompts\n"
"@subsection Prompts\n"
"@cindex prompts\n"
"@cindex delimited continuations\n"
"@cindex composable continuations\n"
"@cindex non-local exit"
msgstr ""
"@node Prompts\n"
"@subsection Запросы(Prompts)\n"
"@cindex prompts\n"
"@cindex delimited continuations\n"
"@cindex composable continuations\n"
"@cindex non-local exit"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:467
msgid ""
"Prompts are control-flow barriers between different parts of a program. In "
"the\n"
"same way that a user sees a shell prompt (e.g., the Bash prompt) as a "
"barrier\n"
"between the operating system and her programs, Scheme prompts allow the "
"Scheme\n"
"programmer to treat parts of programs as if they were running in different\n"
"operating systems."
msgstr ""
"Запросы являются барьерами потока управления между различными частями "
"программы. \n"
"Таким же образом пользователь видит запрос(prompt) командной "
"оболочки(shell) \n"
"(например, приглашение/запрос Bash) как барьер между операционной системой "
"и\n"
"его программой, запросы Scheme позволяют программисту Scheme обрабатывать\n"
"части программы, как если бы они работали в разных операционных системах."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:472
msgid ""
"We use this roundabout explanation because, unless you're a functional\n"
"programming junkie, you probably haven't heard the term, ``delimited, "
"composable\n"
"continuation''. That's OK; it's a relatively recent topic, but a very "
"useful\n"
"one to know about."
msgstr ""
"Мы используем это окольное объяснение, потому что,  если вы не наркоман "
"функционального\n"
"программирования, то наверное не слышали термин ``разграниченное, составное "
"продолжение''.\n"
"Это ХОРОШО; это относительно новая тема, но очень полезная для понимания."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:477
msgid ""
"@menu\n"
"* Prompt Primitives::           Call-with-prompt and abort-to-prompt.\n"
"* Shift and Reset::             The zoo of delimited control operators.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:480
msgid ""
"@node Prompt Primitives\n"
"@subsubsection Prompt Primitives"
msgstr ""
"@node Prompt Primitives\n"
"@subsubsection Примитивы Запросов(Prompt)"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:483
msgid ""
"Guile's primitive delimited control operators are\n"
"@code{call-with-prompt} and @code{abort-to-prompt}."
msgstr ""
"Примитивы Guile разделяют управляющие операторы на\n"
"@code{call-with-prompt} и @code{abort-to-prompt}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:486
msgid ""
"@deffn {Scheme Procedure} call-with-prompt tag thunk handler\n"
"Set up a prompt, and call @var{thunk} within that prompt."
msgstr ""
"@deffn {Scheme Procedure} call-with-prompt tag thunk handler\n"
"Устанавливает запрос(prompt), и вызывает чанк(@var{thunk}) в этом "
"запросе(prompt)."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:491
msgid ""
"During the dynamic extent of the call to @var{thunk}, a prompt named "
"@var{tag}\n"
"will be present in the dynamic context, such that if a user calls\n"
"@code{abort-to-prompt} (see below) with that tag, control rewinds back to "
"the\n"
"prompt, and the @var{handler} is run."
msgstr ""
"Во время динамического распространения вызова чанка @var{thunk}, в "
"динамическом\n"
"контексте запроса(prompt) будет присутствовать метка с именем @var{tag}, "
"такая что,\n"
"если пользователь вызовет @code{abort-to-prompt} (смотри ниже) с этой "
"меткой(tag), \n"
"управление перейдет обратно в запрос(prompt), и будет запущен обработчик\n"
"@var{handler}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:497
msgid ""
"@var{handler} must be a procedure. The first argument to @var{handler} will "
"be\n"
"the state of the computation begun when @var{thunk} was called, and ending "
"with\n"
"the call to @code{abort-to-prompt}. The remaining arguments to @var{handler} "
"are\n"
"those passed to @code{abort-to-prompt}.\n"
"@end deffn"
msgstr ""
"@var{handler} должен быть процедурой. Первым аргументом обработчика "
"@var{handler} \n"
"будет состояние вычислений начавшихся когда был вызван чанк @var{thunk} и "
"закончившихся\n"
"когда был вызван @code{abort-to-prompt}. Остальные аргументы для обработчика "
"@var{handler}\n"
"это аргументы передаваемые в @code{abort-to-prompt}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:503
msgid ""
"@deffn {Scheme Procedure} make-prompt-tag [stem]\n"
"Make a new prompt tag.  A prompt tag is simply a unique object.\n"
"Currently, a prompt tag is a fresh pair.  This may change in some future\n"
"Guile version.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} make-prompt-tag [stem]\n"
"Создает новый тег запроса(prompt).  Тег запроса(prompt tag) это просто\n"
"уникальный объект. В настоящее время тег запроса это чистая пара. Это может\n"
"измениться в будущих версиях Guile.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:511
msgid ""
"@deffn {Scheme Procedure} default-prompt-tag\n"
"Return the default prompt tag.  Having a distinguished default prompt\n"
"tag allows some useful prompt and abort idioms, discussed in the next\n"
"section.  Note that @code{default-prompt-tag} is actually a parameter,\n"
"and so may be dynamically rebound using @code{parameterize}.\n"
"@xref{Parameters}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} default-prompt-tag\n"
"Возвращает тег запроса(prompt) по умолчанию.  Наличие отличительного тега\n"
"у запроса по умолчанию, позволяет создавать некоторые полезные запросы и\n"
"идиомы прерываний, обсуждаемые в следующем разделе.  Обратите внимание, что\n"
"@code{default-prompt-tag} на самом деле является параметром, и может быть\n"
"динамически перепривязан использованием @code{parameterize}.\n"
"@xref{Parameters}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:516
msgid ""
"@deffn {Scheme Procedure} abort-to-prompt tag val1 val2 @dots{}\n"
"Unwind the dynamic and control context to the nearest prompt named "
"@var{tag},\n"
"also passing the given values.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} abort-to-prompt tag val1 val2 @dots{}\n"
"Раскручивает динамический и управляющий контекст ближайшего запроса\n"
"с именем @var{tag}, а также передает предоставляемые значения.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:523
msgid ""
"C programmers may recognize @code{call-with-prompt} and @code{abort-to-"
"prompt}\n"
"as a fancy kind of @code{setjmp} and @code{longjmp}, respectively. Prompts "
"are\n"
"indeed quite useful as non-local escape mechanisms. Guile's @code{catch} "
"and\n"
"@code{throw} are implemented in terms of prompts. Prompts are more "
"convenient\n"
"than @code{longjmp}, in that one has the opportunity to pass multiple values "
"to\n"
"the jump target."
msgstr ""
"Си программисты могут увидеть в вызовах @code{call-with-prompt} и "
"@code{abort-to-prompt}\n"
"причудливые на вид @code{setjmp} и @code{longjmp}, соответственно. Запросы "
"действительно\n"
"весьма полезны в качестве не локального механизма выхода. Guile конструкции "
"@code{catch} и\n"
"@code{throw} реализованы в терминах запросов(prompts). Запросы(Prompts) "
"более удобны,\n"
"чем @code{longjmp}, так как они имеют возможность передавать несколько "
"значений цели\n"
"перехода."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:530
msgid ""
"Also unlike @code{longjmp}, the prompt handler is given the full state of "
"the\n"
"process that was aborted, as the first argument to the prompt's handler. "
"That\n"
"state is the @dfn{continuation} of the computation wrapped by the prompt. It "
"is\n"
"a @dfn{delimited continuation}, because it is not the whole continuation of "
"the\n"
"program; rather, just the computation initiated by the call to\n"
"@code{call-with-prompt}."
msgstr ""
"Кроме того, в отличии от @code{longjmp}, обработчик(handler) "
"запроса(prompt) \n"
"получает полное состояние процесса, который был прерван, как первый "
"аргумент\n"
"обработчика(prompt handler). Это состояние является "
"продолжением(@dfn{continuation})\n"
"вычисления, заключенного в запрос(prompt). Это и есть разделенное "
"продолжение\n"
"(@dfn{delimited continuation}), потому что это не всё продолжение "
"программы;\n"
"скорее , это просто вычисление начатое вызовом @code{call-with-prompt}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:536
msgid ""
"The continuation is a procedure, and may be reinstated simply by invoking "
"it,\n"
"with any number of values. Here's where things get interesting, and "
"complicated\n"
"as well. Besides being described as delimited, continuations reified by "
"prompts\n"
"are also @dfn{composable}, because invoking a prompt-saved continuation "
"composes\n"
"that continuation with the current one."
msgstr ""
"Продолжение является процедурой, и его можно восстановить просто вызвав "
"его,\n"
"с любым количеством значений. Здесь все становиться интересным и сложным. "
"Кроме\n"
"того описываемые как разделенные, продолжения, ограниченные "
"запросами(prompts),\n"
"также являются составными(@dfn{composable}), потому что вызов сохраненного "
"запроса\n"
"(prompt-saved) продолжения составляет это продолжение с текущим."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:538
msgid "Imagine you have saved a continuation via call-with-prompt:"
msgstr "Представьте что вы сохранили продолжение с помощью call-with-prompt:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:550
msgid ""
"@example\n"
"(define cont\n"
"  (call-with-prompt\n"
"   ;; tag\n"
"   'foo\n"
"   ;; thunk\n"
"   (lambda ()\n"
"     (+ 34 (abort-to-prompt 'foo)))\n"
"   ;; handler\n"
"   (lambda (k) k)))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:552
msgid ""
"The resulting continuation is the addition of 34. It's as if you had written:"
msgstr ""
"В результате вы получает продолжение добавляющее 34. Это как если бы вы "
"написали:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:558
msgid ""
"@example\n"
"(define cont\n"
"  (lambda (x)\n"
"    (+ 34 x)))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:561
msgid ""
"So, if we call @code{cont} with one numeric value, we get that number,\n"
"incremented by 34:"
msgstr ""
"Итак, если мы вызовем @code{cont} с одним числовым значением, мы получим "
"это\n"
"число увеличенное на 34:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:568
msgid ""
"@example\n"
"(cont 8)\n"
"@result{} 42\n"
"(* 2 (cont 8))\n"
"@result{} 84\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:574
msgid ""
"The last example illustrates what we mean when we say, \"composes with the\n"
"current continuation\". We mean that there is a current continuation -- "
"some\n"
"remaining things to compute, like @code{(lambda (x) (* x 2))} -- and that\n"
"calling the saved continuation doesn't wipe out the current continuation, "
"it\n"
"composes the saved continuation with the current one."
msgstr ""
"Последний пример иллюстрирует то, что мы имеем в виду, когда говорим, \n"
"составляется с текущим продолжением (\"composes with the current continuation"
"\").\n"
"Мы имеем в виду, что есть текущее продолжение --- некоторое оставшееся \n"
"вычисление, такое как @code{(lambda (x) (* x 2))} -- и что вызов "
"сохраненного\n"
"продолжения не стирает текущее продолжение, он составляет сохраненное "
"продолжение\n"
"с текущим."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:579
msgid ""
"We're belaboring the point here because traditional Scheme continuations, "
"as\n"
"discussed in the next section, aren't composable, and are actually less\n"
"expressive than continuations captured by prompts. But there's a place for "
"them\n"
"both."
msgstr ""
"Мы обсуждаем этот вопрос здесь, потому что традиционные продолжения Scheme, "
"какие\n"
"обсуждаются в следующем разделе, не являются соединяемыми и на самом деле\n"
"менее выразительны, чем продолжения захваченные с помощью "
"запросов(prompts).\n"
"Но тут есть место для них обоих."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:584
msgid ""
"Before moving on, we should mention that if the handler of a prompt is a\n"
"@code{lambda} expression, and the first argument isn't referenced, an abort "
"to\n"
"that prompt will not cause a continuation to be reified.  This can be an\n"
"important efficiency consideration to keep in mind."
msgstr ""
"Прежде чем двигаться дальше, мы должны упомянуть, что если обработчик "
"запроса\n"
"является @code{lambda} выражением, и не ссылается на свой первый аргумент, "
"прерывание\n"
"этого запроса(prompt) не вызовет создания продолжения.  Это может быть "
"важным\n"
"фактором эффективности, который следует помнить."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:591
msgid ""
"@cindex continuation, escape\n"
"One example where this optimization matters is @dfn{escape\n"
"continuations}.  Escape continuations are delimited continuations whose\n"
"only use is to make a non-local exit---i.e., to escape from the current\n"
"continuation.  A common use of escape continuations is when throwing an\n"
"exception (@pxref{Exceptions})."
msgstr ""
"@cindex continuation, escape\n"
"Одним из примеров, где эта оптимизация имеет значение являются escape\n"
"продолжения (@dfn{escape continuations}).  Escape-продолжения, являются\n"
"разделенными продолжениями, единственное использование которых -- создать\n"
"нелокальный выход, т.е убежать(escape) из текущего продолжения. \n"
"Обычное использование escape-продолжений это выбрасывание исключений.\n"
"(@pxref{Exceptions})."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:594
msgid ""
"The constructs below are syntactic sugar atop prompts to simplify the\n"
"use of escape continuations."
msgstr ""
"Приведенные ниже конструкции представляют собой синтаксический сахар над\n"
"запросами(propts), упрощающий использование escape-продолжений."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:598
msgid ""
"@deffn {Scheme Procedure} call-with-escape-continuation proc\n"
"@deffnx {Scheme Procedure} call/ec proc\n"
"Call @var{proc} with an escape continuation."
msgstr ""
"@deffn {Scheme Procedure} call-with-escape-continuation proc\n"
"@deffnx {Scheme Procedure} call/ec proc\n"
"Вызывает @var{proc} с escape-продолжением."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:601
msgid ""
"In the example below, the @var{return} continuation is used to escape\n"
"the continuation of the call to @code{fold}."
msgstr ""
"В приведенном ниже примере, возвращаемое @var{return} продолжение "
"используется\n"
"для выхода(побега) из продолжения вызова @code{fold}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:605
msgid ""
"@lisp\n"
"(use-modules (ice-9 control)\n"
"             (srfi srfi-1))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:617
msgid ""
"(define (prefix x lst)\n"
"  ;; Return all the elements before the first occurrence\n"
"  ;; of X in LST.\n"
"  (call/ec\n"
"    (lambda (return)\n"
"      (fold (lambda (element prefix)\n"
"              (if (equal? element x)\n"
"                  (return (reverse prefix))  ; escape `fold'\n"
"                  (cons element prefix)))\n"
"            '()\n"
"            lst))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:622
msgid ""
"(prefix 'a '(0 1 2 a 3 4 5))\n"
"@result{} (0 1 2)\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:626
msgid ""
"@deffn {Scheme Syntax} let-escape-continuation k body @dots{}\n"
"@deffnx {Scheme Syntax} let/ec k body @dots{}\n"
"Bind @var{k} within @var{body} to an escape continuation."
msgstr ""
"@deffn {Scheme Syntax} let-escape-continuation k body @dots{}\n"
"@deffnx {Scheme Syntax} let/ec k body @dots{}\n"
"Связывает @var{k} внутри @var{body} с escape-продолжением."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:630
msgid ""
"This is equivalent to\n"
"@code{(call/ec (lambda (@var{k}) @var{body} @dots{}))}.\n"
"@end deffn"
msgstr ""
"Это эквивалентно\n"
"@code{(call/ec (lambda (@var{k}) @var{body} @dots{}))}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:633
msgid ""
"Additionally there is another helper primitive exported by @code{(ice-9\n"
"control)}, so load up that module for @code{suspendable-continuation?}:"
msgstr ""
"Кроме того, есть еще один вспомогательный примитив, экспортируемый  "
"@code{(ice-9\n"
"control)}, поэтому загрузите этот модуль для использования\n"
"@code{suspendable-continuation?}:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:637
msgctxt "/home/bear/work/guile/doc/guile/en/api-control.texi:637"
msgid ""
"@example\n"
"(use-modules (ice-9 control))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:642
msgid ""
"@deffn {Scheme Procedure} suspendable-continuation? tag\n"
"Return @code{#t} if a call to @code{abort-to-prompt} with the prompt tag\n"
"@var{tag} would produce a delimited continuation that could be resumed\n"
"later."
msgstr ""
"@deffn {Scheme Procedure} suspendable-continuation? tag\n"
"Возвращает @code{#t} если вызов @code{abort-to-prompt} с тегом запроса\n"
"(prompt tag) @var{tag} приведет к созданию разделенного продолжения, "
"которое\n"
"может быть возобновлено позже."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:654
msgid ""
"Almost all continuations have this property.  The exception is where\n"
"some code between the @code{call-with-prompt} and the\n"
"@code{abort-to-prompt} recursed through C for some reason, the\n"
"@code{abort-to-prompt} will succeed but any attempt to resume the\n"
"continuation (by calling it) would fail.  This is because composing a\n"
"saved continuation with the current continuation involves relocating the\n"
"stack frames that were saved from the old stack onto a (possibly) new\n"
"position on the new stack, and Guile can only do this for stack frames\n"
"that it created for Scheme code, not stack frames created by the C\n"
"compiler.  It's a bit gnarly but if you stick with Scheme, you won't\n"
"have any problem."
msgstr ""
"Почти все продолжения имеют это свойство.  Исключением является случай,\n"
"когда между @code{call-with-prompt} и вызов @code{abort-to-prompt} \n"
"повторяются через Си по нескольким причинам,\n"
"@code{abort-to-prompt} будет успешным, но любая попытка возобновить\n"
"продолжение( вызвав его) потерпит неудачу. Это потому, что составление\n"
"сохраненного продолжения с текущим продолжением сопряжено с перемещением\n"
"кадров стека, которые были сохранены из старого стека на (возможно) новую\n"
"позицию нового стека, и Guile может это сделать только для кадров стека\n"
"созданных для  кода Scheme, а не кадров стека созданных Си компилятором.\n"
"Это немного грубовато, но если вы будете придерживаться Scheme, у вас не\n"
"будет проблем."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:658
msgid ""
"If no prompt is found with the given tag, this procedure just returns\n"
"@code{#f}.\n"
"@end deffn"
msgstr ""
"Если запрос с данным тегом не найден, эта процедура просто возвращает\n"
"@code{#f}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:661
msgid ""
"@node Shift and Reset\n"
"@subsubsection Shift, Reset, and All That"
msgstr ""
"@node Shift and Reset\n"
"@subsubsection Сдвиг(Shift), Переустановка(Reset), и все такое."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:665
msgid ""
"There is a whole zoo of delimited control operators, and as it does not\n"
"seem to be a bounded set, Guile implements support for them in a\n"
"separate module:"
msgstr ""
"Существует целый зоопарк операторов управления с разделителями, и как\n"
"представляется он не ограничивается этим набором, Guile реализует их \n"
"поддержку в отдельном модуле:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:669
msgctxt "/home/bear/work/guile/doc/guile/en/api-control.texi:669"
msgid ""
"@example\n"
"(use-modules (ice-9 control))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:672
msgid ""
"Firstly, we have a helpful abbreviation for the @code{call-with-prompt}\n"
"operator."
msgstr ""
"Во первых, у нас есть полезное сокращение для оператора @code{call-with-"
"prompt}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:678
msgid ""
"@deffn {Scheme Syntax} % expr\n"
"@deffnx {Scheme Syntax} % expr handler\n"
"@deffnx {Scheme Syntax} % tag expr handler\n"
"Evaluate @var{expr} in a prompt, optionally specifying a tag and a\n"
"handler.  If no tag is given, the default prompt tag is used."
msgstr ""
"@deffn {Scheme Syntax} % expr\n"
"@deffnx {Scheme Syntax} % expr handler\n"
"@deffnx {Scheme Syntax} % tag expr handler\n"
"Вычисляет выражение @var{expr} в запросе(prompt), опционально указывается "
"тег(tag)\n"
"и обработчик(handler).  Если тега нет, по умолчанию используется тег "
"подсказки по\n"
"умолчанию."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:682
msgid ""
"If no handler is given, a default handler is installed.  The default\n"
"handler accepts a procedure of one argument, which will called on the\n"
"captured continuation, within a prompt."
msgstr ""
"Если обработчик не указан, устанавливается обработчик по умолчанию.  "
"Обработчик\n"
"по умолчанию  принимает процедуру одного аргумента, которая будет \n"
"вызываться на захваченном продолжении, в пределах запроса."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:684
msgid "Sometimes it's easier just to show code, as in this case:"
msgstr "Иногда проще показать код, как в этом случае:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:691
msgid ""
"@example\n"
"(define (default-prompt-handler k proc)\n"
"  (% (default-prompt-tag)\n"
"     (proc k)\n"
"     default-prompt-handler))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:694
msgid ""
"The @code{%} symbol is chosen because it looks like a prompt.\n"
"@end deffn"
msgstr ""
"Символьный знак @code{%} выбран потому, что он выглядит как запрос.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:697
msgid ""
"Likewise there is an abbreviation for @code{abort-to-prompt}, which\n"
"assumes the default prompt tag:"
msgstr ""
"Аналогично, существует сокращение для @code{abort-to-prompt}, которое\n"
"принимает метку запоса по умолчанию(default prompt tag):"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:702
msgid ""
"@deffn {Scheme Procedure} abort val1 val2 @dots{}\n"
"Abort to the default prompt tag, passing @var{val1} @var{val2} @dots{}\n"
"to the handler.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} abort val1 val2 @dots{}\n"
"Прерывает запрос по умолчанию с меткой, передавая обработчику \n"
"@var{val1} @var{val2} @dots{}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:707
msgid ""
"As mentioned before, @code{(ice-9 control)} also provides other\n"
"delimited control operators.  This section is a bit technical, and\n"
"first-time users of delimited continuations should probably come back to\n"
"it after some practice with @code{%}."
msgstr ""
"Как упоминалось ранее, @code{(ice-9 control)} также предоставляет другие\n"
"операторы управления разделениями.  Этот раздел является немного "
"техническим,\n"
"и начинающим пользователям работающим с разделенными продолжениями, "
"вероятно\n"
"стоит вернуться к нему после некоторой практики работы с @code{%}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:714
msgid ""
"Still here?  So, when one implements a delimited control operator like\n"
"@code{call-with-prompt}, one needs to make two decisions.  Firstly, does\n"
"the handler run within or outside the prompt?  Having the handler run\n"
"within the prompt allows an abort inside the handler to return to the\n"
"same prompt handler, which is often useful.  However it prevents tail\n"
"calls from the handler, so it is less general."
msgstr ""
"Вы все еще здесь?  Итак, когда реализуется операто управления разделениями,\n"
"подобный @code{call-with-prompt}, нужно принять два решения.  Первое, "
"работает\n"
"ли обработчик внутри или снаружи запроса?  Наличие обработчика "
"запускаемого \n"
"в запросе позволяет превать внутри и вернуться к тому же обработчику "
"запроса,\n"
"что часто бывает полезно. Однако это предотвращает хвостовые вызовы от\n"
"обработчика, поэтому он менее общий."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:717
msgid ""
"Similarly, does invoking a captured continuation reinstate a prompt?\n"
"Again we have the tradeoff of convenience versus proper tail calls."
msgstr ""
"Аналогично, вызывает ли захваченное продолжение восстановление "
"запроса(prompt)?\n"
"Снова у нас есть компромисс между удобством и  правильными хвостовыми "
"вызовами."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:722
msgid ""
"These decisions are captured in the Felleisen @dfn{F} operator.  If\n"
"neither the continuations nor the handlers implicitly add a prompt, the\n"
"operator is known as @dfn{--F--}.  This is the case for Guile's\n"
"@code{call-with-prompt} and @code{abort-to-prompt}."
msgstr ""
"Эти решения фиксируются в операторе Феллайзена(Felleisen) @dfn{F}.  Если\n"
"ни одно продолжение не имеет обработчиков неявно добавляется запрос, "
"оператор\n"
"известный как @dfn{--F--}.  Этот случай для Guile @code{call-with-prompt}\n"
"и @code{abort-to-prompt}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:726
msgid ""
"If both continuation and handler implicitly add prompts, then the\n"
"operator is @dfn{+F+}.  @code{shift} and @code{reset} are such\n"
"operators."
msgstr ""
"Если оба, продолжение и обработчик неявно добавляют запрос, то оператор\n"
"будет @dfn{+F+}.  @code{shift} и @code{reset} являются такими операторами."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:730
msgid ""
"@deffn {Scheme Syntax} reset body1 body2 @dots{}\n"
"Establish a prompt, and evaluate @var{body1} @var{body2} @dots{} within\n"
"that prompt."
msgstr ""
"@deffn {Scheme Syntax} reset body1 body2 @dots{}\n"
"Устанавливают запрос, и вычисляют @var{body1} @var{body2} @dots{} в этом\n"
"запросе."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:734
msgid ""
"The prompt handler is designed to work with @code{shift}, described\n"
"below.\n"
"@end deffn"
msgstr ""
"Обработчик запроса предназначенный для работы с @code{shift}, описан ниже.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:739
msgid ""
"@deffn {Scheme Syntax} shift cont body1 body2 @dots{}\n"
"Abort to the nearest @code{reset}, and evaluate @var{body1} @var{body2}\n"
"@dots{} in a context in which the captured continuation is bound to\n"
"@var{cont}."
msgstr ""
"@deffn {Scheme Syntax} shift cont body1 body2 @dots{}\n"
"Прерывает до ближайшего @code{reset}, и вычисляет @var{body1} @var{body2}\n"
"@dots{} в контексте, в котором захваченное продолжение связано с \n"
"@var{cont}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:744
msgid ""
"As mentioned above, taken together, the @var{body1} @var{body2} @dots{}\n"
"expressions and the invocations of @var{cont} implicitly establish a\n"
"prompt.\n"
"@end deffn"
msgstr ""
"Как упоминалось выше, вместе взятые выражения the @var{body1} @var{body2} "
"@dots{}\n"
"и вызовы @var{cont} неявно устанавливают запрос(prompt).\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:748
msgid ""
"Interested readers are invited to explore Oleg Kiselyov's wonderful web\n"
"site at @uref{http://okmij.org/ftp/}, for more information on these\n"
"operators."
msgstr ""
"Заинтересованным читателям предлагается ознакомиться с замечательным сайтом\n"
"Олега Киселёва по адресу @uref{http://okmij.org/ftp/}, для получения "
"дополнительной\n"
"информации об этих операторах."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:753
msgid ""
"@node Continuations\n"
"@subsection Continuations\n"
"@cindex continuations"
msgstr ""
"@node Continuations\n"
"@subsection Продолжения\n"
"@cindex continuations"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:756
msgid ""
"A ``continuation'' is the code that will execute when a given function\n"
"or expression returns.  For example, consider"
msgstr ""
"Продолжение(``continuation'') это код, который будет выполняться когда\n"
"функция или выражение завершиться(возвратит управление). Например, \n"
"рассмотрим"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:763
msgid ""
"@example\n"
"(define (foo)\n"
"  (display \"hello\\n\")\n"
"  (display (bar)) (newline)\n"
"  (exit))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:767
msgid ""
"The continuation from the call to @code{bar} comprises a\n"
"@code{display} of the value returned, a @code{newline} and an\n"
"@code{exit}.  This can be expressed as a function of one argument."
msgstr ""
"Продолжение из вызова @code{bar} содержит\n"
"@code{display} возвращенного значения, и вызовы функций @code{newline} и\n"
"@code{exit}.  Это может быть выражено как функция одного аргумента."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:773
msgid ""
"@example\n"
"(lambda (r)\n"
"  (display r) (newline)\n"
"  (exit))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:778
msgid ""
"In Scheme, continuations are represented as special procedures just\n"
"like this.  The special property is that when a continuation is called\n"
"it abandons the current program location and jumps directly to that\n"
"represented by the continuation."
msgstr ""
"В Scheme, продолжения представлены в виде специальных процедур, подобнгых\n"
"этой. Специальное свойство заключается в том, что когда вызывается "
"продолжение,\n"
"оно оставляет текущее местоположение программы и переходит непосредственно "
"к\n"
"тому, которое представлено продолжением."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:782
msgid ""
"A continuation is like a dynamic label, capturing at run-time a point\n"
"in program execution, including all the nested calls that have lead to\n"
"it (or rather the code that will execute when those calls return)."
msgstr ""
"Продолжение похоже на динамическую метку, фиксирующую во время выполнения\n"
"точку выполнения программы, включая все вложенные вызовы, которые привели "
"к \n"
"ней(или скорее код, который будет выполнен, когда эти вызовы завершаться)."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:784
msgid "Continuations are created with the following functions."
msgstr "Продолжения создаются следующими функциями."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:792
msgid ""
"@deffn {Scheme Procedure} call-with-current-continuation proc\n"
"@deffnx {Scheme Procedure} call/cc proc\n"
"@rnindex call-with-current-continuation\n"
"Capture the current continuation and call @code{(@var{proc}\n"
"@var{cont})} with it.  The return value is the value returned by\n"
"@var{proc}, or when @code{(@var{cont} @var{value})} is later invoked,\n"
"the return is the @var{value} passed."
msgstr ""
"@deffn {Scheme Procedure} call-with-current-continuation proc\n"
"@deffnx {Scheme Procedure} call/cc proc\n"
"@rnindex call-with-current-continuation\n"
"Захватывает текущее продолжение и вызывает процедуру @code{(@var{proc}\n"
"@var{cont})}  с ним.  Возвращаемое значение является значением возвращаемым\n"
"@var{proc}, или когда @code{(@var{cont} @var{value})} вызывается позже,\n"
"возвращается переданное значение @var{value}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:797
msgid ""
"Normally @var{cont} should be called with one argument, but when the\n"
"location resumed is expecting multiple values (@pxref{Multiple\n"
"Values}) then they should be passed as multiple arguments, for\n"
"instance @code{(@var{cont} @var{x} @var{y} @var{z})}."
msgstr ""
"Обысно @var{cont} должен вызываться с одним аргументом, но когда "
"местоположение\n"
"возобновляется ожидается множественное значение (@pxref{Multiple\n"
"Values}) затем они должны быть переданы в виде нескольких аргументов, для\n"
"экземпляра продолжения @code{(@var{cont} @var{x} @var{y} @var{z})}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:801
msgid ""
"@var{cont} may only be used from the same side of a continuation\n"
"barrier as it was created (@pxref{Continuation Barriers}), and in a\n"
"multi-threaded program only from the thread in which it was created."
msgstr ""
"@var{cont} может использоваться только с той же стороны от барьера\n"
"продолжения, с какой оно было создано (@pxref{Continuation Barriers}), \n"
"и в много-поточных программах, только из той же ветки, в которой оно\n"
"было создано."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:806
msgid ""
"The call to @var{proc} is not part of the continuation captured, it runs\n"
"only when the continuation is created.  Often a program will want to\n"
"store @var{cont} somewhere for later use; this can be done in\n"
"@var{proc}."
msgstr ""
"Вызов @var{proc} не является частью захваченного продолжения, оно "
"выполняется\n"
"только тогда, когда продолжение создается. Часто программа захочет хранить\n"
"продолжение @var{cont} где то, для использования в дальнейшем; это можно "
"сделать\n"
"в процедуре @var{proc}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:811
msgid ""
"The @code{call} in the name @code{call-with-current-continuation}\n"
"refers to the way a call to @var{proc} gives the newly created\n"
"continuation.  It's not related to the way a call is used later to\n"
"invoke that continuation."
msgstr ""
"Слово @code{call} в имени @code{call-with-current-continuation}\n"
"относиться к способу вызова процедуры @var{proc} передавая ей\n"
"вновь созданное продолжения. Это не связано с тем, как используется\n"
"вызов позже, чтобы вызывать продолжение."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:815
msgid ""
"@code{call/cc} is an alias for @code{call-with-current-continuation}.\n"
"This is in common use since the latter is rather long.\n"
"@end deffn"
msgstr ""
"@code{call/cc} это псевноним для @code{call-with-current-continuation}.\n"
"Он для общего использования, так как последнее имя довольно длинное.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:819
msgid ""
"@sp 1\n"
"@noindent\n"
"Here is a simple example,"
msgstr ""
"@sp 1\n"
"@noindent\n"
"Вот простой пример,"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:827
msgid ""
"@example\n"
"(define kont #f)\n"
"(format #t \"the return is ~a\\n\"\n"
"        (call/cc (lambda (k)\n"
"                   (set! kont k)\n"
"                   1)))\n"
"@result{} the return is 1"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:831
msgid ""
"(kont 2)\n"
"@result{} the return is 2\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:837
msgid ""
"@code{call/cc} captures a continuation in which the value returned is\n"
"going to be displayed by @code{format}.  The @code{lambda} stores this\n"
"in @code{kont} and gives an initial return @code{1} which is\n"
"displayed.  The later invocation of @code{kont} resumes the captured\n"
"point, but this time returning @code{2}, which is displayed."
msgstr ""
"@code{call/cc} захватывает продолжение, в котором возвращаемое значение\n"
"будет отображаться с помощью @code{format}.  Функция @code{lambda} "
"сохраняет\n"
"данное продолжение в @code{kont} и делает начальный возврат значения "
"равного\n"
"@code{1} который и отображается. Более поздний вызов @code{kont} "
"возобновляет\n"
"захваченную точку, но на этот раз возвращает @code{2}, которое и "
"отображается."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:842
msgid ""
"When Guile is run interactively, a call to @code{format} like this has\n"
"an implicit return back to the read-eval-print loop.  @code{call/cc}\n"
"captures that like any other return, which is why interactively\n"
"@code{kont} will come back to read more input."
msgstr ""
"Когда Guile запускается интерактивно, вызов такого @code{format} неявно\n"
"возвращается назад в цикл REPL(read-eval-print loop).  @code{call/cc}\n"
"перехватывает это как и любой другой возврат, вот почему интерактивно\n"
"@code{kont} выполнит возврат, чтобы читать ввод дальше."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:851
msgid ""
"@sp 1\n"
"C programmers may note that @code{call/cc} is like @code{setjmp} in\n"
"the way it records at runtime a point in program execution.  A call to\n"
"a continuation is like a @code{longjmp} in that it abandons the\n"
"present location and goes to the recorded one.  Like @code{longjmp},\n"
"the value passed to the continuation is the value returned by\n"
"@code{call/cc} on resuming there.  However @code{longjmp} can only go\n"
"up the program stack, but the continuation mechanism can go anywhere."
msgstr ""
"@sp 1\n"
"Си программисты могут заметить, что @code{call/cc} подобен @code{setjmp}\n"
"в том, как он записывает во время выполнения точку выполнения программы.\n"
"А вызов продолжения подобен @code{longjmp} в том смысле, что он покидает\n"
"текущее местоположение и переходит к записанному. Как и @code{longjmp},\n"
"значение передаваемое в продолжение является значением возвращаемым\n"
"@code{call/cc} при возобновлении там.  Однако @code{longjmp} может идти\n"
"только вверх, по стеку программ, но механизм продолжений может идти куда\n"
"угодно."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:857
msgid ""
"When a continuation is invoked, @code{call/cc} and subsequent code\n"
"effectively ``returns'' a second time.  It can be confusing to imagine\n"
"a function returning more times than it was called.  It may help\n"
"instead to think of it being stealthily re-entered and then program\n"
"flow going on as normal."
msgstr ""
"Когда вызывается продолжение, @code{call/cc} и последующий код\n"
"эффективно  ``возвращаются(returns)'' повторно.  Может показаться\n"
"странным, что функция возвращается больше раз, чем она была вызвана.\n"
"Вместо этого может помочь мысль о том, что она тайно повторно\n"
"перевходит и затем поток программы следует как обычно."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:861
msgid ""
"@code{dynamic-wind} (@pxref{Dynamic Wind}) can be used to ensure setup\n"
"and cleanup code is run when a program locus is resumed or abandoned\n"
"through the continuation mechanism."
msgstr ""
"@code{dynamic-wind} (@pxref{Dynamic Wind}) может использоваться для\n"
"обеспечения  кода установки и кода очистк, запускаемого когда локус\n"
"программы возобновляется или отменяется через механизм продолжения."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:866
msgid ""
"@sp 1\n"
"Continuations are a powerful mechanism, and can be used to implement\n"
"almost any sort of control structure, such as loops, coroutines, or\n"
"exception handlers."
msgstr ""
"@sp 1\n"
"Продолжения являются мощным механизмом, и могут использоваться для "
"реализации\n"
"практически любого вида структур управления, таких как циклы, сопрограммы "
"или\n"
"обработка исключений."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:872
msgid ""
"However the implementation of continuations in Guile is not as\n"
"efficient as one might hope, because Guile is designed to cooperate\n"
"with programs written in other languages, such as C, which do not know\n"
"about continuations.  Basically continuations are captured by a block\n"
"copy of the stack, and resumed by copying back."
msgstr ""
"Однако реализация продолжений в Guile не так эффективна, какой она могла\n"
"бы быть, поскольку Guile предназначен для взаимодействия с программами\n"
"написанными на других языках, таких как Си, которые не знают о "
"продолжениях.\n"
"В основном продолжения захватываются копированием блока стека, и "
"возобновляются\n"
"копированием блока обратно."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:876
msgid ""
"For this reason, continuations captured by @code{call/cc} should be used "
"only\n"
"when there is no other simple way to achieve the desired result, or when "
"the\n"
"elegance of the continuation mechanism outweighs the need for performance."
msgstr ""
"По этой причине, продолжения захваченные с помощью @code{call/cc} должны "
"использоваться\n"
"только когда нет другого простого способа достижения желаемого результата, "
"или когда\n"
"элегантность механизма продолжения перевешивает необходимость в "
"быстродействии."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:882
msgid ""
"Escapes upwards from loops or nested functions are generally best\n"
"handled with prompts (@pxref{Prompts}).  Coroutines can be\n"
"efficiently implemented with cooperating threads (a thread holds a\n"
"full program stack but doesn't copy it around the way continuations\n"
"do)."
msgstr ""
"Побеги(Escapes) из всех циклов или вложенных функций обычно лучше всего\n"
"обрабатываются с помощью запросов(prompts) (@pxref{Prompts}).  Сопрограммы\n"
"(Coroutines) могут быть эффективно реализованы с помощью взаимодействующих\n"
"потоков(cooperating threads) (поток содержит полный программный стек, но\n"
"не копирует его, как это делает продолжение)."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:886
msgid ""
"@node Multiple Values\n"
"@subsection Returning and Accepting Multiple Values"
msgstr ""
"@node Multiple Values\n"
"@subsection Возврат и Прием Множества значений."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:889
msgid ""
"@cindex multiple values\n"
"@cindex receive"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:896
msgid ""
"Scheme allows a procedure to return more than one value to its caller.\n"
"This is quite different to other languages which only allow\n"
"single-value returns.  Returning multiple values is different from\n"
"returning a list (or pair or vector) of values to the caller, because\n"
"conceptually not @emph{one} compound object is returned, but several\n"
"distinct values."
msgstr ""
"Scheme позволяет процедуре возвращать более одного значения вызывающему.\n"
"Это совсем не похоже на другие языки, которые позволяют возвращать\n"
"только одно значение.  Возврат нескольких значений отличается от\n"
"возврата списка (или пары, или вектора) значений вызывающей стороне,\n"
"поскольку концептуально возвращается не один(not @emph{one}) составной\n"
"объект, а несколько различных значений."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:904
msgid ""
"The primitive procedures for handling multiple values are @code{values}\n"
"and @code{call-with-values}.  @code{values} is used for returning\n"
"multiple values from a procedure.  This is done by placing a call to\n"
"@code{values} with zero or more arguments in tail position in a\n"
"procedure body.  @code{call-with-values} combines a procedure returning\n"
"multiple values with a procedure which accepts these values as\n"
"parameters."
msgstr ""
"Примитивными процедурами для обработки нескольких значений являются \n"
"@code{values} и @code{call-with-values}.  @code{values} используется \n"
"для возврата нескольких значений из процедуры.  Просто поместите\n"
"вызов @code{values} с нулем или большим количеством аргументов в хвостовую\n"
"позицию тела процедуры.  @code{call-with-values} объединяет возврат "
"процедуры\n"
"возвращающей множество значений с процедурой которая принимает эти значения\n"
"в качестве параметров."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:913
msgid ""
"@rnindex values\n"
"@deffn {Scheme Procedure} values arg @dots{}\n"
"@deffnx {C Function} scm_values (args)\n"
"Delivers all of its arguments to its continuation.  Except for\n"
"continuations created by the @code{call-with-values} procedure,\n"
"all continuations take exactly one value.  The effect of\n"
"passing no value or more than one value to continuations that\n"
"were not created by @code{call-with-values} is unspecified."
msgstr ""
"@rnindex values\n"
"@deffn {Scheme Procedure} values arg @dots{}\n"
"@deffnx {C Function} scm_values (args)\n"
"Поставляет все свои аргументы в продолжение. За исключением\n"
"продолжений созданных процедурой @code{call-with-values},\n"
"все продолжения принимают одно значение.  Эффект от перадачи\n"
"нуля значений или более чем одного значения в продолжения которые\n"
"не были созданы @code{call-with-values} не определен."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:919
msgid ""
"For @code{scm_values}, @var{args} is a list of arguments and the\n"
"return is a multiple-values object which the caller can return.  In\n"
"the current implementation that object shares structure with\n"
"@var{args}, so @var{args} should not be modified subsequently.\n"
"@end deffn"
msgstr ""
"Для @code{scm_values}, @var{args} это список аргументов, а возвращаемое\n"
"значение это объект множества значений, которые мог вернуть вызывающий.\n"
"В текущей реализаци этот объект разделяет структуру с \n"
"@var{args}, поэтому @var{args} не должны быть изменены в последствии.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:924
msgid ""
"@deftypefn {C Function} SCM scm_c_values (SCM *base, size_t n)\n"
"@code{scm_c_values} is an alternative to @code{scm_values}.  It creates\n"
"a new values object, and copies into it the @var{n} values starting from\n"
"@var{base}."
msgstr ""
"@deftypefn {C Function} SCM scm_c_values (SCM *base, size_t n)\n"
"@code{scm_c_values} яляется альтернативой @code{scm_values}.  Она создает\n"
"новый объект значений, и копирует в него  @var{n} значений начиная с\n"
"@var{base}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:929
msgid ""
"Currently this creates a list and passes it to @code{scm_values}, but we\n"
"expect that in the future we will be able to use a more efficient\n"
"representation.\n"
"@end deftypefn"
msgstr ""
"В настоящее время он создает список и передает его в\n"
" @code{scm_values}, но в будущем мы сможем использовать\n"
"более эффективное представление\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:934
msgid ""
"@deftypefn {C Function} size_t scm_c_nvalues (SCM obj)\n"
"If @var{obj} is a multiple-values object, returns the number of values\n"
"it contains.  Otherwise returns 1.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Function} size_t scm_c_nvalues (SCM obj)\n"
"Если @var{obj} является объектом с несколькими значениями, возвращает\n"
"количество значений, которые он содержит. Иначе возвращает 1.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:941
msgid ""
"@deftypefn {C Function} SCM scm_c_value_ref (SCM obj, size_t idx)\n"
"Returns the value at the position specified by @var{idx} in\n"
"@var{obj}.  Note that @var{obj} will ordinarily be a\n"
"multiple-values object, but it need not be.  Any other object\n"
"represents a single value (itself), and is handled appropriately.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Function} SCM scm_c_value_ref (SCM obj, size_t idx)\n"
"Возвращает значение в позиции указанной @var{idx} объекта @var{obj}.\n"
"Обратите внимание, что объект @var{obj} обычно будет объектом с \n"
"несколькими значениями, но это не обязательно.  Любой другой объект\n"
"представляет собой одиночной значение(он сам), и обрабатывается\n"
"соответствующим образом.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:949
msgid ""
"@rnindex call-with-values\n"
"@deffn {Scheme Procedure} call-with-values producer consumer\n"
"Calls its @var{producer} argument with no values and a\n"
"continuation that, when passed some values, calls the\n"
"@var{consumer} procedure with those values as arguments.  The\n"
"continuation for the call to @var{consumer} is the continuation\n"
"of the call to @code{call-with-values}."
msgstr ""
"@rnindex call-with-values\n"
"@deffn {Scheme Procedure} call-with-values producer consumer\n"
"Вызывает аргумент @var{producer} без значений и продолжение,\n"
"которое при передаче нескольких значений, вызывает процедуру\n"
"@var{consumer} с этими значениями в качестве аргументов.\n"
"Продолжение для вызвова @var{consumer} является продолжением\n"
"вызвова @code{call-with-values}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:954
msgid ""
"@example\n"
"(call-with-values (lambda () (values 4 5))\n"
"                  (lambda (a b) b))\n"
"@result{} 5"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:961
msgid ""
"@end example\n"
"@example\n"
"(call-with-values * -)\n"
"@result{} -1\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:966
msgid ""
"In addition to the fundamental procedures described above, Guile has a\n"
"module which exports a syntax called @code{receive}, which is much\n"
"more convenient.  This is in the @code{(ice-9 receive)} and is the\n"
"same as specified by SRFI-8 (@pxref{SRFI-8})."
msgstr ""
"В дополнение к основным процедурам, описанным выше, в Guile есть модуль\n"
"который экспортирует синтаксис с именем @code{receive}, который\n"
"гораздо удобнее.  Он есть в @code{(ice-9 receive)} и соответствует\n"
"SRFI-8 (@pxref{SRFI-8})."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:970
msgid ""
"@lisp\n"
"(use-modules (ice-9 receive))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:978
msgid ""
"@deffn {library syntax} receive formals expr body @dots{}\n"
"Evaluate the expression @var{expr}, and bind the result values (zero\n"
"or more) to the formal arguments in @var{formals}.  @var{formals} is a\n"
"list of symbols, like the argument list in a @code{lambda}\n"
"(@pxref{Lambda}).  After binding the variables, the expressions in\n"
"@var{body} @dots{} are evaluated in order, the return value is the\n"
"result from the last expression."
msgstr ""
"@deffn {library syntax} receive formals expr body @dots{}\n"
"Вычисляет выражение @var{expr}, и связывает результирующие значения\n"
"(ноль или больее) с результирующими значениями(ноль или больше)\n"
"в @var{formals}.  @var{formals} это список символов, такие как \n"
"список аргументов в @code{lambda}\n"
"(@pxref{Lambda}).  После связывания переменных в @var{body} @dots{} \n"
"вычисляются по порядку, возвращая значениев последнем\n"
"выражении."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:981
msgid ""
"For example getting results from @code{partition} in SRFI-1\n"
"(@pxref{SRFI-1}),"
msgstr ""
"Например, получение результатов из @code{partition} в SRFI-1\n"
"(@pxref{SRFI-1}),"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:990
msgid ""
"@example\n"
"(receive (odds evens)\n"
"    (partition odd? '(7 4 2 8 3))\n"
"  (display odds)\n"
"  (display \" and \")\n"
"  (display evens))\n"
"@print{} (7 3) and (4 2 8)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:992
msgid "@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:998
msgid ""
"@node Exceptions\n"
"@subsection Exceptions\n"
"@cindex error handling\n"
"@cindex exception handling"
msgstr ""
"@node Exceptions\n"
"@subsection Исключения\n"
"@cindex error handling\n"
"@cindex exception handling"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1005
msgid ""
"A common requirement in applications is to want to jump\n"
"@dfn{non-locally} from the depths of a computation back to, say, the\n"
"application's main processing loop.  Usually, the place that is the\n"
"target of the jump is somewhere in the calling stack of procedures that\n"
"called the procedure that wants to jump back.  For example, typical\n"
"logic for a key press driven application might look something like this:"
msgstr ""
"Общим требованием в приложениях является желание выпрыгивать не локально\n"
"(@dfn{non-locally}) из глубины вычислений обратно, скажем, в основной\n"
"цикл обработки(main processing loop).  Обычно, место, то есть цель перехода\n"
"находиться где то в стеке вызывающих процедур, которые вызвали процедуру, "
"которая\n"
"хочет выпрыгнуть назад.  Например, типичная логика для обработки нажатий "
"клавиш\n"
"приложения может выглядеть примерно так:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1009
msgid ""
"@example\n"
"main-loop:\n"
"  read the next key press and call dispatch-key"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1013
msgid ""
"dispatch-key:\n"
"  lookup the key in a keymap and call an appropriate procedure,\n"
"  say find-file"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1017
msgid ""
"find-file:\n"
"  interactively read the required file name, then call\n"
"  find-specified-file"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1022
msgid ""
"find-specified-file:\n"
"  check whether file exists; if not, jump back to main-loop\n"
"  @dots{}\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1029
msgid ""
"The jump back to @code{main-loop} could be achieved by returning through\n"
"the stack one procedure at a time, using the return value of each\n"
"procedure to indicate the error condition, but Guile (like most modern\n"
"programming languages) provides an additional mechanism called\n"
"@dfn{exception handling} that can be used to implement such jumps much\n"
"more conveniently."
msgstr ""
"Переход к основному циклу to @code{main-loop} может быть достигнут путем\n"
"возврата через стек одной процедуры за раз, используя возвращаемое значение\n"
"каждой процедуры, чтобы указать состояние ошибки, но Guile (как и "
"большинство\n"
"современных языков программирования) предоставляет дополнительный механизм,\n"
"называемый обработкой исключений(@dfn{exception handling}), который может "
"быть\n"
"использован для реализации таких переходов гораздо удобнее."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1037
msgid ""
"@menu\n"
"* Exception Terminology::       Different ways to say the same thing.\n"
"* Catch::                       Setting up to catch exceptions.\n"
"* Throw Handlers::              Handling exceptions before unwinding the "
"stack.\n"
"* Throw::                       Throwing an exception.\n"
"* Exception Implementation::    How Guile implements exceptions.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1041
msgid ""
"@node Exception Terminology\n"
"@subsubsection Exception Terminology"
msgstr ""
"@node Exception Terminology\n"
"@subsubsection Терминология Исключений"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1045
msgid ""
"There are several variations on the terminology for dealing with\n"
"non-local jumps.  It is useful to be aware of them, and to realize\n"
"that they all refer to the same basic mechanism."
msgstr ""
"Существует несколько вариантов терминологии для работы с нелокальными\n"
"переходами(non-local jumps). Это полезно знать о них и понимать, что все "
"они\n"
"относятся к одному и тому же основному механизму."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1053
msgid ""
"@itemize @bullet\n"
"@item\n"
"Actually making a non-local jump may be called @dfn{raising an\n"
"exception}, @dfn{raising a signal}, @dfn{throwing an exception} or\n"
"@dfn{doing a long jump}.  When the jump indicates an error condition,\n"
"people may talk about @dfn{signalling}, @dfn{raising} or @dfn{throwing}\n"
"@dfn{an error}."
msgstr ""
"@itemize @bullet\n"
"@item\n"
"На самом деле совершение не локального перехода, можно называть вызовом\n"
"исключения(@dfn{raising an exception}), вызовом сигнала(@dfn{raising a "
"signal}), \n"
"выбросом исключения (@dfn{throwing an exception}) или выполнением длинного "
"перехода\n"
"@dfn{doing a long jump}.  Когда переход указывает на состояние ошибки,\n"
"люди могут говорит о сигнале(@dfn{signalling}), вызове(@dfn{raising}) или\n"
"выбросе( @dfn{throwing})\n"
"@dfn{an error}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1059
msgid ""
"@item\n"
"Handling the jump at its target may be referred to as @dfn{catching} or\n"
"@dfn{handling} the @dfn{exception}, @dfn{signal} or, where an error\n"
"condition is involved, @dfn{error}.\n"
"@end itemize"
msgstr ""
"@item\n"
"Обработка перехода(прыжка) к своей цели может упоминаться как "
"ловля(@dfn{catching})\n"
"или обработка(@dfn{handling}) исключения( @dfn{exception}), "
"сигнала(@dfn{signal}) или\n"
"в случае состояния ошибки, ошибкой(@dfn{error}).\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1062
msgid ""
"Where @dfn{signal} and @dfn{signalling} are used, special care is needed\n"
"to avoid the risk of confusion with POSIX signals."
msgstr ""
"Там где используется сигнал(@dfn{signal}) и сигнализация(@dfn{signalling}),\n"
"требуется особая осторожность, чтобы избежать риска путаницы с\n"
"сигналами POSIX."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1065
msgid ""
"This manual prefers to speak of throwing and catching exceptions, since\n"
"this terminology matches the corresponding Guile primitives."
msgstr ""
"Это руководство предпочитает говорить о создании и отлове исключений,\n"
"так как эта терминология соответствует соответствующим примитивам Guile."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1070
msgid ""
"The exception mechanism described in this section has connections with\n"
"@dfn{delimited continuations} (@pxref{Prompts}).  In particular,\n"
"throwing an exception is akin to invoking an @dfn{escape continuation}\n"
"(@pxref{Prompt Primitives, @code{call/ec}})."
msgstr ""
"Механизм исключений описанный в этом разделе, имеет связи с разделенными\n"
"продолжениями(@dfn{delimited continuations}) (@pxref{Prompts}).  В "
"частности,\n"
"выбрасывание исключения сродни вызову выхода/побега из "
"продолжения(@dfn{escape continuation})\n"
"(@pxref{Prompt Primitives, @code{call/ec}})."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1074
msgid ""
"@node Catch\n"
"@subsubsection Catching Exceptions"
msgstr ""
"@node Catch\n"
"@subsubsection Ловля/Перехват Исключений(Catching Exceptions)"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1083
msgid ""
"@code{catch} is used to set up a target for a possible non-local jump.\n"
"The arguments of a @code{catch} expression are a @dfn{key}, which\n"
"restricts the set of exceptions to which this @code{catch} applies, a\n"
"thunk that specifies the code to execute and one or two @dfn{handler}\n"
"procedures that say what to do if an exception is thrown while executing\n"
"the code.  If the execution thunk executes @dfn{normally}, which means\n"
"without throwing any exceptions, the handler procedures are not called\n"
"at all."
msgstr ""
"@code{catch} используется для установки цели для возможного не локального\n"
"прыжка/перехода. Аргументами выражения @code{catch} являются "
"ключ(@dfn{key}),\n"
"который ограничивает набор исключений, к которым применяется этот "
"@code{catch},\n"
"чанк(thunk) который определяет исполняемый код и одина или две процедуры \n"
"обработчики (@dfn{handler}), которые говорят, что делать, если при "
"выполнении\n"
"кода возникает исключение. Если выполнение чанка(thunk) происходит "
"нормально\n"
"(@dfn{normally}), что означает, без исключений, процедуры обработчики не "
"вызываются\n"
"вовсе."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1089
msgid ""
"When an exception is thrown using the @code{throw} function, the first\n"
"argument of the @code{throw} is a symbol that indicates the type of the\n"
"exception.  For example, Guile throws an exception using the symbol\n"
"@code{numerical-overflow} to indicate numerical overflow errors such as\n"
"division by zero:"
msgstr ""
"Когда исключение выбрасывается с использованием функции @code{throw}"
"(бросать), \n"
"первый аргумент @code{throw} является символом, указывающим на тип "
"исключения.\n"
"Например, Guile выбрасывает исключения используя символ @code{numerical-"
"overflow}\n"
"для указания ошибок числового переполнения, таких как деление на ноль:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1095
msgid ""
"@lisp\n"
"(/ 1 0)\n"
"@result{}\n"
"ABORT: (numerical-overflow)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1102
msgid ""
"The @var{key} argument in a @code{catch} expression corresponds to this\n"
"symbol.  @var{key} may be a specific symbol, such as\n"
"@code{numerical-overflow}, in which case the @code{catch} applies\n"
"specifically to exceptions of that type; or it may be @code{#t}, which\n"
"means that the @code{catch} applies to all exceptions, irrespective of\n"
"their type."
msgstr ""
"Аргумент @var{key} в выражении @code{catch} соответствует этому символу.\n"
"@var{key} может быть конкретным символом, таким как @code{numerical-"
"overflow},\n"
"в этом случае @code{catch} применяется к конкретным исключениям этого типа;\n"
"или это может быть @code{#t}, что означает, что @code{catch} применяется ко\n"
"всем исключениям, независимо от их типа."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1109
msgid ""
"The second argument of a @code{catch} expression should be a thunk\n"
"(i.e.@: a procedure that accepts no arguments) that specifies the normal\n"
"case code.  The @code{catch} is active for the execution of this thunk,\n"
"including any code called directly or indirectly by the thunk's body.\n"
"Evaluation of the @code{catch} expression activates the catch and then\n"
"calls this thunk."
msgstr ""
"Второй аргумент выражения @code{catch} должен быть чанком(thunk)\n"
"(т.е.@: процедурой которая не принимает ни одного аргумента), который\n"
"указывает обычнй исполняемый код.  @code{catch} активен когда\n"
"исполняется этот чанк(thunk), включая любой код вызываемый непосредственно\n"
"или косвенно из тела чанка. Вычисление выражения @code{catch} активирует\n"
"этот catch и затем вызывает этот чанк(thunk)."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1116
msgid ""
"The third argument of a @code{catch} expression is a handler procedure.\n"
"If an exception is thrown, this procedure is called with exactly the\n"
"arguments specified by the @code{throw}.  Therefore, the handler\n"
"procedure must be designed to accept a number of arguments that\n"
"corresponds to the number of arguments in all @code{throw} expressions\n"
"that can be caught by this @code{catch}."
msgstr ""
"Третий аргумент выражения @code{catch} это процедура обработчик.\n"
"Если возникает исключение, вызывается эта процедура с точно теми же\n"
"аргументами, которые указываюстя в @code{throw}.  Следовательно, процедура\n"
"обработчика должна быть разработана, что бы принимать такое число "
"аргументов,\n"
"которое соответствует всем выражениям @code{throw}, которые могут быть\n"
"перехвачены данным @code{catch}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1126
msgid ""
"The fourth, optional argument of a @code{catch} expression is another\n"
"handler procedure, called the @dfn{pre-unwind} handler.  It differs from\n"
"the third argument in that if an exception is thrown, it is called,\n"
"@emph{before} the third argument handler, in exactly the dynamic context\n"
"of the @code{throw} expression that threw the exception.  This means\n"
"that it is useful for capturing or displaying the stack at the point of\n"
"the @code{throw}, or for examining other aspects of the dynamic context,\n"
"such as fluid values, before the context is unwound back to that of the\n"
"prevailing @code{catch}."
msgstr ""
"Четвертый, необязательный аргумент выражения @code{catch} это другая "
"процедура\n"
"обработчик, называемая обработчик предварительной раскрутки(@dfn{pre-"
"unwind}).\n"
"Он отличается от третьего аргумента тем, что если выбрасывается исключение,\n"
"он вызывается перед(@emph{before}) обработчиком из третьего аргумента, точно "
"в\n"
"динамическом контексте выражения, которое выбросило исключение "
"@code{throw}.\n"
"Это означает, что оно полезно для захвата или отображения стека в точке \n"
"вызова @code{throw}, или для изучения других аспектов динамического "
"контекста,\n"
"таких как значения флюидов(fluid values), до того, как контекст будет "
"перемота\n"
"обратно, к контексту господствующего @code{catch}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1136
msgid ""
"@deffn {Scheme Procedure} catch key thunk handler [pre-unwind-handler]\n"
"@deffnx {C Function} scm_catch_with_pre_unwind_handler (key, thunk, handler, "
"pre_unwind_handler)\n"
"@deffnx {C Function} scm_catch (key, thunk, handler)\n"
"Invoke @var{thunk} in the dynamic context of @var{handler} for\n"
"exceptions matching @var{key}.  If thunk throws to the symbol\n"
"@var{key}, then @var{handler} is invoked this way:\n"
"@lisp\n"
"(handler key args ...)\n"
"@end lisp"
msgstr ""
"@deffn {Scheme Procedure} catch key thunk handler [pre-unwind-handler]\n"
"@deffnx {C Function} scm_catch_with_pre_unwind_handler (key, thunk, handler, "
"pre_unwind_handler)\n"
"@deffnx {C Function} scm_catch (key, thunk, handler)\n"
"Вызывает чанк @var{thunk} в динамическом контексте обработчика "
"@var{handler} \n"
"исключения соответствующего ключу @var{key}.  Если чанк(thunk) выбросит "
"исключение с\n"
"ключем @var{key}, вызовется обработчик @var{handler}, вот так:\n"
"@lisp\n"
"(handler key args ...)\n"
"@end lisp"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1138
msgid "@var{key} is a symbol or @code{#t}."
msgstr "@var{key} это символ или @code{#t}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1141
msgid ""
"@var{thunk} takes no arguments.  If @var{thunk} returns\n"
"normally, that is the return value of @code{catch}."
msgstr ""
"@var{thunk} не принимает аргументов.  Если @var{thunk} возвращается\n"
"нормально, его возвращаемое значене возвращается выражением @code{catch}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1145
msgid ""
"Handler is invoked outside the scope of its own @code{catch}.\n"
"If @var{handler} again throws to the same key, a new handler\n"
"from further up the call chain is invoked."
msgstr ""
"Обработчик вызывается за пределами области охвата @code{catch}.\n"
"Если @var{handler} снова выбрасывает исключение с тем же ключем(key), \n"
"далее вызывается новый обработчик стоящий по цепочке выше."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1148
msgid ""
"If the key is @code{#t}, then a throw to @emph{any} symbol will\n"
"match this call to @code{catch}."
msgstr ""
"Если ключ это @code{#t}, тогда выбрасывание любого(@emph{any}) символа\n"
"будет соответствовать этому вызову для @code{catch}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1158
msgid ""
"If a @var{pre-unwind-handler} is given and @var{thunk} throws\n"
"an exception that matches @var{key}, Guile calls the\n"
"@var{pre-unwind-handler} before unwinding the dynamic state and\n"
"invoking the main @var{handler}.  @var{pre-unwind-handler} should\n"
"be a procedure with the same signature as @var{handler}, that\n"
"is @code{(lambda (key . args))}.  It is typically used to save\n"
"the stack at the point where the exception occurred, but can also\n"
"query other parts of the dynamic state at that point, such as\n"
"fluid values."
msgstr ""
"Если задан @var{pre-unwind-handler} и чанк(@var{thunk}) выбрасывает\n"
"исключение которое соответствует @var{key}, Guile вызывает\n"
"@var{pre-unwind-handler} до того, как произойдет разматывание(unwinding)\n"
"динамического состояния и вызов основного обработчика @var{handler}.  \n"
"@var{pre-unwind-handler} должен быть процедурой с той же сигнатурой\n"
"что и @var{handler}, который имеет сигнатуру @code{(lambda (key . args))}.\n"
"Он обычно используется для сохранения стека в точке, где произошло\n"
"исключение, но может также запрашивать другие части динамического состояния\n"
"в этой точке, такие как значения флюидов(fluid values)."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1164
msgid ""
"A @var{pre-unwind-handler} can exit either normally or non-locally.\n"
"If it exits normally, Guile unwinds the stack and dynamic context\n"
"and then calls the normal (third argument) handler.  If it exits\n"
"non-locally, that exit determines the continuation.\n"
"@end deffn"
msgstr ""
"@var{pre-unwind-handler} может выйти как нормально, так и не локально.\n"
"Если он выходит нормально, Guile раскручивает стек и динамический контекст\n"
"и затем вызывает обычный обработчк(третий аргумент).  Если он выходит не\n"
"локально, этот выход определяется продолжением.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1168
msgid ""
"If a handler procedure needs to match a variety of @code{throw}\n"
"expressions with varying numbers of arguments, you should write it like\n"
"this:"
msgstr ""
"Если процедура обработчика должна соответствовать различным выражениям "
"@code{throw}\n"
"с различным числом аргументов, вы должны написать его так:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1173
msgid ""
"@lisp\n"
"(lambda (key . args)\n"
"  @dots{})\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1180
msgid ""
"@noindent\n"
"The @var{key} argument is guaranteed always to be present, because a\n"
"@code{throw} without a @var{key} is not valid.  The number and\n"
"interpretation of the @var{args} varies from one type of exception to\n"
"another, but should be specified by the documentation for each exception\n"
"type."
msgstr ""
"@noindent\n"
"Аргумент @var{key} гарантированно присутствует всегда, потому что\n"
"выбрасывание исключения(@code{throw}) без ключа @var{key} не "
"действительна. \n"
"Количество и интерпретация аргументов @var{args} варьируется от одного типа\n"
"исключений к другому, но должна быть указана к документации для каждого "
"типа\n"
"исключений."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1186
msgid ""
"Note that, once the normal (post-unwind) handler procedure is invoked,\n"
"the catch that led to the handler procedure being called is no longer\n"
"active.  Therefore, if the handler procedure itself throws an exception,\n"
"that exception can only be caught by another active catch higher up the\n"
"call stack, if there is one."
msgstr ""
"Обратите внимание, что после вызова обычного обработчика (после "
"разматывания\n"
"стека(post-unwind)), перехват прерываний(catch), который вызвал процедуру\n"
"обработки исключений, больше не активен. Поэтому, если обработчик "
"исключений\n"
"сам выбросит  исключение, это исключение может быть перехвачено только "
"другими\n"
"активными выражениями catch находящимися в стеке выше, если они есть."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1194
msgid ""
"@sp 1\n"
"@deftypefn {C Function} SCM scm_c_catch (SCM tag, scm_t_catch_body body, "
"void *body_data, scm_t_catch_handler handler, void *handler_data, "
"scm_t_catch_handler pre_unwind_handler, void *pre_unwind_handler_data)\n"
"@deftypefnx {C Function} SCM scm_internal_catch (SCM tag, scm_t_catch_body "
"body, void *body_data, scm_t_catch_handler handler, void *handler_data)\n"
"The above @code{scm_catch_with_pre_unwind_handler} and @code{scm_catch}\n"
"take Scheme procedures as body and handler arguments.\n"
"@code{scm_c_catch} and @code{scm_internal_catch} are equivalents taking\n"
"C functions."
msgstr ""
"@sp 1\n"
"@deftypefn {C Function} SCM scm_c_catch (SCM tag, scm_t_catch_body body, "
"void *body_data, scm_t_catch_handler handler, void *handler_data, "
"scm_t_catch_handler pre_unwind_handler, void *pre_unwind_handler_data)\n"
"@deftypefnx {C Function} SCM scm_internal_catch (SCM tag, scm_t_catch_body "
"body, void *body_data, scm_t_catch_handler handler, void *handler_data)\n"
"Вышеупомянутые @code{scm_catch_with_pre_unwind_handler} и @code{scm_catch}\n"
"принимают Scheme процеруды в качестве аргументов тела и обработчика "
"исключений.\n"
"@code{scm_c_catch} и @code{scm_internal_catch} являются их эквивалентами, "
"принимающими\n"
"Си функции."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1201
msgid ""
"@var{body} is called as @code{@var{body} (@var{body_data})} with a catch\n"
"on exceptions of the given @var{tag} type.  If an exception is caught,\n"
"@var{pre_unwind_handler} and @var{handler} are called as\n"
"@code{@var{handler} (@var{handler_data}, @var{key}, @var{args})}.\n"
"@var{key} and @var{args} are the @code{SCM} key and argument list from\n"
"the @code{throw}."
msgstr ""
"@var{body} вызывается как @code{@var{body} (@var{body_data})} с перехватом\n"
"исключений соответствующего @var{tag} типа.  Если ислючение поймано,\n"
"вызываются @var{pre_unwind_handler} и @var{handler} как\n"
"@code{@var{handler} (@var{handler_data}, @var{key}, @var{args})}.\n"
"@var{key} и @var{args} являются @code{SCM} ключем(key) и списком аргументов "
"из\n"
"@code{throw}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1207
msgid ""
"@tpindex scm_t_catch_body\n"
"@tpindex scm_t_catch_handler\n"
"@var{body} and @var{handler} should have the following prototypes.\n"
"@code{scm_t_catch_body} and @code{scm_t_catch_handler} are pointer\n"
"typedefs for these."
msgstr ""
"@tpindex scm_t_catch_body\n"
"@tpindex scm_t_catch_handler\n"
"@var{body} и @var{handler} должны иметь следующие прототипы.\n"
"@code{scm_t_catch_body} и @code{scm_t_catch_handler} это указатель\n"
"определения типа для них."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1212
msgid ""
"@example\n"
"SCM body (void *data);\n"
"SCM handler (void *data, SCM key, SCM args);\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1216
msgid ""
"The @var{body_data} and @var{handler_data} parameters are passed to\n"
"the respective calls so an application can communicate extra\n"
"information to those functions."
msgstr ""
"параметры @var{body_data} и @var{handler_data} передаются в соответствующие\n"
"вызовы так что приложение может передавать дополнительную информацию для \n"
"этих функций."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1225
msgid ""
"If the data consists of an @code{SCM} object, care should be taken that\n"
"it isn't garbage collected while still required.  If the @code{SCM} is a\n"
"local C variable, one way to protect it is to pass a pointer to that\n"
"variable as the data parameter, since the C compiler will then know the\n"
"value must be held on the stack.  Another way is to use\n"
"@code{scm_remember_upto_here_1} (@pxref{Foreign Object Memory\n"
"Management}).\n"
"@end deftypefn"
msgstr ""
"Если data состоит из объекта @code{SCM}, следует позаботиться о том, чтобы\n"
"он небыл собран сборщиком мусора, пока он еще требуется.  Если @code{SCM} "
"это\n"
"локальная Си переменная, один из способов защитить ее - передать указатель "
"на\n"
"эту переменную в качестве параметра data, поскольку Си компилятор будет "
"знать\n"
"ее значение, оно будет храниться в стеке. Другой способ --- использовать\n"
"@code{scm_remember_upto_here_1} (@pxref{Foreign Object Memory\n"
"Management}).\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1229
msgid ""
"@node Throw Handlers\n"
"@subsubsection Throw Handlers"
msgstr ""
"@node Throw Handlers\n"
"@subsubsection Обработчики Исключений"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1235
msgid ""
"It's sometimes useful to be able to intercept an exception that is being\n"
"thrown before the stack is unwound. This could be to clean up some\n"
"related state, to print a backtrace, or to pass information about the\n"
"exception to a debugger, for example. The @code{with-throw-handler}\n"
"procedure provides a way to do this."
msgstr ""
"Иногда полезно перехватить исключение, которое выдается перед разматыванием\n"
"стека. Это может быть необходимо, чтобы очистить некоторые связанные "
"состояния,\n"
"распечатки трассы вызовов или например, передать информацию об исключении в\n"
"отладчик. Процедура @code{with-throw-handler} предоставляет способ сделать "
"это."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1240
msgid ""
"@deffn {Scheme Procedure} with-throw-handler key thunk handler\n"
"@deffnx {C Function} scm_with_throw_handler (key, thunk, handler)\n"
"Add @var{handler} to the dynamic context as a throw handler\n"
"for key @var{key}, then invoke @var{thunk}."
msgstr ""
"@deffn {Scheme Procedure} with-throw-handler key thunk handler\n"
"@deffnx {C Function} scm_with_throw_handler (key, thunk, handler)\n"
"Добавляет обработчик @var{handler} в динамический контекст в качестве\n"
"обработчика исключения для ключа @var{key}, затем вызывает чанк(@var{thunk})."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1247
msgid ""
"This behaves exactly like @code{catch}, except that it does not unwind\n"
"the stack before invoking @var{handler}. If the @var{handler} procedure\n"
"returns normally, Guile rethrows the same exception again to the next\n"
"innermost catch or throw handler. @var{handler} may exit nonlocally, of\n"
"course, via an explicit throw or via invoking a continuation.\n"
"@end deffn"
msgstr ""
"Он ведет себя также как @code{catch}, за исключением того, что не "
"разматывает\n"
"стек до того как вызовет обработчик @var{handler}. Если процедура "
"@var{handler}\n"
"возвращается нормально, Guile повторно выбрасывает тоже самое исключение "
"для\n"
"следующего ближайшего catch или throw обработчика. @var{handler} может "
"выходить\n"
"не локально, конечно, выйти не локально можно через явный выброс исключения "
"или\n"
"вызов продолжения.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1251
msgid ""
"Typically @var{handler} is used to display a backtrace of the stack at\n"
"the point where the corresponding @code{throw} occurred, or to save off\n"
"this information for possible display later."
msgstr ""
"Обычно обработчик @var{handler} используется для отображения трассы вызовов\n"
"стека, в точке где произошел соответствующий выброс "
"исключения(@code{throw}),\n"
"или чтобы сохранить эту информацию для возможного отображения позже."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1256
msgid ""
"Not unwinding the stack means that throwing an exception that is handled\n"
"via a throw handler is equivalent to calling the throw handler handler\n"
"inline instead of each @code{throw}, and then omitting the surrounding\n"
"@code{with-throw-handler}. In other words,"
msgstr ""
"Не разматывать стек(Not unwinding) означает, что выбрасывается исключение,\n"
"которое обрабатывается с помощью обработчика throw, эквивалентно вызову\n"
"встроенного встроенного(inline) обработчика для каждого @code{throw}, и\n"
"затем пропуском окружающих @code{with-throw-handler}. Другими словами,"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1262
msgid ""
"@lisp\n"
"(with-throw-handler 'key\n"
"  (lambda () @dots{} (throw 'key args @dots{}) @dots{})\n"
"  handler)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1265
msgid ""
"@noindent\n"
"is mostly equivalent to"
msgstr ""
"@noindent\n"
"в основом эквивалентно"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1269
msgid ""
"@lisp\n"
"((lambda () @dots{} (handler 'key args @dots{}) @dots{}))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1277
msgid ""
"In particular, the dynamic context when @var{handler} is invoked is that\n"
"of the site where @code{throw} is called. The examples are not quite\n"
"equivalent, because the body of a @code{with-throw-handler} is not in\n"
"tail position with respect to the @code{with-throw-handler}, and if\n"
"@var{handler} exits normally, Guile arranges to rethrow the error, but\n"
"hopefully the intention is clear. (For an introduction to what is meant\n"
"by dynamic context, @xref{Dynamic Wind}.)"
msgstr ""
"В частности, динамический контекст при вызове обработчика @var{handler} \n"
"это это место где вызывается @code{throw}. Примеры, не совсем эквиваленты,\n"
"поскольку тело @code{with-throw-handler} не находиться в хвостовой позиции\n"
"по отношению к @code{with-throw-handler}, и если обработчик @var{handler}\n"
"завершиться нормально, Guile организует повторный выброс (rethrow) ошибки,\n"
"но надеюсь, цель этого ясна. (For an introduction to what is meant\n"
"by dynamic context, @xref{Dynamic Wind}.)"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1285
msgid ""
"@deftypefn {C Function} SCM scm_c_with_throw_handler (SCM tag, "
"scm_t_catch_body body, void *body_data, scm_t_catch_handler handler, void "
"*handler_data, int lazy_catch_p)\n"
"The above @code{scm_with_throw_handler} takes Scheme procedures as body\n"
"(thunk) and handler arguments.  @code{scm_c_with_throw_handler} is an\n"
"equivalent taking C functions.  See @code{scm_c_catch} (@pxref{Catch})\n"
"for a description of the parameters, the behaviour however of course\n"
"follows @code{with-throw-handler}.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Function} SCM scm_c_with_throw_handler (SCM tag, "
"scm_t_catch_body body, void *body_data, scm_t_catch_handler handler, void "
"*handler_data, int lazy_catch_p)\n"
"Приведенные выше @code{scm_with_throw_handler} получают аргументами "
"процедуры Scheme \n"
"в качестве тела((thunk) и обработчика.  @code{scm_c_with_throw_handler} "
"является\n"
"эквивалентом, принимающим Си функции. См. @code{scm_c_catch} "
"(@pxref{Catch})\n"
"для описания параметров, однако поведение коенчно соответствует\n"
"@code{with-throw-handler}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1294
msgid ""
"If @var{thunk} throws an exception, Guile handles that exception by\n"
"invoking the innermost @code{catch} or throw handler whose key matches\n"
"that of the exception.  When the innermost thing is a throw handler,\n"
"Guile calls the specified handler procedure using @code{(apply\n"
"@var{handler} key args)}.  The handler procedure may either return\n"
"normally or exit non-locally.  If it returns normally, Guile passes the\n"
"exception on to the next innermost @code{catch} or throw handler.  If it\n"
"exits non-locally, that exit determines the continuation."
msgstr ""
"Если чанк(@var{thunk}) выбрасывает исключение, Guile обрабатывает это\n"
"исключение, вызывая самый внутренний обработчик @code{catch} или throw\n"
"ключ которого совпадает с ключем исключения. Когда самый внутренний\n"
"обработчик исключения найден, Guile вызывает указанную процедуру "
"обработчика\n"
"используя @code{(apply @var{handler} key args)}.  Процедура обработчика "
"может\n"
"вернуться нормально, либо выйти не локально. Если она завершается "
"нормально,\n"
"Guile передает исключение следующему самому внутреннему обработчику "
"@code{catch}\n"
"или throw.  Если он выходит не локально, этот выход определяется "
"продолжением."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1304
msgid ""
"The behaviour of a throw handler is very similar to that of a\n"
"@code{catch} expression's optional pre-unwind handler.  In particular, a\n"
"throw handler's handler procedure is invoked in the exact dynamic\n"
"context of the @code{throw} expression, just as a pre-unwind handler is.\n"
"@code{with-throw-handler} may be seen as a half-@code{catch}: it does\n"
"everything that a @code{catch} would do until the point where\n"
"@code{catch} would start unwinding the stack and dynamic context, but\n"
"then it rethrows to the next innermost @code{catch} or throw handler\n"
"instead."
msgstr ""
"Поведение обработчика исключений throw очень похоже на поведение\n"
"необязательного обработчика pre-unwind  в выражении @code{catch}.\n"
"В частности, процедура обработчика  throw вызывается  в том же\n"
"динамическом конетесте, так же как и в выражении the @code{throw},\n"
"так и обработчике pre-unwind.\n"
"@code{with-throw-handler} можно рассматривать как половину -@code{catch}: он "
"делает\n"
"все, что и @code{catch} до тех пор пока  @code{catch} не начинает "
"разматывать\n"
"стек и динамический контекст, но затем он возвращается к следующему "
"внутреннему\n"
"обработчику @code{catch} или throw."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1310
msgid ""
"Note also that since the dynamic context is not unwound, if a\n"
"@code{with-throw-handler} handler throws to a key that does not match\n"
"the @code{with-throw-handler} expression's @var{key}, the new throw may\n"
"be handled by a @code{catch} or throw handler that is @emph{closer} to\n"
"the throw than the first @code{with-throw-handler}."
msgstr ""
"Также обратите внимание, что поскольку динамический контекст не "
"разматывается, \n"
"если обработчик @code{with-throw-handler} выбрасывает исключение с ключем,\n"
"который не соответствует ключу @var{key} выражения @code{with-throw-"
"handler},\n"
"новый бросок(исключение) может быть обработано обработчиком @code{catch} "
"или\n"
"throw которые БЛИЖЕ(@emph{closer}) выбросившему исключение коду, чем первый\n"
"обработчик @code{with-throw-handler}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1312
msgid "Here is an example to illustrate this behavior:"
msgstr "Вот пример, демонстрирующий это поведение:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1326
msgid ""
"@lisp\n"
"(catch 'a\n"
"  (lambda ()\n"
"    (with-throw-handler 'b\n"
"      (lambda ()\n"
"        (catch 'a\n"
"          (lambda ()\n"
"            (throw 'b))\n"
"          inner-handler))\n"
"      (lambda (key . args)\n"
"        (throw 'a))))\n"
"  outer-handler)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1330
msgid ""
"@noindent\n"
"This code will call @code{inner-handler} and then continue with the\n"
"continuation of the inner @code{catch}."
msgstr ""
"@noindent\n"
"Этот код вызывает внутренний обработчик @code{inner-handler} и затем\n"
"продолжает с продолжения внутреннего @code{catch}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1334
msgid ""
"@node Throw\n"
"@subsubsection Throwing Exceptions"
msgstr ""
"@node Throw\n"
"@subsubsection Выброс/Генерация Исключений"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1342
msgid ""
"The @code{throw} primitive is used to throw an exception.  One argument,\n"
"the @var{key}, is mandatory, and must be a symbol; it indicates the type\n"
"of exception that is being thrown.  Following the @var{key},\n"
"@code{throw} accepts any number of additional arguments, whose meaning\n"
"depends on the exception type.  The documentation for each possible type\n"
"of exception should specify the additional arguments that are expected\n"
"for that kind of exception."
msgstr ""
"Примитив @code{throw} используется для выброса исключения. Один аргумент\n"
" @var{key}, является обязательным, и должен быть символом; он указывает\n"
"тип исключения которое выбрасывается.  Следующий аргумент @var{args},\n"
"@code{throw} принимает произвольное число дополнительных аргументов,\n"
"значение которых зависит от типа исключения. Документация для каждого\n"
"возможного типа исключения должна описывать дополнительные аргументы,\n"
"которые ожидаются для такого рода исключения."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1347
msgid ""
"@deffn {Scheme Procedure} throw key arg @dots{}\n"
"@deffnx {C Function} scm_throw (key, args)\n"
"Invoke the catch form matching @var{key}, passing @var{arg} @dots{} to\n"
"the @var{handler}."
msgstr ""
"@deffn {Scheme Procedure} throw key arg @dots{}\n"
"@deffnx {C Function} scm_throw (key, args)\n"
"Вызывает catch форму соответствующую ключу @var{key}, передавая аргументы "
"@var{arg} @dots{}\n"
"в обработчик @var{handler}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1350
msgid ""
"@var{key} is a symbol.  It will match catches of the same symbol or of\n"
"@code{#t}."
msgstr ""
"@var{key} это симовл.  Он будет соответствовать перехватывающим "
"формам(catch)\n"
"с тем же самым символом или  @code{#t}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1353
msgid ""
"If there is no handler at all, Guile prints an error and then exits.\n"
"@end deffn"
msgstr ""
"Если обработчик вообще отсутствует, Guile напечатает ошибку и затем завершит "
"работу.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1361
msgid ""
"When an exception is thrown, it will be caught by the innermost\n"
"@code{catch} or throw handler that applies to the type of the thrown\n"
"exception; in other words, whose @var{key} is either @code{#t} or the\n"
"same symbol as that used in the @code{throw} expression.  Once Guile has\n"
"identified the appropriate @code{catch} or throw handler, it handles the\n"
"exception by applying the relevant handler procedure(s) to the arguments\n"
"of the @code{throw}."
msgstr ""
"Когда генерируется исключение, оно будет перехвачено самым внутренним\n"
"обработчиком @code{catch} или throw который применим к данному типу\n"
"исключения; другими словами, чей ключ @var{key} является @code{#t} или\n"
"тем же символом что и используемый в выражении @code{throw}.  Как только\n"
"Guile определил соответствующий обработчик @code{catch} или throw, он\n"
"обрабатывает исключение, применяя соответсвтующие процедуры обработчики\n"
"к аргументам из @code{throw}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1371
msgid ""
"If there is no appropriate @code{catch} or throw handler for a thrown\n"
"exception, Guile prints an error to the current error port indicating an\n"
"uncaught exception, and then exits.  In practice, it is quite difficult\n"
"to observe this behaviour, because Guile when used interactively\n"
"installs a top level @code{catch} handler that will catch all exceptions\n"
"and print an appropriate error message @emph{without} exiting.  For\n"
"example, this is what happens if you try to throw an unhandled exception\n"
"in the standard Guile REPL; note that Guile's command loop continues\n"
"after the error message:"
msgstr ""
"Если для сгенерированного ислючения нет подходящего обработчика "
"@code{catch}\n"
"или throw, Guile печатает ошибку в текущий порт ошибки, указывающую на \n"
"неперехваченное исключение, и затем завершается.  На практике, это довольно\n"
"трудно наблюдать, поскольку Guile при интерактивном использовании "
"устанавливает\n"
"обработчик верхнего уровня @code{catch}, который перехватывает все "
"исключения\n"
"и печатает соответствующее сообщение об ошибке без(@emph{without}) выхода. \n"
"Например, это то, что происходит если вы пытаетесь выбросить не "
"обрабатываемое\n"
"исключение в стандартном Guile REPL; обратите внимание, что цикл команд "
"Guile\n"
"продолжается после сообщения об ошибке:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1379
msgid ""
"@lisp\n"
"guile> (throw 'badex)\n"
"<unnamed port>:3:1: In procedure gsubr-apply @dots{}\n"
"<unnamed port>:3:1: unhandled-exception: badex\n"
"ABORT: (misc-error)\n"
"guile> \n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1382
msgid ""
"The default uncaught exception behaviour can be observed by evaluating a\n"
"@code{throw} expression from the shell command line:"
msgstr ""
"Поведение по умолчанию для необработанного исключения можно наблюдать, "
"вычислив\n"
"выражение @code{throw} из командной строки shell:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1388
msgid ""
"@example\n"
"$ guile -c \"(begin (throw 'badex) (display \\\"here\\\\n\\\"))\"\n"
"guile: uncaught throw to badex: ()\n"
"$ \n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1394
msgid ""
"@noindent\n"
"That Guile exits immediately following the uncaught exception\n"
"is shown by the absence of any output from the @code{display}\n"
"expression, because Guile never gets to the point of evaluating that\n"
"expression."
msgstr ""
"@noindent\n"
"То что Guile выходит сразу после неизвестного исключения, демонстрируется\n"
"отсутствием любого вывода от выражения @code{display}, поскольку Guile \n"
"никогда не достигает точки вычисления этого выражения."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1398
msgid ""
"@node Exception Implementation\n"
"@subsubsection How Guile Implements Exceptions"
msgstr ""
"@node Exception Implementation\n"
"@subsubsection Как Guile Реализует Исключения"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1404
msgid ""
"It is traditional in Scheme to implement exception systems using\n"
"@code{call-with-current-continuation}.  Continuations\n"
"(@pxref{Continuations}) are such a powerful concept that any other\n"
"control mechanism --- including @code{catch} and @code{throw} --- can be\n"
"implemented in terms of them."
msgstr ""
"В обычной Scheme система исключений реализуется использованием\n"
"@code{call-with-current-continuation}.  Продолжения\n"
"(@pxref{Continuations}) являются мощной концепцией, которую может "
"использовать\n"
"любой другой механизм управления--- в том числе @code{catch} и @code{throw} "
"--- \n"
"могут быть реализованы в терминах продолжений."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1413
msgid ""
"Guile does not implement @code{catch} and @code{throw} like this,\n"
"though.  Why not?  Because Guile is specifically designed to be easy to\n"
"integrate with applications written in C.  In a mixed Scheme/C\n"
"environment, the concept of @dfn{continuation} must logically include\n"
"``what happens next'' in the C parts of the application as well as the\n"
"Scheme parts, and it turns out that the only reasonable way of\n"
"implementing continuations like this is to save and restore the complete\n"
"C stack."
msgstr ""
"Однако Guile не реализует функции @code{catch} и @code{throw} подобным "
"образом.\n"
"Почему нет?  Потому что Guile специально разработан для легкой интеграции "
"с \n"
"приложениями написанными на Си.  В смешанной среде Scheme/Си, концепция\n"
"продолжений(@dfn{continuation}) должна логически включать\n"
"``что произойдет следующим(what happens next)'' в Си части приложения, а "
"также\n"
"в части Scheme, и получается, что единственный разумный способ реализации "
"таких\n"
"продолжений - это сохранять и восстанавливать полный Си стек."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1418
msgid ""
"So Guile's implementation of @code{call-with-current-continuation} is a\n"
"stack copying one.  This allows it to interact well with ordinary C\n"
"code, but means that creating and calling a continuation is slowed down\n"
"by the time that it takes to copy the C stack."
msgstr ""
"Таким образом, реализация через @code{call-with-current-continuation} в "
"Guile\n"
"является копированием стека. Это позволяет ей хорошо взаимодействовать с\n"
"обычным Си кодом, но означает, что создание и вызов продолжений "
"замедляется \n"
"на время которое нужно для копирования Си стека."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1426
msgid ""
"The more targeted mechanism provided by @code{catch} and @code{throw}\n"
"does not need to save and restore the C stack because the @code{throw}\n"
"always jumps to a location higher up the stack of the code that executes\n"
"the @code{throw}.  Therefore Guile implements the @code{catch} and\n"
"@code{throw} primitives independently of\n"
"@code{call-with-current-continuation}, in a way that takes advantage of\n"
"this @emph{upwards only} nature of exceptions."
msgstr ""
"Более целенаправленный механизм, предоставляемый @code{catch} и "
"@code{throw}\n"
"не требует сохранения и востановления Си стека, потому что @code{throw}\n"
"всегда прыгает в место ВЫШЕ по стеку, относительно кода выполнившего\n"
"@code{throw}.  Поэтому Guile реализует примитивы @code{catch} и\n"
"@code{throw} независимо от @code{call-with-current-continuation} способом,\n"
"который использует преимущества обычных исключений движущихся только вверх\n"
"(@emph{upwards only})."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1430
msgid ""
"@node Error Reporting\n"
"@subsection Procedures for Signaling Errors"
msgstr ""
"@node Error Reporting\n"
"@subsection Процедуры для Сообщения об Ошибках"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1434
msgid ""
"Guile provides a set of convenience procedures for signaling error\n"
"conditions that are implemented on top of the exception primitives just\n"
"described."
msgstr ""
"Guile предоставляет набор удобных процедур для сообщения об ошибках,\n"
"которые реализованы поверх только что описанных примитивов исключений."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1439
msgid ""
"@deffn {Scheme Procedure} error msg arg @dots{}\n"
"Raise an error with key @code{misc-error} and a message constructed by\n"
"displaying @var{msg} and writing @var{arg} @enddots{}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} error msg arg @dots{}\n"
"Выбрасывает ошибку с кодом @code{misc-error} и сообщением, созданным\n"
"с помощью отображения @var{msg} и записи @var{arg} @enddots{}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1459
msgid ""
"@deffn {Scheme Procedure} scm-error key subr message args data\n"
"@deffnx {C Function} scm_error_scm (key, subr, message, args, data)\n"
"Raise an error with key @var{key}.  @var{subr} can be a string\n"
"naming the procedure associated with the error, or @code{#f}.\n"
"@var{message} is the error message string, possibly containing\n"
"@code{~S} and @code{~A} escapes.  When an error is reported,\n"
"these are replaced by formatting the corresponding members of\n"
"@var{args}: @code{~A} (was @code{%s} in older versions of\n"
"Guile) formats using @code{display} and @code{~S} (was\n"
"@code{%S}) formats using @code{write}.  @var{data} is a list or\n"
"@code{#f} depending on @var{key}: if @var{key} is\n"
"@code{system-error} then it should be a list containing the\n"
"Unix @code{errno} value; If @var{key} is @code{signal} then it\n"
"should be a list containing the Unix signal number; If\n"
"@var{key} is @code{out-of-range}, @code{wrong-type-arg},\n"
"or @code{keyword-argument-error},\n"
"it is a list containing the bad value; otherwise\n"
"it will usually be @code{#f}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} scm-error key subr message args data\n"
"@deffnx {C Function} scm_error_scm (key, subr, message, args, data)\n"
"Выбрасывает ошибку с кодом @var{key}.  @var{subr} может быть строкой\n"
"с именем связанной с ошибкой процедуры, или @code{#f}.\n"
"@var{message} это строка сообщения об ошибке, возможно содержащая\n"
"эскейп-коды @code{~S} и @code{~A}.  Когда сообщается об ошибке, они \n"
"заменяются форматированными соотвующими членами @var{args}: @code{~A} \n"
"(был @code{%s} в более старых версиях Guile) форматом используемым для\n"
"@code{display} и @code{~S} (было @code{%S}) форматом используемым для\n"
"@code{write}.  @var{data} это список или @code{#f} в зависимости от\n"
"ключа @var{key}: если @var{key} это @code{system-error} тогда это должен\n"
"быть список, содержащий значение Unix @code{errno}; Если @var{key} это\n"
"@code{signal} тогда это должен быть список содержащий номер сигнала\n"
"Unix; Если @var{key} это @code{out-of-range}, @code{wrong-type-arg},\n"
"или @code{keyword-argument-error}, это список содержащий плохое значение; \n"
"иначе это обычно @code{#f}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1464
msgid ""
"@deffn {Scheme Procedure} strerror err\n"
"@deffnx {C Function} scm_strerror (err)\n"
"Return the Unix error message corresponding to @var{err}, an integer\n"
"@code{errno} value."
msgstr ""
"@deffn {Scheme Procedure} strerror err\n"
"@deffnx {C Function} scm_strerror (err)\n"
"Возвращает сообщение об ошибке Unix соответствующее @var{err}, "
"целочисленное\n"
"значение @code{errno}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1469
msgid ""
"When @code{setlocale} has been called (@pxref{Locales}), the message\n"
"is in the language and charset of @code{LC_MESSAGES}.  (This is done\n"
"by the C library.)\n"
"@end deffn"
msgstr ""
"Когда вызывается  @code{setlocale} (@pxref{Locales}), сообщение будет\n"
"на языке и в кодировке(charset) соответсвующей @code{LC_MESSAGES}.  \n"
"(Это делается библиотекой Си.)\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1476
msgid ""
"@c begin (scm-doc-string \"boot-9.scm\" \"false-if-exception\")\n"
"@deffn syntax false-if-exception expr\n"
"Returns the result of evaluating its argument; however\n"
"if an exception occurs then @code{#f} is returned instead.\n"
"@end deffn\n"
"@c end"
msgstr ""
"@c begin (scm-doc-string \"boot-9.scm\" \"false-if-exception\")\n"
"@deffn syntax false-if-exception expr\n"
"Возвращает результат вычисления своего аргумента; однако если возникает\n"
"исключение, то вместо него возвращается @code{#f}.\n"
"@end deffn\n"
"@c end"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1480
msgid ""
"@node Dynamic Wind\n"
"@subsection Dynamic Wind"
msgstr ""
"@node Dynamic Wind\n"
"@subsection Динамический Ветер(Dynamic Wind)"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1486
msgid ""
"For Scheme code, the fundamental procedure to react to non-local entry\n"
"and exits of dynamic contexts is @code{dynamic-wind}.  C code could\n"
"use @code{scm_internal_dynamic_wind}, but since C does not allow the\n"
"convenient construction of anonymous procedures that close over\n"
"lexical variables, this will be, well, inconvenient."
msgstr ""
"Для кода Scheme, основной процедурой реагирования на нелокальные входы и \n"
"выходы в/из динамического контекста является @code{dynamic-wind}.  Си код\n"
"может использовать @code{scm_internal_dynamic_wind}, но так как Си код не \n"
"позволяет удобно строить анонимные процедуры которые замыкаются "
"относительно\n"
"лексических переменных, это будет, ну, неудобно."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1497
msgid ""
"Therefore, Guile offers the functions @code{scm_dynwind_begin} and\n"
"@code{scm_dynwind_end} to delimit a dynamic extent.  Within this\n"
"dynamic extent, which is called a @dfn{dynwind context}, you can\n"
"perform various @dfn{dynwind actions} that control what happens when\n"
"the dynwind context is entered or left.  For example, you can register\n"
"a cleanup routine with @code{scm_dynwind_unwind_handler} that is\n"
"executed when the context is left.  There are several other more\n"
"specialized dynwind actions as well, for example to temporarily block\n"
"the execution of asyncs or to temporarily change the current output\n"
"port.  They are described elsewhere in this manual."
msgstr ""
"Поэтому, Guile предлагает функции @code{scm_dynwind_begin} и\n"
"@code{scm_dynwind_end} для разделения динамического динамического\n"
"пространства(extent). В этом динамическом пространстве, который называется\n"
"динамический контекст(@dfn{dynwind context}), вы можете выполнять различные\n"
"действия(@dfn{dynwind actions}) которые управляют тем, что происходит\n"
"когда происходит вход в динамический контекс, или выход из него.\n"
"Например, вы можете зарегистрировать процедуру очистки с помощью \n"
"@code{scm_dynwind_unwind_handler} которая будет выполняться, когда\n"
"управление покидает контекст.  Есть еще несколько других специалзированных\n"
"действий динамического ветра(dynwind), например, чтобы временно "
"заблокировать\n"
"асинхронное выполнение или временно изменить текущий порт вывода.\n"
"Они описаны в другом месте этого руководтсва."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1499
msgid "Here is an example that shows how to prevent memory leaks."
msgstr "Вот пример, который показывает, как предотвратить утечки памяти."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1501
msgid "@example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1505
msgid ""
"/* Suppose there is a function called FOO in some library that you\n"
"   would like to make available to Scheme code (or to C code that\n"
"   follows the Scheme conventions)."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1509
msgid ""
"   FOO takes two C strings and returns a new string.  When an error has\n"
"   occurred in FOO, it returns NULL.\n"
"*/"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1511
msgid "char *foo (char *s1, char *s2);"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1516
msgid ""
"/* SCM_FOO interfaces the C function FOO to the Scheme way of life.\n"
"   It takes care to free up all temporary strings in the case of\n"
"   non-local exits.\n"
" */"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1521
msgid ""
"SCM\n"
"scm_foo (SCM s1, SCM s2)\n"
"@{\n"
"  char *c_s1, *c_s2, *c_res;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1523
msgid "  scm_dynwind_begin (0);"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1525
msgid "  c_s1 = scm_to_locale_string (s1);"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1529
msgid ""
"  /* Call 'free (c_s1)' when the dynwind context is left. \n"
"  */\n"
"  scm_dynwind_unwind_handler (free, c_s1, SCM_F_WIND_EXPLICITLY);"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1531
msgid "  c_s2 = scm_to_locale_string (s2);"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1535
msgid ""
"  /* Same as above, but more concisely.\n"
"  */\n"
"  scm_dynwind_free (c_s2);"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1539
msgid ""
"  c_res = foo (c_s1, c_s2);\n"
"  if (c_res == NULL)\n"
"    scm_memory_error (\"foo\");"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1541
msgid "  scm_dynwind_end ();"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1545
msgid ""
"  return scm_take_locale_string (res);\n"
"@}\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1552
msgid ""
"@rnindex dynamic-wind\n"
"@deffn {Scheme Procedure} dynamic-wind in_guard thunk out_guard\n"
"@deffnx {C Function} scm_dynamic_wind (in_guard, thunk, out_guard)\n"
"All three arguments must be 0-argument procedures.\n"
"@var{in_guard} is called, then @var{thunk}, then\n"
"@var{out_guard}."
msgstr ""
"@rnindex dynamic-wind\n"
"@deffn {Scheme Procedure} dynamic-wind in_guard thunk out_guard\n"
"@deffnx {C Function} scm_dynamic_wind (in_guard, thunk, out_guard)\n"
"Все три аргумента должны быть процедурами без аргументов.\n"
"сначала вызывается @var{in_guard}, потом @var{thunk}, затем\n"
"@var{out_guard}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1559
msgid ""
"If, any time during the execution of @var{thunk}, the\n"
"dynamic extent of the @code{dynamic-wind} expression is escaped\n"
"non-locally, @var{out_guard} is called.  If the dynamic extent of\n"
"the dynamic-wind is re-entered, @var{in_guard} is called.  Thus\n"
"@var{in_guard} and @var{out_guard} may be called any number of\n"
"times."
msgstr ""
"Если в любое время, во время выполнения чанка @var{thunk}, в\n"
"динамическом пространства выражения @code{dynamic-wind} произойдет\n"
"нелокальный выход, вызывается @var{out_guard}.  Если произойдет\n"
"повторный вход в динамическое пространство описываемое динамическим\n"
"ветром(dynamic-wind) вызывается @var{in_guard}.  Таким образом\n"
"@var{in_guard} и @var{out_guard} могут быть вызваны любое количество\n"
"раз."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1571
msgid ""
"@lisp\n"
"(define x 'normal-binding)\n"
"@result{} x\n"
"(define a-cont\n"
"  (call-with-current-continuation\n"
"   (lambda (escape)\n"
"     (let ((old-x x))\n"
"       (dynamic-wind\n"
"           ;; in-guard:\n"
"           ;;\n"
"           (lambda () (set! x 'special-binding))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1578
msgid ""
"           ;; thunk\n"
"           ;;\n"
"           (lambda () (display x) (newline)\n"
"                      (call-with-current-continuation escape)\n"
"                      (display x) (newline)\n"
"                      x)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1599
msgid ""
"           ;; out-guard:\n"
"           ;;\n"
"           (lambda () (set! x old-x)))))))\n"
";; Prints:\n"
"special-binding\n"
";; Evaluates to:\n"
"@result{} a-cont\n"
"x\n"
"@result{} normal-binding\n"
"(a-cont #f)\n"
";; Prints:\n"
"special-binding\n"
";; Evaluates to:\n"
"@result{} a-cont  ;; the value of the (define a-cont...)\n"
"x\n"
"@result{} normal-binding\n"
"a-cont\n"
"@result{} special-binding\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1604
msgid ""
"@deftp {C Type} scm_t_dynwind_flags\n"
"This is an enumeration of several flags that modify the behavior of\n"
"@code{scm_dynwind_begin}.  The flags are listed in the following\n"
"table."
msgstr ""
"@deftp {C Type} scm_t_dynwind_flags\n"
"Это перечисление имеет несколько флагов, которые изменяют поведение\n"
"@code{scm_dynwind_begin}.  Флаги перечислены в следующей таблице."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1611
msgid ""
"@table @code\n"
"@item SCM_F_DYNWIND_REWINDABLE\n"
"The dynamic context is @dfn{rewindable}.  This means that it can be\n"
"reentered non-locally (via the invocation of a continuation).  The\n"
"default is that a dynwind context can not be reentered non-locally.\n"
"@end table"
msgstr ""
"@table @code\n"
"@item SCM_F_DYNWIND_REWINDABLE\n"
"Динамический контекст становиться \"перематываемым\"(@dfn{rewindable}). Это "
"означает\n"
"что в него можно повторно войти нелокально(через вызов продолжения). По "
"умолчанию\n"
"в этот контекст динамического ветра(dynwind) нельзя повторно войти не "
"локально.\n"
"@end table"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1613
msgid "@end deftp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1617
msgid ""
"@deftypefn {C Function} void scm_dynwind_begin (scm_t_dynwind_flags flags)\n"
"The function @code{scm_dynwind_begin} starts a new dynamic context and\n"
"makes it the `current' one."
msgstr ""
"@deftypefn {C Function} void scm_dynwind_begin (scm_t_dynwind_flags flags)\n"
"Функция @code{scm_dynwind_begin} запускает новый динамический контекст и \n"
"делает его  `текущим'."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1623
msgid ""
"The @var{flags} argument determines the default behavior of the\n"
"context.  Normally, use 0.  This will result in a context that can not\n"
"be reentered with a captured continuation.  When you are prepared to\n"
"handle reentries, include @code{SCM_F_DYNWIND_REWINDABLE} in\n"
"@var{flags}."
msgstr ""
"Аргумент @var{flags} определяет поведение контекста по умолчанию.\n"
"Обычно используется 0.  Это приведет к созданию контекста, в который\n"
"нельзя повторно войти с захваченным продолжением. Когда вы будете готовы\n"
"обработать повторные входы, включите повторные входы \n"
"@code{SCM_F_DYNWIND_REWINDABLE} в @var{flags}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1629
msgid ""
"Being prepared for reentry means that the effects of unwind handlers\n"
"can be undone on reentry.  In the example above, we want to prevent a\n"
"memory leak on non-local exit and thus register an unwind handler that\n"
"frees the memory.  But once the memory is freed, we can not get it\n"
"back on reentry.  Thus reentry can not be allowed."
msgstr ""
"Быть готовым к повторному входу означает, что эффекты обработчика\n"
"unwind могут быть отменены при повторном входе. В приведенном выше \n"
"примере мы хотели предотвратить утечку памяти при нелокальном выходе\n"
"и поэтому зарегистрировали обработчик раскрутки(unwind) которые освобождает\n"
"память.  Но как только память освобождена, мы не можем вернуться обратно,\n"
"т.е войти в продолжение. Таким образом возвращение не может быть разрешено."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1633
msgid ""
"The consequence is that continuations become less useful when\n"
"non-reentrant contexts are captured, but you don't need to worry\n"
"about that too much."
msgstr ""
"Следствием этого является то, что продолжения становяться менее\n"
"полезными, нельзя войти в захваченные контексты, но вам не нужно\n"
"слишком сильно беспокоиться об этом."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1640
msgid ""
"The context is ended either implicitly when a non-local exit happens,\n"
"or explicitly with @code{scm_dynwind_end}.  You must make sure that a\n"
"dynwind context is indeed ended properly.  If you fail to call\n"
"@code{scm_dynwind_end} for each @code{scm_dynwind_begin}, the behavior\n"
"is undefined.\n"
"@end deftypefn"
msgstr ""
"Контекст завершается либо неявно, когда происходит нелокальный выход,\n"
"либо явно вызовом @code{scm_dynwind_end}.  Вы должны убедиться, что\n"
"контекст динамического ветра(dynwind) действительно закончен должным\n"
"образом. Если вам не удасться вызвать @code{scm_dynwind_end} для \n"
"каждого @code{scm_dynwind_begin}, поведение будет неопеделенным.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1645
msgid ""
"@deftypefn {C Function} void scm_dynwind_end ()\n"
"End the current dynamic context explicitly and make the previous one\n"
"current.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Function} void scm_dynwind_end ()\n"
"Явно завершает текущий динамический контекст и делает текущим предыдущий.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1651
msgid ""
"@deftp {C Type} scm_t_wind_flags\n"
"This is an enumeration of several flags that modify the behavior of\n"
"@code{scm_dynwind_unwind_handler} and\n"
"@code{scm_dynwind_rewind_handler}.  The flags are listed in the\n"
"following table."
msgstr ""
"@deftp {C Type} scm_t_wind_flags\n"
"Это перечисление нескольких флагов, которые изменяют поведение\n"
"@code{scm_dynwind_unwind_handler} и\n"
"@code{scm_dynwind_rewind_handler}.  Флаги перечислены в следующей\n"
"таблице."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1659
msgid ""
"@table @code\n"
"@item SCM_F_WIND_EXPLICITLY\n"
"@vindex SCM_F_WIND_EXPLICITLY\n"
"The registered action is also carried out when the dynwind context is\n"
"entered or left locally.\n"
"@end table\n"
"@end deftp"
msgstr ""
"@table @code\n"
"@item SCM_F_WIND_EXPLICITLY\n"
"@vindex SCM_F_WIND_EXPLICITLY\n"
"Зарегистрированное действие так же выполняется, когда в/из контекста "
"динамического\n"
"ветра(dynwind) осуществляется локальный вход или выход.\n"
"@end table\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1666
msgid ""
"@deftypefn {C Function} void scm_dynwind_unwind_handler (void (*func)(void "
"*), void *data, scm_t_wind_flags flags)\n"
"@deftypefnx {C Function} void scm_dynwind_unwind_handler_with_scm (void "
"(*func)(SCM), SCM data, scm_t_wind_flags flags)\n"
"Arranges for @var{func} to be called with @var{data} as its arguments\n"
"when the current context ends implicitly.  If @var{flags} contains\n"
"@code{SCM_F_WIND_EXPLICITLY}, @var{func} is also called when the\n"
"context ends explicitly with @code{scm_dynwind_end}."
msgstr ""
"@deftypefn {C Function} void scm_dynwind_unwind_handler (void (*func)(void "
"*), void *data, scm_t_wind_flags flags)\n"
"@deftypefnx {C Function} void scm_dynwind_unwind_handler_with_scm (void "
"(*func)(SCM), SCM data, scm_t_wind_flags flags)\n"
"Организация вызова для @var{func} с аргументами @var{data}, когда текущий\n"
"контекст завершается не явно.  Если @var{flags} содержит  "
"@code{SCM_F_WIND_EXPLICITLY}, \n"
"@var{func} также вызывается, когда контекст завершается явно с помощью  "
"@code{scm_dynwind_end}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1670
msgid ""
"The function @code{scm_dynwind_unwind_handler_with_scm} takes care that\n"
"@var{data} is protected from garbage collection.\n"
"@end deftypefn"
msgstr ""
"Функция @code{scm_dynwind_unwind_handler_with_scm} обеспечивает\n"
"защиту @var{data} от сборщика мусора.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1677
msgid ""
"@deftypefn {C Function} void scm_dynwind_rewind_handler (void (*func)(void "
"*), void *data, scm_t_wind_flags flags)\n"
"@deftypefnx {C Function} void scm_dynwind_rewind_handler_with_scm (void "
"(*func)(SCM), SCM data, scm_t_wind_flags flags)\n"
"Arrange for @var{func} to be called with @var{data} as its argument when\n"
"the current context is restarted by rewinding the stack.  When @var{flags}\n"
"contains @code{SCM_F_WIND_EXPLICITLY}, @var{func} is called immediately\n"
"as well."
msgstr ""
"@deftypefn {C Function} void scm_dynwind_rewind_handler (void (*func)(void "
"*), void *data, scm_t_wind_flags flags)\n"
"@deftypefnx {C Function} void scm_dynwind_rewind_handler_with_scm (void "
"(*func)(SCM), SCM data, scm_t_wind_flags flags)\n"
"Организация вызова для функции @var{func} вызываемой с аргументом "
"@var{data}, когда\n"
"текущий контекст стартует заново путем перемотки стека.  когда флаги "
"@var{flags}\n"
"содержат @code{SCM_F_WIND_EXPLICITLY}, функция @var{func} также вызывается "
"еще и немедленно."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1681
msgid ""
"The function @code{scm_dynwind_rewind_handler_with_scm} takes care that\n"
"@var{data} is protected from garbage collection.\n"
"@end deftypefn"
msgstr ""
"Функция @code{scm_dynwind_rewind_handler_with_scm} обеспечивает защиту "
"данных\n"
"@var{data} от сборщика мусора.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1688
msgid ""
"@deftypefn {C Function} void scm_dynwind_free (void *mem)\n"
"Arrange for @var{mem} to be freed automatically whenever the current\n"
"context is exited, whether normally or non-locally.\n"
"@code{scm_dynwind_free (mem)} is an equivalent shorthand for\n"
"@code{scm_dynwind_unwind_handler (free, mem, SCM_F_WIND_EXPLICITLY)}.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Function} void scm_dynwind_free (void *mem)\n"
"Организует автоматическое освобождение для @var{mem} при каждом выходе\n"
"из текущего контекста, нормального или не-локального.\n"
"@code{scm_dynwind_free (mem)} ялвяется эквивалентнцм сокращением для\n"
"@code{scm_dynwind_unwind_handler (free, mem, SCM_F_WIND_EXPLICITLY)}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1692
msgid ""
"@node Fluids and Dynamic States\n"
"@subsection Fluids and Dynamic States"
msgstr ""
"@node Fluids and Dynamic States\n"
"@subsection Флюиды/Жидкие и изменичивые(Fluids) и Динамические "
"состояния(Dynamic States)"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1694
msgid "@cindex fluids"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1701
msgid ""
"A @emph{fluid} is a variable whose value is associated with the dynamic\n"
"extent of a function call.  In the same way that an operating system\n"
"runs a process with a given set of current input and output ports (or\n"
"file descriptors), in Guile you can arrange to call a function while\n"
"binding a fluid to a particular value.  That association between fluid\n"
"and value will exist during the dynamic extent of the function call."
msgstr ""
"Флюид(@emph{fluid}) это переменная, значение которой связано с динамическим\n"
"пространством вызванной функции.  Так же как операционная система запускает\n"
"процесс с предоставлением ему установленных портов текущего ввода и вывода\n"
"(или файловых дискрипторов), в Guile вы можете организовать вызов функции\n"
"во время связывания флюида(fluid/переменно) с особым значением. Эта связь\n"
"между флюидом и значением будет существовать во время динамического "
"пространства\n"
"вызова функции."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1711
msgid ""
"Fluids are a therefore a building block for implementing dynamically\n"
"scoped variables.  Dynamically scoped variables are useful when you want\n"
"to set a variable to a value during some dynamic extent in the execution\n"
"of your program and have them revert to their original value when the\n"
"control flow is outside of this dynamic extent.  See the description of\n"
"@code{with-fluids} below for details.  This association between fluids,\n"
"values, and dynamic extents is robust to multiple entries (as when a\n"
"captured continuation is invoked more than once) and early exits (for\n"
"example, when throwing exceptions)."
msgstr ""
"Поэтому флюиды являются строительными блоками для реализации переменных\n"
"с динамической сферой действия.  Переменные с динамической сферой действия\n"
"полезны, когда вы хотите установить значение переменной значением в течении\n"
"некоторого динамического пространства при исполнении вашей программы и "
"заставить\n"
"ее вернуться к своему исходному значению, поток управления выходит за "
"пределы\n"
"этого динамического пространствва.  Смотри описание к @code{with-fluids} \n"
"ниже, для более детального ознакомления.  Эта связь между флюидами, "
"значениями\n"
"и динамическим пространством устойчива к множественным входам( например,\n"
"когда захваченное продолжение вызывается более чем один раз) и ранним "
"выходам\n"
"(например при выбрасывании/возникновении исключений)."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1716
msgid ""
"Guile uses fluids to implement parameters (@pxref{Parameters}).  Usually\n"
"you just want to use parameters directly.  However it can be useful to\n"
"know what a fluid is and how it works, so that's what this section is\n"
"about."
msgstr ""
"Guile использует флюиды для реализации параметров (@pxref{Parameters}).  "
"Обычно\n"
"вы просто хотите использовать параметры напрямую. Однако, может быть "
"полезным узнать\n"
"что такое флюиды и как они работают, вот о чем этот раздел."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1724
msgid ""
"The current set of fluid-value associations can be captured in a\n"
"@emph{dynamic state} object.  A dynamic extent is simply that: a\n"
"snapshot of the current fluid-value associations.  Guile users can\n"
"capture the current dynamic state with @code{current-dynamic-state} and\n"
"restore it later via @code{with-dynamic-state} or similar procedures.\n"
"This facility is especially useful when implementing lightweight\n"
"thread-like abstractions."
msgstr ""
"Текущий набор ассоциаций флюид-значение может быть зафиксирован в\n"
"объекте динамического состояния(@emph{dynamic state} object). \n"
"Динамическое пространство(dynamic extent) это просто моментальный\n"
"снимок текущий ассоциаций флюид-значение(fluid-value).  Пользователи Guile\n"
"могут захватывать(фиксировать) текущее динамическое состояние с помощью\n"
"@code{current-dynamic-state} и восстанавливать его позже через \n"
"@code{with-dynamic-state} или пдобных процедур.\n"
"Это средство особенно полезно, когда реализуются абстракции подобные \n"
"легковесным потокам(lightweight thread)."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1729
msgid ""
"New fluids are created with @code{make-fluid} and @code{fluid?} is\n"
"used for testing whether an object is actually a fluid.  The values\n"
"stored in a fluid can be accessed with @code{fluid-ref} and\n"
"@code{fluid-set!}."
msgstr ""
"Новые флюиды создаются с помощью @code{make-fluid} и @code{fluid?} \n"
"используется для проверки, является ли объект на самом деле флюидом.\n"
"К значениям хранящися во флюиде можно получать доступ с помощью\n"
"@code{fluid-ref} и @code{fluid-set!}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1732
msgid ""
"@xref{Thread Local Variables}, for further notes on fluids, threads,\n"
"parameters, and dynamic states."
msgstr ""
"@xref{Thread Local Variables}, для получения дополнительных сведений о\n"
"флюидах, потоках и динамических состояниях."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1745
msgid ""
"@deffn {Scheme Procedure} make-fluid [dflt]\n"
"@deffnx {C Function} scm_make_fluid ()\n"
"@deffnx {C Function} scm_make_fluid_with_default (dflt)\n"
"Return a newly created fluid, whose initial value is @var{dflt}, or\n"
"@code{#f} if @var{dflt} is not given.\n"
"Fluids are objects that can hold one\n"
"value per dynamic state.  That is, modifications to this value are\n"
"only visible to code that executes with the same dynamic state as\n"
"the modifying code.  When a new dynamic state is constructed, it\n"
"inherits the values from its parent.  Because each thread normally executes\n"
"with its own dynamic state, you can use fluids for thread local storage.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} make-fluid [dflt]\n"
"@deffnx {C Function} scm_make_fluid ()\n"
"@deffnx {C Function} scm_make_fluid_with_default (dflt)\n"
"Возвращает вновь созданный флюид, начальное значение которого равно "
"@var{dflt}, \n"
"или @code{#f} если @var{dflt} не задано.\n"
"Флюиды это объекты которые могут одно значение для одного динамического "
"состояния.\n"
"То есть, изменения этого значения видны только коду, который выполняется с "
"тем же\n"
"динамическим состоянием, что и модифицирующий код.  Когда создается новое \n"
"динамическое состояние, оно наследует значения от своего родителя. Поскольку "
"каждый\n"
"поток, обычно, выполняется со своим собственным динамическим состоянием, вы "
"может\n"
"использовать флюиды, для хранения локальных значений потока.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1751
msgid ""
"@deffn {Scheme Procedure} make-unbound-fluid\n"
"@deffnx {C Function} scm_make_unbound_fluid ()\n"
"Return a new fluid that is initially unbound (instead of being\n"
"implicitly bound to some definite value).\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} make-unbound-fluid\n"
"@deffnx {C Function} scm_make_unbound_fluid ()\n"
"Возвращает новый флюид, который изначально не связан (вместо того,\n"
"чтобы быть связанным с каким то определенным значением).\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1757
msgid ""
"@deffn {Scheme Procedure} fluid? obj\n"
"@deffnx {C Function} scm_fluid_p (obj)\n"
"Return @code{#t} if @var{obj} is a fluid; otherwise, return\n"
"@code{#f}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} fluid? obj\n"
"@deffnx {C Function} scm_fluid_p (obj)\n"
"Возвращает @code{#t} если @var{obj} это флюид, иначе возвращает\n"
"@code{#f}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1765
msgid ""
"@deffn {Scheme Procedure} fluid-ref fluid\n"
"@deffnx {C Function} scm_fluid_ref (fluid)\n"
"Return the value associated with @var{fluid} in the current\n"
"dynamic root.  If @var{fluid} has not been set, then return\n"
"its default value. Calling @code{fluid-ref} on an unbound fluid produces\n"
"a runtime error.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} fluid-ref fluid\n"
"@deffnx {C Function} scm_fluid_ref (fluid)\n"
"Возвращает значение связанное с флюидом @var{fluid} в текущем \n"
"динамическвом корне. Если @var{fluid} не был установлен, возвращается\n"
"значение по умолчанию. Вызов @code{fluid-ref} для несвязанного флюида\n"
"вызывает ошибку времени выполнения.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1770
msgid ""
"@deffn {Scheme Procedure} fluid-set! fluid value\n"
"@deffnx {C Function} scm_fluid_set_x (fluid, value)\n"
"Set the value associated with @var{fluid} in the current dynamic root.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} fluid-set! fluid value\n"
"@deffnx {C Function} scm_fluid_set_x (fluid, value)\n"
"Устанавливает значение связанное с флюидом @var{fluid} в текущем "
"динамическом\n"
"корне.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1777
msgid ""
"@deffn {Scheme Procedure} fluid-ref* fluid depth\n"
"@deffnx {C Function} scm_fluid_ref_star (fluid, depth)\n"
"Return the @var{depth}th oldest value associated with @var{fluid} in the\n"
"current thread.  If @var{depth} equals or exceeds the number of values\n"
"that have been assigned to @var{fluid}, return the default value of the\n"
"fluid.  @code{(fluid-ref* f 0)} is equivalent to @code{(fluid-ref f)}."
msgstr ""
"@deffn {Scheme Procedure} fluid-ref* fluid depth\n"
"@deffnx {C Function} scm_fluid_ref_star (fluid, depth)\n"
"Возвращает старое значение присвоенное флюиду @var{fluid} имеющее "
"глубину(@var{depth})\n"
"в текущем потоке. Если глубина(@var{depth}) равна или превышает\n"
"количество значений, которые были присвоены @var{fluid}, возвращает "
"значение\n"
"по умолчанию для флюида.  @code{(fluid-ref* f 0)} эквивалентно коду "
"@code{(fluid-ref f)}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1785
msgid ""
"@code{fluid-ref*} is useful when you want to maintain a stack-like\n"
"structure in a fluid, such as the stack of current exception handlers.\n"
"Using @code{fluid-ref*} instead of an explicit stack allows any partial\n"
"continuation captured by @code{call-with-prompt} to only capture the\n"
"bindings made within the limits of the prompt instead of the entire\n"
"continuation.  @xref{Prompts}, for more on delimited continuations.\n"
"@end deffn"
msgstr ""
"@code{fluid-ref*} полезен, когда вы хотите поддерживать стеко-подобную\n"
"структуру во флюиде, например, такую как стек текущих обработчиков "
"исключений.\n"
"Использование @code{fluid-ref*} вместо явного стека позволяет любому\n"
"частичному продолжению захватывать используя @code{call-with-prompt} только\n"
"привязки созданные только в пределах запроса, вместо всего продолжения.\n"
"@xref{Prompts}, для получения дополнительной информации о разделенных "
"продолжениях.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1790
msgid ""
"@deffn {Scheme Procedure} fluid-unset! fluid\n"
"@deffnx {C Function} scm_fluid_unset_x (fluid)\n"
"Disassociate the given fluid from any value, making it unbound.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} fluid-unset! fluid\n"
"@deffnx {C Function} scm_fluid_unset_x (fluid)\n"
"Отсоединяет данный флюид от любого значения, делая его несвязанным.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1796
msgid ""
"@deffn {Scheme Procedure} fluid-bound? fluid\n"
"@deffnx {C Function} scm_fluid_bound_p (fluid)\n"
"Returns @code{#t} if the given fluid is bound to a value, otherwise\n"
"@code{#f}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} fluid-bound? fluid\n"
"@deffnx {C Function} scm_fluid_bound_p (fluid)\n"
"Возвращает @code{#t} если данный флюид связан со значением, иначе\n"
"@code{#f}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1800
msgid ""
"@code{with-fluids*} temporarily changes the values of one or more fluids,\n"
"so that the given procedure and each procedure called by it access the\n"
"given values.  After the procedure returns, the old values are restored."
msgstr ""
"@code{with-fluids*} временно изменяет значение одного или нескольких "
"флюидов,\n"
"так что процедура и каждая вызванная ей процедура обращаются к заданным\n"
"значениям.  После возврата процедуры, старые значения восстанавливаются."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1806
msgid ""
"@deffn {Scheme Procedure} with-fluid* fluid value thunk\n"
"@deffnx {C Function} scm_with_fluid (fluid, value, thunk)\n"
"Set @var{fluid} to @var{value} temporarily, and call @var{thunk}.\n"
"@var{thunk} must be a procedure with no argument.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} with-fluid* fluid value thunk\n"
"@deffnx {C Function} scm_with_fluid (fluid, value, thunk)\n"
"Устанавливает флюиду @var{fluid} временное значение @var{value} и вызывает "
"чанк @var{thunk}.\n"
"@var{thunk} должен быть процедурой без аргументов.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1817
msgid ""
"@deffn {Scheme Procedure} with-fluids* fluids values thunk\n"
"@deffnx {C Function} scm_with_fluids (fluids, values, thunk)\n"
"Set @var{fluids} to @var{values} temporary, and call @var{thunk}.\n"
"@var{fluids} must be a list of fluids and @var{values} must be the\n"
"same number of their values to be applied.  Each substitution is done\n"
"in the order given.  @var{thunk} must be a procedure with no argument.\n"
"It is called inside a @code{dynamic-wind} and the fluids are\n"
"set/restored when control enter or leaves the established dynamic\n"
"extent.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} with-fluids* fluids values thunk\n"
"@deffnx {C Function} scm_with_fluids (fluids, values, thunk)\n"
"Устанавливает флюидам @var{fluids} временные значения @var{values} и "
"вызывает \n"
"чанк @var{thunk}. @var{fluids} должен быть списком флюидов и @var{values} \n"
"должен иметь тоже количество значений.  Каждая подстановка делается в "
"указанном\n"
"порядке.  @var{thunk} должен быть процедурой без аргументов.\n"
"Он вызывается внутри динамического ветра( @code{dynamic-wind}) и флюиды\n"
"устанавливаются/восстанавиливаются когда управление входит или покидает \n"
"динамическое пространство.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1825
msgid ""
"@deffn {Scheme Macro} with-fluids ((fluid value) @dots{}) body1 body2 "
"@dots{}\n"
"Execute body @var{body1} @var{body2} @dots{}  while each @var{fluid} is\n"
"set to the corresponding @var{value}.  Both @var{fluid} and @var{value}\n"
"are evaluated and @var{fluid} must yield a fluid.  The body is executed\n"
"inside a @code{dynamic-wind} and the fluids are set/restored when\n"
"control enter or leaves the established dynamic extent.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Macro} with-fluids ((fluid value) @dots{}) body1 body2 "
"@dots{}\n"
"Выполняет тело @var{body1} @var{body2} @dots{}  в то время как каждый флюид\n"
"@var{fluid} устанавиливается соответствующим значением @var{value}.  Как "
"@var{fluid},\n"
"так и значение @var{value} вычисляются и @var{fluid} должен выдавать  "
"флюид.  \n"
"Тело выполняется внутри динамического ветра(@code{dynamic-wind}) и флюиды \n"
"устанавливаются/восстанавливаются когда управление входит или покидает "
"установленный\n"
"динамическое пространство.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1830
msgid ""
"@deftypefn {C Function} SCM scm_c_with_fluids (SCM fluids, SCM vals, SCM "
"(*cproc)(void *), void *data)\n"
"@deftypefnx {C Function} SCM scm_c_with_fluid (SCM fluid, SCM val, SCM "
"(*cproc)(void *), void *data)\n"
"The function @code{scm_c_with_fluids} is like @code{scm_with_fluids}\n"
"except that it takes a C function to call instead of a Scheme thunk."
msgstr ""
"@deftypefn {C Function} SCM scm_c_with_fluids (SCM fluids, SCM vals, SCM "
"(*cproc)(void *), void *data)\n"
"@deftypefnx {C Function} SCM scm_c_with_fluid (SCM fluid, SCM val, SCM "
"(*cproc)(void *), void *data)\n"
"Функция @code{scm_c_with_fluids} похожа на @code{scm_with_fluids} за "
"исключением\n"
"того, что она принимает Си функцию для вызова, вместо чанка Scheme."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1834
msgid ""
"The function @code{scm_c_with_fluid} is similar but only allows one\n"
"fluid to be set instead of a list.\n"
"@end deftypefn"
msgstr ""
"Функция @code{scm_c_with_fluid} аналогична, но позволяет устанавливать\n"
"один флюид вместо списка.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1840
msgid ""
"@deftypefn {C Function} void scm_dynwind_fluid (SCM fluid, SCM val)\n"
"This function must be used inside a pair of calls to\n"
"@code{scm_dynwind_begin} and @code{scm_dynwind_end} (@pxref{Dynamic\n"
"Wind}).  During the dynwind context, the fluid @var{fluid} is set to\n"
"@var{val}."
msgstr ""
"@deftypefn {C Function} void scm_dynwind_fluid (SCM fluid, SCM val)\n"
"Эта функция должна использоваться внутри пары вызовов\n"
"@code{scm_dynwind_begin} и @code{scm_dynwind_end} (@pxref{Dynamic\n"
"Wind}).  Во время контекста динамического ветра(dynwind), флюид @var{fluid}\n"
"устанавливается значением @var{val}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1845
msgid ""
"More precisely, the value of the fluid is swapped with a `backup'\n"
"value whenever the dynwind context is entered or left.  The backup\n"
"value is initialized with the @var{val} argument.\n"
"@end deftypefn"
msgstr ""
"Точнее, значение флюида заменяется на `сохраненное/резервированное'\n"
"значение, всякий раз когда в контекст динамического ветра(dynwind) входит\n"
"поток управления и покидает его. Резервное значение инициализируется "
"значением\n"
"аргумента @var{val}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1851
msgid ""
"@deffn {Scheme Procedure} dynamic-state? obj\n"
"@deffnx {C Function} scm_dynamic_state_p (obj)\n"
"Return @code{#t} if @var{obj} is a dynamic state object;\n"
"return @code{#f} otherwise.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} dynamic-state? obj\n"
"@deffnx {C Function} scm_dynamic_state_p (obj)\n"
"Возвращает @code{#t} если @var{obj} это объект динамического "
"состояния(dynamic state object);\n"
"иначе @code{#f}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1856
msgid ""
"@deftypefn {C Procedure} int scm_is_dynamic_state (SCM obj)\n"
"Return non-zero if @var{obj} is a dynamic state object;\n"
"return zero otherwise.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Procedure} int scm_is_dynamic_state (SCM obj)\n"
"Возвращает не ноль, если @var{obj} это объект динамического состояния;\n"
"иначе возвращает 0.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1862
msgid ""
"@deffn {Scheme Procedure} current-dynamic-state\n"
"@deffnx {C Function} scm_current_dynamic_state ()\n"
"Return a snapshot of the current fluid-value associations as a fresh\n"
"dynamic state object.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} current-dynamic-state\n"
"@deffnx {C Function} scm_current_dynamic_state ()\n"
"Возвращает снимок текущих связей флюид-значение(fluid-value) в виде\n"
"нового объекта динамического состояния.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1870
msgid ""
"@deffn {Scheme Procedure} set-current-dynamic-state state\n"
"@deffnx {C Function} scm_set_current_dynamic_state (state)\n"
"Restore the saved fluid-value associations from @var{state}, replacing\n"
"the current fluid-value associations.  Return the current fluid-value\n"
"associatoins as a dynamic state object, as in\n"
"@code{current-dynamic-state}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} set-current-dynamic-state state\n"
"@deffnx {C Function} scm_set_current_dynamic_state (state)\n"
"Восстанавливает сохранненые ассоциации флюид-значение(fluid-value), заменяя\n"
"текущие ассоциации флюид-значение(fluid-value).  Возвращает текущие "
"ассоциации\n"
"fluid-value в виде объекта динамического состояния, как в\n"
"@code{current-dynamic-state}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1880
msgid ""
"@deffn {Scheme Procedure} with-dynamic-state state proc\n"
"@deffnx {C Function} scm_with_dynamic_state (state, proc)\n"
"Call @var{proc} while the fluid bindings from @var{state} have been made\n"
"current, saving the current fluid bindings.  When control leaves the\n"
"invocation of @var{proc}, restore the saved bindings, saving instead the\n"
"fluid bindings from inside the call.  If control later re-enters\n"
"@var{proc}, restore those saved bindings, saving the current bindings,\n"
"and so on.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} with-dynamic-state state proc\n"
"@deffnx {C Function} scm_with_dynamic_state (state, proc)\n"
"Вызывает @var{proc} делая привязки флюидов из @var{state} текущими,\n"
"запоминая текущие привязки флюидов.  Когда управление покидает вызов\n"
" @var{proc}, восстанавливает сохраненные привязки, сохраняя вместо этого\n"
"привязки флюидов внутри вызова.  Если управление обратно входит в\n"
"@var{proc}, восстанавливает эти сохраненные привязки, запоминая текущие\n"
"привязки и так далее.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1886
msgid ""
"@deftypefn {C Procedure} void scm_dynwind_current_dynamic_state (SCM state)\n"
"Set the current dynamic state to @var{state} for the current dynwind\n"
"context.  Like @code{with-dynamic-state}, but in terms of Guile's\n"
"``dynwind'' C API.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Procedure} void scm_dynwind_current_dynamic_state (SCM state)\n"
"Устанавливает текущим динамическое состояние @var{state} для текущего\n"
"контекста динамического ветра(dynwind).  Подобно @code{with-dynamic-"
"state}, \n"
"но в с точки зрения Си интерфейса API Guile ``dynwind''.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1891
msgid ""
"@deftypefn {C Procedure} {void *} scm_c_with_dynamic_state (SCM state, void "
"*(*func)(void *), void *data)\n"
"Like @code{scm_with_dynamic_state}, but call @var{func} with\n"
"@var{data}.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Procedure} {void *} scm_c_with_dynamic_state (SCM state, void "
"*(*func)(void *), void *data)\n"
"Как @code{scm_with_dynamic_state}, но вызывая @var{func} с данными\n"
"@var{data}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1894
msgid ""
"@node Parameters\n"
"@subsection Parameters"
msgstr ""
"@node Parameters\n"
"@subsection Параметры(Parameters)"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1898
msgid ""
"@cindex SRFI-39\n"
"@cindex parameter object\n"
"@tindex Parameter"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1900
msgid "Parameters are Guile's facility for dynamically bound variables."
msgstr ""
"Параметры являются средством Guile для динамически связанных переменных."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1904
msgid ""
"On the most basic level, a parameter object is a procedure.  Calling it\n"
"with no arguments returns its value.  Calling it with one argument sets\n"
"the value."
msgstr ""
"На самом нижнем уровне, объект параметр это процедура.  Вызывая ее без\n"
"аргументов возвращает свое значение.  Вызов ее с одним аргументом\n"
"устанавливает ее значение."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1911
msgid ""
"@example\n"
"(define my-param (make-parameter 123))\n"
"(my-param) @result{} 123\n"
"(my-param 456)\n"
"(my-param) @result{} 456\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1917
msgid ""
"The @code{parameterize} special form establishes new locations for\n"
"parameters, those new locations having effect within the dynamic extent\n"
"of the @code{parameterize} body.  Leaving restores the previous\n"
"locations.  Re-entering (through a saved continuation) will again use\n"
"the new locations."
msgstr ""
"Специальная форма @code{parameterize} устанавливает новое местоположение "
"для\n"
"параметров, т.е новые местоположения, имеющие эффект в пределах "
"динамического\n"
"пространства параметризированного(@code{parameterize}) тела.  Выход "
"востанавливает\n"
"предыдущие местположения. Повторный вход (через сохраненное продолжение) "
"снова будет\n"
"использовать новые местопоолжения."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1923
msgid ""
"@example\n"
"(parameterize ((my-param 789))\n"
"  (my-param)) @result{} 789\n"
"(my-param) @result{} 456\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1929
msgid ""
"Parameters are like dynamically bound variables in other Lisp dialects.\n"
"They allow an application to establish parameter settings (as the name\n"
"suggests) just for the execution of a particular bit of code, restoring\n"
"when done.  Examples of such parameters might be case-sensitivity for a\n"
"search, or a prompt for user input."
msgstr ""
"Параметры похожи на динамически связанные переменные в других диалектах\n"
"Лиспа. Они позволяют приложениям устанавливать параметры( как следует\n"
"из названия) только для выполнения определенной части кода, восстанавливая\n"
"их когда он завершиться.  Примером таких параметров могут быть "
"чувствительность\n"
"к регистру во время поиска, или подсказка для пользовательского ввода."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1934
msgid ""
"Global variables are not as good as parameter objects for this sort of\n"
"thing.  Changes to them are visible to all threads, but in Guile\n"
"parameter object locations are per-thread, thereby truly limiting the\n"
"effect of @code{parameterize} to just its dynamic execution."
msgstr ""
"Глобальные переменные не так хороши, как объекты параметров для такого\n"
"рода вещей. Изменения в них видны всем потокам, но в  Guile\n"
"местоположение объекта параметра устанавливается для каждого потока,\n"
"тем самым действительно ограниичивая эффект от "
"параметризации(@code{parameterize})\n"
"только его динамическим выполнением."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1940
msgid ""
"Passing arguments to functions is thread-safe, but that soon becomes\n"
"tedious when there's more than a few or when they need to pass down\n"
"through several layers of calls before reaching the point they should\n"
"affect.  Introducing a new setting to existing code is often easier with\n"
"a parameter object than adding arguments."
msgstr ""
"Передача аргументов в функции является потоко-защищенной, но это "
"становиться\n"
"утомительным когда есть больше чем несколько, или когда они должны пройти\n"
"через несколько уровней вызова перед тем, как дойти до точки где они "
"вызвать\n"
"эффект. Введение нового параметра в существующий код, часто гораздо проще\n"
"с использованием объекта параметра, чем добавлением аргументов."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1943
msgid ""
"@deffn {Scheme Procedure} make-parameter init [converter]\n"
"Return a new parameter object, with initial value @var{init}."
msgstr ""
"@deffn {Scheme Procedure} make-parameter init [converter]\n"
"Возвращает новый объект параметр, с начальным значением @var{init}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1947
msgid ""
"If a @var{converter} is given, then a call @code{(@var{converter}\n"
"val)} is made for each value set, its return is the value stored.\n"
"Such a call is made for the @var{init} initial value too."
msgstr ""
"Если задан преобразователь @var{converter}, то для каждой установки\n"
"значения выполняется вызов @code{(@var{converter} val)}, возвращаемое им\n"
"значение сохраняется. Такой вызов также выполняется для начального\n"
"значения @var{init}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1950
msgid ""
"A @var{converter} allows values to be validated, or put into a\n"
"canonical form.  For example,"
msgstr ""
"@var{converter} позволяет проверять значения, или вводить их в каноническую\n"
"форму. Например,"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1961
msgid ""
"@example\n"
"(define my-param (make-parameter 123\n"
"                   (lambda (val)\n"
"                     (if (not (number? val))\n"
"                         (error \"must be a number\"))\n"
"                     (inexact->exact val))))\n"
"(my-param 0.75)\n"
"(my-param) @result{} 3/4\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1967
msgid ""
"@deffn {library syntax} parameterize ((param value) @dots{}) body1 body2 "
"@dots{}\n"
"Establish a new dynamic scope with the given @var{param}s bound to new\n"
"locations and set to the given @var{value}s.  @var{body1} @var{body2}\n"
"@dots{} is evaluated in that environment.  The value returned is that of\n"
"last body form."
msgstr ""
"@deffn {library syntax} parameterize ((param value) @dots{}) body1 body2 "
"@dots{}\n"
"Устанавливает новую динамическую область с заданными параметрами "
"@var{param}, привязанными\n"
"к новым местоположениям и установленными заданными значениями @var{value}"
"s. \n"
"Выражения @var{body1} @var{body2} @dots{} вычисляются в этой среде.  \n"
"Значение возвращаемое последним body формы возвращается."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1972
msgid ""
"Each @var{param} is an expression which is evaluated to get the\n"
"parameter object.  Often this will just be the name of a variable\n"
"holding the object, but it can be anything that evaluates to a\n"
"parameter."
msgstr ""
"Каждый параметр @var{param} является выражением, которое вычисляется для \n"
"получения объекта параметра.  Часто это будет просто имя переменной, "
"содержащей\n"
"объект, но это может быть что угодно что вычисляет параметр."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1976
msgid ""
"The @var{param} expressions and @var{value} expressions are all\n"
"evaluated before establishing the new dynamic bindings, and they're\n"
"evaluated in an unspecified order."
msgstr ""
"Выражения @var{param} и выражения @var{value} все вычисляются перед "
"установкой\n"
"новой динамической привязки, и они вычисляются в неопределенном порядке."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1978
msgid "For example,"
msgstr "Например,"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1984
msgid ""
"@example\n"
"(define prompt (make-parameter \"Type something: \"))\n"
"(define (get-input)\n"
"  (display (prompt))\n"
"  ...)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1990
msgid ""
"(parameterize ((prompt \"Type a number: \"))\n"
"  (get-input)\n"
"  ...)\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-control.texi:1997
msgid ""
"Parameter objects are implemented using fluids (@pxref{Fluids and\n"
"Dynamic States}), so each dynamic state has its own parameter\n"
"locations.  That includes the separate locations when outside any\n"
"@code{parameterize} form.  When a parameter is created it gets a\n"
"separate initial location in each dynamic state, all initialized to the\n"
"given @var{init} value."
msgstr ""
"Объекты параметры реализуются с использованием флюидов (@pxref{Fluids and\n"
"Dynamic States}), поэтому каждое динамическое состояние имеет свои "
"собственные\n"
"местоположения. Это включает отдельные местопоолжения за пределами любой\n"
"паораметризованной(@code{parameterize}) формы.  Когда параметр создан он "
"получает\n"
"отдельное начальное местположение в каждом динамическом состоянии, все они\n"
"инициализируются заданным значением @var{init}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2002
msgid ""
"New code should probably just use parameters instead of fluids, because\n"
"the interface is better.  But for migrating old code or otherwise\n"
"providing interoperability, Guile provides the @code{fluid->parameter}\n"
"procedure:"
msgstr ""
"Новый код, вероятно, должен просто использовать параметры вместо флюидов,\n"
"поскольку интерфейс работы с ними лучше. Но для переноса старого кода или\n"
"обеспечения иного взаимодействия, Guile предоставляет процедуру \n"
"@code{fluid->parameter}:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2005
msgid ""
"@deffn {Scheme Procedure} fluid->parameter fluid [conv]\n"
"Make a parameter that wraps a fluid."
msgstr ""
"@deffn {Scheme Procedure} fluid->parameter fluid [conv]\n"
"Создает параметр, который оборачивает флюид."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2012
msgid ""
"The value of the parameter will be the same as the value of the fluid.\n"
"If the parameter is rebound in some dynamic extent, perhaps via\n"
"@code{parameterize}, the new value will be run through the optional\n"
"@var{conv} procedure, as with any parameter.  Note that unlike\n"
"@code{make-parameter}, @var{conv} is not applied to the initial value.\n"
"@end deffn"
msgstr ""
"Значение параметра будет тем же самым, что и значение флюида.\n"
"Если параметр пересвязывается в некотором динамическом пространстве,\n"
"возможно через @code{parameterize}, новое значение будет выполнять\n"
"необязательную процедуру @var{conv}, как и для любого параметра.  \n"
"Обратите внимание, что в отличии от @code{make-parameter}, @var{conv} \n"
"не применяется к начальному значению.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2018
msgid ""
"As alluded to above, because each thread usually has a separate dynamic\n"
"state, each thread has its own locations behind parameter objects, and\n"
"changes in one thread are not visible to any other.  When a new dynamic\n"
"state or thread is created, the values of parameters in the originating\n"
"context are copied, into new locations."
msgstr ""
"Как упоминалось выше, потому что каждый поток обычно имеет отдельное\n"
"динамическое состояние, каждый поток имеет имеет и свои собственные\n"
"местоположения для объектов параметров, и изменения в одном потоке не\n"
"видно никакому другому. Когда создается новое динамическое состояние или\n"
"поток, значения параметров в исходном контексте, копируются в новое\n"
"местоположение."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2021
msgid ""
"@cindex SRFI-39\n"
"Guile's parameters conform to SRFI-39 (@pxref{SRFI-39})."
msgstr ""
"@cindex SRFI-39\n"
"Параметры Guile соответствуют SRFI-39 (@pxref{SRFI-39})."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2025
msgid ""
"@node Handling Errors\n"
"@subsection How to Handle Errors"
msgstr ""
"@node Handling Errors\n"
"@subsection Как обрабатывать Ошибки"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2028
msgid ""
"Error handling is based on @code{catch} and @code{throw}.  Errors are\n"
"always thrown with a @var{key} and four arguments:"
msgstr ""
"Обработка ошибок основана на @code{catch} и @code{throw}.  Ошибки всегда\n"
"выбрасываются с  ключем @var{key} и четырьмя аргументами:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2033
msgid ""
"@itemize @bullet\n"
"@item\n"
"@var{key}: a symbol which indicates the type of error.  The symbols used\n"
"by libguile are listed below."
msgstr ""
"@itemize @bullet\n"
"@item\n"
"@var{key}: символ, который указывает тип ошибки.  Символы используемые\n"
"в libguile перечислены ниже."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2037
msgid ""
"@item\n"
"@var{subr}: the name of the procedure from which the error is thrown, or\n"
"@code{#f}."
msgstr ""
"@item\n"
"@var{subr}: имя процедуры, из которой выдается ошибка, или\n"
"@code{#f}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2048
msgid ""
"@item\n"
"@var{message}: a string (possibly language and system dependent)\n"
"describing the error.  The tokens @code{~A} and @code{~S} can be\n"
"embedded within the message: they will be replaced with members of the\n"
"@var{args} list when the message is printed.  @code{~A} indicates an\n"
"argument printed using @code{display}, while @code{~S} indicates an\n"
"argument printed using @code{write}.  @var{message} can also be\n"
"@code{#f}, to allow it to be derived from the @var{key} by the error\n"
"handler (may be useful if the @var{key} is to be thrown from both C and\n"
"Scheme)."
msgstr ""
"@item\n"
"@var{message}: это строка (возможно, зависящая от языка и системы)\n"
"описывающая ошибку.  Токены @code{~A} и @code{~S} могут быть\n"
"встроены в это сообщение: они будут заменены на элементы списка \n"
"@var{args} когда сообщение будет распечатано.  @code{~A} указывает на\n"
"аргумент печатаемый с использованием @code{display}, тогда как @code{~S}\n"
"указывает на аргумент печатаемый с использованием @code{write}.  \n"
"@var{message} также может быть @code{#f}, чтобы его можно было извлечь из\n"
"@var{key} обработчиком ошибок (может быть полезно, если @var{key} может "
"быть\n"
"выброшен как из Си, так и из Scheme)."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2053
msgid ""
"@item\n"
"@var{args}: a list of arguments to be used to expand @code{~A} and\n"
"@code{~S} tokens in @var{message}.  Can also be @code{#f} if no\n"
"arguments are required."
msgstr ""
"@item\n"
"@var{args}: список аргументов, которые будут использоваться для расширения\n"
"токенов @code{~A} и @code{~S} в @var{message}.  Может также быть @code{#f} \n"
"если аргументы не требуются."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2059
msgid ""
"@item\n"
"@var{rest}: a list of any additional objects required. e.g., when the\n"
"key is @code{'system-error}, this contains the C errno value.  Can also\n"
"be @code{#f} if no additional objects are required.\n"
"@end itemize"
msgstr ""
"@item\n"
"@var{rest}: список любых дополнительных необходимых объектов. например, "
"когда\n"
"ключ key это @code{'system-error}, он содержит значение Си errno.  Также "
"может\n"
"быть @code{#f} если никакие дополнительные объекты не требуется.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2062
msgid ""
"In addition to @code{catch} and @code{throw}, the following Scheme\n"
"facilities are available:"
msgstr ""
"В дополнении к @code{catch} и @code{throw}, доступны следующие возмоности\n"
"Scheme:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2073
msgid ""
"@deffn {Scheme Procedure} display-error frame port subr message args rest\n"
"@deffnx {C Function} scm_display_error (frame, port, subr, message, args, "
"rest)\n"
"Display an error message to the output port @var{port}.\n"
"@var{frame} is the frame in which the error occurred, @var{subr} is\n"
"the name of the procedure in which the error occurred and\n"
"@var{message} is the actual error message, which may contain\n"
"formatting instructions. These will format the arguments in\n"
"the list @var{args} accordingly.  @var{rest} is currently\n"
"ignored.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} display-error frame port subr message args rest\n"
"@deffnx {C Function} scm_display_error (frame, port, subr, message, args, "
"rest)\n"
"Выводит сообщение об ошибке в порт вывода @var{port}.\n"
"@var{frame} это кадр в котором произошла ошибка, @var{subr} это\n"
"имя процедуры в которой произошла ошибка и @var{message} это фактическое\n"
"сообщение об ошибке, которое может содержать инструкции по форматированию.\n"
"Они позволяют форматированно выводить аргументы из списка @var{args}.  \n"
"@var{rest} игнорируется.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2076
msgid ""
"The following are the error keys defined by libguile and the situations\n"
"in which they are used:"
msgstr ""
"Ниже приведены ключи ошибок, определенные в libguile и ситуации, в которых "
"они\n"
"используются:"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2084
msgid ""
"@itemize @bullet\n"
"@item\n"
"@cindex @code{error-signal}\n"
"@code{error-signal}: thrown after receiving an unhandled fatal signal\n"
"such as SIGSEGV, SIGBUS, SIGFPE etc.  The @var{rest} argument in the throw\n"
"contains the coded signal number (at present this is not the same as the\n"
"usual Unix signal number)."
msgstr ""
"@itemize @bullet\n"
"@item\n"
"@cindex @code{error-signal}\n"
"@code{error-signal}: выбрасывается после получение необработанного "
"фатального\n"
"сигнала, такого как SIGSEGV, SIGBUS, SIGFPE и т.п.  Аргумент @var{rest} в "
"функции\n"
"throw содержит код номера сигнала (в настоящее время это не тоже самое, что "
"обычный\n"
"номер сигнала Unix)."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2090
msgid ""
"@item\n"
"@cindex @code{system-error}\n"
"@code{system-error}: thrown after the operating system indicates an\n"
"error condition.  The @var{rest} argument in the throw contains the\n"
"errno value."
msgstr ""
"@item\n"
"@cindex @code{system-error}\n"
"@code{system-error}: выбрасывается после того как операционная система\n"
"указала на состояние ошибки. Аргумент @var{rest} при вызове throw содержит\n"
"значение errno."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2094
msgid ""
"@item\n"
"@cindex @code{numerical-overflow}\n"
"@code{numerical-overflow}: numerical overflow."
msgstr ""
"@item\n"
"@cindex @code{numerical-overflow}\n"
"@code{numerical-overflow}: числовое переполнение."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2099
msgid ""
"@item\n"
"@cindex @code{out-of-range}\n"
"@code{out-of-range}: the arguments to a procedure do not fall within the\n"
"accepted domain."
msgstr ""
"@item\n"
"@cindex @code{out-of-range}\n"
"@code{out-of-range}: аргументы процедуры не попадают в допустимую область."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2103
msgid ""
"@item\n"
"@cindex @code{wrong-type-arg}\n"
"@code{wrong-type-arg}: an argument to a procedure has the wrong type."
msgstr ""
"@item\n"
"@cindex @code{wrong-type-arg}\n"
"@code{wrong-type-arg}: аргумент процедуры имеет неправильный тип."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2108
msgid ""
"@item\n"
"@cindex @code{wrong-number-of-args}\n"
"@code{wrong-number-of-args}: a procedure was called with the wrong number\n"
"of arguments."
msgstr ""
"@item\n"
"@cindex @code{wrong-number-of-args}\n"
"@code{wrong-number-of-args}: процедура была вызвана с неправильным числом "
"аргументов."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2112
msgid ""
"@item\n"
"@cindex @code{memory-allocation-error}\n"
"@code{memory-allocation-error}: memory allocation error."
msgstr ""
"@item\n"
"@cindex @code{memory-allocation-error}\n"
"@code{memory-allocation-error}: ошибка выделения памяти."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2116
msgid ""
"@item\n"
"@cindex @code{stack-overflow}\n"
"@code{stack-overflow}: stack overflow error."
msgstr ""
"@item\n"
"@cindex @code{stack-overflow}\n"
"@code{stack-overflow}: ошибка переполнения стека."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2121
msgid ""
"@item\n"
"@cindex @code{regular-expression-syntax}\n"
"@code{regular-expression-syntax}: errors generated by the regular\n"
"expression library."
msgstr ""
"@item\n"
"@cindex @code{regular-expression-syntax}\n"
"@code{regular-expression-syntax}: ошибки генерируемые библиотекой\n"
"регулярных выражений."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2126
msgid ""
"@item\n"
"@cindex @code{misc-error}\n"
"@code{misc-error}: other errors.\n"
"@end itemize"
msgstr ""
"@item\n"
"@cindex @code{misc-error}\n"
"@code{misc-error}: другие ошибки.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2129
msgid "@subsubsection C Support"
msgstr "@subsubsection Поддержка Си"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2132
msgid ""
"In the following C functions, @var{SUBR} and @var{MESSAGE} parameters\n"
"can be @code{NULL} to give the effect of @code{#f} described above."
msgstr ""
"В следующих Си функциях, параметры @var{SUBR} и @var{MESSAGE} могут\n"
"иметь значение @code{NULL}, что бы получить эффект как от @code{#f} \n"
"описанный выше."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2136
msgid ""
"@deftypefn {C Function} SCM scm_error (SCM @var{key}, char *@var{subr}, char "
"*@var{message}, SCM @var{args}, SCM @var{rest})\n"
"Throw an error, as per @code{scm-error} (@pxref{Error Reporting}).\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Function} SCM scm_error (SCM @var{key}, char *@var{subr}, char "
"*@var{message}, SCM @var{args}, SCM @var{rest})\n"
"Выбрасывает(генерирует) ошибку, для каждого @code{scm-error} (@pxref{Error "
"Reporting}).\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2142
msgid ""
"@deftypefn {C Function} void scm_syserror (char *@var{subr})\n"
"@deftypefnx {C Function} void scm_syserror_msg (char *@var{subr}, char "
"*@var{message}, SCM @var{args})\n"
"Throw an error with key @code{system-error} and supply @code{errno} in\n"
"the @var{rest} argument.  For @code{scm_syserror} the message is\n"
"generated using @code{strerror}."
msgstr ""
"@deftypefn {C Function} void scm_syserror (char *@var{subr})\n"
"@deftypefnx {C Function} void scm_syserror_msg (char *@var{subr}, char "
"*@var{message}, SCM @var{args})\n"
"Генерирует ошибку с ключем @code{system-error} и указывает @code{errno} в\n"
"аргументе @var{rest}.  Для @code{scm_syserror} сообщение генерируется с\n"
"использованием @code{strerror}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2146
msgid ""
"Care should be taken that any code in between the failing operation\n"
"and the call to these routines doesn't change @code{errno}.\n"
"@end deftypefn"
msgstr ""
"Следует позаботиться о том, чтобы любой код между ошибочной операцией и "
"вызовом\n"
"этой процедуры не изменил @code{errno}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2155
msgid ""
"@deftypefn {C Function} void scm_num_overflow (char *@var{subr})\n"
"@deftypefnx {C Function} void scm_out_of_range (char *@var{subr}, SCM "
"@var{bad_value})\n"
"@deftypefnx {C Function} void scm_wrong_num_args (SCM @var{proc})\n"
"@deftypefnx {C Function} void scm_wrong_type_arg (char *@var{subr}, int "
"@var{argnum}, SCM @var{bad_value})\n"
"@deftypefnx {C Function} void scm_wrong_type_arg_msg (char *@var{subr}, int "
"@var{argnum}, SCM @var{bad_value}, const char *@var{expected})\n"
"@deftypefnx {C Function} void scm_memory_error (char *@var{subr})\n"
"@deftypefnx {C Function} void scm_misc_error (const char *@var{subr}, const "
"char *@var{message}, SCM @var{args})\n"
"Throw an error with the various keys described above."
msgstr ""
"@deftypefn {C Function} void scm_num_overflow (char *@var{subr})\n"
"@deftypefnx {C Function} void scm_out_of_range (char *@var{subr}, SCM "
"@var{bad_value})\n"
"@deftypefnx {C Function} void scm_wrong_num_args (SCM @var{proc})\n"
"@deftypefnx {C Function} void scm_wrong_type_arg (char *@var{subr}, int "
"@var{argnum}, SCM @var{bad_value})\n"
"@deftypefnx {C Function} void scm_wrong_type_arg_msg (char *@var{subr}, int "
"@var{argnum}, SCM @var{bad_value}, const char *@var{expected})\n"
"@deftypefnx {C Function} void scm_memory_error (char *@var{subr})\n"
"@deftypefnx {C Function} void scm_misc_error (const char *@var{subr}, const "
"char *@var{message}, SCM @var{args})\n"
"Выбрасывает ошибку с различными ключами описанными выше."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2159
msgid ""
"In @code{scm_wrong_num_args}, @var{proc} should be a Scheme symbol\n"
"which is the name of the procedure incorrectly invoked.  The other\n"
"routines take the name of the invoked procedure as a C string."
msgstr ""
"В @code{scm_wrong_num_args}, @var{proc} должен быть символом Scheme,\n"
"который является именем неправильно вызванной процедуры. Другие\n"
"подпрограммы принимают имя вызванной процедуры в виде Си строки."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2162
msgid ""
"In @code{scm_wrong_type_arg_msg}, @var{expected} is a C string\n"
"describing the type of argument that was expected."
msgstr ""
"В @code{scm_wrong_type_arg_msg}, @var{expected} ожидается Си строка\n"
"описывающая тип аргумента, который ожидался."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2167
msgid ""
"In @code{scm_misc_error}, @var{message} is the error message string,\n"
"possibly containing @code{simple-format} escapes (@pxref{Simple\n"
"Output}), and the corresponding arguments in the @var{args} list.\n"
"@end deftypefn"
msgstr ""
"В @code{scm_misc_error}, @var{message} это строка сообщения об ошибке,\n"
"возможно, содержащая простой формат @code{simple-format} экранирования "
"(@pxref{Simple\n"
"Output}), и соответствующие аргументы в списке @var{args}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2170
msgid "@subsubsection Signalling Type Errors"
msgstr "@subsubsection Сигнализация об Ошибках в Типе"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2175
msgid ""
"Every function visible at the Scheme level should aggressively check the\n"
"types of its arguments, to avoid misinterpreting a value, and perhaps\n"
"causing a segmentation fault.  Guile provides some macros to make this\n"
"easier."
msgstr ""
"Каждая функция, видимая на уровне Scheme должна активно проверять типы\n"
"своих аргументов, чтобы избежать неверной интерпретации значения, и\n"
"возможно выдавать ошибку сегментации.  Guile предоставляет некоторые "
"макросы\n"
"чтобы делать это просто."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2181
msgid ""
"@deftypefn Macro void SCM_ASSERT (int @var{test}, SCM @var{obj}, unsigned "
"int @var{position}, const char *@var{subr})\n"
"@deftypefnx Macro void SCM_ASSERT_TYPE (int @var{test}, SCM @var{obj}, "
"unsigned int @var{position}, const char *@var{subr}, const char "
"*@var{expected}) \n"
"If @var{test} is zero, signal a ``wrong type argument'' error,\n"
"attributed to the subroutine named @var{subr}, operating on the value\n"
"@var{obj}, which is the @var{position}'th argument of @var{subr}."
msgstr ""
"@deftypefn Macro void SCM_ASSERT (int @var{test}, SCM @var{obj}, unsigned "
"int @var{position}, const char *@var{subr})\n"
"@deftypefnx Macro void SCM_ASSERT_TYPE (int @var{test}, SCM @var{obj}, "
"unsigned int @var{position}, const char *@var{subr}, const char "
"*@var{expected}) \n"
"Если @var{test} равен нулю, сигнализирует об ошибке ``неверный тип "
"аргумента(wrong type argument)'',\n"
"свяазнной с программой с именем @var{subr}, oработающей со значением\n"
"@var{obj}, котое является аргументом в позиции @var{position} @var{subr}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2185
msgid ""
"In @code{SCM_ASSERT_TYPE}, @var{expected} is a C string describing the\n"
"type of argument that was expected.\n"
"@end deftypefn"
msgstr ""
"В @code{SCM_ASSERT_TYPE}, @var{expected} это Си строка описывающая тип\n"
"аргумента, который ожидается.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2201
msgid ""
"@deftypefn Macro int SCM_ARG1\n"
"@deftypefnx Macro int SCM_ARG2\n"
"@deftypefnx Macro int SCM_ARG3\n"
"@deftypefnx Macro int SCM_ARG4\n"
"@deftypefnx Macro int SCM_ARG5\n"
"@deftypefnx Macro int SCM_ARG6\n"
"@deftypefnx Macro int SCM_ARG7\n"
"One of the above values can be used for @var{position} to indicate the\n"
"number of the argument of @var{subr} which is being checked.\n"
"Alternatively, a positive integer number can be used, which allows to\n"
"check arguments after the seventh.  However, for parameter numbers up to\n"
"seven it is preferable to use @code{SCM_ARGN} instead of the\n"
"corresponding raw number, since it will make the code easier to\n"
"understand.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Macro int SCM_ARG1\n"
"@deftypefnx Macro int SCM_ARG2\n"
"@deftypefnx Macro int SCM_ARG3\n"
"@deftypefnx Macro int SCM_ARG4\n"
"@deftypefnx Macro int SCM_ARG5\n"
"@deftypefnx Macro int SCM_ARG6\n"
"@deftypefnx Macro int SCM_ARG7\n"
"Одно из приведенных выше значений может использоваться для @var{position}, "
"чтобы указать\n"
"номер аргумента в @var{subr} который проверяется.\n"
"Кроме того, положительное целое число может быть испольовано, что позволяет "
"проверять\n"
"аргументы после семи.  Однако для параметра с номером выше семи, "
"предпочтительно\n"
"использовать @code{SCM_ARGN} вместо соответствующего необработанного числа, "
"поскольку\n"
"оно облегчает понимание кода.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2207
msgid ""
"@deftypefn Macro int SCM_ARGn\n"
"Passing a value of zero or @code{SCM_ARGn} for @var{position} allows to\n"
"leave it unspecified which argument's type is incorrect.  Again,\n"
"@code{SCM_ARGn} should be preferred over a raw zero constant.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Macro int SCM_ARGn\n"
"Передача нулевого значения  или @code{SCM_ARGn} для позиции @var{position} "
"позволяет\n"
"оставить ее неопределенной, с неправильным типом аргумента. Опять же\n"
"@code{SCM_ARGn} должен быть предпочтительнее постаоянного необработанного "
"нуля.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2210
msgid ""
"@node Continuation Barriers\n"
"@subsection Continuation Barriers"
msgstr ""
"@node Continuation Barriers\n"
"@subsection Барьеры Продолжений"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2214
msgid ""
"The non-local flow of control caused by continuations might sometimes\n"
"not be wanted. You can use @code{with-continuation-barrier} to erect\n"
"fences that continuations can not pass."
msgstr ""
"Не локальный поток управления, вызыванный продолжениями, иногда может быть\n"
"нежелательным. Вы можете использовать @code{with-continuation-barrier} для\n"
"возведения барьера, который не смогут проходить продолжения."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2221
msgid ""
"@deffn {Scheme Procedure} with-continuation-barrier proc\n"
"@deffnx {C Function} scm_with_continuation_barrier (proc)\n"
"Call @var{proc} and return its result.  Do not allow the invocation of\n"
"continuations that would leave or enter the dynamic extent of the call\n"
"to @code{with-continuation-barrier}.  Such an attempt causes an error\n"
"to be signaled."
msgstr ""
"@deffn {Scheme Procedure} with-continuation-barrier proc\n"
"@deffnx {C Function} scm_with_continuation_barrier (proc)\n"
"Вызывает @var{proc} и возвращает его результат.  Не позволяйте вызываемым\n"
"продолжениям, которые покидают или входят в динамическое "
"пространство(экстент)\n"
"вызывать @code{with-continuation-barrier}.  Такая попытка приведет к "
"сообщению об\n"
"ошибке."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2225
msgid ""
"Throws (such as errors) that are not caught from within @var{proc} are\n"
"caught by @code{with-continuation-barrier}.  In that case, a short\n"
"message is printed to the current error port and @code{#f} is returned."
msgstr ""
"Выбросы/вызовы(Throws) (такие как ошибки), которые не перехвачены внутри\n"
"@var{proc} ловяться  @code{with-continuation-barrier}.  В этом случае, "
"печатается\n"
"короткое сообщение в текущий порт ошибки и возвращается @code{#f}."

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2228
msgid ""
"Thus, @code{with-continuation-barrier} returns exactly once.\n"
"@end deffn"
msgstr ""
"Таким образом, @code{with-continuation-barrier} возвращается ровноо один "
"раз.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2233
msgid ""
"@deftypefn {C Function} {void *} scm_c_with_continuation_barrier (void "
"*(*func) (void *), void *data)\n"
"Like @code{scm_with_continuation_barrier} but call @var{func} on\n"
"@var{data}.  When an error is caught, @code{NULL} is returned.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Function} {void *} scm_c_with_continuation_barrier (void "
"*(*func) (void *), void *data)\n"
"Как @code{scm_with_continuation_barrier} но вызывает @var{func} для\n"
"@var{data}.  Когда ловит ошибку, возвращает @code{NULL}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-control.texi:2237
msgid ""
"@c Local Variables:\n"
"@c TeX-master: \"guile.texi\"\n"
"@c End:"
msgstr ""
