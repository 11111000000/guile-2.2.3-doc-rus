@c -*-texinfo-*-
@c This is part of the GNU Guile Reference Manual.
@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2006, 2010, 2011, 2013
@c   Free Software Foundation, Inc.
@c See the file guile.texi for copying conditions.

@node Introduction
@chapter Введение

Guile - это реализация языка программирования Scheme.  Scheme
(@url{http://schemers.org/}) - это элегантный и концептуально простой 
диалект  Lisp, созданный  Guy Steele и Gerald Sussman, а также из-за
серии отчетов известных как RnRS (the
@tex
Revised$^n$
@end tex
@ifnottex
Revised^n
@end ifnottex
Reports on Scheme).

В отличии от, например, Python или Perl, Scheme не имеет доброжелательного
диктатора.  Здесь очень много реализаций Scheme, с различными характеристиками
и с сообществами и академическим действиями вокруг них, и язык развивается в 
результате взаимодействия между ними.
Особенностью Guile является то, что:

@itemize
@item
он легко сочектается с другим кодом, написанным на Си
@item
он имеет историческую и постоянную связь с проектом GNU
@item
он подчеркивает интерактивное и инкрементальное программирование
@item
он фактически поддерживает несколько языков, а не только Scheme.
@end itemize

@noindent
Следующие несколько разделов объясняют, что мы подразумеваем под этими пунктами.
После этого раздела идет информация о том как в может получить и установить Guile,
и типографские соглашения, которые мы используем в этом руководстве.

@menu
* Guile and Scheme::              
* Combining with C::              
* Guile and the GNU Project::
* Interactive Programming::
* Supporting Multiple Languages::
* Obtaining and Installing Guile::  
* Organisation of this Manual::
* Typographical Conventions::          
@end menu

@node Guile and Scheme
@section Guile и Scheme

Guile реализует Scheme, как описано в 
@tex
Revised$^5$
@end tex
@ifnottex
Revised^5
@end ifnottex
Report on the Algorithmic Language Scheme (известная как
@acronym{R5RS}), обеспечивающая чистые и общие данные и структуры
управления.  Guile выходит за рамки довольно сурового языка,
представленного в @acronym{R5RS}, расширяя его с помощью модульной
системы, полного доступа к системным вызовам @acronym{POSIX},
сетевой поддержки, многопоточности, динамического связывания,
интерфейса вызова внешних функций, мощной обработкой строк, и
множества других функций, необходимых для программирования в 
реальном мире.

Сообщество Scheme недавно приняло и опубликовало R6RS, последнее
дополнение в серии RnRS.  R6RS значительно расширяет основной язык
Scheme, и стандартизирует многие неосновные функции, которые 
реализуются, в том числе и в Guile, ранее разными путями. Guile был
обновлен с учетом некоторых особенностей R6RS, и скорректировал 
некотоыре существующие функции, чтобы соответствовать спецификации
R6RS, оно это ни коим образом не означает полную реализацию R6RS.
@xref{R6RS Support}.

Между R5RS и R6RS, идет процесс SRFI (@url{http://srfi.schemers.org/})
стандартизации интерфейсов для многих практических задач, таких как
многопоточное программирование и многомерные массивы.  Guile поддерживает
множество SRFI, как подробно описано в @ref{SRFI Support}.

Резюмируя, что касается отношения к стандартам Scheme, то Guile
является реализацией R5RS со многими расширениями, некоторые из
которых соответствуют SRFIs или соответствуют части R6RS.

@node Combining with C
@section Объединение с Си кодом

Подбно shell, Guile может запускаться интерактивно читая выражения от пользователя,
производя их вычисления, отоброжать результаты --- или как интерпретатор сценариев,
читающий и исполняющий код Scheme из файла.  Guile также прдоставляет библиотеку
объектов @dfn{libguile}, которая позволяет другим приложениям легко вкючать полный
интерпретатор Scheme.  Затем приложение может использоать Guile как язык расширения,
чистый и мощный язык настройки, или как многоцелевой ``клей(glue)'', соединяющий 
примитивы, предоставляемые приложением. Код Scheme легко вызывать из кода на Си
и наоборот, что дает разработчику приложения полный контроль над тем, как и когда 
вызывать интерпретатор. Приложения могут добавлять новые функции, типы данных, 
структуры управления, и даже синтаксис для Guile, создавая специфичный языковой
домен, адаптированный к задаче, но на основе надежного языкового дизайна.

Этому сочетанию помогают четыре аспекта дизайна и истории Guile.
Сначала это то что Guile всегда был ориентирован как язык расширения.
Следовательно его Си API всегда был очень важен и был соответствующим
образом разработан. Второе и третье, технические моменты --- что  Guile
использует консервативную сборку мусора и что она реализует концепцию
Scheme продолжений(continuations) путем копирования и востановления
стека Си, но чьим практическим последствием является то, что большинство
существующего Си кода можно склеить в Guile как есть, без небохдимости
модификации, что бы справиться со странным выполнения  Scheme.
Последним является модуль системы, который помогает расширениям 
сосуществовать, не мешая друг другу.

Модульная система Guile позволяет разбить большую программу на 
управляемые секции с четко определенными интерфейсами между ними.
Модули могут содержать смесь интерпретируемого и скомпилированного
кода; Guile может использовать статическую или динамическую компоновку
для включения скомпилированного кода. Модули также поощряют разработчиков
накапливать полезные коллекции подпрограмм для общего распространения; 
на момент написания этой статьи можно найти интерфесы Emacs, подпрограммы
доступа к базам данных, компиляторы, интерфейсы инстурментария @acronym{GUI}
и функции клиенты @acronym{HTTP}, среди прочих.

@node Guile and the GNU Project
@section Guile и проект GNU

Guile был задуман проектом GNU после фантастического успеха Emacs 
Lisp в качестве языка расширения Emacs.  Так же, как Emacs
Lisp допускал завершенные и непредвиденные приложения, которые
написаны в среде Emacs, идея заключалась в том, что Guile должне
сделать тоже самое для других приложений проекта GNU.  
Эта цель остается актуальной и сегодня.

Идея расширяемости тесно связана с основной задачей проекта GNU:
продвижение свободы программного обеспечения. Свобода программного
обеспечения означает, что люди, получающие программное обеспечение
могут менять или улучшать его по собственному желанию, в том числе
способами, о которых даже не подозревали разработчики. Для программ
написанных и скомпилированных на языках подобных Си, эта свобода
охватывает модификацию и востановление Си кода, но если программа
также предоставляет язык расширений, который обычно является гораздо
более дружественным, он будет более низким барьером, чтобы пользователь
начал создавать свои собственные изменения.

Guile теперь используется проектами GNU, такими как AutoGen, Lilypond, Denemo,
Mailutils, TeXmacs и Gnucash, и мы надеемся, что в будущем их будет намного
больше.

@node Interactive Programming
@section Интерактивное Программирование

Несвободное программное обеспечение не заинтересовано в том, чтобы пользователи
могли видиеть, как оно работает. Они должны просто принять его или сообщить о
проблемах и надеятся, что владельцы исходного кода будут решать их проблему.

Свободное программное обеспечение направлено на то, чтобы работать надежно, как
и несвободное ПО, но оно должно также расширять возможности своих пользвателей,
делая свою работу доступной.  Это полезно по многим причинам, включая образование,
аудит и усовершенствования, а также проблемы отладки.

Идеальная свободная программная система достигает этого, позволяя заинтересованным
пользователям видеть исходный код функций, которые они используют, и следить за
этим исходным кодом шаг за шагом, по мере его выполнения. В Emacs, хорошими 
поимерами этого являются гиперссылки исходного кода в справочной системе и 
@code{edebug}. Затем, в качестве бонуса и максимизации возможностей пользователь
может провести эксперименты с изменением исходного кода, система должна
разрешать изменять часть исходного кода и перезагружать эти изменения в 
исходную программу, что бы получить немедленный эффект.

Guile разработан для такого рода интерактивного программирования, и это
отличает его от многих реализаций Scheme, которые запускают фиксированную
программу Scheme как можно быстрее --- потому что есть компромисс между
производительностью и способностью изменить части уже запущенной программы.
Есть более быстрые Schemes чем Guile, но Guile это проект GNU,
поэтому он ставит приоритет в отношении концепции свободы программирования
и эксперементирования.

@node Supporting Multiple Languages
@section Поддержка множества языков

Начиная с версии 2.0 архитектура Guile поддерживает компиляцию любого языка
в его основной виртуальный машинный байт-код, а Scheme это только один из
поддерживаемых языков. Другими поддерживаемыми языками являются Emacs Lisp, 
ECMAScript (обычно известный как Javascript) и Brainfuck, и ведется
обсуждение для Lua, Ruby и Python.

Это означает, что пользователи могут программировать в приложениях, которые
используют Guile выбирая свой язык, а не язык навязываемый им автором
приложения.

@node Obtaining and Installing Guile
@section Obtaining and Installing Guile

Guile can be obtained from the main GNU archive site
@url{ftp://ftp.gnu.org} or any of its mirrors.  The file will be named
guile-@var{version}.tar.gz.  The current version is @value{VERSION}, so the
file you should grab is:

@url{ftp://ftp.gnu.org/gnu/guile/guile-@value{VERSION}.tar.gz}

To unbundle Guile use the instruction

@example
zcat guile-@value{VERSION}.tar.gz | tar xvf -
@end example

@noindent
which will create a directory called @file{guile-@value{VERSION}} with
all the sources.  You can look at the file @file{INSTALL} for detailed
instructions on how to build and install Guile, but you should be able
to just do

@example
cd guile-@value{VERSION}
./configure
make
make install
@end example

This will install the Guile executable @file{guile}, the Guile library
@file{libguile} and various associated header files and support libraries. It
will also install the Guile reference manual.

@c [[include instructions for getting R5RS]]

Since this manual frequently refers to the Scheme ``standard'', also
known as R5RS, or the
@tex
``Revised$^5$ Report on the Algorithmic Language Scheme'',
@end tex
@ifnottex
``Revised^5 Report on the Algorithmic Language Scheme'',
@end ifnottex
we have included the report in the Guile distribution; see
@ref{Top, , Introduction, r5rs, Revised(5) Report on the Algorithmic
Language Scheme}.
This will also be installed in your info directory.

@node Organisation of this Manual
@section Организация данного Руководства

Остальная часть этого руководства состоит из следующих разделов.

@table @strong
@item Chapter 2: Hello Guile!
Быстрый тур показывающий, как Guile можно использовать интерактивно и
как интерпретатор скриптов, как внедрить Guile в ваше приложение и
как писать модули интерпретируемого и компилируемого кода для использования
с Guile.  Все рассказанное здесь документируется и полностью описывается в 
последующих частях руководства.

@item Chapter 3: Hello Scheme!
Для читателей не знакомых со Scheme, данная глава содержит введение в 
идеи языка Scheme.  Данный материал применим к любой реализации Scheme
и поэтому не ссылается ни на что, что связано со спецификой Guile.

@item Chapter 4: Программирование в Scheme
Предоставляет обзор программирования на Scheme используя Guile.  В нем рассказывается,
как вызывать программу @code{guile} из командной строки и как писать скрипты на Scheme.
В нем также представлены расширения, которые  Guile предлагает за пределами стандартной
Scheme.

@item Chapter 5: Programming in C
Предоставляет обзор того, как использовать Guile в Си программах. В
нем обсуждаются фундаментальные концепции, которые необходимо понять
для доступа к функциям Guile, такие как динамические типы и сборщик
мусора. Это объясняется в учебнике как определить новые типы данных
и функции для использования в программе Scheme.

@item Chapter 6: Guile API Reference
В этой части руководства содержиться описание  @acronym{API} Guile по
функциональным группам с интерфейсами Scheme и Си, представленными
бок о бок.

@item Chapter 7: Guile Modules
Описывыает некоторые важные модули, распространяемые как часть дистрибутива
Guile, которые расширяют функциональность, предоставляемую ядром Guile Scheme.

@item Chapter 8: GOOPS
Описывает GOOPS, объектно-ориентированное расширение Guile, которое
предоставляет классы, множественное наследование и общие функции.

@end table

@node Typographical Conventions
@section Типографические соглашения

In examples and procedure descriptions and all other places where the
evaluation of Scheme expression is shown, we use some notation for
denoting the output and evaluation results of expressions.

The symbol @samp{@result{}} is used to tell which value is returned by
an evaluation:

@lisp
(+ 1 2)
@result{} 3
@end lisp

Some procedures produce some output besides returning a value.  This
is denoted by the symbol @samp{@print{}}.

@lisp
(begin (display 1) (newline) 'hooray)
@print{} 1
@result{} hooray
@end lisp

As you can see, this code prints @samp{1} (denoted by
@samp{@print{}}), and returns @code{hooray} (denoted by
@samp{@result{}}).

@c Local Variables:
@c TeX-master: "guile.texi"
@c End: