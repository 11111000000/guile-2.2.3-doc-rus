@c -*-texinfo-*-
@c This is part of the GNU Guile Reference Manual.
@c Copyright (C)  1996, 1997, 2000-2004, 2006-2017
@c   Free Software Foundation, Inc.
@c See the file guile.texi for copying conditions.

@node Data Types
@section Data Types

Типы данных Guile образуют мощную встроенную библиотеку представлений
и функциональных возможностей, которые вы можете использовать в вашей
проблемной области. В этой главе рассматриваются типы данных, встроенные
в Guile, от простых до сложных.

@menu
* Booleans::                    True/false values.
* Numbers::                     Numerical data types.
* Characters::                  Single characters.
* Character Sets::              Sets of characters.
* Strings::                     Sequences of characters.
* Symbols::                     Symbols.
* Keywords::                    Self-quoting, customizable display keywords.
* Pairs::                       Scheme's basic building block.
* Lists::                       Special list functions supported by Guile.
* Vectors::                     One-dimensional arrays of Scheme objects.
* Bit Vectors::                 Vectors of bits.
* Bytevectors::                 Sequences of bytes.
* Arrays::                      Multidimensional matrices.
* VLists::                      Vector-like lists.
* Record Overview::             Walking through the maze of record APIs.
* SRFI-9 Records::              The standard, recommended record API.
* Records::                     Guile's historical record API.
* Structures::                  Low-level record representation.
* Dictionary Types::            About dictionary types in general.
* Association Lists::           List-based dictionaries.
* VHashes::                     VList-based dictionaries.   
* Hash Tables::                 Table-based dictionaries.
* Other Types::                 Other sections describe data types too.
@end menu

@node Booleans
@subsection Booleans
@tpindex Booleans

Два логических значения @code{#t} истина и @code{#f} ложь.
Они также могут быть записаны как @code{#true} и @code{#false}, 
согласно R7RS.

Boolean values are returned by predicate procedures, such as the general
equality predicates @code{eq?}, @code{eqv?} and @code{equal?}
(@pxref{Equality}) and numerical and string comparison operators like
@code{string=?} (@pxref{String Comparison}) and @code{<=}
(@pxref{Comparison}).

@lisp
(<= 3 8)
@result{} #t

(<= 3 -3)
@result{} #f

(equal? "house" "houses")
@result{} #f

(eq? #f #f)
@result{}
#t
@end lisp

In test condition contexts like @code{if} and @code{cond}
(@pxref{Conditionals}), where a group of subexpressions will be
evaluated only if a @var{condition} expression evaluates to ``true'',
``true'' means any value at all except @code{#f}.

@lisp
(if #t "yes" "no")
@result{} "yes"

(if 0 "yes" "no")
@result{} "yes"

(if #f "yes" "no")
@result{} "no"
@end lisp

Результатом этой асимметрии является то, что типичный исходный код Scheme
чаще всего испльзует @code{#f} чем @code{#t}: @code{#f} необходима для
представления ложного значения @code{if} или @code{cond}, тогда как @code{#t}
не является необходимым для того чтобы представлять истинное значение в 
@code{if} или @code{cond}.

Важно отметить, что @code{#f} @strong{НЕ} эквивалентен никакому другому
значению Scheme.  В частности, @code{#f} это не тоже самое, что число 0 
(как в C и C++), и не тоже самое, что ``пустой список''
(как в некоторых диалектах Лиспа).

В Си, два логических значения Scheme доступны как две константы 
@code{SCM_BOOL_T} для @code{#t} и @code{SCM_BOOL_F} для @code{#f}.
Следует соблюдать осторожность с ложным значением @code{SCM_BOOL_F}: 
это не false при использовании в условных выражениях Си.  Чтобы
проверить значение использйте @code{scm_is_false} или @code{scm_is_true}.

@rnindex not
@deffn {Scheme Procedure} not x
@deffnx {C Function} scm_not (x)
Return @code{#t} if @var{x} is @code{#f}, else return @code{#f}.
@end deffn

@rnindex boolean?
@deffn {Scheme Procedure} boolean? obj
@deffnx {C Function} scm_boolean_p (obj)
Return @code{#t} if @var{obj} is either @code{#t} or @code{#f}, else
return @code{#f}.
@end deffn

@deftypevr {C Macro} SCM SCM_BOOL_T
The @code{SCM} representation of the Scheme object @code{#t}.
@end deftypevr

@deftypevr {C Macro} SCM SCM_BOOL_F
The @code{SCM} representation of the Scheme object @code{#f}.
@end deftypevr

@deftypefn {C Function} int scm_is_true (SCM obj)
Return @code{0} if @var{obj} is @code{#f}, else return @code{1}.
@end deftypefn

@deftypefn {C Function} int scm_is_false (SCM obj)
Return @code{1} if @var{obj} is @code{#f}, else return @code{0}.
@end deftypefn

@deftypefn {C Function} int scm_is_bool (SCM obj)
Return @code{1} if @var{obj} is either @code{#t} or @code{#f}, else
return @code{0}.
@end deftypefn

@deftypefn {C Function} SCM scm_from_bool (int val)
Return @code{#f} if @var{val} is @code{0}, else return @code{#t}.
@end deftypefn

@deftypefn {C Function} int scm_to_bool (SCM val)
Возвращает @code{1} если значение @var{val} равно @code{SCM_BOOL_T}, 
возвращает @code{0} если значение @var{val} равно @code{SCM_BOOL_F},
иначе сигнал ошибки `wrong type'(неправильный тип).

Вы должны использовать @code{scm_is_true} вместо этой функции,
когда хотите просто проверить истинность значения @code{SCM}.
@end deftypefn

@node Numbers
@subsection Numerical data types
@tpindex Numbers

Guile поддерживает богатую ``башню'' из числовых типов -
целые числа, рациональные, реальные и комплексные ---
и предоставляет обширный набор математических и научных
функций для работы с числовыми данными. В этом разделе
руководства указаны эти типы и функции.

Вы также можете обнаружить что раздел освещает  R5RS's - представление
чисел в Scheme, для большей ясности: см
@ref{Numbers,,,r5rs,R5RS}.

@menu
* Numerical Tower::             Scheme's numerical "tower".
* Integers::                    Whole numbers.
* Reals and Rationals::         Real and rational numbers.
* Complex Numbers::             Complex numbers.
* Exactness::                   Exactness and inexactness.
* Number Syntax::               Read syntax for numerical data.
* Integer Operations::          Operations on integer values.
* Comparison::                  Comparison predicates.
* Conversion::                  Converting numbers to and from strings.
* Complex::                     Complex number operations.
* Arithmetic::                  Arithmetic functions.
* Scientific::                  Scientific functions.
* Bitwise Operations::          Logical AND, OR, NOT, and so on.
* Random::                      Random number generation.
@end menu

@node Numerical Tower
@subsubsection Scheme's Numerical ``Tower''
@rnindex number?

Числовая ``башня'' Scheme состоит из следующих числовых категорий:

@table @dfn
@item integers
Целые числа, положительные или отритцательные; например @: --5, 0, 18.

@item rationals
Рациональные числа - набор чисел, который может быть выражен как 
@math{@var{p}/@var{q}} где @var{p} и @var{q} целые; например@: 
@math{9/16}, но pi (иррациональное число) нельзя так представить. 
К ним относятся и целые числа, т.к (@math{@var{n}/1}).

@item real numbers
Реальные(Вещественные) числа - набор чисел, который описывает все возможные
положения вдоль одномерной линии. Он включает в себя и
рациональные и иррациональные числа.

@item complex numbers
Комплексные числа, набор чисел, который описывает все возможные положения
в двумерном пространстве. Он включает как реальные так и мнимые числа
(@math{@var{a}+@var{b}i}, где @var{a} это @dfn{real part(реальная часть)},
@var{b} это @dfn{imaginary part(мнимая часть)}, и @math{i} это квадратный
корень из @minus{}1.)
@end table

Это называется башней, потому что каждая категория ``сидит'' над той,
которая следует за ней, в том смысле, что целое число, также является
рациональным, а все рациональные числа, также вещественны и каждое 
вещественное число одновременно и комплексное(но с нулевой мнимой частью)

В добавление к классификации в целые числа, рациональные, вещественные
и комплексные числа, Scheme также различает, представлено ли число точно
или нет.  Например, результат @m{2\sin(\pi/4),2*sin(pi/4)} точно 
@m{\sqrt{2},2^(1/2)}, но Guile неможет представлять ни @m{\pi/4,pi/4}
ни @m{\sqrt{2},2^(1/2)} точно.
Вместо этого он хранит неточное приближение, используя Си тип
@code{double}.

Guile может представлять точные рациональности любой величины,
неточные рациональности которые описываеются в Си @code{double},
и неточные комплексные числа с типом Си @code{double} реальной
и мнимой частью.

Предикат @code{number?} может быть применен к любому значению Scheme,
чтобы выяснить является ли значение числом для любого из поддерживаемых
числовых типов.

@deffn {Scheme Procedure} number? obj
@deffnx {C Function} scm_number_p (obj)
Return @code{#t} if @var{obj} is any kind of number, else @code{#f}.
@end deffn

For example:

@lisp
(number? 3)
@result{} #t

(number? "hello there!")
@result{} #f

(define pi 3.141592654)
(number? pi)
@result{} #t
@end lisp

@deftypefn {C Function} int scm_is_number (SCM obj)
This is equivalent to @code{scm_is_true (scm_number_p (obj))}.
@end deftypefn

Следующие несколько подразделов подробно описывают каждый из численных
типов данных Guile.

@node Integers
@subsubsection Integers

@tpindex Integer numbers

@rnindex integer?

Integers are whole numbers, that is numbers with no fractional part,
such as 2, 83, and @minus{}3789.

Целые числа в Guile могут быть сколь угодно большими, как
показано в следующем примере.

@lisp
(define (factorial n)
  (let loop ((n n) (product 1))
    (if (= n 0)
        product
        (loop (- n 1) (* product n)))))

(factorial 3)
@result{} 6

(factorial 20)
@result{} 2432902008176640000

(- (factorial 45))
@result{} -119622220865480194561963161495657715064383733760000000000
@end lisp

Читатели, чьи имеющие знания в языках программирования низкого уровня
(типа Си), где целые числа ограничены необходимостью умещаться в
4 или 8 байт памяти, могут найти это удивительным и подозревать, что
представление целых чисел Guile неэффективно. Фактически, Guile 
достигает почти оптимального баланса удобства и эффективности,
используя представление целых чисел, где это возможно, в виде
удобном для работы компьютера(т.е в Си типах), и более общее
представление, где требуемое число не соответсвует ограничениям
используемого компьютера. Преобразованием между этими двумя 
представлениями происходит автоматически и полностью невидимо
для программиста Scheme.

Си имеет множество разных целых типов, а Guile предлагает множество
функций для преобразования между ними и представлением @code{SCM}.
Например, Си @code{int} можно обрабатывать с помощью @code{scm_to_int}
и @code{scm_from_int}.  Guile также определяет несколько собственных
целочисленных Си типов, чтобы помочь преодолевать различия
между различными компьютерными системами.

C integer types that are not covered can be handled with the generic
@code{scm_to_signed_integer} and @code{scm_from_signed_integer} for
signed types, or with @code{scm_to_unsigned_integer} and
@code{scm_from_unsigned_integer} for unsigned types.

Целые числа в Scheme могут быть точными и не точными. Например, число
записываемое как @code{3.0} с явной десятичной точкой является неточным,
но оно также является целым числом. Функции @code{integer?} и
@code{scm_is_integer} сообщают истина для такого чилса, но функции
@code{exact-integer?}, @code{scm_is_exact_integer},
@code{scm_is_signed_integer}, и @code{scm_is_unsigned_integer} разрешают
работу только с точными числами и сообщают об ошибке.  Аналогично,
функции преобразования, такие как @code{scm_to_signed_integer} принимают
только точные целые числа.

Обоснование такого поведения заключается в том. что неточность числа
не должна быть устранена молча.  Если вы хотите работать с неточным
числом, вы можете явно вставить вызов @code{inexact->exact} или его
эквилвалент в Си @code{scm_inexact_to_exact}. (Только неточные
целые числа будут преобразованы этим вызовом в точные; нецелые числа
надо преобразовывать почастям.)

@deffn {Scheme Procedure} integer? x
@deffnx {C Function} scm_integer_p (x)
Return @code{#t} if @var{x} is an exact or inexact integer number, else
return @code{#f}.

@lisp
(integer? 487)
@result{} #t

(integer? 3.0)
@result{} #t

(integer? -3.4)
@result{} #f

(integer? +inf.0)
@result{} #f
@end lisp
@end deffn

@deftypefn {C Function} int scm_is_integer (SCM x)
This is equivalent to @code{scm_is_true (scm_integer_p (x))}.
@end deftypefn

@deffn {Scheme Procedure} exact-integer? x
@deffnx {C Function} scm_exact_integer_p (x)
Return @code{#t} if @var{x} is an exact integer number, else
return @code{#f}.

@lisp
(exact-integer? 37)
@result{} #t

(exact-integer? 3.0)
@result{} #f
@end lisp
@end deffn

@deftypefn {C Function} int scm_is_exact_integer (SCM x)
This is equivalent to @code{scm_is_true (scm_exact_integer_p (x))}.
@end deftypefn

@defvr  {C Type} scm_t_int8
@defvrx {C Type} scm_t_uint8
@defvrx {C Type} scm_t_int16
@defvrx {C Type} scm_t_uint16
@defvrx {C Type} scm_t_int32
@defvrx {C Type} scm_t_uint32
@defvrx {C Type} scm_t_int64
@defvrx {C Type} scm_t_uint64
@defvrx {C Type} scm_t_intmax
@defvrx {C Type} scm_t_uintmax
The C types are equivalent to the corresponding ISO C types but are
defined on all platforms, with the exception of @code{scm_t_int64} and
@code{scm_t_uint64}, which are only defined when a 64-bit type is
available.  For example, @code{scm_t_int8} is equivalent to
@code{int8_t}.

You can regard these definitions as a stop-gap measure until all
platforms provide these types.  If you know that all the platforms
that you are interested in already provide these types, it is better
to use them directly instead of the types provided by Guile.
@end defvr

@deftypefn  {C Function} int scm_is_signed_integer (SCM x, scm_t_intmax min, scm_t_intmax max)
@deftypefnx {C Function} int scm_is_unsigned_integer (SCM x, scm_t_uintmax min, scm_t_uintmax max)
Return @code{1} when @var{x} represents an exact integer that is
between @var{min} and @var{max}, inclusive.

These functions can be used to check whether a @code{SCM} value will
fit into a given range, such as the range of a given C integer type.
If you just want to convert a @code{SCM} value to a given C integer
type, use one of the conversion functions directly.
@end deftypefn

@deftypefn  {C Function} scm_t_intmax scm_to_signed_integer (SCM x, scm_t_intmax min, scm_t_intmax max)
@deftypefnx {C Function} scm_t_uintmax scm_to_unsigned_integer (SCM x, scm_t_uintmax min, scm_t_uintmax max)
When @var{x} represents an exact integer that is between @var{min} and
@var{max} inclusive, return that integer.  Else signal an error,
either a `wrong-type' error when @var{x} is not an exact integer, or
an `out-of-range' error when it doesn't fit the given range.
@end deftypefn

@deftypefn  {C Function} SCM scm_from_signed_integer (scm_t_intmax x)
@deftypefnx {C Function} SCM scm_from_unsigned_integer (scm_t_uintmax x)
Return the @code{SCM} value that represents the integer @var{x}.  This
function will always succeed and will always return an exact number.
@end deftypefn

@deftypefn  {C Function} char scm_to_char (SCM x)
@deftypefnx {C Function} {signed char} scm_to_schar (SCM x)
@deftypefnx {C Function} {unsigned char} scm_to_uchar (SCM x)
@deftypefnx {C Function} short scm_to_short (SCM x)
@deftypefnx {C Function} {unsigned short} scm_to_ushort (SCM x)
@deftypefnx {C Function} int scm_to_int (SCM x)
@deftypefnx {C Function} {unsigned int} scm_to_uint (SCM x)
@deftypefnx {C Function} long scm_to_long (SCM x)
@deftypefnx {C Function} {unsigned long} scm_to_ulong (SCM x)
@deftypefnx {C Function} {long long} scm_to_long_long (SCM x)
@deftypefnx {C Function} {unsigned long long} scm_to_ulong_long (SCM x)
@deftypefnx {C Function} size_t scm_to_size_t (SCM x)
@deftypefnx {C Function} ssize_t scm_to_ssize_t (SCM x)
@deftypefnx {C Function} scm_t_uintptr scm_to_uintptr_t (SCM x)
@deftypefnx {C Function} scm_t_ptrdiff scm_to_ptrdiff_t (SCM x)
@deftypefnx {C Function} scm_t_int8 scm_to_int8 (SCM x)
@deftypefnx {C Function} scm_t_uint8 scm_to_uint8 (SCM x)
@deftypefnx {C Function} scm_t_int16 scm_to_int16 (SCM x)
@deftypefnx {C Function} scm_t_uint16 scm_to_uint16 (SCM x)
@deftypefnx {C Function} scm_t_int32 scm_to_int32 (SCM x)
@deftypefnx {C Function} scm_t_uint32 scm_to_uint32 (SCM x)
@deftypefnx {C Function} scm_t_int64 scm_to_int64 (SCM x)
@deftypefnx {C Function} scm_t_uint64 scm_to_uint64 (SCM x)
@deftypefnx {C Function} scm_t_intmax scm_to_intmax (SCM x)
@deftypefnx {C Function} scm_t_uintmax scm_to_uintmax (SCM x)
@deftypefnx {C Function} scm_t_intptr scm_to_intptr_t (SCM x)
@deftypefnx {C Function} scm_t_uintptr scm_to_uintptr_t (SCM x)
When @var{x} represents an exact integer that fits into the indicated
C type, return that integer.  Else signal an error, either a
`wrong-type' error when @var{x} is not an exact integer, or an
`out-of-range' error when it doesn't fit the given range.

The functions @code{scm_to_long_long}, @code{scm_to_ulong_long},
@code{scm_to_int64}, and @code{scm_to_uint64} are only available when
the corresponding types are.
@end deftypefn

@deftypefn  {C Function} SCM scm_from_char (char x)
@deftypefnx {C Function} SCM scm_from_schar (signed char x)
@deftypefnx {C Function} SCM scm_from_uchar (unsigned char x)
@deftypefnx {C Function} SCM scm_from_short (short x)
@deftypefnx {C Function} SCM scm_from_ushort (unsigned short x)
@deftypefnx {C Function} SCM scm_from_int (int  x)
@deftypefnx {C Function} SCM scm_from_uint (unsigned int x)
@deftypefnx {C Function} SCM scm_from_long (long x)
@deftypefnx {C Function} SCM scm_from_ulong (unsigned long x)
@deftypefnx {C Function} SCM scm_from_long_long (long long x)
@deftypefnx {C Function} SCM scm_from_ulong_long (unsigned long long x)
@deftypefnx {C Function} SCM scm_from_size_t (size_t x)
@deftypefnx {C Function} SCM scm_from_ssize_t (ssize_t x)
@deftypefnx {C Function} SCM scm_from_uintptr_t (uintptr_t x)
@deftypefnx {C Function} SCM scm_from_ptrdiff_t (scm_t_ptrdiff x)
@deftypefnx {C Function} SCM scm_from_int8 (scm_t_int8 x)
@deftypefnx {C Function} SCM scm_from_uint8 (scm_t_uint8 x)
@deftypefnx {C Function} SCM scm_from_int16 (scm_t_int16 x)
@deftypefnx {C Function} SCM scm_from_uint16 (scm_t_uint16 x)
@deftypefnx {C Function} SCM scm_from_int32 (scm_t_int32 x)
@deftypefnx {C Function} SCM scm_from_uint32 (scm_t_uint32 x)
@deftypefnx {C Function} SCM scm_from_int64 (scm_t_int64 x)
@deftypefnx {C Function} SCM scm_from_uint64 (scm_t_uint64 x)
@deftypefnx {C Function} SCM scm_from_intmax (scm_t_intmax x)
@deftypefnx {C Function} SCM scm_from_uintmax (scm_t_uintmax x)
@deftypefnx {C Function} SCM scm_from_intptr_t (scm_t_intptr x)
@deftypefnx {C Function} SCM scm_from_uintptr_t (scm_t_uintptr x)
Return the @code{SCM} value that represents the integer @var{x}.
These functions will always succeed and will always return an exact
number.
@end deftypefn

@deftypefn {C Function} void scm_to_mpz (SCM val, mpz_t rop)
Assign @var{val} to the multiple precision integer @var{rop}.
@var{val} must be an exact integer, otherwise an error will be
signalled.  @var{rop} must have been initialized with @code{mpz_init}
before this function is called.  When @var{rop} is no longer needed
the occupied space must be freed with @code{mpz_clear}.
@xref{Initializing Integers,,, gmp, GNU MP Manual}, for details.
@end deftypefn

@deftypefn {C Function} SCM scm_from_mpz (mpz_t val)
Return the @code{SCM} value that represents @var{val}.
@end deftypefn

@node Reals and Rationals
@subsubsection Real and Rational Numbers
@tpindex Real numbers
@tpindex Rational numbers

@rnindex real?
@rnindex rational?

Математически вещественные числа представляют собой набор чисел, 
описывающих все возможные точки вдоль непрерывной бесконечной
одномерной линии. Рациональные числа - это совокупность всех
чисел которые могут быть записаны как дроби @var{p}/@var{q}, 
где @var{p} и @var{q} целые числа. Все рациональные числа являются
также и вещественными, но существуют вещественные числа, которые
не являются рациональными, например: @m{\sqrt{2}, квадратный корень из 2},
и @m{\pi,pi}.

Guile может представлять как точные, так и не точные рациональные числа,
не не может представлять тоными конечные иррациональные числа. Точные
рациональности представлены путем хранения числителя и знаменателя в 
виде двух точных целых чисел. Неточные рациональности храняться как
числа с плавающей запятой, использущие тип Си @code{double}.

Точные рациональные числа записываются как часть целых чисел. Не должно
быть пробелов вокруг косой черты.

@lisp
1/2
-22/7
@end lisp

Несмотря на то, что фактическое кодирование неточных рациональных чисел
находиться в двоичном представлении, может оказаться полезным думать о
нем как о десятичном числе с ограниченным числом значимых цифр и 
десятичной точкой стоящей гдето, так как это соответствует стандартной 
нотации для нецелых чисел.
Например:

@lisp
0.34
-0.00000142857931198
-5648394822220000000000.0
4.0
@end lisp

Ограниченная точность кодирования Guile's означает, что любое конечное
``реальное'' число в Guile может быть записано в рациональной форме,
умножая и деля на достаточные степени 10 (или фактически, 2).  Например,
@samp{-0.00000142857931198} это тоже, что и @minus{}142857931198 деленное
на 100000000000000000.  В текущей реализации Guile's , следовательно, 
предикаты @code{rational?} и @code{real?} эквивалентны для конечных
чисел.

Dividing by an exact zero leads to a error message, as one might expect.
However, dividing by an inexact zero does not produce an error.
Instead, the result of the division is either plus or minus infinity,
depending on the sign of the divided number and the sign of the zero
divisor (some platforms support signed zeroes @samp{-0.0} and
@samp{+0.0}; @samp{0.0} is the same as @samp{+0.0}).

Dividing zero by an inexact zero yields a @acronym{NaN} (`not a number')
value, although they are actually considered numbers by Scheme.
Attempts to compare a @acronym{NaN} value with any number (including
itself) using @code{=}, @code{<}, @code{>}, @code{<=} or @code{>=}
always returns @code{#f}.  Although a @acronym{NaN} value is not
@code{=} to itself, it is both @code{eqv?} and @code{equal?} to itself
and other @acronym{NaN} values.  However, the preferred way to test for
them is by using @code{nan?}.

The real @acronym{NaN} values and infinities are written @samp{+nan.0},
@samp{+inf.0} and @samp{-inf.0}.  This syntax is also recognized by
@code{read} as an extension to the usual Scheme syntax.  These special
values are considered by Scheme to be inexact real numbers but not
rational.  Note that non-real complex numbers may also contain
infinities or @acronym{NaN} values in their real or imaginary parts.  To
test a real number to see if it is infinite, a @acronym{NaN} value, or
neither, use @code{inf?}, @code{nan?}, or @code{finite?}, respectively.
Every real number in Scheme belongs to precisely one of those three
classes.

On platforms that follow @acronym{IEEE} 754 for their floating point
arithmetic, the @samp{+inf.0}, @samp{-inf.0}, and @samp{+nan.0} values
are implemented using the corresponding @acronym{IEEE} 754 values.
They behave in arithmetic operations like @acronym{IEEE} 754 describes
it, i.e., @code{(= +nan.0 +nan.0)} @result{} @code{#f}.

@deffn {Scheme Procedure} real? obj
@deffnx {C Function} scm_real_p (obj)
Return @code{#t} if @var{obj} is a real number, else @code{#f}.  Note
that the sets of integer and rational values form subsets of the set
of real numbers, so the predicate will also be fulfilled if @var{obj}
is an integer number or a rational number.
@end deffn

@deffn {Scheme Procedure} rational? x
@deffnx {C Function} scm_rational_p (x)
Return @code{#t} if @var{x} is a rational number, @code{#f} otherwise.
Note that the set of integer values forms a subset of the set of
rational numbers, i.e.@: the predicate will also be fulfilled if
@var{x} is an integer number.
@end deffn

@deffn {Scheme Procedure} rationalize x eps
@deffnx {C Function} scm_rationalize (x, eps)
Returns the @emph{simplest} rational number differing
from @var{x} by no more than @var{eps}.  

As required by @acronym{R5RS}, @code{rationalize} only returns an
exact result when both its arguments are exact.  Thus, you might need
to use @code{inexact->exact} on the arguments.

@lisp
(rationalize (inexact->exact 1.2) 1/100)
@result{} 6/5
@end lisp

@end deffn

@deffn  {Scheme Procedure} inf? x
@deffnx {C Function} scm_inf_p (x)
Return @code{#t} if the real number @var{x} is @samp{+inf.0} or
@samp{-inf.0}.  Otherwise return @code{#f}.
@end deffn

@deffn {Scheme Procedure} nan? x
@deffnx {C Function} scm_nan_p (x)
Return @code{#t} if the real number @var{x} is @samp{+nan.0}, or
@code{#f} otherwise.
@end deffn

@deffn {Scheme Procedure} finite? x
@deffnx {C Function} scm_finite_p (x)
Return @code{#t} if the real number @var{x} is neither infinite nor a
NaN, @code{#f} otherwise.
@end deffn

@deffn {Scheme Procedure} nan
@deffnx {C Function} scm_nan ()
Return @samp{+nan.0}, a @acronym{NaN} value.
@end deffn

@deffn {Scheme Procedure} inf
@deffnx {C Function} scm_inf ()
Return @samp{+inf.0}, positive infinity.
@end deffn

@deffn {Scheme Procedure} numerator x
@deffnx {C Function} scm_numerator (x)
Return the numerator of the rational number @var{x}.
@end deffn

@deffn {Scheme Procedure} denominator x
@deffnx {C Function} scm_denominator (x)
Return the denominator of the rational number @var{x}.
@end deffn

@deftypefn  {C Function} int scm_is_real (SCM val)
@deftypefnx {C Function} int scm_is_rational (SCM val)
Equivalent to @code{scm_is_true (scm_real_p (val))} and
@code{scm_is_true (scm_rational_p (val))}, respectively.
@end deftypefn

@deftypefn {C Function} double scm_to_double (SCM val)
Returns the number closest to @var{val} that is representable as a
@code{double}.  Returns infinity for a @var{val} that is too large in
magnitude.  The argument @var{val} must be a real number.
@end deftypefn

@deftypefn {C Function} SCM scm_from_double (double val)
Return the @code{SCM} value that represents @var{val}.  The returned
value is inexact according to the predicate @code{inexact?}, but it
will be exactly equal to @var{val}.
@end deftypefn

@node Complex Numbers
@subsubsection Complex Numbers
@tpindex Complex numbers

@rnindex complex?

Комплексные числа - это набор чисел, описывающих всевозможные точки в
двумерном пространстве. Известные две координаты конкретной точки в этом
пространстве называются как @dfn{real(реальная)} и @dfn{imaginary(мнимая)}
части комплексного числа, которое описывает эту точку.

В Guile, комплексные числа записываются в прямоугольной форме как сумма
их реальной и мнимой частей, используя символ @code{i} для обозначения
мнимой части.

@lisp
3+4i
@result{}
3.0+4.0i

(* 3-8i 2.3+0.3i)
@result{}
9.3-17.5i
@end lisp

@cindex polar form
@noindent
Также может использоваться Полярная форма с симовлом @samp{@@} между
величиной и углом.

@lisp
1@@3.141592 @result{} -1.0      (approx)
-1@@1.57079 @result{} 0.0-1.0i  (approx)
@end lisp

Guile представляет комплексное число как пару неточных действительных
чисел, поэтому реальная и мнимая части комплексного числа имеют
одинаковые свойства неточности и ограниченной точности как единичные
неточные действительные числа.

Обратите внимание, что каждая часть комплексного числа может содержать
любое неточное реальное значение, включая специальные значения @samp{+nan.0},
@samp{+inf.0} и @samp{-inf.0}, а также любой из нулей со знаком @samp{0.0} или
@samp{-0.0}.

@deffn {Scheme Procedure} complex? z
@deffnx {C Function} scm_complex_p (z)
Return @code{#t} if @var{z} is a complex number, @code{#f}
otherwise.  Note that the sets of real, rational and integer
values form subsets of the set of complex numbers, i.e.@: the
predicate will also be fulfilled if @var{z} is a real,
rational or integer number.
@end deffn

@deftypefn {C Function} int scm_is_complex (SCM val)
Equivalent to @code{scm_is_true (scm_complex_p (val))}.
@end deftypefn

@node Exactness
@subsubsection Exact and Inexact Numbers
@tpindex Exact numbers
@tpindex Inexact numbers

@rnindex exact?
@rnindex inexact?
@rnindex exact->inexact
@rnindex inexact->exact

R5RS требует чтобы, за небольшим исключением, вычисления с использоанием
неточных чисел всегда давали неточный результат. Чтобы соответствовать
этому требованию, Guile различает точное целочисленное значение, такое 
как @samp{5} и соотвественно, неточное целочисленное значение, ограниченной
точности, не имеющее дробной части и печатающееся как @samp{5.0}.  Guile
конвертирует последнее значение в первое только, когда оно вынуждено
делать это путем вызова процедуры @code{inexact->exact}.

Единственное исключение из вышеуказанного требования - когда значения
неточных чисел не влияют на результат. Например @code{(expt n 0)}
равно @samp{1} для любого значения  @code{n}, поэтому @code{(expt 5.0 0)} 
разрешено возрващать точное @samp{1}.

@deffn {Scheme Procedure} exact? z
@deffnx {C Function} scm_exact_p (z)
Return @code{#t} if the number @var{z} is exact, @code{#f}
otherwise.

@lisp
(exact? 2)
@result{} #t

(exact? 0.5)
@result{} #f

(exact? (/ 2))
@result{} #t
@end lisp

@end deffn

@deftypefn {C Function} int scm_is_exact (SCM z)
Return a @code{1} if the number @var{z} is exact, and @code{0}
otherwise.  This is equivalent to @code{scm_is_true (scm_exact_p (z))}.

An alternate approch to testing the exactness of a number is to 
use @code{scm_is_signed_integer} or @code{scm_is_unsigned_integer}.
@end deftypefn

@deffn {Scheme Procedure} inexact? z
@deffnx {C Function} scm_inexact_p (z)
Return @code{#t} if the number @var{z} is inexact, @code{#f}
else.
@end deffn

@deftypefn {C Function} int scm_is_inexact (SCM z)
Return a @code{1} if the number @var{z} is inexact, and @code{0}
otherwise.  This is equivalent to @code{scm_is_true (scm_inexact_p (z))}.
@end deftypefn

@deffn {Scheme Procedure} inexact->exact z
@deffnx {C Function} scm_inexact_to_exact (z)
Return an exact number that is numerically closest to @var{z}, when
there is one.  For inexact rationals, Guile returns the exact rational
that is numerically equal to the inexact rational.  Inexact complex
numbers with a non-zero imaginary part can not be made exact.

@lisp
(inexact->exact 0.5)
@result{} 1/2
@end lisp

The following happens because 12/10 is not exactly representable as a
@code{double} (on most platforms).  However, when reading a decimal
number that has been marked exact with the ``#e'' prefix, Guile is
able to represent it correctly.

@lisp
(inexact->exact 1.2)  
@result{} 5404319552844595/4503599627370496

#e1.2
@result{} 6/5
@end lisp

@end deffn

@c begin (texi-doc-string "guile" "exact->inexact")
@deffn {Scheme Procedure} exact->inexact z
@deffnx {C Function} scm_exact_to_inexact (z)
Convert the number @var{z} to its inexact representation.
@end deffn

@node Number Syntax
@subsubsection Read Syntax for Numerical Data

Синтаксис чтения целых чисел представляет собой строку цифр,
необязательно предшествует которой символ плюс или минус, код
указывающий базу системы счисления, в которой закодировано число
и код указывающий является ли число точным или неточным.
Поддерживаемые базовые коды:

@table @code
@item #b
@itemx #B
целое записанное в бинарном формате (база 2)

@item #o
@itemx #O
целое записанное в восмеричном формате (base 8)

@item #d
@itemx #D
целое записанное в десятичном формате (base 10)

@item #x
@itemx #X
целое записанное в шестнадцатеричном формате (base 16)
@end table

Если код базы опущен, целое число считается десятичным. Следующие примеры
покажут, как использовать эти базовые коды.

@lisp
-13
@result{} -13

#d-13
@result{} -13

#x-13
@result{} -19

#b+1101
@result{} 13

#o377
@result{} 255
@end lisp

Коды для указания точности (которые, кстати, могут применяться ко всем
числовым значениям):

@table @code
@item #e
@itemx #E
the number is exact

@item #i
@itemx #I
the number is inexact.
@end table

Если индикатор точности опущен, это число точно, если оно не содержит
точку. Поскольку Guile не может представлять точные комплексные числа,
при запросе о точности комплексного числа возникает ошибка.

@lisp
(exact? 1.2)
@result{} #f

(exact? #e1.2)
@result{} #t

(exact? #e+1i)
ERROR: Wrong type argument
@end lisp

Guile also understands the syntax @samp{+inf.0} and @samp{-inf.0} for
plus and minus infinity, respectively.  The value must be written
exactly as shown, that is, they always must have a sign and exactly
one zero digit after the decimal point.  It also understands
@samp{+nan.0} and @samp{-nan.0} for the special `not-a-number' value.
The sign is ignored for `not-a-number' and the value is always printed
as @samp{+nan.0}.

@node Integer Operations
@subsubsection Operations on Integer Values
@rnindex odd?
@rnindex even?
@rnindex quotient
@rnindex remainder
@rnindex modulo
@rnindex gcd
@rnindex lcm

@deffn {Scheme Procedure} odd? n
@deffnx {C Function} scm_odd_p (n)
Return @code{#t} if @var{n} is an odd number, @code{#f}
otherwise.
@end deffn

@deffn {Scheme Procedure} even? n
@deffnx {C Function} scm_even_p (n)
Return @code{#t} if @var{n} is an even number, @code{#f}
otherwise.
@end deffn

@c begin (texi-doc-string "guile" "quotient")
@c begin (texi-doc-string "guile" "remainder")
@deffn {Scheme Procedure} quotient n d
@deffnx {Scheme Procedure} remainder n d
@deffnx {C Function} scm_quotient (n, d)
@deffnx {C Function} scm_remainder (n, d)
Return the quotient or remainder from @var{n} divided by @var{d}.  The
quotient is rounded towards zero, and the remainder will have the same
sign as @var{n}.  In all cases quotient and remainder satisfy
@math{@var{n} = @var{q}*@var{d} + @var{r}}.

@lisp
(remainder 13 4) @result{} 1
(remainder -13 4) @result{} -1
@end lisp

See also @code{truncate-quotient}, @code{truncate-remainder} and
related operations in @ref{Arithmetic}.
@end deffn

@c begin (texi-doc-string "guile" "modulo")
@deffn {Scheme Procedure} modulo n d
@deffnx {C Function} scm_modulo (n, d)
Return the remainder from @var{n} divided by @var{d}, with the same
sign as @var{d}.

@lisp
(modulo 13 4) @result{} 1
(modulo -13 4) @result{} 3
(modulo 13 -4) @result{} -3
(modulo -13 -4) @result{} -1
@end lisp

See also @code{floor-quotient}, @code{floor-remainder} and
related operations in @ref{Arithmetic}.
@end deffn

@c begin (texi-doc-string "guile" "gcd")
@deffn {Scheme Procedure} gcd x@dots{}
@deffnx {C Function} scm_gcd (x, y)
Return the greatest common divisor of all arguments.
If called without arguments, 0 is returned.

The C function @code{scm_gcd} always takes two arguments, while the
Scheme function can take an arbitrary number.
@end deffn

@c begin (texi-doc-string "guile" "lcm")
@deffn {Scheme Procedure} lcm x@dots{}
@deffnx {C Function} scm_lcm (x, y)
Return the least common multiple of the arguments.
If called without arguments, 1 is returned.

The C function @code{scm_lcm} always takes two arguments, while the
Scheme function can take an arbitrary number.
@end deffn

@deffn {Scheme Procedure} modulo-expt n k m
@deffnx {C Function} scm_modulo_expt (n, k, m)
Return @var{n} raised to the integer exponent
@var{k}, modulo @var{m}.

@lisp
(modulo-expt 2 3 5)
   @result{} 3
@end lisp
@end deffn

@deftypefn {Scheme Procedure} {} exact-integer-sqrt @var{k}
@deftypefnx {C Function} void scm_exact_integer_sqrt (SCM @var{k}, SCM *@var{s}, SCM *@var{r})
Return two exact non-negative integers @var{s} and @var{r}
such that @math{@var{k} = @var{s}^2 + @var{r}} and
@math{@var{s}^2 <= @var{k} < (@var{s} + 1)^2}.
An error is raised if @var{k} is not an exact non-negative integer.

@lisp
(exact-integer-sqrt 10) @result{} 3 and 1
@end lisp
@end deftypefn

@node Comparison
@subsubsection Comparison Predicates
@rnindex zero?
@rnindex positive?
@rnindex negative?

Фукнции сравнения Си ниже всегда принимают два аргумента, а функции
Scheme могут принимать произвольное число аргументов. Также имейте
в виду, что функции Си возвращают один из буферных значений Scheme
@code{SCM_BOOL_T} или @code{SCM_BOOL_F}, которые являются для Си
истинными(что не верно).  Таким образом, всегда пишите 
@code{scm_is_true (scm_num_eq_p (x, y))} при сравнении двух
величин Scheme, например для выяснения равенства @code{x} и @code{y}.

@c begin (texi-doc-string "guile" "=")
@deffn {Scheme Procedure} =
@deffnx {C Function} scm_num_eq_p (x, y)
Return @code{#t} if all parameters are numerically equal.
@end deffn

@c begin (texi-doc-string "guile" "<")
@deffn {Scheme Procedure} <
@deffnx {C Function} scm_less_p (x, y)
Return @code{#t} if the list of parameters is monotonically
increasing.
@end deffn

@c begin (texi-doc-string "guile" ">")
@deffn {Scheme Procedure} >
@deffnx {C Function} scm_gr_p (x, y)
Return @code{#t} if the list of parameters is monotonically
decreasing.
@end deffn

@c begin (texi-doc-string "guile" "<=")
@deffn {Scheme Procedure} <=
@deffnx {C Function} scm_leq_p (x, y)
Return @code{#t} if the list of parameters is monotonically
non-decreasing.
@end deffn

@c begin (texi-doc-string "guile" ">=")
@deffn {Scheme Procedure} >=
@deffnx {C Function} scm_geq_p (x, y)
Return @code{#t} if the list of parameters is monotonically
non-increasing.
@end deffn

@c begin (texi-doc-string "guile" "zero?")
@deffn {Scheme Procedure} zero? z
@deffnx {C Function} scm_zero_p (z)
Return @code{#t} if @var{z} is an exact or inexact number equal to
zero.
@end deffn

@c begin (texi-doc-string "guile" "positive?")
@deffn {Scheme Procedure} positive? x
@deffnx {C Function} scm_positive_p (x)
Return @code{#t} if @var{x} is an exact or inexact number greater than
zero.
@end deffn

@c begin (texi-doc-string "guile" "negative?")
@deffn {Scheme Procedure} negative? x
@deffnx {C Function} scm_negative_p (x)
Return @code{#t} if @var{x} is an exact or inexact number less than
zero.
@end deffn

@node Conversion
@subsubsection Converting Numbers To and From Strings
@rnindex number->string
@rnindex string->number

Следующие процедуры считывают и записывают числа в соответствии с их
внешним представлением как определено в  R5RS (@pxref{Lexical structure,
R5RS Lexical Structure,, r5rs, The Revised^5 Report on the Algorithmic
Language Scheme}).  @xref{Number Input and Output, the @code{(ice-9
i18n)} module}, для разбора числа, зависящего от текущей локали.

@deffn {Scheme Procedure} number->string n [radix]
@deffnx {C Function} scm_number_to_string (n, radix)
Return a string holding the external representation of the
number @var{n} in the given @var{radix}.  If @var{n} is
inexact, a radix of 10 will be used.
@end deffn

@deffn {Scheme Procedure} string->number string [radix]
@deffnx {C Function} scm_string_to_number (string, radix)
Return a number of the maximally precise representation
expressed by the given @var{string}. @var{radix} must be an
exact integer, either 2, 8, 10, or 16. If supplied, @var{radix}
is a default radix that may be overridden by an explicit radix
prefix in @var{string} (e.g.@: "#o177"). If @var{radix} is not
supplied, then the default radix is 10. If string is not a
syntactically valid notation for a number, then
@code{string->number} returns @code{#f}.
@end deffn

@deftypefn {C Function} SCM scm_c_locale_stringn_to_number (const char *string, size_t len, unsigned radix)
As per @code{string->number} above, but taking a C string, as pointer
and length.  The string characters should be in the current locale
encoding (@code{locale} in the name refers only to that, there's no
locale-dependent parsing).
@end deftypefn

@node Complex
@subsubsection Complex Number Operations
@rnindex make-rectangular
@rnindex make-polar
@rnindex real-part
@rnindex imag-part
@rnindex magnitude
@rnindex angle

@deffn {Scheme Procedure} make-rectangular real_part imaginary_part
@deffnx {C Function} scm_make_rectangular (real_part, imaginary_part)
Return a complex number constructed of the given @var{real-part} and @var{imaginary-part} parts.
@end deffn

@deffn {Scheme Procedure} make-polar mag ang
@deffnx {C Function} scm_make_polar (mag, ang)
@cindex polar form
Return the complex number @var{mag} * e^(i * @var{ang}).
@end deffn

@c begin (texi-doc-string "guile" "real-part")
@deffn {Scheme Procedure} real-part z
@deffnx {C Function} scm_real_part (z)
Return the real part of the number @var{z}.
@end deffn

@c begin (texi-doc-string "guile" "imag-part")
@deffn {Scheme Procedure} imag-part z
@deffnx {C Function} scm_imag_part (z)
Return the imaginary part of the number @var{z}.
@end deffn

@c begin (texi-doc-string "guile" "magnitude")
@deffn {Scheme Procedure} magnitude z
@deffnx {C Function} scm_magnitude (z)
Return the magnitude of the number @var{z}. This is the same as
@code{abs} for real arguments, but also allows complex numbers.
@end deffn

@c begin (texi-doc-string "guile" "angle")
@deffn {Scheme Procedure} angle z
@deffnx {C Function} scm_angle (z)
Return the angle of the complex number @var{z}.
@end deffn

@deftypefn  {C Function} SCM scm_c_make_rectangular (double re, double im)
@deftypefnx {C Function} SCM scm_c_make_polar (double x, double y)
Like @code{scm_make_rectangular} or @code{scm_make_polar},
respectively, but these functions take @code{double}s as their
arguments.
@end deftypefn

@deftypefn  {C Function} double scm_c_real_part (z)
@deftypefnx {C Function} double scm_c_imag_part (z)
Returns the real or imaginary part of @var{z} as a @code{double}.
@end deftypefn

@deftypefn  {C Function} double scm_c_magnitude (z)
@deftypefnx {C Function} double scm_c_angle (z)
Returns the magnitude or angle of @var{z} as a @code{double}.
@end deftypefn

@node Arithmetic
@subsubsection Arithmetic Functions
@rnindex max
@rnindex min
@rnindex +
@rnindex *
@rnindex -
@rnindex /
@findex 1+
@findex 1-
@rnindex abs
@rnindex floor
@rnindex ceiling
@rnindex truncate
@rnindex round
@rnindex euclidean/
@rnindex euclidean-quotient
@rnindex euclidean-remainder
@rnindex floor/
@rnindex floor-quotient
@rnindex floor-remainder
@rnindex ceiling/
@rnindex ceiling-quotient
@rnindex ceiling-remainder
@rnindex truncate/
@rnindex truncate-quotient
@rnindex truncate-remainder
@rnindex centered/
@rnindex centered-quotient
@rnindex centered-remainder
@rnindex round/
@rnindex round-quotient
@rnindex round-remainder

Арфиметические функции Си ниже всегда принимают два аргумента,
а функции Scheme могут принимать произвольное число аргументов.
Когда вам нужно вызвать их только с одним аргуметом, например для
вычисления эквивалента @code{(- x)}, передайте @code{SCM_UNDEFINED} 
вторым аргументом, вот так: @code{scm_difference (x, SCM_UNDEFINED)}.

@c begin (texi-doc-string "guile" "+")
@deffn {Scheme Procedure} + z1 @dots{}
@deffnx {C Function} scm_sum (z1, z2)
Return the sum of all parameter values.  Return 0 if called without any
parameters.
@end deffn

@c begin (texi-doc-string "guile" "-")
@deffn {Scheme Procedure} - z1 z2 @dots{}
@deffnx {C Function} scm_difference (z1, z2)
If called with one argument @var{z1}, -@var{z1} is returned. Otherwise
the sum of all but the first argument are subtracted from the first
argument.
@end deffn

@c begin (texi-doc-string "guile" "*")
@deffn {Scheme Procedure} * z1 @dots{}
@deffnx {C Function} scm_product (z1, z2)
Return the product of all arguments.  If called without arguments, 1 is
returned.
@end deffn

@c begin (texi-doc-string "guile" "/")
@deffn {Scheme Procedure} / z1 z2 @dots{}
@deffnx {C Function} scm_divide (z1, z2)
Divide the first argument by the product of the remaining arguments.  If
called with one argument @var{z1}, 1/@var{z1} is returned.
@end deffn

@deffn {Scheme Procedure} 1+ z
@deffnx {C Function} scm_oneplus (z)
Return @math{@var{z} + 1}.
@end deffn

@deffn {Scheme Procedure} 1- z
@deffnx {C function} scm_oneminus (z)
Return @math{@var{z} - 1}.
@end deffn

@c begin (texi-doc-string "guile" "abs")
@deffn {Scheme Procedure} abs x
@deffnx {C Function} scm_abs (x)
Return the absolute value of @var{x}.

@var{x} must be a number with zero imaginary part.  To calculate the
magnitude of a complex number, use @code{magnitude} instead.
@end deffn

@c begin (texi-doc-string "guile" "max")
@deffn {Scheme Procedure} max x1 x2 @dots{}
@deffnx {C Function} scm_max (x1, x2)
Return the maximum of all parameter values.
@end deffn

@c begin (texi-doc-string "guile" "min")
@deffn {Scheme Procedure} min x1 x2 @dots{}
@deffnx {C Function} scm_min (x1, x2)
Return the minimum of all parameter values.
@end deffn

@c begin (texi-doc-string "guile" "truncate")
@deffn {Scheme Procedure} truncate x
@deffnx {C Function} scm_truncate_number (x)
Round the inexact number @var{x} towards zero.
@end deffn

@c begin (texi-doc-string "guile" "round")
@deffn {Scheme Procedure} round x
@deffnx {C Function} scm_round_number (x)
Round the inexact number @var{x} to the nearest integer.  When exactly
halfway between two integers, round to the even one.
@end deffn

@c begin (texi-doc-string "guile" "floor")
@deffn {Scheme Procedure} floor x
@deffnx {C Function} scm_floor (x)
Round the number @var{x} towards minus infinity.
@end deffn

@c begin (texi-doc-string "guile" "ceiling")
@deffn {Scheme Procedure} ceiling x
@deffnx {C Function} scm_ceiling (x)
Round the number @var{x} towards infinity.
@end deffn

@deftypefn  {C Function} double scm_c_truncate (double x)
@deftypefnx {C Function} double scm_c_round (double x)
Like @code{scm_truncate_number} or @code{scm_round_number},
respectively, but these functions take and return @code{double}
values.
@end deftypefn

@deftypefn {Scheme Procedure} {} euclidean/ @var{x} @var{y}
@deftypefnx {Scheme Procedure} {} euclidean-quotient @var{x} @var{y}
@deftypefnx {Scheme Procedure} {} euclidean-remainder @var{x} @var{y}
@deftypefnx {C Function} void scm_euclidean_divide (SCM @var{x}, SCM @var{y}, SCM *@var{q}, SCM *@var{r})
@deftypefnx {C Function} SCM scm_euclidean_quotient (SCM @var{x}, SCM @var{y})
@deftypefnx {C Function} SCM scm_euclidean_remainder (SCM @var{x}, SCM @var{y})
These procedures accept two real numbers @var{x} and @var{y}, where the
divisor @var{y} must be non-zero.  @code{euclidean-quotient} returns the
integer @var{q} and @code{euclidean-remainder} returns the real number
@var{r} such that @math{@var{x} = @var{q}*@var{y} + @var{r}} and
@math{0 <= @var{r} < |@var{y}|}.  @code{euclidean/} returns both @var{q} and
@var{r}, and is more efficient than computing each separately.  Note
that when @math{@var{y} > 0}, @code{euclidean-quotient} returns
@math{floor(@var{x}/@var{y})}, otherwise it returns
@math{ceiling(@var{x}/@var{y})}.

Note that these operators are equivalent to the R6RS operators
@code{div}, @code{mod}, and @code{div-and-mod}.

@lisp
(euclidean-quotient 123 10) @result{} 12
(euclidean-remainder 123 10) @result{} 3
(euclidean/ 123 10) @result{} 12 and 3
(euclidean/ 123 -10) @result{} -12 and 3
(euclidean/ -123 10) @result{} -13 and 7
(euclidean/ -123 -10) @result{} 13 and 7
(euclidean/ -123.2 -63.5) @result{} 2.0 and 3.8
(euclidean/ 16/3 -10/7) @result{} -3 and 22/21
@end lisp
@end deftypefn

@deftypefn {Scheme Procedure} {} floor/ @var{x} @var{y}
@deftypefnx {Scheme Procedure} {} floor-quotient @var{x} @var{y}
@deftypefnx {Scheme Procedure} {} floor-remainder @var{x} @var{y}
@deftypefnx {C Function} void scm_floor_divide (SCM @var{x}, SCM @var{y}, SCM *@var{q}, SCM *@var{r})
@deftypefnx {C Function} SCM scm_floor_quotient (@var{x}, @var{y})
@deftypefnx {C Function} SCM scm_floor_remainder (@var{x}, @var{y})
These procedures accept two real numbers @var{x} and @var{y}, where the
divisor @var{y} must be non-zero.  @code{floor-quotient} returns the
integer @var{q} and @code{floor-remainder} returns the real number
@var{r} such that @math{@var{q} = floor(@var{x}/@var{y})} and
@math{@var{x} = @var{q}*@var{y} + @var{r}}.  @code{floor/} returns
both @var{q} and @var{r}, and is more efficient than computing each
separately.  Note that @var{r}, if non-zero, will have the same sign
as @var{y}.

When @var{x} and @var{y} are integers, @code{floor-remainder} is
equivalent to the R5RS integer-only operator @code{modulo}.

@lisp
(floor-quotient 123 10) @result{} 12
(floor-remainder 123 10) @result{} 3
(floor/ 123 10) @result{} 12 and 3
(floor/ 123 -10) @result{} -13 and -7
(floor/ -123 10) @result{} -13 and 7
(floor/ -123 -10) @result{} 12 and -3
(floor/ -123.2 -63.5) @result{} 1.0 and -59.7
(floor/ 16/3 -10/7) @result{} -4 and -8/21
@end lisp
@end deftypefn

@deftypefn {Scheme Procedure} {} ceiling/ @var{x} @var{y}
@deftypefnx {Scheme Procedure} {} ceiling-quotient @var{x} @var{y}
@deftypefnx {Scheme Procedure} {} ceiling-remainder @var{x} @var{y}
@deftypefnx {C Function} void scm_ceiling_divide (SCM @var{x}, SCM @var{y}, SCM *@var{q}, SCM *@var{r})
@deftypefnx {C Function} SCM scm_ceiling_quotient (@var{x}, @var{y})
@deftypefnx {C Function} SCM scm_ceiling_remainder (@var{x}, @var{y})
These procedures accept two real numbers @var{x} and @var{y}, where the
divisor @var{y} must be non-zero.  @code{ceiling-quotient} returns the
integer @var{q} and @code{ceiling-remainder} returns the real number
@var{r} such that @math{@var{q} = ceiling(@var{x}/@var{y})} and
@math{@var{x} = @var{q}*@var{y} + @var{r}}.  @code{ceiling/} returns
both @var{q} and @var{r}, and is more efficient than computing each
separately.  Note that @var{r}, if non-zero, will have the opposite sign
of @var{y}.

@lisp
(ceiling-quotient 123 10) @result{} 13
(ceiling-remainder 123 10) @result{} -7
(ceiling/ 123 10) @result{} 13 and -7
(ceiling/ 123 -10) @result{} -12 and 3
(ceiling/ -123 10) @result{} -12 and -3
(ceiling/ -123 -10) @result{} 13 and 7
(ceiling/ -123.2 -63.5) @result{} 2.0 and 3.8
(ceiling/ 16/3 -10/7) @result{} -3 and 22/21
@end lisp
@end deftypefn

@deftypefn {Scheme Procedure} {} truncate/ @var{x} @var{y}
@deftypefnx {Scheme Procedure} {} truncate-quotient @var{x} @var{y}
@deftypefnx {Scheme Procedure} {} truncate-remainder @var{x} @var{y}
@deftypefnx {C Function} void scm_truncate_divide (SCM @var{x}, SCM @var{y}, SCM *@var{q}, SCM *@var{r})
@deftypefnx {C Function} SCM scm_truncate_quotient (@var{x}, @var{y})
@deftypefnx {C Function} SCM scm_truncate_remainder (@var{x}, @var{y})
These procedures accept two real numbers @var{x} and @var{y}, where the
divisor @var{y} must be non-zero.  @code{truncate-quotient} returns the
integer @var{q} and @code{truncate-remainder} returns the real number
@var{r} such that @var{q} is @math{@var{x}/@var{y}} rounded toward zero,
and @math{@var{x} = @var{q}*@var{y} + @var{r}}.  @code{truncate/} returns
both @var{q} and @var{r}, and is more efficient than computing each
separately.  Note that @var{r}, if non-zero, will have the same sign
as @var{x}.

When @var{x} and @var{y} are integers, these operators are
equivalent to the R5RS integer-only operators @code{quotient} and
@code{remainder}.

@lisp
(truncate-quotient 123 10) @result{} 12
(truncate-remainder 123 10) @result{} 3
(truncate/ 123 10) @result{} 12 and 3
(truncate/ 123 -10) @result{} -12 and 3
(truncate/ -123 10) @result{} -12 and -3
(truncate/ -123 -10) @result{} 12 and -3
(truncate/ -123.2 -63.5) @result{} 1.0 and -59.7
(truncate/ 16/3 -10/7) @result{} -3 and 22/21
@end lisp
@end deftypefn

@deftypefn {Scheme Procedure} {} centered/ @var{x} @var{y}
@deftypefnx {Scheme Procedure} {} centered-quotient @var{x} @var{y}
@deftypefnx {Scheme Procedure} {} centered-remainder @var{x} @var{y}
@deftypefnx {C Function} void scm_centered_divide (SCM @var{x}, SCM @var{y}, SCM *@var{q}, SCM *@var{r})
@deftypefnx {C Function} SCM scm_centered_quotient (SCM @var{x}, SCM @var{y})
@deftypefnx {C Function} SCM scm_centered_remainder (SCM @var{x}, SCM @var{y})
These procedures accept two real numbers @var{x} and @var{y}, where the
divisor @var{y} must be non-zero.  @code{centered-quotient} returns the
integer @var{q} and @code{centered-remainder} returns the real number
@var{r} such that @math{@var{x} = @var{q}*@var{y} + @var{r}} and
@math{-|@var{y}/2| <= @var{r} < |@var{y}/2|}.  @code{centered/}
returns both @var{q} and @var{r}, and is more efficient than computing
each separately.

Note that @code{centered-quotient} returns @math{@var{x}/@var{y}}
rounded to the nearest integer.  When @math{@var{x}/@var{y}} lies
exactly half-way between two integers, the tie is broken according to
the sign of @var{y}.  If @math{@var{y} > 0}, ties are rounded toward
positive infinity, otherwise they are rounded toward negative infinity.
This is a consequence of the requirement that
@math{-|@var{y}/2| <= @var{r} < |@var{y}/2|}.

Note that these operators are equivalent to the R6RS operators
@code{div0}, @code{mod0}, and @code{div0-and-mod0}.

@lisp
(centered-quotient 123 10) @result{} 12
(centered-remainder 123 10) @result{} 3
(centered/ 123 10) @result{} 12 and 3
(centered/ 123 -10) @result{} -12 and 3
(centered/ -123 10) @result{} -12 and -3
(centered/ -123 -10) @result{} 12 and -3
(centered/ 125 10) @result{} 13 and -5
(centered/ 127 10) @result{} 13 and -3
(centered/ 135 10) @result{} 14 and -5
(centered/ -123.2 -63.5) @result{} 2.0 and 3.8
(centered/ 16/3 -10/7) @result{} -4 and -8/21
@end lisp
@end deftypefn

@deftypefn {Scheme Procedure} {} round/ @var{x} @var{y}
@deftypefnx {Scheme Procedure} {} round-quotient @var{x} @var{y}
@deftypefnx {Scheme Procedure} {} round-remainder @var{x} @var{y}
@deftypefnx {C Function} void scm_round_divide (SCM @var{x}, SCM @var{y}, SCM *@var{q}, SCM *@var{r})
@deftypefnx {C Function} SCM scm_round_quotient (@var{x}, @var{y})
@deftypefnx {C Function} SCM scm_round_remainder (@var{x}, @var{y})
These procedures accept two real numbers @var{x} and @var{y}, where the
divisor @var{y} must be non-zero.  @code{round-quotient} returns the
integer @var{q} and @code{round-remainder} returns the real number
@var{r} such that @math{@var{x} = @var{q}*@var{y} + @var{r}} and
@var{q} is @math{@var{x}/@var{y}} rounded to the nearest integer,
with ties going to the nearest even integer.  @code{round/}
returns both @var{q} and @var{r}, and is more efficient than computing
each separately.

Note that @code{round/} and @code{centered/} are almost equivalent, but
their behavior differs when @math{@var{x}/@var{y}} lies exactly half-way
between two integers.  In this case, @code{round/} chooses the nearest
even integer, whereas @code{centered/} chooses in such a way to satisfy
the constraint @math{-|@var{y}/2| <= @var{r} < |@var{y}/2|}, which
is stronger than the corresponding constraint for @code{round/},
@math{-|@var{y}/2| <= @var{r} <= |@var{y}/2|}.  In particular,
when @var{x} and @var{y} are integers, the number of possible remainders
returned by @code{centered/} is @math{|@var{y}|}, whereas the number of
possible remainders returned by @code{round/} is @math{|@var{y}|+1} when
@var{y} is even.

@lisp
(round-quotient 123 10) @result{} 12
(round-remainder 123 10) @result{} 3
(round/ 123 10) @result{} 12 and 3
(round/ 123 -10) @result{} -12 and 3
(round/ -123 10) @result{} -12 and -3
(round/ -123 -10) @result{} 12 and -3
(round/ 125 10) @result{} 12 and 5
(round/ 127 10) @result{} 13 and -3
(round/ 135 10) @result{} 14 and -5
(round/ -123.2 -63.5) @result{} 2.0 and 3.8
(round/ 16/3 -10/7) @result{} -4 and -8/21
@end lisp
@end deftypefn

@node Scientific
@subsubsection Scientific Functions

Следующие процедуры принимают любое число в качестве аргументов,
включая комплексные числа.

@rnindex sqrt
@c begin (texi-doc-string "guile" "sqrt")
@deffn {Scheme Procedure} sqrt z
Return the square root of @var{z}.  Of the two possible roots
(positive and negative), the one with a positive real part is
returned, or if that's zero then a positive imaginary part.  Thus,

@example
(sqrt 9.0)       @result{} 3.0
(sqrt -9.0)      @result{} 0.0+3.0i
(sqrt 1.0+1.0i)  @result{} 1.09868411346781+0.455089860562227i
(sqrt -1.0-1.0i) @result{} 0.455089860562227-1.09868411346781i
@end example
@end deffn

@rnindex expt
@c begin (texi-doc-string "guile" "expt")
@deffn {Scheme Procedure} expt z1 z2
Return @var{z1} raised to the power of @var{z2}.
@end deffn

@rnindex sin
@c begin (texi-doc-string "guile" "sin")
@deffn {Scheme Procedure} sin z
Return the sine of @var{z}.
@end deffn

@rnindex cos
@c begin (texi-doc-string "guile" "cos")
@deffn {Scheme Procedure} cos z
Return the cosine of @var{z}.
@end deffn

@rnindex tan
@c begin (texi-doc-string "guile" "tan")
@deffn {Scheme Procedure} tan z
Return the tangent of @var{z}.
@end deffn

@rnindex asin
@c begin (texi-doc-string "guile" "asin")
@deffn {Scheme Procedure} asin z
Return the arcsine of @var{z}.
@end deffn

@rnindex acos
@c begin (texi-doc-string "guile" "acos")
@deffn {Scheme Procedure} acos z
Return the arccosine of @var{z}.
@end deffn

@rnindex atan
@c begin (texi-doc-string "guile" "atan")
@deffn {Scheme Procedure} atan z
@deffnx {Scheme Procedure} atan y x
Return the arctangent of @var{z}, or of @math{@var{y}/@var{x}}.
@end deffn

@rnindex exp
@c begin (texi-doc-string "guile" "exp")
@deffn {Scheme Procedure} exp z
Return e to the power of @var{z}, where e is the base of natural
logarithms (2.71828@dots{}).
@end deffn

@rnindex log
@c begin (texi-doc-string "guile" "log")
@deffn {Scheme Procedure} log z
Return the natural logarithm of @var{z}.
@end deffn

@c begin (texi-doc-string "guile" "log10")
@deffn {Scheme Procedure} log10 z
Return the base 10 logarithm of @var{z}.
@end deffn

@c begin (texi-doc-string "guile" "sinh")
@deffn {Scheme Procedure} sinh z
Return the hyperbolic sine of @var{z}.
@end deffn

@c begin (texi-doc-string "guile" "cosh")
@deffn {Scheme Procedure} cosh z
Return the hyperbolic cosine of @var{z}.
@end deffn

@c begin (texi-doc-string "guile" "tanh")
@deffn {Scheme Procedure} tanh z
Return the hyperbolic tangent of @var{z}.
@end deffn

@c begin (texi-doc-string "guile" "asinh")
@deffn {Scheme Procedure} asinh z
Return the hyperbolic arcsine of @var{z}.
@end deffn

@c begin (texi-doc-string "guile" "acosh")
@deffn {Scheme Procedure} acosh z
Return the hyperbolic arccosine of @var{z}.
@end deffn

@c begin (texi-doc-string "guile" "atanh")
@deffn {Scheme Procedure} atanh z
Return the hyperbolic arctangent of @var{z}.
@end deffn

@node Bitwise Operations
@subsubsection Bitwise Operations

Для следующих побитовых функций отритцательные числа рассматриваются
как двоичные дополнения бесконечной точности.  Например @math{-6} 
в битовом представлении @math{@dots{}111010}, как число бесконечным
числом единиц слева.  Это видно, что добавление  6 (binary 110) к
такой битовой схеме дает все нули.

@deffn {Scheme Procedure} logand n1 n2 @dots{}
@deffnx {C Function} scm_logand (n1, n2)
Return the bitwise @sc{and} of the integer arguments.

@lisp
(logand) @result{} -1
(logand 7) @result{} 7
(logand #b111 #b011 #b001) @result{} 1
@end lisp
@end deffn

@deffn {Scheme Procedure} logior n1 n2 @dots{}
@deffnx {C Function} scm_logior (n1, n2)
Return the bitwise @sc{or} of the integer arguments.

@lisp
(logior) @result{} 0
(logior 7) @result{} 7
(logior #b000 #b001 #b011) @result{} 3
@end lisp
@end deffn

@deffn {Scheme Procedure} logxor n1 n2 @dots{}
@deffnx {C Function} scm_loxor (n1, n2)
Return the bitwise @sc{xor} of the integer arguments.  A bit is
set in the result if it is set in an odd number of arguments.

@lisp
(logxor) @result{} 0
(logxor 7) @result{} 7
(logxor #b000 #b001 #b011) @result{} 2
(logxor #b000 #b001 #b011 #b011) @result{} 1
@end lisp
@end deffn

@deffn {Scheme Procedure} lognot n
@deffnx {C Function} scm_lognot (n)
Return the integer which is the ones-complement of the integer
argument, ie.@: each 0 bit is changed to 1 and each 1 bit to 0.

@lisp
(number->string (lognot #b10000000) 2)
   @result{} "-10000001"
(number->string (lognot #b0) 2)
   @result{} "-1"
@end lisp
@end deffn

@deffn {Scheme Procedure} logtest j k
@deffnx {C Function} scm_logtest (j, k)
Test whether @var{j} and @var{k} have any 1 bits in common.  This is
equivalent to @code{(not (zero? (logand j k)))}, but without actually
calculating the @code{logand}, just testing for non-zero.

@lisp
(logtest #b0100 #b1011) @result{} #f
(logtest #b0100 #b0111) @result{} #t
@end lisp
@end deffn

@deffn {Scheme Procedure} logbit? index j
@deffnx {C Function} scm_logbit_p (index, j)
Test whether bit number @var{index} in @var{j} is set.  @var{index}
starts from 0 for the least significant bit.

@lisp
(logbit? 0 #b1101) @result{} #t
(logbit? 1 #b1101) @result{} #f
(logbit? 2 #b1101) @result{} #t
(logbit? 3 #b1101) @result{} #t
(logbit? 4 #b1101) @result{} #f
@end lisp
@end deffn

@deffn {Scheme Procedure} ash n count
@deffnx {C Function} scm_ash (n, count)
Return @math{floor(n * 2^{count})}.
@var{n} and @var{count} must be exact integers.

With @var{n} viewed as an infinite-precision twos-complement
integer, @code{ash} means a left shift introducing zero bits
when @var{count} is positive, or a right shift dropping bits
when @var{count} is negative.  This is an ``arithmetic'' shift.

@lisp
(number->string (ash #b1 3) 2)     @result{} "1000"
(number->string (ash #b1010 -1) 2) @result{} "101"

;; -23 is bits ...11101001, -6 is bits ...111010
(ash -23 -2) @result{} -6
@end lisp
@end deffn

@deffn {Scheme Procedure} round-ash n count
@deffnx {C Function} scm_round_ash (n, count)
Return @math{round(n * 2^count)}.
@var{n} and @var{count} must be exact integers.

With @var{n} viewed as an infinite-precision twos-complement
integer, @code{round-ash} means a left shift introducing zero
bits when @var{count} is positive, or a right shift rounding
to the nearest integer (with ties going to the nearest even
integer) when @var{count} is negative.  This is a rounded
``arithmetic'' shift.

@lisp
(number->string (round-ash #b1 3) 2)     @result{} \"1000\"
(number->string (round-ash #b1010 -1) 2) @result{} \"101\"
(number->string (round-ash #b1010 -2) 2) @result{} \"10\"
(number->string (round-ash #b1011 -2) 2) @result{} \"11\"
(number->string (round-ash #b1101 -2) 2) @result{} \"11\"
(number->string (round-ash #b1110 -2) 2) @result{} \"100\"
@end lisp
@end deffn

@deffn {Scheme Procedure} logcount n
@deffnx {C Function} scm_logcount (n)
Return the number of bits in integer @var{n}.  If @var{n} is
positive, the 1-bits in its binary representation are counted.
If negative, the 0-bits in its two's-complement binary
representation are counted.  If zero, 0 is returned.

@lisp
(logcount #b10101010)
   @result{} 4
(logcount 0)
   @result{} 0
(logcount -2)
   @result{} 1
@end lisp
@end deffn

@deffn {Scheme Procedure} integer-length n
@deffnx {C Function} scm_integer_length (n)
Return the number of bits necessary to represent @var{n}.

For positive @var{n} this is how many bits to the most significant one
bit.  For negative @var{n} it's how many bits to the most significant
zero bit in twos complement form.

@lisp
(integer-length #b10101010) @result{} 8
(integer-length #b1111)     @result{} 4
(integer-length 0)          @result{} 0
(integer-length -1)         @result{} 0
(integer-length -256)       @result{} 8
(integer-length -257)       @result{} 9
@end lisp
@end deffn

@deffn {Scheme Procedure} integer-expt n k
@deffnx {C Function} scm_integer_expt (n, k)
Return @var{n} raised to the power @var{k}.  @var{k} must be an exact
integer, @var{n} can be any number.

Negative @var{k} is supported, and results in @m{1/n^|k|, 1/n^abs(k)}
in the usual way.  @math{@var{n}^0} is 1, as usual, and that includes
@math{0^0} is 1.

@lisp
(integer-expt 2 5)   @result{} 32
(integer-expt -3 3)  @result{} -27
(integer-expt 5 -3)  @result{} 1/125
(integer-expt 0 0)   @result{} 1
@end lisp
@end deffn

@deffn {Scheme Procedure} bit-extract n start end
@deffnx {C Function} scm_bit_extract (n, start, end)
Return the integer composed of the @var{start} (inclusive)
through @var{end} (exclusive) bits of @var{n}.  The
@var{start}th bit becomes the 0-th bit in the result.

@lisp
(number->string (bit-extract #b1101101010 0 4) 2)
   @result{} "1010"
(number->string (bit-extract #b1101101010 4 9) 2)
   @result{} "10110"
@end lisp
@end deffn

@node Random
@subsubsection Random Number Generation

Псевдослучайные чила генерируются из объекта случаного состояния,
который может быть создан функциями @code{seed->random-state} или
@code{datum->random-state}.  Внешнее представление (т.е..@: 
которое может быть записано @code{write} и считано @code{read}) 
объекта случайного состояния) может быть получено вызовом
@code{random-state->datum}.  Параметр @var{state} для различных
функци ниже, не обязателен, по умолчанию используется объект 
состояния в переменной  @code{*random-state*}.

@deffn {Scheme Procedure} copy-random-state [state]
@deffnx {C Function} scm_copy_random_state (state)
Возвращает копию случайного состояния @var{state}.
@end deffn

@deffn {Scheme Procedure} random n [state]
@deffnx {C Function} scm_random (n, state)
Возвращает номер в рамках [0, @var{n}).

Принимает полжительное целое или вещественное n и 
возвращает число того же типа между нулем(включительно)
и @var{n} (исключая). Возвращаемые значения имеют
равномерное распределение.
@end deffn

@deffn {Scheme Procedure} random:exp [state]
@deffnx {C Function} scm_random_exp (state)
Возвращает не точное вещественное значение в экспотенциальном
распределении со средним 1.  Для экспотенциального распределения
со средним равным @var{u} используйте @code{(* @var{u} (random:exp))}.
@end deffn

@deffn {Scheme Procedure} random:hollow-sphere! vect [state]
@deffnx {C Function} scm_random_hollow_sphere_x (vect, state)
Заполняет вектор @var{vect} неточными вещественными случайными
числами сумма квадратов которых равна 1.0.  Думая о векторе @var{vect}
как о пространстве размерности @var{n} @math{=} @code{(vector-length @var{vect})},
координаты равномерно распределены по поверхности единичной n-сферы.
@end deffn

@deffn {Scheme Procedure} random:normal [state]
@deffnx {C Function} scm_random_normal (state)
Возвращает не точное нормальное распределение. Это распределение
имеет среднее 0 и стандартное отклонение 1.  Для номрмального распределения
со средним @var{m} и стандартным отклонением @var{d} используйте @code{(+ @var{m}
(* @var{d} (random:normal)))}.
@end deffn

@deffn {Scheme Procedure} random:normal-vector! vect [state]
@deffnx {C Function} scm_random_normal_vector_x (vect, state)
Заполняет вектор  @var{vect} неточными вещественными случайными
числами, которые являются независимыми и стандартно распределенными
(т.е со средним 0 и дисперсией 1).
@end deffn

@deffn {Scheme Procedure} random:solid-sphere! vect [state]
@deffnx {C Function} scm_random_solid_sphere_x (vect, state)
Заполняет вектор @var{vect} неточными вещественными случайными числами,
сумма квадратов которых меньше 1.0.  Думая о векторе @var{vect} как о
координатах в пространстве размерности @var{n} 
@math{=} @code{(vector-length @var{vect})}, координаты равномерно
распределены внутри единично @var{n}-сферы.
@c FIXME: What does this mean, particularly the n-sphere part?
@end deffn

@deffn {Scheme Procedure} random:uniform [state]
@deffnx {C Function} scm_random_uniform (state)
Возвращает равномернораспределенное неточное вещественное
число в границах [0,1).
@end deffn

@deffn {Scheme Procedure} seed->random-state seed
@deffnx {C Function} scm_seed_to_random_state (seed)
Возвращает новое случайное состояние с использванием
@var{seed}.
@end deffn

@deffn {Scheme Procedure} datum->random-state datum
@deffnx {C Function} scm_datum_to_random_state (datum)
Возвращает новое случайное состояние из @var{datum}, которое
должно быть получено вызовом @code{random-state->datum}.
@end deffn

@deffn {Scheme Procedure} random-state->datum state
@deffnx {C Function} scm_random_state_to_datum (state)
Возвращает представление случайного состояния @var{state} которое может быть
записано и прочитано с помощью функций чтения Scheme.
@end deffn

@deffn {Scheme Procedure} random-state-from-platform
@deffnx {C Function} scm_random_state_from_platform ()
Создание нового случайного состояния, сгенерированное из энтропии, 
специфичной для платформы, подходящее для использования в не критичных
для безопасности приложениях. В настоящее время @file{/dev/urandom} 
сначала, основывается на времени и дате, идентификаторе процесса, адресе
недавно выделенной ячейки кучи, адресе из локального фрейма стека и таймере
высокого разрешения, если он доступен.
@end deffn

@defvar *random-state*
Глобальное случайное состояние, используемое вышеуказанными функциями, 
когда параметр @var{state} не задан.
@end defvar

Обратите внимание, что начальное значение @code{*random-state*} одинаково
при каждом запуске Guile. Поэтому, если вы не передадите параметр
состояния указанным выше процедурам, и вы не установите
@code{*random-state*} вызвом @code{(seed->random-state your-seed)}, где
@code{your-seed} это не одно и тоже значение каждый раз, вы получите
одну и туже последовательность ``случайных'' чисел при каждом запуске
программы.

Например, если соответствующий код не был изменен, 
@code{(map random (cdr (iota 30)))}, если первое использование
случайных чисел с момента запуска Guile всегда будет давать:

@lisp
(map random (cdr (iota 19)))
@result{}
(0 1 1 2 2 2 1 2 6 7 10 0 5 3 12 5 5 12)
@end lisp

Чтобы разумно распределять случайное состояние для приложений, не
относящихся к супер безопасным, сделайте это во время инициализации
вашей программы.

@lisp
(set! *random-state* (random-state-from-platform))
@end lisp

@node Characters
@subsection Characters
@tpindex Characters

В схеме существует тип данных для описания одиночных символов

Определение того, что такое символ может быть сложнее, чем кажется. Guile
следует рекомендациям R6RS и использует стандарт Unicode, чтобы определить, 
что является символом. Итак, для Guile символ - это что-то из базы данных
символов Юникода.

@cindex code point
@cindex Unicode code point

База данных символов Юникода представляет собой таблицу символов,
индексированную с использованием целых чисел называемых «кодовыми
точками». Действительные кодовые точки находятся в диапазоне от 
0 до @code{#xD7FF} включительно или @code{#xE000} до  @code{#x10FFFF} 
включительно, что составляет около 1,1 миллиона кодовых точек.


@cindex designated code point
@cindex code point, designated

Любая кодовая точка, которая была назначена символу или которая 
имеет значение в Unicode называется «обозначенной кодовой точкой».
Большинство обозначенных кодовых точек, около 200 000 указывают 
на символы, акценты или сочетания меток, которые изменяют
другие символы, символы, пробелы и управляющие символы. Некоторые 
из них не являются символами, но являются индикаторами, которые 
указывают, как форматировать или отображать соседние символы.

@cindex reserved code point
@cindex code point, reserved

Если кодовая точка не является назначенной кодовой точкой - т.е если 
она не назначена символу в стандарте Unicode - это 'зарезервированная 
кодовая точка', что означает, что она зарезервирована для
будущего использования. Большинство кодовых точек, около 800 000, 
являются «зарезервированными кодовыми точками».

По соглашению, кодовая точка Unicode записывается как 
``U+XXXX'', где ``XXXX'' является шестнадцатеричным числом. 
Обратите внимание, что это удобное обозначение является недопустимым 
кодом. Guile не интерпретирует ``U+XXXX'' как символ.


В Scheme символьный литерал записывается как @code{#\@var{name}}, где 
@var{name} - это имя символа, который вам нужен. Печатные 
символы имеют свое обычное односимвольное имя; Например, 
@code{#\a} - это нижний регистр @code{a}.

Некоторые из кодовых точек - это 'комбинирующие символы', которые не 
предназначены для печати а вместо этого предназначены для изменения 
внешнего вида предыдущего символа. Для комбинирующих символов, 
альтернативная форма символьного литерала - @code{#\}, затем U+25CC
(маленький, пунктирный круг), за которым следует комбинирующий символ. 
Это позволяет создать комбинированный символ, который будет нарисован 
на круге, а не обычную обратную косую черту  @code{#\}.

Многие из непечатаемых символов, таких как символы пробелов и управляющие 
символы, также имеют имена.

Наиболее часто используемые непечатаемые символы имеют длинные имена 
символов, описанны в таблице ниже

@multitable {@code{#\backspace}} {Preferred}
@item Character Name @tab Codepoint
@item @code{#\nul} @tab U+0000
@item @code{#\alarm} @tab U+0007
@item @code{#\backspace} @tab U+0008
@item @code{#\tab} @tab U+0009
@item @code{#\linefeed} @tab U+000A
@item @code{#\newline} @tab U+000A
@item @code{#\vtab} @tab U+000B
@item @code{#\page} @tab U+000C
@item @code{#\return} @tab U+000D
@item @code{#\esc} @tab U+001B
@item @code{#\space} @tab U+0020
@item @code{#\delete} @tab U+007F
@end multitable

Также есть короткие имена для всех ``C0 управляющих символов''
(те, у кого есть кодовые точки ниже 32).  В следующей таблице
указаны краткие имена для каждого символа.

@multitable @columnfractions .25 .25 .25 .25
@item 0 = @code{#\nul}
 @tab 1 = @code{#\soh}
 @tab 2 = @code{#\stx}
 @tab 3 = @code{#\etx}
@item 4 = @code{#\eot}
 @tab 5 = @code{#\enq}
 @tab 6 = @code{#\ack}
 @tab 7 = @code{#\bel}
@item 8 = @code{#\bs}
 @tab 9 = @code{#\ht}
 @tab 10 = @code{#\lf}
 @tab 11 = @code{#\vt}
@item 12 = @code{#\ff}
 @tab 13 = @code{#\cr}
 @tab 14 = @code{#\so}
 @tab 15 = @code{#\si}
@item 16 = @code{#\dle}
 @tab 17 = @code{#\dc1}
 @tab 18 = @code{#\dc2}
 @tab 19 = @code{#\dc3}
@item 20 = @code{#\dc4}
 @tab 21 = @code{#\nak}
 @tab 22 = @code{#\syn}
 @tab 23 = @code{#\etb}
@item 24 = @code{#\can}
 @tab 25 = @code{#\em}
 @tab 26 = @code{#\sub}
 @tab 27 = @code{#\esc}
@item 28 = @code{#\fs}
 @tab 29 = @code{#\gs}
 @tab 30 = @code{#\rs}
 @tab 31 = @code{#\us}
@item 32 = @code{#\sp}
@end multitable

Короткое имя для символа удалить ``delete'' (кодовая точка U+007F)
@code{#\del}.

The R7RS name for the ``escape'' character (code point U+001B) is
@code{#\escape}.

Есть также несколько альтернативных имен, оставшихся для совместимости с
предыдущими версиями из Guile.

@multitable {@code{#\backspace}} {Preferred}
@item Alternate @tab Standard
@item @code{#\nl} @tab @code{#\newline}
@item @code{#\np} @tab @code{#\page}
@item @code{#\null} @tab @code{#\nul}
@end multitable

Characters may also be written using their code point values.  They can
be written with as an octal number, such as @code{#\10} for
@code{#\bs} or @code{#\177} for @code{#\del}.

Если кто-то предпочитает использовать шестнадцатеричный код, 
сущетствует дополнительный синткасис с обратной косой чертой:
@code{#\xHHHH} -- за символом 'x' следует шестнадцатеричное число
от одной до восми цифр.

@rnindex char?
@deffn {Scheme Procedure} char? x
@deffnx {C Function} scm_char_p (x)
Return @code{#t} if @var{x} is a character, else @code{#f}.
@end deffn

Fundamentally, the character comparison operations below are
numeric comparisons of the character's code points.

@rnindex char=?
@deffn {Scheme Procedure} char=? x y
Return @code{#t} if code point of @var{x} is equal to the code point
of @var{y}, else @code{#f}.
@end deffn

@rnindex char<?
@deffn {Scheme Procedure} char<? x y
Return @code{#t} if the code point of @var{x} is less than the code
point of @var{y}, else @code{#f}.
@end deffn

@rnindex char<=?
@deffn {Scheme Procedure} char<=? x y
Return @code{#t} if the code point of @var{x} is less than or equal
to the code point of @var{y}, else @code{#f}.
@end deffn

@rnindex char>?
@deffn {Scheme Procedure} char>? x y
Return @code{#t} if the code point of @var{x} is greater than the
code point of @var{y}, else @code{#f}.
@end deffn

@rnindex char>=?
@deffn {Scheme Procedure} char>=? x y
Return @code{#t} if the code point of @var{x} is greater than or
equal to the code point of @var{y}, else @code{#f}.
@end deffn

@cindex case folding

Case-insensitive character comparisons use @emph{Unicode case
folding}.  In case folding comparisons, if a character is lowercase
and has an uppercase form that can be expressed as a single character,
it is converted to uppercase before comparison.  All other characters
undergo no conversion before the comparison occurs.  This includes the
German sharp S (Eszett) which is not uppercased before conversion
because its uppercase form has two characters.  Unicode case folding
is language independent: it uses rules that are generally true, but,
it cannot cover all cases for all languages.

@rnindex char-ci=?
@deffn {Scheme Procedure} char-ci=? x y
Return @code{#t} if the case-folded code point of @var{x} is the same
as the case-folded code point of @var{y}, else @code{#f}.
@end deffn

@rnindex char-ci<?
@deffn {Scheme Procedure} char-ci<? x y
Return @code{#t} if the case-folded code point of @var{x} is less
than the case-folded code point of @var{y}, else @code{#f}.
@end deffn

@rnindex char-ci<=?
@deffn {Scheme Procedure} char-ci<=? x y
Return @code{#t} if the case-folded code point of @var{x} is less
than or equal to the case-folded code point of @var{y}, else
@code{#f}.
@end deffn

@rnindex char-ci>?
@deffn {Scheme Procedure} char-ci>? x y
Return @code{#t} if the case-folded code point of @var{x} is greater
than the case-folded code point of @var{y}, else @code{#f}.
@end deffn

@rnindex char-ci>=?
@deffn {Scheme Procedure} char-ci>=? x y
Return @code{#t} if the case-folded code point of @var{x} is greater
than or equal to the case-folded code point of @var{y}, else
@code{#f}.
@end deffn

@rnindex char-alphabetic?
@deffn {Scheme Procedure} char-alphabetic? chr
@deffnx {C Function} scm_char_alphabetic_p (chr)
Return @code{#t} if @var{chr} is alphabetic, else @code{#f}.
@end deffn

@rnindex char-numeric?
@deffn {Scheme Procedure} char-numeric? chr
@deffnx {C Function} scm_char_numeric_p (chr)
Return @code{#t} if @var{chr} is numeric, else @code{#f}.
@end deffn

@rnindex char-whitespace?
@deffn {Scheme Procedure} char-whitespace? chr
@deffnx {C Function} scm_char_whitespace_p (chr)
Return @code{#t} if @var{chr} is whitespace, else @code{#f}.
@end deffn

@rnindex char-upper-case?
@deffn {Scheme Procedure} char-upper-case? chr
@deffnx {C Function} scm_char_upper_case_p (chr)
Return @code{#t} if @var{chr} is uppercase, else @code{#f}.
@end deffn

@rnindex char-lower-case?
@deffn {Scheme Procedure} char-lower-case? chr
@deffnx {C Function} scm_char_lower_case_p (chr)
Return @code{#t} if @var{chr} is lowercase, else @code{#f}.
@end deffn

@deffn {Scheme Procedure} char-is-both? chr
@deffnx {C Function} scm_char_is_both_p (chr)
Return @code{#t} if @var{chr} is either uppercase or lowercase, else
@code{#f}.
@end deffn

@deffn {Scheme Procedure} char-general-category chr
@deffnx {C Function} scm_char_general_category (chr)
Return a symbol giving the two-letter name of the Unicode general 
category assigned to @var{chr} or @code{#f} if no named category is 
assigned.  The following table provides a list of category names along
with their meanings.

@multitable @columnfractions .1 .4 .1 .4
@item Lu
 @tab Uppercase letter
 @tab Pf
 @tab Final quote punctuation
@item Ll
 @tab Lowercase letter
 @tab Po
 @tab Other punctuation
@item Lt
 @tab Titlecase letter
 @tab Sm
 @tab Math symbol
@item Lm
 @tab Modifier letter
 @tab Sc
 @tab Currency symbol
@item Lo
 @tab Other letter
 @tab Sk
 @tab Modifier symbol
@item Mn
 @tab Non-spacing mark
 @tab So
 @tab Other symbol
@item Mc
 @tab Combining spacing mark
 @tab Zs
 @tab Space separator
@item Me
 @tab Enclosing mark
 @tab Zl
 @tab Line separator
@item Nd
 @tab Decimal digit number
 @tab Zp
 @tab Paragraph separator
@item Nl
 @tab Letter number
 @tab Cc
 @tab Control
@item No
 @tab Other number
 @tab Cf
 @tab Format
@item Pc
 @tab Connector punctuation
 @tab Cs
 @tab Surrogate
@item Pd
 @tab Dash punctuation
 @tab Co
 @tab Private use
@item Ps
 @tab Open punctuation
 @tab Cn
 @tab Unassigned
@item Pe
 @tab Close punctuation
 @tab
 @tab
@item Pi
 @tab Initial quote punctuation
 @tab
 @tab
@end multitable
@end deffn

@rnindex char->integer
@deffn {Scheme Procedure} char->integer chr
@deffnx {C Function} scm_char_to_integer (chr)
Return the code point of @var{chr}.
@end deffn

@rnindex integer->char
@deffn {Scheme Procedure} integer->char n
@deffnx {C Function} scm_integer_to_char (n)
Return the character that has code point @var{n}.  The integer @var{n}
must be a valid code point.  Valid code points are in the ranges 0 to
@code{#xD7FF} inclusive or @code{#xE000} to @code{#x10FFFF} inclusive.
@end deffn

@rnindex char-upcase
@deffn {Scheme Procedure} char-upcase chr
@deffnx {C Function} scm_char_upcase (chr)
Return the uppercase character version of @var{chr}.
@end deffn

@rnindex char-downcase
@deffn {Scheme Procedure} char-downcase chr
@deffnx {C Function} scm_char_downcase (chr)
Return the lowercase character version of @var{chr}.
@end deffn

@rnindex char-titlecase
@deffn {Scheme Procedure} char-titlecase chr
@deffnx {C Function} scm_char_titlecase (chr)
Return the titlecase character version of @var{chr} if one exists;
otherwise return the uppercase version.  

For most characters these will be the same, but the Unicode Standard 
includes certain digraph compatibility characters, such as @code{U+01F3}
``dz'', for which the uppercase and titlecase characters are different 
(@code{U+01F1} ``DZ'' and @code{U+01F2} ``Dz'' in this case, 
respectively).
@end deffn

@tindex scm_t_wchar
@deftypefn {C Function} scm_t_wchar scm_c_upcase (scm_t_wchar @var{c})
@deftypefnx {C Function} scm_t_wchar scm_c_downcase (scm_t_wchar @var{c})
@deftypefnx {C Function} scm_t_wchar scm_c_titlecase (scm_t_wchar @var{c})

These C functions take an integer representation of a Unicode
codepoint and return the codepoint corresponding to its uppercase,
lowercase, and titlecase forms respectively.  The type
@code{scm_t_wchar} is a signed, 32-bit integer.
@end deftypefn

Символы также имеют ``формальные имена'', которые определены Unicode.
Этим имена могут быть доступны в Guile из модуля @code{(ice-9 unicode)}:


@example
(use-modules (ice-9 unicode))
@end example

@deffn {Scheme Procedure} char->formal-name chr
Return the formal all-upper-case Unicode name of @var{ch},
as a string, or @code{#f} if the character has no name.
@end deffn

@deffn {Scheme Procedure} formal-name->char name
Return the character whose formal all-upper-case Unicode name is
@var{name}, or @code{#f} if no such character is known.
@end deffn

@node Character Sets
@subsection Character Sets

Функции, описанные в данном разделе, соответствуют SRFI-14.

Тип данных @dfn{(Набор символов)charset} реализует множество символов.
(@pxref{Characters}).  Поскольку внутреннее представление множества 
символов не видно пользователю, предоставляется множество процедур для
их обработки.

Наборы символов могут быть созданы, расширены, проверены на принадлежность
символов и могут быть сравнены с другими наборами символов.

@menu
* Character Set Predicates/Comparison::
* Iterating Over Character Sets::  Enumerate charset elements.
* Creating Character Sets::        Making new charsets.
* Querying Character Sets::        Test charsets for membership etc.
* Character-Set Algebra::          Calculating new charsets.
* Standard Character Sets::        Variables containing predefined charsets.
@end menu

@node Character Set Predicates/Comparison
@subsubsection Character Set Predicates/Comparison

Используйте эти процедуры для проверки того, является ли объект набором
символов, или проверки равны ли между собой несколько наборов символов
или является ли один набор символов, подмножеством другого. Функция
@code{char-set-hash} вычисляет хеш-значение набора символов и может 
быть использована в быстрых процедурах поиска.


@deffn {Scheme Procedure} char-set? obj
@deffnx {C Function} scm_char_set_p (obj)
Return @code{#t} if @var{obj} is a character set, @code{#f}
otherwise.
@end deffn

@deffn {Scheme Procedure} char-set= char_set @dots{}
@deffnx {C Function} scm_char_set_eq (char_sets)
Return @code{#t} if all given character sets are equal.
@end deffn

@deffn {Scheme Procedure} char-set<= char_set @dots{}
@deffnx {C Function} scm_char_set_leq (char_sets)
Return @code{#t} if every character set @var{char_set}i is a subset
of character set @var{char_set}i+1.
@end deffn

@deffn {Scheme Procedure} char-set-hash cs [bound]
@deffnx {C Function} scm_char_set_hash (cs, bound)
Compute a hash value for the character set @var{cs}.  If
@var{bound} is given and non-zero, it restricts the
returned value to the range 0 @dots{} @var{bound} - 1.
@end deffn

@c ===================================================================

@node Iterating Over Character Sets
@subsubsection Iterating Over Character Sets

Указатели в наборе символов - это средство для итерации над элементами
набора символов.  После создания указателя(курсора) набора символов
с помощью функции @code{char-set-cursor}, указатель может быть
разименован(получен элемент набора символов) @code{char-set-ref}, 
перемещен к следующему элементу @code{char-set-cursor-next}.  
Проверить когда указатель прошел последний элемент можно 
функцией @code{end-of-char-set?}.

Кроме того, предоставляются функции сопоставления(mapping) и функции
складывания(fold)/создания(unfold) набора символов.

@deffn {Scheme Procedure} char-set-cursor cs
@deffnx {C Function} scm_char_set_cursor (cs)
Return a cursor into the character set @var{cs}.
@end deffn

@deffn {Scheme Procedure} char-set-ref cs cursor
@deffnx {C Function} scm_char_set_ref (cs, cursor)
Return the character at the current cursor position
@var{cursor} in the character set @var{cs}.  It is an error to
pass a cursor for which @code{end-of-char-set?} returns true.
@end deffn

@deffn {Scheme Procedure} char-set-cursor-next cs cursor
@deffnx {C Function} scm_char_set_cursor_next (cs, cursor)
Advance the character set cursor @var{cursor} to the next
character in the character set @var{cs}.  It is an error if the
cursor given satisfies @code{end-of-char-set?}.
@end deffn

@deffn {Scheme Procedure} end-of-char-set? cursor
@deffnx {C Function} scm_end_of_char_set_p (cursor)
Return @code{#t} if @var{cursor} has reached the end of a
character set, @code{#f} otherwise.
@end deffn

@deffn {Scheme Procedure} char-set-fold kons knil cs
@deffnx {C Function} scm_char_set_fold (kons, knil, cs)
Fold the procedure @var{kons} over the character set @var{cs},
initializing it with @var{knil}.
@end deffn

@deffn {Scheme Procedure} char-set-unfold p f g seed [base_cs]
@deffnx {C Function} scm_char_set_unfold (p, f, g, seed, base_cs)
This is a fundamental constructor for character sets.
@itemize @bullet
@item @var{g} is used to generate a series of ``seed'' values
from the initial seed: @var{seed}, (@var{g} @var{seed}),
(@var{g}^2 @var{seed}), (@var{g}^3 @var{seed}), @dots{}
@item @var{p} tells us when to stop -- when it returns true
when applied to one of the seed values.
@item @var{f} maps each seed value to a character. These
characters are added to the base character set @var{base_cs} to
form the result; @var{base_cs} defaults to the empty set.
@end itemize
@end deffn

@deffn {Scheme Procedure} char-set-unfold! p f g seed base_cs
@deffnx {C Function} scm_char_set_unfold_x (p, f, g, seed, base_cs)
This is a fundamental constructor for character sets.
@itemize @bullet
@item @var{g} is used to generate a series of ``seed'' values
from the initial seed: @var{seed}, (@var{g} @var{seed}),
(@var{g}^2 @var{seed}), (@var{g}^3 @var{seed}), @dots{}
@item @var{p} tells us when to stop -- when it returns true
when applied to one of the seed values.
@item @var{f} maps each seed value to a character. These
characters are added to the base character set @var{base_cs} to
form the result; @var{base_cs} defaults to the empty set.
@end itemize
@end deffn

@deffn {Scheme Procedure} char-set-for-each proc cs
@deffnx {C Function} scm_char_set_for_each (proc, cs)
Apply @var{proc} to every character in the character set
@var{cs}.  The return value is not specified.
@end deffn

@deffn {Scheme Procedure} char-set-map proc cs
@deffnx {C Function} scm_char_set_map (proc, cs)
Map the procedure @var{proc} over every character in @var{cs}.
@var{proc} must be a character -> character procedure.
@end deffn

@c ===================================================================

@node Creating Character Sets
@subsubsection Creating Character Sets

С помощью этих процедур создаются новые наборы символов.

@deffn {Scheme Procedure} char-set-copy cs
@deffnx {C Function} scm_char_set_copy (cs)
Return a newly allocated character set containing all
characters in @var{cs}.
@end deffn

@deffn {Scheme Procedure} char-set chr @dots{}
@deffnx {C Function} scm_char_set (chrs)
Return a character set containing all given characters.
@end deffn

@deffn {Scheme Procedure} list->char-set list [base_cs]
@deffnx {C Function} scm_list_to_char_set (list, base_cs)
Convert the character list @var{list} to a character set.  If
the character set @var{base_cs} is given, the character in this
set are also included in the result.
@end deffn

@deffn {Scheme Procedure} list->char-set! list base_cs
@deffnx {C Function} scm_list_to_char_set_x (list, base_cs)
Convert the character list @var{list} to a character set.  The
characters are added to @var{base_cs} and @var{base_cs} is
returned.
@end deffn

@deffn {Scheme Procedure} string->char-set str [base_cs]
@deffnx {C Function} scm_string_to_char_set (str, base_cs)
Convert the string @var{str} to a character set.  If the
character set @var{base_cs} is given, the characters in this
set are also included in the result.
@end deffn

@deffn {Scheme Procedure} string->char-set! str base_cs
@deffnx {C Function} scm_string_to_char_set_x (str, base_cs)
Convert the string @var{str} to a character set.  The
characters from the string are added to @var{base_cs}, and
@var{base_cs} is returned.
@end deffn

@deffn {Scheme Procedure} char-set-filter pred cs [base_cs]
@deffnx {C Function} scm_char_set_filter (pred, cs, base_cs)
Return a character set containing every character from @var{cs}
so that it satisfies @var{pred}.  If provided, the characters
from @var{base_cs} are added to the result.
@end deffn

@deffn {Scheme Procedure} char-set-filter! pred cs base_cs
@deffnx {C Function} scm_char_set_filter_x (pred, cs, base_cs)
Return a character set containing every character from @var{cs}
so that it satisfies @var{pred}.  The characters are added to
@var{base_cs} and @var{base_cs} is returned.
@end deffn

@deffn {Scheme Procedure} ucs-range->char-set lower upper [error [base_cs]]
@deffnx {C Function} scm_ucs_range_to_char_set (lower, upper, error, base_cs)
Return a character set containing all characters whose
character codes lie in the half-open range
[@var{lower},@var{upper}).

If @var{error} is a true value, an error is signalled if the
specified range contains characters which are not contained in
the implemented character range.  If @var{error} is @code{#f},
these characters are silently left out of the resulting
character set.

The characters in @var{base_cs} are added to the result, if
given.
@end deffn

@deffn {Scheme Procedure} ucs-range->char-set! lower upper error base_cs
@deffnx {C Function} scm_ucs_range_to_char_set_x (lower, upper, error, base_cs)
Return a character set containing all characters whose
character codes lie in the half-open range
[@var{lower},@var{upper}).

If @var{error} is a true value, an error is signalled if the
specified range contains characters which are not contained in
the implemented character range.  If @var{error} is @code{#f},
these characters are silently left out of the resulting
character set.

The characters are added to @var{base_cs} and @var{base_cs} is
returned.
@end deffn

@deffn {Scheme Procedure} ->char-set x
@deffnx {C Function} scm_to_char_set (x)
Coerces x into a char-set. @var{x} may be a string, character or
char-set. A string is converted to the set of its constituent
characters; a character is converted to a singleton set; a char-set is
returned as-is.
@end deffn

@c ===================================================================

@node Querying Character Sets
@subsubsection Querying Character Sets

С помощью этих процедур осущетсвляется получение доступа к элементам и 
получение другой информации о наборе символов.

@deffn {Scheme Procedure} %char-set-dump cs
Returns an association list containing debugging information
for @var{cs}. The association list has the following entries.
@table @code
@item char-set
The char-set itself
@item len
The number of groups of contiguous code points the char-set
contains
@item ranges
A list of lists where each sublist is a range of code points
and their associated characters
@end table
The return value of this function cannot be relied upon to be
consistent between versions of Guile and should not be used in code.
@end deffn

@deffn {Scheme Procedure} char-set-size cs
@deffnx {C Function} scm_char_set_size (cs)
Return the number of elements in character set @var{cs}.
@end deffn

@deffn {Scheme Procedure} char-set-count pred cs
@deffnx {C Function} scm_char_set_count (pred, cs)
Return the number of the elements int the character set
@var{cs} which satisfy the predicate @var{pred}.
@end deffn

@deffn {Scheme Procedure} char-set->list cs
@deffnx {C Function} scm_char_set_to_list (cs)
Return a list containing the elements of the character set
@var{cs}.
@end deffn

@deffn {Scheme Procedure} char-set->string cs
@deffnx {C Function} scm_char_set_to_string (cs)
Return a string containing the elements of the character set
@var{cs}.  The order in which the characters are placed in the
string is not defined.
@end deffn

@deffn {Scheme Procedure} char-set-contains? cs ch
@deffnx {C Function} scm_char_set_contains_p (cs, ch)
Return @code{#t} if the character @var{ch} is contained in the
character set @var{cs}, or @code{#f} otherwise.
@end deffn

@deffn {Scheme Procedure} char-set-every pred cs
@deffnx {C Function} scm_char_set_every (pred, cs)
Return a true value if every character in the character set
@var{cs} satisfies the predicate @var{pred}.
@end deffn

@deffn {Scheme Procedure} char-set-any pred cs
@deffnx {C Function} scm_char_set_any (pred, cs)
Return a true value if any character in the character set
@var{cs} satisfies the predicate @var{pred}.
@end deffn

@c ===================================================================

@node Character-Set Algebra
@subsubsection Character-Set Algebra

Наборами символов можно манипулировать с помощью операций общей алгебры
множеств, таких как объединение, дополнения, пересечения и т.д. Все эти
процедуры имеют побочные эффекты, которые изменяют их аргумент(ы) - 
наборы символов.

@deffn {Scheme Procedure} char-set-adjoin cs chr @dots{}
@deffnx {C Function} scm_char_set_adjoin (cs, chrs)
Add all character arguments to the first argument, which must
be a character set.
@end deffn

@deffn {Scheme Procedure} char-set-delete cs chr @dots{}
@deffnx {C Function} scm_char_set_delete (cs, chrs)
Delete all character arguments from the first argument, which
must be a character set.
@end deffn

@deffn {Scheme Procedure} char-set-adjoin! cs chr @dots{}
@deffnx {C Function} scm_char_set_adjoin_x (cs, chrs)
Add all character arguments to the first argument, which must
be a character set.
@end deffn

@deffn {Scheme Procedure} char-set-delete! cs chr @dots{}
@deffnx {C Function} scm_char_set_delete_x (cs, chrs)
Delete all character arguments from the first argument, which
must be a character set.
@end deffn

@deffn {Scheme Procedure} char-set-complement cs
@deffnx {C Function} scm_char_set_complement (cs)
Return the complement of the character set @var{cs}.
@end deffn

Note that the complement of a character set is likely to contain many
reserved code points (code points that are not associated with
characters).  It may be helpful to modify the output of
@code{char-set-complement} by computing its intersection with the set
of designated code points, @code{char-set:designated}.

@deffn {Scheme Procedure} char-set-union cs @dots{}
@deffnx {C Function} scm_char_set_union (char_sets)
Return the union of all argument character sets.
@end deffn

@deffn {Scheme Procedure} char-set-intersection cs @dots{}
@deffnx {C Function} scm_char_set_intersection (char_sets)
Return the intersection of all argument character sets.
@end deffn

@deffn {Scheme Procedure} char-set-difference cs1 cs @dots{}
@deffnx {C Function} scm_char_set_difference (cs1, char_sets)
Return the difference of all argument character sets.
@end deffn

@deffn {Scheme Procedure} char-set-xor cs @dots{}
@deffnx {C Function} scm_char_set_xor (char_sets)
Return the exclusive-or of all argument character sets.
@end deffn

@deffn {Scheme Procedure} char-set-diff+intersection cs1 cs @dots{}
@deffnx {C Function} scm_char_set_diff_plus_intersection (cs1, char_sets)
Return the difference and the intersection of all argument
character sets.
@end deffn

@deffn {Scheme Procedure} char-set-complement! cs
@deffnx {C Function} scm_char_set_complement_x (cs)
Return the complement of the character set @var{cs}.
@end deffn

@deffn {Scheme Procedure} char-set-union! cs1 cs @dots{}
@deffnx {C Function} scm_char_set_union_x (cs1, char_sets)
Return the union of all argument character sets.
@end deffn

@deffn {Scheme Procedure} char-set-intersection! cs1 cs @dots{}
@deffnx {C Function} scm_char_set_intersection_x (cs1, char_sets)
Return the intersection of all argument character sets.
@end deffn

@deffn {Scheme Procedure} char-set-difference! cs1 cs @dots{}
@deffnx {C Function} scm_char_set_difference_x (cs1, char_sets)
Return the difference of all argument character sets.
@end deffn

@deffn {Scheme Procedure} char-set-xor! cs1 cs @dots{}
@deffnx {C Function} scm_char_set_xor_x (cs1, char_sets)
Return the exclusive-or of all argument character sets.
@end deffn

@deffn {Scheme Procedure} char-set-diff+intersection! cs1 cs2 cs @dots{}
@deffnx {C Function} scm_char_set_diff_plus_intersection_x (cs1, cs2, char_sets)
Return the difference and the intersection of all argument
character sets.
@end deffn

@c ===================================================================

@node Standard Character Sets
@subsubsection Standard Character Sets

Чтобы использовать тип данных и процедуры набора символов, существуют
предопределенные наборы символов.

@cindex codeset
@cindex charset
@cindex locale

Эти наборы символов независимы от локали и не пересчитываются при
вызове @code{setlocale}.  Они содержат символы из всего диапазона
кодовых точек Unicode. Например, @code{char-set:letter} содержит
около 100,000 символов.

@defvr {Scheme Variable} char-set:lower-case
@defvrx {C Variable} scm_char_set_lower_case
All lower-case characters.
@end defvr

@defvr {Scheme Variable} char-set:upper-case
@defvrx {C Variable} scm_char_set_upper_case
All upper-case characters.
@end defvr

@defvr {Scheme Variable} char-set:title-case
@defvrx {C Variable} scm_char_set_title_case
All single characters that function as if they were an upper-case
letter followed by a lower-case letter.
@end defvr

@defvr {Scheme Variable} char-set:letter
@defvrx {C Variable} scm_char_set_letter
All letters.  This includes @code{char-set:lower-case},
@code{char-set:upper-case}, @code{char-set:title-case}, and many
letters that have no case at all.  For example, Chinese and Japanese
characters typically have no concept of case.
@end defvr

@defvr {Scheme Variable} char-set:digit
@defvrx {C Variable} scm_char_set_digit
All digits.
@end defvr

@defvr {Scheme Variable} char-set:letter+digit
@defvrx {C Variable} scm_char_set_letter_and_digit
The union of @code{char-set:letter} and @code{char-set:digit}.
@end defvr

@defvr {Scheme Variable} char-set:graphic
@defvrx {C Variable} scm_char_set_graphic
All characters which would put ink on the paper.
@end defvr

@defvr {Scheme Variable} char-set:printing
@defvrx {C Variable} scm_char_set_printing
The union of @code{char-set:graphic} and @code{char-set:whitespace}.
@end defvr

@defvr {Scheme Variable} char-set:whitespace
@defvrx {C Variable} scm_char_set_whitespace
All whitespace characters.
@end defvr

@defvr {Scheme Variable} char-set:blank
@defvrx {C Variable} scm_char_set_blank
All horizontal whitespace characters, which notably includes
@code{#\space} and @code{#\tab}.
@end defvr

@defvr {Scheme Variable} char-set:iso-control
@defvrx {C Variable} scm_char_set_iso_control
The ISO control characters are the C0 control characters (U+0000 to
U+001F), delete (U+007F), and the C1 control characters (U+0080 to
U+009F).
@end defvr

@defvr {Scheme Variable} char-set:punctuation
@defvrx {C Variable} scm_char_set_punctuation
All punctuation characters, such as the characters
@code{!"#%&'()*,-./:;?@@[\\]_@{@}}
@end defvr

@defvr {Scheme Variable} char-set:symbol
@defvrx {C Variable} scm_char_set_symbol
All symbol characters, such as the characters @code{$+<=>^`|~}.
@end defvr

@defvr {Scheme Variable} char-set:hex-digit
@defvrx {C Variable} scm_char_set_hex_digit
The hexadecimal digits @code{0123456789abcdefABCDEF}.
@end defvr

@defvr {Scheme Variable} char-set:ascii
@defvrx {C Variable} scm_char_set_ascii
All ASCII characters.
@end defvr

@defvr {Scheme Variable} char-set:empty
@defvrx {C Variable} scm_char_set_empty
The empty character set.
@end defvr

@defvr {Scheme Variable} char-set:designated
@defvrx {C Variable} scm_char_set_designated
This character set contains all designated code points.  This includes
all the code points to which Unicode has assigned a character or other
meaning.
@end defvr

@defvr {Scheme Variable} char-set:full
@defvrx {C Variable} scm_char_set_full
This character set contains all possible code points.  This includes
both designated and reserved code points.
@end defvr

@node Strings
@subsection Strings
@tpindex Strings

Строки представляют собой последовательности символов фиксированной длины.
Они могут быть созданы путем вызова процедуры конструктора, но они так же 
могут непосредственно вводиться в REPL или размещаться в исходных файлах
Scheme.

@c Guile provides a rich set of string processing procedures, because text
@c handling is very important when Guile is used as a scripting language.

Строки всегда содержат информацию о том, сколько символов они содержат,
поэтому нет специального симовола конца строки, как например в Си. Это
означает, что Scheme строки могут содержать любой символ, даже 
@samp{#\nul}  @samp{\0}.

Чтобы эффективно использовать строки, вам нужно немного узнать о том,
как Guile их реализует. В Guile, строка состоит из двух частей, головы
и выделенной памяти, где фактически хранятся символы. Когда копируется
строка(или ее подстрока), создается только новый заголовок, память
обычно не копируется. Два заголовка начинают указывать на одну и туже
память.

Когда одна из этих двух строк изменяется, например вызовом @code{string-set!}
их общая память копируется так, что каждая строка получает свою копию
собственной памяти и модификация не может случайно изменить другие строки.
Таким образом, строки Guile являются "копируемыми при записи"; Настоящее
копирование их памяти задерживается до тех пор, пока не будет изменена какая
либо из строк.

Эта реализация делает такие функции, как @code{substring} очень
эффективными в общем случаее когда никаких изменений используемых
строк не производиться.

Если вы знаете, что ваши строки сразу изменяются, вы можете использовать
@code{substring/copy} вместо @code{substring}. Эта функция немедленно
выполняет копию во время создания подстроки. Это более эффективно, особенно
в многопоточной программе. Также @code{substring/copy} поможет избежать
проблемы, заключающейся в том, что короткая подстрока сохраняется в памяти
очень большой оригинальной строки, которую в противном случае можно было бы
повторно использовать.

Если вы хотите полностью отказаться от копирования, что бы изменения
одной строки отображались в другой, вы можете использовать функцию
@code{substring/shared}. Строки созданные процедурой, называются
изменяющимися разделяемыми строками, которые меняются при модификации
каждой из строк.

Если вы хотите предотвратить изменения, используйте вызов
@code{substring/read-only}.

Guile предоставляет все процедуры SRFI-13 и еще несколько.

@menu
* String Syntax::                   Read syntax for strings.
* String Predicates::               Testing strings for certain properties.
* String Constructors::             Creating new string objects.
* List/String Conversion::          Converting from/to lists of characters.
* String Selection::                Select portions from strings.
* String Modification::             Modify parts or whole strings.
* String Comparison::               Lexicographic ordering predicates.
* String Searching::                Searching in strings.
* Alphabetic Case Mapping::         Convert the alphabetic case of strings.
* Reversing and Appending Strings:: Appending strings to form a new string.
* Mapping Folding and Unfolding::   Iterating over strings.
* Miscellaneous String Operations:: Replicating, insertion, parsing, ...
* Representing Strings as Bytes::   Encoding and decoding strings.
* Conversion to/from C::
* String Internals::                The storage strategy for strings.
@end menu

@node String Syntax
@subsubsection String Read Syntax

@c  In the following @code is used to get a good font in TeX etc, but
@c  is omitted for Info format, so as not to risk any confusion over
@c  whether surrounding ` ' quotes are part of the escape or are
@c  special in a string (they're not).

Синтаксис чтения строк - это произвольно длинная последовательность
символов, заключенных в двойные кавычки(@nicode{"}).

Обратная косая черта это символ экранирования и может использоваться
для вставки следующих специальных символов. @nicode{\"} и @nicode{\\}
в соответсвии со стандартом R5RS, @nicode{\|} по стандарту R7RS,
следующие за ними 7 символов по стандарту R6RS --- обратите внимание
они следуют Си синтаксису, а остальные 4 --- Guile расширения.

@table @asis
@item @nicode{\\}
Backslash character.

@item @nicode{\"}
Double quote character (an unescaped @nicode{"} is otherwise the end
of the string).

@item @nicode{\|}
Vertical bar character.

@item @nicode{\a}
Bell character (ASCII 7).

@item @nicode{\f}
Formfeed character (ASCII 12).

@item @nicode{\n}
Newline character (ASCII 10).

@item @nicode{\r}
Carriage return character (ASCII 13).

@item @nicode{\t}
Tab character (ASCII 9).

@item @nicode{\v}
Vertical tab character (ASCII 11).

@item @nicode{\b}
Backspace character (ASCII 8).

@item @nicode{\0}
NUL character (ASCII 0).

@item @nicode{\(}
Открывающая скобка. Этот символ предназначен для использования в начале
строк в многострочной строке, чтобы избежать путаницы режимов в Emacs lisp.

@item @nicode{\} следует новая линия (ASCII 10)
Ничего.  Таким образом, если @nicode{\} это последний символ в строке,
строка будет продолжена с первым символом из следующей строки
без разрыва строки.


Если включен режим чтения @code{hungry-eol-escapes}, что не соотвествует
умолчанию, начальные пробелы на следующей строке отбрасываются.

@lisp
"foo\
  bar"
@result{} "foo  bar"
(read-enable 'hungry-eol-escapes)
"foo\
  bar"
@result{} "foobar"
@end lisp
@item @nicode{\xHH}
Character code given by two hexadecimal digits.  For example
@nicode{\x7f} for an ASCII DEL (127).

@item @nicode{\uHHHH}
Character code given by four hexadecimal digits.  For example
@nicode{\u0100} for a capital A with macron (U+0100).

@item @nicode{\UHHHHHH}
Character code given by six hexadecimal digits.  For example
@nicode{\U010402}.
@end table

@noindent
The following are examples of string literals:

@lisp
"foo"
"bar plonk"
"Hello World"
"\"Hi\", he said."
@end lisp

Три эскейп последовательности @code{\xHH}, @code{\uHHHH} и @code{\UHHHHHH} были
выбраны так, чтобы не нарушать совместимость с кодом, написанным для предыдущих
версий Guile.  Спецификация R6RS предлагает другой, несовместимый синтаксис для
экранирования шестнадцатеричных символов: @code{\xHHHH;} -- код символа, за которым
следуют от одной до восьми шестнадцатеричных цифр, заканчивающихся
точкой с запятой. Если вам надо использовать этот формат для функции чтения, его
можно включить с помощью опции @code{r6rs-hex-escapes}.

@lisp
(read-enable 'r6rs-hex-escapes)
@end lisp

For more on reader options, @xref{Scheme Read}.

@node String Predicates
@subsubsection Строковые Предикаты

Следующие процедуры могут использваться для проверки того, соответствует
ли данная строка некоторым определенным свойствам.

@rnindex string?
@deffn {Scheme Procedure} string? obj
@deffnx {C Function} scm_string_p (obj)
Return @code{#t} if @var{obj} is a string, else @code{#f}.
@end deffn

@deftypefn {C Function} int scm_is_string (SCM obj)
Returns @code{1} if @var{obj} is a string, @code{0} otherwise.
@end deftypefn

@deffn {Scheme Procedure} string-null? str
@deffnx {C Function} scm_string_null_p (str)
Return @code{#t} if @var{str}'s length is zero, and
@code{#f} otherwise.
@lisp
(string-null? "")  @result{} #t
y                    @result{} "foo"
(string-null? y)     @result{} #f
@end lisp
@end deffn

@deffn {Scheme Procedure} string-any char_pred s [start [end]]
@deffnx {C Function} scm_string_any (char_pred, s, start, end)
Check if @var{char_pred} is true for any character in string @var{s}.

@var{char_pred} can be a character to check for any equal to that, or
a character set (@pxref{Character Sets}) to check for any in that set,
or a predicate procedure to call.

For a procedure, calls @code{(@var{char_pred} c)} are made
successively on the characters from @var{start} to @var{end}.  If
@var{char_pred} returns true (ie.@: non-@code{#f}), @code{string-any}
stops and that return value is the return from @code{string-any}.  The
call on the last character (ie.@: at @math{@var{end}-1}), if that
point is reached, is a tail call.

If there are no characters in @var{s} (ie.@: @var{start} equals
@var{end}) then the return is @code{#f}.
@end deffn

@deffn {Scheme Procedure} string-every char_pred s [start [end]]
@deffnx {C Function} scm_string_every (char_pred, s, start, end)
Check if @var{char_pred} is true for every character in string
@var{s}.

@var{char_pred} can be a character to check for every character equal
to that, or a character set (@pxref{Character Sets}) to check for
every character being in that set, or a predicate procedure to call.

For a procedure, calls @code{(@var{char_pred} c)} are made
successively on the characters from @var{start} to @var{end}.  If
@var{char_pred} returns @code{#f}, @code{string-every} stops and
returns @code{#f}.  The call on the last character (ie.@: at
@math{@var{end}-1}), if that point is reached, is a tail call and the
return from that call is the return from @code{string-every}.

If there are no characters in @var{s} (ie.@: @var{start} equals
@var{end}) then the return is @code{#t}.
@end deffn

@node String Constructors
@subsubsection Конструкторы Строк

Процедуры создания строк создают новые строковые объекты, повозможности
инициализируя их некоторыми заданными символьными данными.  Смотри также
@xref{String Selection}, для ознакомления со способами создания строк
из существующих строк.

@c FIXME::martin: list->string belongs into `List/String Conversion'

@deffn {Scheme Procedure} string char@dots{}
@rnindex string
Return a newly allocated string made from the given character
arguments.

@example
(string #\x #\y #\z) @result{} "xyz"
(string)             @result{} ""
@end example
@end deffn

@deffn {Scheme Procedure} list->string lst
@deffnx {C Function} scm_string (lst)
@rnindex list->string
Return a newly allocated string made from a list of characters.

@example
(list->string '(#\a #\b #\c)) @result{} "abc"
@end example
@end deffn

@deffn {Scheme Procedure} reverse-list->string lst
@deffnx {C Function} scm_reverse_list_to_string (lst)
Return a newly allocated string made from a list of characters, in
reverse order.

@example
(reverse-list->string '(#\a #\B #\c)) @result{} "cBa"
@end example
@end deffn

@rnindex make-string
@deffn {Scheme Procedure} make-string k [chr]
@deffnx {C Function} scm_make_string (k, chr)
Return a newly allocated string of
length @var{k}.  If @var{chr} is given, then all elements of
the string are initialized to @var{chr}, otherwise the contents
of the string are unspecified.
@end deffn

@deftypefn {C Function} SCM scm_c_make_string (size_t len, SCM chr)
Like @code{scm_make_string}, but expects the length as a
@code{size_t}.
@end deftypefn

@deffn {Scheme Procedure} string-tabulate proc len
@deffnx {C Function} scm_string_tabulate (proc, len)
@var{proc} is an integer->char procedure.  Construct a string
of size @var{len} by applying @var{proc} to each index to
produce the corresponding string element.  The order in which
@var{proc} is applied to the indices is not specified.
@end deffn

@deffn {Scheme Procedure} string-join ls [delimiter [grammar]]
@deffnx {C Function} scm_string_join (ls, delimiter, grammar)
Append the string in the string list @var{ls}, using the string
@var{delimiter} as a delimiter between the elements of @var{ls}.
@var{grammar} is a symbol which specifies how the delimiter is
placed between the strings, and defaults to the symbol
@code{infix}.

@table @code
@item infix
Insert the separator between list elements.  An empty string
will produce an empty list.
@item strict-infix
Like @code{infix}, but will raise an error if given the empty
list.
@item suffix
Insert the separator after every list element.
@item prefix
Insert the separator before each list element.
@end table
@end deffn

@node List/String Conversion
@subsubsection Преобразование Список/Строка

При обработке строк часто бывает удобно сначала перобразовать их в 
представление списка с помощью процедуры @code{string->list},
работать с результирующим списком, а затем преобразовать его обратно
в строку. Эти процедуры полезны для подобных задач.

@rnindex string->list
@deffn {Scheme Procedure} string->list str [start [end]]
@deffnx {C Function} scm_substring_to_list (str, start, end)
@deffnx {C Function} scm_string_to_list (str)
Convert the string @var{str} into a list of characters.
@end deffn

@deffn {Scheme Procedure} string-split str char_pred
@deffnx {C Function} scm_string_split (str, char_pred)
Split the string @var{str} into a list of substrings delimited
by appearances of characters that

@itemize @bullet
@item
equal @var{char_pred}, if it is a character,

@item
satisfy the predicate @var{char_pred}, if it is a procedure,

@item
are in the set @var{char_pred}, if it is a character set.
@end itemize

Note that an empty substring between separator characters will result in
an empty string in the result list.

@lisp
(string-split "root:x:0:0:root:/root:/bin/bash" #\:)
@result{}
("root" "x" "0" "0" "root" "/root" "/bin/bash")

(string-split "::" #\:)
@result{}
("" "" "")

(string-split "" #\:)
@result{}
("")
@end lisp
@end deffn

@node String Selection
@subsubsection Строковые Селекторы

Этими процедурами могут быть извлечены части строк. 
@code{string-ref} предоставляет индивидуальне символы, в то время как
@code{substring} можно использовать для извлечения подстрок из более
длинных строк.

@rnindex string-length
@deffn {Scheme Procedure} string-length string
@deffnx {C Function} scm_string_length (string)
Return the number of characters in @var{string}.
@end deffn

@deftypefn {C Function} size_t scm_c_string_length (SCM str)
Return the number of characters in @var{str} as a @code{size_t}.
@end deftypefn

@rnindex string-ref
@deffn {Scheme Procedure} string-ref str k
@deffnx {C Function} scm_string_ref (str, k)
Return character @var{k} of @var{str} using zero-origin
indexing. @var{k} must be a valid index of @var{str}.
@end deffn

@deftypefn {C Function} SCM scm_c_string_ref (SCM str, size_t k)
Return character @var{k} of @var{str} using zero-origin
indexing. @var{k} must be a valid index of @var{str}.
@end deftypefn

@rnindex string-copy
@deffn {Scheme Procedure} string-copy str [start [end]]
@deffnx {C Function} scm_substring_copy (str, start, end)
@deffnx {C Function} scm_string_copy (str)
Return a copy of the given string @var{str}.

The returned string shares storage with @var{str} initially, but it is
copied as soon as one of the two strings is modified.
@end deffn

@rnindex substring
@deffn {Scheme Procedure} substring str start [end]
@deffnx {C Function} scm_substring (str, start, end)
Return a new string formed from the characters
of @var{str} beginning with index @var{start} (inclusive) and
ending with index @var{end} (exclusive).
@var{str} must be a string, @var{start} and @var{end} must be
exact integers satisfying:

0 <= @var{start} <= @var{end} <= @code{(string-length @var{str})}.

The returned string shares storage with @var{str} initially, but it is
copied as soon as one of the two strings is modified.
@end deffn

@deffn {Scheme Procedure} substring/shared str start [end]
@deffnx {C Function} scm_substring_shared (str, start, end)
Like @code{substring}, but the strings continue to share their storage
even if they are modified.  Thus, modifications to @var{str} show up
in the new string, and vice versa.
@end deffn

@deffn {Scheme Procedure} substring/copy str start [end]
@deffnx {C Function} scm_substring_copy (str, start, end)
Like @code{substring}, but the storage for the new string is copied
immediately.
@end deffn

@deffn {Scheme Procedure} substring/read-only str start [end]
@deffnx {C Function} scm_substring_read_only (str, start, end)
Like @code{substring}, but the resulting string can not be modified.
@end deffn

@deftypefn  {C Function} SCM scm_c_substring (SCM str, size_t start, size_t end)
@deftypefnx {C Function} SCM scm_c_substring_shared (SCM str, size_t start, size_t end)
@deftypefnx {C Function} SCM scm_c_substring_copy (SCM str, size_t start, size_t end)
@deftypefnx {C Function} SCM scm_c_substring_read_only (SCM str, size_t start, size_t end)
Like @code{scm_substring}, etc. but the bounds are given as a @code{size_t}.
@end deftypefn

@deffn {Scheme Procedure} string-take s n
@deffnx {C Function} scm_string_take (s, n)
Return the @var{n} first characters of @var{s}.
@end deffn

@deffn {Scheme Procedure} string-drop s n
@deffnx {C Function} scm_string_drop (s, n)
Return all but the first @var{n} characters of @var{s}.
@end deffn

@deffn {Scheme Procedure} string-take-right s n
@deffnx {C Function} scm_string_take_right (s, n)
Return the @var{n} last characters of @var{s}.
@end deffn

@deffn {Scheme Procedure} string-drop-right s n
@deffnx {C Function} scm_string_drop_right (s, n)
Return all but the last @var{n} characters of @var{s}.
@end deffn

@deffn {Scheme Procedure} string-pad s len [chr [start [end]]]
@deffnx {Scheme Procedure} string-pad-right s len [chr [start [end]]]
@deffnx {C Function} scm_string_pad (s, len, chr, start, end)
@deffnx {C Function} scm_string_pad_right (s, len, chr, start, end)
Take characters @var{start} to @var{end} from the string @var{s} and
either pad with @var{chr} or truncate them to give @var{len}
characters.

@code{string-pad} pads or truncates on the left, so for example

@example
(string-pad "x" 3)     @result{} "  x"
(string-pad "abcde" 3) @result{} "cde"
@end example

@code{string-pad-right} pads or truncates on the right, so for example

@example
(string-pad-right "x" 3)     @result{} "x  "
(string-pad-right "abcde" 3) @result{} "abc"
@end example
@end deffn

@deffn {Scheme Procedure} string-trim s [char_pred [start [end]]]
@deffnx {Scheme Procedure} string-trim-right s [char_pred [start [end]]]
@deffnx {Scheme Procedure} string-trim-both s [char_pred [start [end]]]
@deffnx {C Function} scm_string_trim (s, char_pred, start, end)
@deffnx {C Function} scm_string_trim_right (s, char_pred, start, end)
@deffnx {C Function} scm_string_trim_both (s, char_pred, start, end)
Trim occurrences of @var{char_pred} from the ends of @var{s}.

@code{string-trim} trims @var{char_pred} characters from the left
(start) of the string, @code{string-trim-right} trims them from the
right (end) of the string, @code{string-trim-both} trims from both
ends.

@var{char_pred} can be a character, a character set, or a predicate
procedure to call on each character.  If @var{char_pred} is not given
the default is whitespace as per @code{char-set:whitespace}
(@pxref{Standard Character Sets}).

@example
(string-trim " x ")              @result{} "x "
(string-trim-right "banana" #\a) @result{} "banan"
(string-trim-both ".,xy:;" char-set:punctuation)
                  @result{} "xy"
(string-trim-both "xyzzy" (lambda (c)
                             (or (eqv? c #\x)
                                 (eqv? c #\y))))
                  @result{} "zz"
@end example
@end deffn

@node String Modification
@subsubsection Модификация Строк

Эти процедуры предназначены для изменения строк на месте. Это означает, что
результат операции является не новой строкой; вместо этого изменяется 
представление памяти исходной строки.

@rnindex string-set!
@deffn {Scheme Procedure} string-set! str k chr
@deffnx {C Function} scm_string_set_x (str, k, chr)
Store @var{chr} in element @var{k} of @var{str} and return
an unspecified value. @var{k} must be a valid index of
@var{str}.
@end deffn

@deftypefn {C Function} void scm_c_string_set_x (SCM str, size_t k, SCM chr)
Like @code{scm_string_set_x}, but the index is given as a @code{size_t}.
@end deftypefn

@rnindex string-fill!
@deffn {Scheme Procedure} string-fill! str chr [start [end]]
@deffnx {C Function} scm_substring_fill_x (str, chr, start, end)
@deffnx {C Function} scm_string_fill_x (str, chr)
Stores @var{chr} in every element of the given @var{str} and
returns an unspecified value.
@end deffn

@deffn {Scheme Procedure} substring-fill! str start end fill
@deffnx {C Function} scm_substring_fill_x (str, start, end, fill)
Change every character in @var{str} between @var{start} and
@var{end} to @var{fill}.

@lisp
(define y (string-copy "abcdefg"))
(substring-fill! y 1 3 #\r)
y
@result{} "arrdefg"
@end lisp
@end deffn

@deffn {Scheme Procedure} substring-move! str1 start1 end1 str2 start2
@deffnx {C Function} scm_substring_move_x (str1, start1, end1, str2, start2)
Copy the substring of @var{str1} bounded by @var{start1} and @var{end1}
into @var{str2} beginning at position @var{start2}.
@var{str1} and @var{str2} can be the same string.
@end deffn

@deffn {Scheme Procedure} string-copy! target tstart s [start [end]]
@deffnx {C Function} scm_string_copy_x (target, tstart, s, start, end)
Copy the sequence of characters from index range [@var{start},
@var{end}) in string @var{s} to string @var{target}, beginning
at index @var{tstart}.  The characters are copied left-to-right
or right-to-left as needed -- the copy is guaranteed to work,
even if @var{target} and @var{s} are the same string.  It is an
error if the copy operation runs off the end of the target
string.
@end deffn

@node String Comparison
@subsubsection Сравнение строк

Процедуры в этом разделе аналогичны предиката используемым для сравнения
символов (@pxref{Characters}), но определены на последовательностях
символов.

Первый набор указан в R5RS и имеет имена, которые заканчиваются @code{?}.
Второй набор указан в SRFI-13 и его имена не заканчиваюься @code{?}.

Предикаты, заканчивающиеся на @code{-ci} игнорируют регистр символов
когда сравнивают строки.  На данный момент, сравнение без учета 
регистра выполняется с использованием правил R5RS, где каждый
строчный символ который имеет одну форму в верхнем регистре
преобразуется в верхний регистр перед сравнением.  См.
@xref{Text Collation, the @code{(ice-9 i18n)} module}, 
для сравнения строк, зависящих от локали.

@rnindex string=?
@deffn {Scheme Procedure} string=? s1 s2 s3 @dots{}
Lexicographic equality predicate; return @code{#t} if all strings are
the same length and contain the same characters in the same positions,
otherwise return @code{#f}.

The procedure @code{string-ci=?} treats upper and lower case
letters as though they were the same character, but
@code{string=?} treats upper and lower case as distinct
characters.
@end deffn

@rnindex string<?
@deffn {Scheme Procedure} string<? s1 s2 s3 @dots{}
Lexicographic ordering predicate; return @code{#t} if, for every pair of
consecutive string arguments @var{str_i} and @var{str_i+1}, @var{str_i} is
lexicographically less than @var{str_i+1}.
@end deffn

@rnindex string<=?
@deffn {Scheme Procedure} string<=? s1 s2 s3 @dots{}
Lexicographic ordering predicate; return @code{#t} if, for every pair of
consecutive string arguments @var{str_i} and @var{str_i+1}, @var{str_i} is
lexicographically less than or equal to @var{str_i+1}.
@end deffn

@rnindex string>?
@deffn {Scheme Procedure} string>? s1 s2 s3 @dots{}
Lexicographic ordering predicate; return @code{#t} if, for every pair of
consecutive string arguments @var{str_i} and @var{str_i+1}, @var{str_i} is
lexicographically greater than @var{str_i+1}.
@end deffn

@rnindex string>=?
@deffn {Scheme Procedure} string>=? s1 s2 s3 @dots{}
Lexicographic ordering predicate; return @code{#t} if, for every pair of
consecutive string arguments @var{str_i} and @var{str_i+1}, @var{str_i} is
lexicographically greater than or equal to @var{str_i+1}.
@end deffn

@rnindex string-ci=?
@deffn {Scheme Procedure} string-ci=? s1 s2 s3 @dots{}
Case-insensitive string equality predicate; return @code{#t} if
all strings are the same length and their component
characters match (ignoring case) at each position; otherwise
return @code{#f}.
@end deffn

@rnindex string-ci<?
@deffn {Scheme Procedure} string-ci<? s1 s2 s3 @dots{}
Case insensitive lexicographic ordering predicate; return @code{#t} if,
for every pair of consecutive string arguments @var{str_i} and
@var{str_i+1}, @var{str_i} is lexicographically less than @var{str_i+1}
regardless of case.
@end deffn

@rnindex string<=?
@deffn {Scheme Procedure} string-ci<=? s1 s2 s3 @dots{}
Case insensitive lexicographic ordering predicate; return @code{#t} if,
for every pair of consecutive string arguments @var{str_i} and
@var{str_i+1}, @var{str_i} is lexicographically less than or equal to
@var{str_i+1} regardless of case.
@end deffn

@rnindex string-ci>?
@deffn {Scheme Procedure} string-ci>? s1 s2 s3 @dots{}
Case insensitive lexicographic ordering predicate; return @code{#t} if,
for every pair of consecutive string arguments @var{str_i} and
@var{str_i+1}, @var{str_i} is lexicographically greater than
@var{str_i+1} regardless of case.
@end deffn

@rnindex string-ci>=?
@deffn {Scheme Procedure} string-ci>=? s1 s2 s3 @dots{}
Case insensitive lexicographic ordering predicate; return @code{#t} if,
for every pair of consecutive string arguments @var{str_i} and
@var{str_i+1}, @var{str_i} is lexicographically greater than or equal to
@var{str_i+1} regardless of case.
@end deffn

@deffn {Scheme Procedure} string-compare s1 s2 proc_lt proc_eq proc_gt [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_compare (s1, s2, proc_lt, proc_eq, proc_gt, start1, end1, start2, end2)
Apply @var{proc_lt}, @var{proc_eq}, @var{proc_gt} to the
mismatch index, depending upon whether @var{s1} is less than,
equal to, or greater than @var{s2}.  The mismatch index is the
largest index @var{i} such that for every 0 <= @var{j} <
@var{i}, @var{s1}[@var{j}] = @var{s2}[@var{j}] -- that is,
@var{i} is the first position that does not match.
@end deffn

@deffn {Scheme Procedure} string-compare-ci s1 s2 proc_lt proc_eq proc_gt [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_compare_ci (s1, s2, proc_lt, proc_eq, proc_gt, start1, end1, start2, end2)
Apply @var{proc_lt}, @var{proc_eq}, @var{proc_gt} to the
mismatch index, depending upon whether @var{s1} is less than,
equal to, or greater than @var{s2}.  The mismatch index is the
largest index @var{i} such that for every 0 <= @var{j} <
@var{i}, @var{s1}[@var{j}] = @var{s2}[@var{j}] -- that is,
@var{i} is the first position where the lowercased letters 
do not match.

@end deffn

@deffn {Scheme Procedure} string= s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_eq (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} and @var{s2} are not equal, a true
value otherwise.
@end deffn

@deffn {Scheme Procedure} string<> s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_neq (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} and @var{s2} are equal, a true
value otherwise.
@end deffn

@deffn {Scheme Procedure} string< s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_lt (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} is greater or equal to @var{s2}, a
true value otherwise.
@end deffn

@deffn {Scheme Procedure} string> s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_gt (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} is less or equal to @var{s2}, a
true value otherwise.
@end deffn

@deffn {Scheme Procedure} string<= s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_le (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} is greater to @var{s2}, a true
value otherwise.
@end deffn

@deffn {Scheme Procedure} string>= s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_ge (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} is less to @var{s2}, a true value
otherwise.
@end deffn

@deffn {Scheme Procedure} string-ci= s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_ci_eq (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} and @var{s2} are not equal, a true
value otherwise.  The character comparison is done
case-insensitively.
@end deffn

@deffn {Scheme Procedure} string-ci<> s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_ci_neq (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} and @var{s2} are equal, a true
value otherwise.  The character comparison is done
case-insensitively.
@end deffn

@deffn {Scheme Procedure} string-ci< s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_ci_lt (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} is greater or equal to @var{s2}, a
true value otherwise.  The character comparison is done
case-insensitively.
@end deffn

@deffn {Scheme Procedure} string-ci> s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_ci_gt (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} is less or equal to @var{s2}, a
true value otherwise.  The character comparison is done
case-insensitively.
@end deffn

@deffn {Scheme Procedure} string-ci<= s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_ci_le (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} is greater to @var{s2}, a true
value otherwise.  The character comparison is done
case-insensitively.
@end deffn

@deffn {Scheme Procedure} string-ci>= s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_ci_ge (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} is less to @var{s2}, a true value
otherwise.  The character comparison is done
case-insensitively.
@end deffn

@deffn {Scheme Procedure} string-hash s [bound [start [end]]]
@deffnx {C Function} scm_substring_hash (s, bound, start, end)
Compute a hash value for @var{s}.  The optional argument @var{bound} is a non-negative exact integer specifying the range of the hash function. A positive value restricts the return value to the range [0,bound).
@end deffn

@deffn {Scheme Procedure} string-hash-ci s [bound [start [end]]]
@deffnx {C Function} scm_substring_hash_ci (s, bound, start, end)
Compute a hash value for @var{s}.  The optional argument @var{bound} is a non-negative exact integer specifying the range of the hash function. A positive value restricts the return value to the range [0,bound).
@end deffn

Поскольку один и тот же визуальный вид абстрактного символа Unicode может
быть получен через несколько последовательностей символов Unicode, даже
при сравнении строк без учета регистра, функции
описанные вышеe, могут возвращать  @code{#f} когда представлены строки,
содержащие разные представления одного и того же символа.  Например,
символ Unicode ``LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE'' может
быть представлен одним символом (U+1E69) или символом ``LATIN
SMALL LETTER S'' (U+0073), за которым следует комбинирующие метки ``COMBINING 
DOT BELOW'' (U+0323) и ``COMBINING DOT ABOVE'' (U+0307).

По этой причине часто желательно обеспечить, чтобы сопоставляемые строки
использовали взаимно согласованное представление для каждого символа.
Стандарт Unicode  определяет два метода нормализации содержимого строк:
разложение, которое разбивает сотавные символы в набор составных символов
с упорядочением, определенным стандартом Unicode, и композицию, выполняющую
обратное преобразование.

Существуют две операции разложения. ``Каноническое разложение''
порождает последовательность символов, которые имеют тот же внешний
вид, что и исходные символы, тогда как ``Совместимое разложение''
производит такие последовательности, чьи визуальные отображения
могут отличаться от оригиналов, но которые представляют собой
абстрактный символ.

Эти операции инкапсулируются в следующем набор нормализационных форм:

@table @dfn
@item NFD
Символы разлагаются на их канонические формы.

@item NFKD
Символы разлагаются на их совместимые формы.

@item NFC
Символы разлагаются на их канонические формы, а затем объединяются

@item NFKC
Символы разлагаются на их совместимые формы, а затем объединяются

@end table

Приведенные ниже функции приводят аргументы в одну из описанных выше форм.

@deffn {Scheme Procedure} string-normalize-nfd s
@deffnx {C Function} scm_string_normalize_nfd (s)
Return the @code{NFD} normalized form of @var{s}.
@end deffn

@deffn {Scheme Procedure} string-normalize-nfkd s
@deffnx {C Function} scm_string_normalize_nfkd (s)
Return the @code{NFKD} normalized form of @var{s}.
@end deffn

@deffn {Scheme Procedure} string-normalize-nfc s
@deffnx {C Function} scm_string_normalize_nfc (s)
Return the @code{NFC} normalized form of @var{s}.
@end deffn

@deffn {Scheme Procedure} string-normalize-nfkc s
@deffnx {C Function} scm_string_normalize_nfkc (s)
Return the @code{NFKC} normalized form of @var{s}.
@end deffn

@node String Searching
@subsubsection Строковый Поиск

@deffn {Scheme Procedure} string-index s char_pred [start [end]]
@deffnx {C Function} scm_string_index (s, char_pred, start, end)
Search through the string @var{s} from left to right, returning
the index of the first occurrence of a character which

@itemize @bullet
@item
equals @var{char_pred}, if it is character,

@item
satisfies the predicate @var{char_pred}, if it is a procedure,

@item
is in the set @var{char_pred}, if it is a character set.
@end itemize

Return @code{#f} if no match is found.
@end deffn

@deffn {Scheme Procedure} string-rindex s char_pred [start [end]]
@deffnx {C Function} scm_string_rindex (s, char_pred, start, end)
Search through the string @var{s} from right to left, returning
the index of the last occurrence of a character which

@itemize @bullet
@item
equals @var{char_pred}, if it is character,

@item
satisfies the predicate @var{char_pred}, if it is a procedure,

@item
is in the set if @var{char_pred} is a character set.
@end itemize

Return @code{#f} if no match is found.
@end deffn

@deffn {Scheme Procedure} string-prefix-length s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_prefix_length (s1, s2, start1, end1, start2, end2)
Return the length of the longest common prefix of the two
strings.
@end deffn

@deffn {Scheme Procedure} string-prefix-length-ci s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_prefix_length_ci (s1, s2, start1, end1, start2, end2)
Return the length of the longest common prefix of the two
strings, ignoring character case.
@end deffn

@deffn {Scheme Procedure} string-suffix-length s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_suffix_length (s1, s2, start1, end1, start2, end2)
Return the length of the longest common suffix of the two
strings.
@end deffn

@deffn {Scheme Procedure} string-suffix-length-ci s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_suffix_length_ci (s1, s2, start1, end1, start2, end2)
Return the length of the longest common suffix of the two
strings, ignoring character case.
@end deffn

@deffn {Scheme Procedure} string-prefix? s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_prefix_p (s1, s2, start1, end1, start2, end2)
Is @var{s1} a prefix of @var{s2}?
@end deffn

@deffn {Scheme Procedure} string-prefix-ci? s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_prefix_ci_p (s1, s2, start1, end1, start2, end2)
Is @var{s1} a prefix of @var{s2}, ignoring character case?
@end deffn

@deffn {Scheme Procedure} string-suffix? s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_suffix_p (s1, s2, start1, end1, start2, end2)
Is @var{s1} a suffix of @var{s2}?
@end deffn

@deffn {Scheme Procedure} string-suffix-ci? s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_suffix_ci_p (s1, s2, start1, end1, start2, end2)
Is @var{s1} a suffix of @var{s2}, ignoring character case?
@end deffn

@deffn {Scheme Procedure} string-index-right s char_pred [start [end]]
@deffnx {C Function} scm_string_index_right (s, char_pred, start, end)
Search through the string @var{s} from right to left, returning
the index of the last occurrence of a character which

@itemize @bullet
@item
equals @var{char_pred}, if it is character,

@item
satisfies the predicate @var{char_pred}, if it is a procedure,

@item
is in the set if @var{char_pred} is a character set.
@end itemize

Return @code{#f} if no match is found.
@end deffn

@deffn {Scheme Procedure} string-skip s char_pred [start [end]]
@deffnx {C Function} scm_string_skip (s, char_pred, start, end)
Search through the string @var{s} from left to right, returning
the index of the first occurrence of a character which

@itemize @bullet
@item
does not equal @var{char_pred}, if it is character,

@item
does not satisfy the predicate @var{char_pred}, if it is a
procedure,

@item
is not in the set if @var{char_pred} is a character set.
@end itemize
@end deffn

@deffn {Scheme Procedure} string-skip-right s char_pred [start [end]]
@deffnx {C Function} scm_string_skip_right (s, char_pred, start, end)
Search through the string @var{s} from right to left, returning
the index of the last occurrence of a character which

@itemize @bullet
@item
does not equal @var{char_pred}, if it is character,

@item
does not satisfy the predicate @var{char_pred}, if it is a
procedure,

@item
is not in the set if @var{char_pred} is a character set.
@end itemize
@end deffn

@deffn {Scheme Procedure} string-count s char_pred [start [end]]
@deffnx {C Function} scm_string_count (s, char_pred, start, end)
Return the count of the number of characters in the string
@var{s} which

@itemize @bullet
@item
equals @var{char_pred}, if it is character,

@item
satisfies the predicate @var{char_pred}, if it is a procedure.

@item
is in the set @var{char_pred}, if it is a character set.
@end itemize
@end deffn

@deffn {Scheme Procedure} string-contains s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_contains (s1, s2, start1, end1, start2, end2)
Does string @var{s1} contain string @var{s2}?  Return the index
in @var{s1} where @var{s2} occurs as a substring, or false.
The optional start/end indices restrict the operation to the
indicated substrings.
@end deffn

@deffn {Scheme Procedure} string-contains-ci s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_contains_ci (s1, s2, start1, end1, start2, end2)
Does string @var{s1} contain string @var{s2}?  Return the index
in @var{s1} where @var{s2} occurs as a substring, or false.
The optional start/end indices restrict the operation to the
indicated substrings.  Character comparison is done
case-insensitively.
@end deffn

@node Alphabetic Case Mapping
@subsubsection Алфавитное Преобразование

Это процедуры дле преобразования строк в их эквиваленты в верхнем
или нижнем регистре, соотвественно, или для заглавных строк.

Они используют основные правила отображение регистров для символов
Unicode. Нет специального языка или рассматриваются контекстные
правила. Полученные строки будут гарантированно иметь ту же длину,
что и входные строки.

@xref{Character Case Mapping, the @code{(ice-9 i18n)} module}, 
для преобразований зависящих от локали.

@deffn {Scheme Procedure} string-upcase str [start [end]]
@deffnx {C Function} scm_substring_upcase (str, start, end)
@deffnx {C Function} scm_string_upcase (str)
Upcase every character in @code{str}.
@end deffn

@deffn {Scheme Procedure} string-upcase! str [start [end]]
@deffnx {C Function} scm_substring_upcase_x (str, start, end)
@deffnx {C Function} scm_string_upcase_x (str)
Destructively upcase every character in @code{str}.

@lisp
(string-upcase! y)
@result{} "ARRDEFG"
y
@result{} "ARRDEFG"
@end lisp
@end deffn

@deffn {Scheme Procedure} string-downcase str [start [end]]
@deffnx {C Function} scm_substring_downcase (str, start, end)
@deffnx {C Function} scm_string_downcase (str)
Downcase every character in @var{str}.
@end deffn

@deffn {Scheme Procedure} string-downcase! str [start [end]]
@deffnx {C Function} scm_substring_downcase_x (str, start, end)
@deffnx {C Function} scm_string_downcase_x (str)
Destructively downcase every character in @var{str}.

@lisp
y
@result{} "ARRDEFG"
(string-downcase! y)
@result{} "arrdefg"
y
@result{} "arrdefg"
@end lisp
@end deffn

@deffn {Scheme Procedure} string-capitalize str
@deffnx {C Function} scm_string_capitalize (str)
Return a freshly allocated string with the characters in
@var{str}, where the first character of every word is
capitalized.
@end deffn

@deffn {Scheme Procedure} string-capitalize! str
@deffnx {C Function} scm_string_capitalize_x (str)
Upcase the first character of every word in @var{str}
destructively and return @var{str}.

@lisp
y                      @result{} "hello world"
(string-capitalize! y) @result{} "Hello World"
y                      @result{} "Hello World"
@end lisp
@end deffn

@deffn {Scheme Procedure} string-titlecase str [start [end]]
@deffnx {C Function} scm_string_titlecase (str, start, end)
Titlecase every first character in a word in @var{str}.
@end deffn

@deffn {Scheme Procedure} string-titlecase! str [start [end]]
@deffnx {C Function} scm_string_titlecase_x (str, start, end)
Destructively titlecase every first character in a word in
@var{str}.
@end deffn

@node Reversing and Appending Strings
@subsubsection Поворот и Добавление Строк

@deffn {Scheme Procedure} string-reverse str [start [end]]
@deffnx {C Function} scm_string_reverse (str, start, end)
Reverse the string @var{str}.  The optional arguments
@var{start} and @var{end} delimit the region of @var{str} to
operate on.
@end deffn

@deffn {Scheme Procedure} string-reverse! str [start [end]]
@deffnx {C Function} scm_string_reverse_x (str, start, end)
Reverse the string @var{str} in-place.  The optional arguments
@var{start} and @var{end} delimit the region of @var{str} to
operate on.  The return value is unspecified.
@end deffn

@rnindex string-append
@deffn {Scheme Procedure} string-append arg @dots{}
@deffnx {C Function} scm_string_append (args)
Return a newly allocated string whose characters form the
concatenation of the given strings, @var{arg} @enddots{}.

@example
(let ((h "hello "))
  (string-append h "world"))
@result{} "hello world"
@end example
@end deffn

@deffn {Scheme Procedure} string-append/shared arg @dots{}
@deffnx {C Function} scm_string_append_shared (args)
Like @code{string-append}, but the result may share memory
with the argument strings.
@end deffn

@deffn {Scheme Procedure} string-concatenate ls
@deffnx {C Function} scm_string_concatenate (ls)
Append the elements (which must be strings) of @var{ls} together into a
single string.  Guaranteed to return a freshly allocated string.
@end deffn

@deffn {Scheme Procedure} string-concatenate-reverse ls [final_string [end]]
@deffnx {C Function} scm_string_concatenate_reverse (ls, final_string, end)
Without optional arguments, this procedure is equivalent to

@lisp
(string-concatenate (reverse ls))
@end lisp

If the optional argument @var{final_string} is specified, it is
consed onto the beginning to @var{ls} before performing the
list-reverse and string-concatenate operations.  If @var{end}
is given, only the characters of @var{final_string} up to index
@var{end} are used.

Guaranteed to return a freshly allocated string.
@end deffn

@deffn {Scheme Procedure} string-concatenate/shared ls
@deffnx {C Function} scm_string_concatenate_shared (ls)
Like @code{string-concatenate}, but the result may share memory
with the strings in the list @var{ls}.
@end deffn

@deffn {Scheme Procedure} string-concatenate-reverse/shared ls [final_string [end]]
@deffnx {C Function} scm_string_concatenate_reverse_shared (ls, final_string, end)
Like @code{string-concatenate-reverse}, but the result may
share memory with the strings in the @var{ls} arguments.
@end deffn

@node Mapping Folding and Unfolding
@subsubsection Отображение(Map), Сворачивание(Fold) и Разворачивание(Unfold) Строк

@deffn {Scheme Procedure} string-map proc s [start [end]]
@deffnx {C Function} scm_string_map (proc, s, start, end)
@var{proc} is a char->char procedure, it is mapped over
@var{s}.  The order in which the procedure is applied to the
string elements is not specified.
@end deffn

@deffn {Scheme Procedure} string-map! proc s [start [end]]
@deffnx {C Function} scm_string_map_x (proc, s, start, end)
@var{proc} is a char->char procedure, it is mapped over
@var{s}.  The order in which the procedure is applied to the
string elements is not specified.  The string @var{s} is
modified in-place, the return value is not specified.
@end deffn

@deffn {Scheme Procedure} string-for-each proc s [start [end]]
@deffnx {C Function} scm_string_for_each (proc, s, start, end)
@var{proc} is mapped over @var{s} in left-to-right order.  The
return value is not specified.
@end deffn

@deffn {Scheme Procedure} string-for-each-index proc s [start [end]]
@deffnx {C Function} scm_string_for_each_index (proc, s, start, end)
Call @code{(@var{proc} i)} for each index i in @var{s}, from left to
right.

For example, to change characters to alternately upper and lower case,

@example
(define str (string-copy "studly"))
(string-for-each-index
    (lambda (i)
      (string-set! str i
        ((if (even? i) char-upcase char-downcase)
         (string-ref str i))))
    str)
str @result{} "StUdLy"
@end example
@end deffn

@deffn {Scheme Procedure} string-fold kons knil s [start [end]]
@deffnx {C Function} scm_string_fold (kons, knil, s, start, end)
Fold @var{kons} over the characters of @var{s}, with @var{knil}
as the terminating element, from left to right.  @var{kons}
must expect two arguments: The actual character and the last
result of @var{kons}' application.
@end deffn

@deffn {Scheme Procedure} string-fold-right kons knil s [start [end]]
@deffnx {C Function} scm_string_fold_right (kons, knil, s, start, end)
Fold @var{kons} over the characters of @var{s}, with @var{knil}
as the terminating element, from right to left.  @var{kons}
must expect two arguments: The actual character and the last
result of @var{kons}' application.
@end deffn

@deffn {Scheme Procedure} string-unfold p f g seed [base [make_final]]
@deffnx {C Function} scm_string_unfold (p, f, g, seed, base, make_final)
@itemize @bullet
@item @var{g} is used to generate a series of @emph{seed}
values from the initial @var{seed}: @var{seed}, (@var{g}
@var{seed}), (@var{g}^2 @var{seed}), (@var{g}^3 @var{seed}),
@dots{}
@item @var{p} tells us when to stop -- when it returns true
when applied to one of these seed values.
@item @var{f} maps each seed value to the corresponding
character in the result string.  These chars are assembled
into the string in a left-to-right order.
@item @var{base} is the optional initial/leftmost portion
of the constructed string; it default to the empty
string.
@item @var{make_final} is applied to the terminal seed
value (on which @var{p} returns true) to produce
the final/rightmost portion of the constructed string.
The default is nothing extra.
@end itemize
@end deffn

@deffn {Scheme Procedure} string-unfold-right p f g seed [base [make_final]]
@deffnx {C Function} scm_string_unfold_right (p, f, g, seed, base, make_final)
@itemize @bullet
@item @var{g} is used to generate a series of @emph{seed}
values from the initial @var{seed}: @var{seed}, (@var{g}
@var{seed}), (@var{g}^2 @var{seed}), (@var{g}^3 @var{seed}),
@dots{}
@item @var{p} tells us when to stop -- when it returns true
when applied to one of these seed values.
@item @var{f} maps each seed value to the corresponding
character in the result string.  These chars are assembled
into the string in a right-to-left order.
@item @var{base} is the optional initial/rightmost portion
of the constructed string; it default to the empty
string.
@item @var{make_final} is applied to the terminal seed
value (on which @var{p} returns true) to produce
the final/leftmost portion of the constructed string.
It defaults to @code{(lambda (x) )}.
@end itemize
@end deffn

@node Miscellaneous String Operations
@subsubsection Различные строковые операции

@deffn {Scheme Procedure} xsubstring s from [to [start [end]]]
@deffnx {C Function} scm_xsubstring (s, from, to, start, end)
This is the @emph{extended substring} procedure that implements
replicated copying of a substring of some string.

@var{s} is a string, @var{start} and @var{end} are optional
arguments that demarcate a substring of @var{s}, defaulting to
0 and the length of @var{s}.  Replicate this substring up and
down index space, in both the positive and negative directions.
@code{xsubstring} returns the substring of this string
beginning at index @var{from}, and ending at @var{to}, which
defaults to @var{from} + (@var{end} - @var{start}).
@end deffn

@deffn {Scheme Procedure} string-xcopy! target tstart s sfrom [sto [start [end]]]
@deffnx {C Function} scm_string_xcopy_x (target, tstart, s, sfrom, sto, start, end)
Exactly the same as @code{xsubstring}, but the extracted text
is written into the string @var{target} starting at index
@var{tstart}.  The operation is not defined if @code{(eq?
@var{target} @var{s})} or these arguments share storage -- you
cannot copy a string on top of itself.
@end deffn

@deffn {Scheme Procedure} string-replace s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_replace (s1, s2, start1, end1, start2, end2)
Return the string @var{s1}, but with the characters
@var{start1} @dots{} @var{end1} replaced by the characters
@var{start2} @dots{} @var{end2} from @var{s2}.
@end deffn

@deffn {Scheme Procedure} string-tokenize s [token_set [start [end]]]
@deffnx {C Function} scm_string_tokenize (s, token_set, start, end)
Split the string @var{s} into a list of substrings, where each
substring is a maximal non-empty contiguous sequence of
characters from the character set @var{token_set}, which
defaults to @code{char-set:graphic}.
If @var{start} or @var{end} indices are provided, they restrict
@code{string-tokenize} to operating on the indicated substring
of @var{s}.
@end deffn

@deffn {Scheme Procedure} string-filter char_pred s [start [end]]
@deffnx {C Function} scm_string_filter (char_pred, s, start, end)
Filter the string @var{s}, retaining only those characters which
satisfy @var{char_pred}.

If @var{char_pred} is a procedure, it is applied to each character as
a predicate, if it is a character, it is tested for equality and if it
is a character set, it is tested for membership.
@end deffn

@deffn {Scheme Procedure} string-delete char_pred s [start [end]]
@deffnx {C Function} scm_string_delete (char_pred, s, start, end)
Delete characters satisfying @var{char_pred} from @var{s}.

If @var{char_pred} is a procedure, it is applied to each character as
a predicate, if it is a character, it is tested for equality and if it
is a character set, it is tested for membership.
@end deffn

@node Representing Strings as Bytes
@subsubsection Представление строк как байтов.

В холодном мире за пределами Guile не все строки обрабатываются одинаково.
Снаружи есть только байты, и существует много способов представления строк
(последовательностей символов) как двоичных данных (последовательностей
байтов).

Как пользователю, вам обычно не надо думать. Когда вы вводите, ваша
клавиатура, ваша система кодирует все ваши нажатия клавиш в виде
байтов в соответствии с языком, который вы настроили на своем 
компьютере. Guile использует локаль для декодирования этих байтов
назад в символы --- мы надеемся, в те же символы, что вы ввели.

Все становиться менее понятным при работе с системой с несколькими 
пользователями, например с веб-сервером. Ваш веб-сервер может получить
запрос от одного пользователя для данных закодированных в наборе символов
ISO-8859-1, а затем получить запрос от другого пользователя дя данных UTF-8.

@cindex iconv
@cindex character encoding
Guile предоставляет модуль @dfn{iconv} для преобразования строк и последовательностей
байтов.  @xref{Bytevectors}, для получения дополнительной информации о том как Guile
представляет собой байты исходной последовательности.  Этот модуль получил свое имя
от общей команды @sc{unix} с тем же именем.

Обратите внимание, что часто достаточно просто читать и писать
строки из портов вместо использования этой функции.  Для этого
укажите кодировку порта с помощью  @code{set-port-encoding!}.  
@xref{Ports}, еще больше о портаи и кодировках символов.

В отличие от остальных процедур в этом разделе вам нужно загрузить
модуль @code{iconv} перед доступом к этим процедурам:

@example
(use-modules (ice-9 iconv))
@end example

@deffn {Scheme Procedure} string->bytevector string encoding [conversion-strategy]
Encode @var{string} as a sequence of bytes.

The string will be encoded in the character set specified by the
@var{encoding} string.  If the string has characters that cannot be
represented in the encoding, by default this procedure raises an
@code{encoding-error}.  Pass a @var{conversion-strategy} argument to
specify other behaviors.

The return value is a bytevector.  @xref{Bytevectors}, for more on
bytevectors.  @xref{Ports}, for more on character encodings and
conversion strategies.
@end deffn

@deffn {Scheme Procedure} bytevector->string bytevector encoding [conversion-strategy]
Decode @var{bytevector} into a string.

The bytes will be decoded from the character set by the @var{encoding}
string.  If the bytes do not form a valid encoding, by default this
procedure raises an @code{decoding-error}.  As with
@code{string->bytevector}, pass the optional @var{conversion-strategy}
argument to modify this behavior.  @xref{Ports}, for more on character
encodings and conversion strategies.
@end deffn

@deffn {Scheme Procedure} call-with-output-encoded-string encoding proc [conversion-strategy]
Like @code{call-with-output-string}, but instead of returning a string,
returns a encoding of the string according to @var{encoding}, as a
bytevector.  This procedure can be more efficient than collecting a
string and then converting it via @code{string->bytevector}.
@end deffn

@node Conversion to/from C
@subsubsection Преобразование в/из Си

При создании строки Scheme из строки Си или при перобразовании строки 
Scheme в строку Си, концепция кодирования символов становиться важной.

В Си строка представляет собой всего лишь последовательность байтов, а
кодировка символов описывает отношение между этими байтами и фактическми
символами, которые составляют сторку. Для строк Scheme, кодировка символов
не является проблемой (в основном), так как на Scheme вы обычно используете
строки как последовательности символов, а не как последовательности байтов.

Преобразование в Си И преобразование из Си имеют свои проблемы.

При преобразовании из Си в Scheme важно, чтобы последовательность байтов
в строке Си была действительной впо отношению к ее кодированию. Например,
стороки  ASCII не могут иметь байтов превышающих значение 127.  Байт ASCII
превышающий 127 считается  @emph{плохо сформированным} и не может 
преобразовываться в символы Scheme.

Проблемы могут возникнуть и при обратном преобразовании. Не все кодировки
символов могут содержать все возможные символы Scheme. Например, некоторые
кодировки, наприер ASCII, могут описать небольшое подмножество всех возможных
символов. Итак, при преобразовании в Си сначала необходимо решить, что
деалть с символами Scheme, которые не могут быть представлены в строке Си.

Преобразуя стороку Scheme в строку Си часто выделяют свежую память
 для хранения результата. Вы должны позаботиться о том, что бы эта
память была освобождена должным образом. Во многих случаях, это
может быть сделано с помощью искользования @code{scm_dynwind_free}
в соответствующем контексте dynwind, @xref{Dynamic Wind}.

@deftypefn  {C Function} SCM scm_from_locale_string (const char *str)
@deftypefnx {C Function} SCM scm_from_locale_stringn (const char *str, size_t len)
Creates a new Scheme string that has the same contents as @var{str} when
interpreted in the character encoding of the current locale.

For @code{scm_from_locale_string}, @var{str} must be null-terminated.

For @code{scm_from_locale_stringn}, @var{len} specifies the length of
@var{str} in bytes, and @var{str} does not need to be null-terminated.
If @var{len} is @code{(size_t)-1}, then @var{str} does need to be
null-terminated and the real length will be found with @code{strlen}.

If the C string is ill-formed, an error will be raised.

Note that these functions should @emph{not} be used to convert C string
constants, because there is no guarantee that the current locale will
match that of the execution character set, used for string and character
constants.  Most modern C compilers use UTF-8 by default, so to convert
C string constants we recommend @code{scm_from_utf8_string}.
@end deftypefn

@deftypefn  {C Function} SCM scm_take_locale_string (char *str)
@deftypefnx {C Function} SCM scm_take_locale_stringn (char *str, size_t len)
Like @code{scm_from_locale_string} and @code{scm_from_locale_stringn},
respectively, but also frees @var{str} with @code{free} eventually.
Thus, you can use this function when you would free @var{str} anyway
immediately after creating the Scheme string.  In certain cases, Guile
can then use @var{str} directly as its internal representation.
@end deftypefn

@deftypefn  {C Function} {char *} scm_to_locale_string (SCM str)
@deftypefnx {C Function} {char *} scm_to_locale_stringn (SCM str, size_t *lenp)
Returns a C string with the same contents as @var{str} in the character
encoding of the current locale.  The C string must be freed with
@code{free} eventually, maybe by using @code{scm_dynwind_free},
@xref{Dynamic Wind}.

For @code{scm_to_locale_string}, the returned string is
null-terminated and an error is signalled when @var{str} contains
@code{#\nul} characters.

For @code{scm_to_locale_stringn} and @var{lenp} not @code{NULL},
@var{str} might contain @code{#\nul} characters and the length of the
returned string in bytes is stored in @code{*@var{lenp}}.  The
returned string will not be null-terminated in this case.  If
@var{lenp} is @code{NULL}, @code{scm_to_locale_stringn} behaves like
@code{scm_to_locale_string}.

If a character in @var{str} cannot be represented in the character
encoding of the current locale, the default port conversion strategy is
used.  @xref{Ports}, for more on conversion strategies.

If the conversion strategy is @code{error}, an error will be raised.  If
it is @code{substitute}, a replacement character, such as a question
mark, will be inserted in its place.  If it is @code{escape}, a hex
escape will be inserted in its place.
@end deftypefn

@deftypefn {C Function} size_t scm_to_locale_stringbuf (SCM str, char *buf, size_t max_len)
Puts @var{str} as a C string in the current locale encoding into the
memory pointed to by @var{buf}.  The buffer at @var{buf} has room for
@var{max_len} bytes and @code{scm_to_local_stringbuf} will never store
more than that.  No terminating @code{'\0'} will be stored.

The return value of @code{scm_to_locale_stringbuf} is the number of
bytes that are needed for all of @var{str}, regardless of whether
@var{buf} was large enough to hold them.  Thus, when the return value
is larger than @var{max_len}, only @var{max_len} bytes have been
stored and you probably need to try again with a larger buffer.
@end deftypefn

For most situations, string conversion should occur using the current
locale, such as with the functions above.  But there may be cases where
one wants to convert strings from a character encoding other than the
locale's character encoding.  For these cases, the lower-level functions
@code{scm_to_stringn} and @code{scm_from_stringn} are provided.  These
functions should seldom be necessary if one is properly using locales.

@deftp {C Type} scm_t_string_failed_conversion_handler
This is an enumerated type that can take one of three values:
@code{SCM_FAILED_CONVERSION_ERROR},
@code{SCM_FAILED_CONVERSION_QUESTION_MARK}, and
@code{SCM_FAILED_CONVERSION_ESCAPE_SEQUENCE}.  They are used to indicate
a strategy for handling characters that cannot be converted to or from a
given character encoding.  @code{SCM_FAILED_CONVERSION_ERROR} indicates
that a conversion should throw an error if some characters cannot be
converted.  @code{SCM_FAILED_CONVERSION_QUESTION_MARK} indicates that a
conversion should replace unconvertable characters with the question
mark character.  And, @code{SCM_FAILED_CONVERSION_ESCAPE_SEQUENCE}
requests that a conversion should replace an unconvertable character
with an escape sequence.

While all three strategies apply when converting Scheme strings to C,
only @code{SCM_FAILED_CONVERSION_ERROR} and
@code{SCM_FAILED_CONVERSION_QUESTION_MARK} can be used when converting C
strings to Scheme.
@end deftp

@deftypefn {C Function} char *scm_to_stringn (SCM str, size_t *lenp, const char *encoding, scm_t_string_failed_conversion_handler handler)
This function returns a newly allocated C string from the Guile string
@var{str}.  The length of the returned string in bytes will be returned in
@var{lenp}.  The character encoding of the C string is passed as the ASCII,
null-terminated C string @var{encoding}.  The @var{handler} parameter
gives a strategy for dealing with characters that cannot be converted
into @var{encoding}.

If @var{lenp} is @code{NULL}, this function will return a null-terminated C
string.  It will throw an error if the string contains a null
character.

The Scheme interface to this function is @code{string->bytevector}, from the
@code{ice-9 iconv} module.  @xref{Representing Strings as Bytes}.
@end deftypefn

@deftypefn {C Function} SCM scm_from_stringn (const char *str, size_t len, const char *encoding, scm_t_string_failed_conversion_handler handler)
This function returns a scheme string from the C string @var{str}.  The
length in bytes of the C string is input as @var{len}.  The encoding of the C
string is passed as the ASCII, null-terminated C string @code{encoding}.
The @var{handler} parameters suggests a strategy for dealing with
unconvertable characters.

The Scheme interface to this function is @code{bytevector->string}.
@xref{Representing Strings as Bytes}.
@end deftypefn

The following conversion functions are provided as a convenience for the
most commonly used encodings.

@deftypefn {C Function} SCM scm_from_latin1_string (const char *str)
@deftypefnx {C Function} SCM scm_from_utf8_string (const char *str)
@deftypefnx {C Function} SCM scm_from_utf32_string (const scm_t_wchar *str)
Return a scheme string from the null-terminated C string @var{str},
which is ISO-8859-1-, UTF-8-, or UTF-32-encoded.  These functions should
be used to convert hard-coded C string constants into Scheme strings.
@end deftypefn

@deftypefn {C Function} SCM scm_from_latin1_stringn (const char *str, size_t len)
@deftypefnx {C Function} SCM scm_from_utf8_stringn (const char *str, size_t len)
@deftypefnx {C Function} SCM scm_from_utf32_stringn (const scm_t_wchar *str, size_t len)
Return a scheme string from C string @var{str}, which is ISO-8859-1-,
UTF-8-, or UTF-32-encoded, of length @var{len}.  @var{len} is the number
of bytes pointed to by @var{str} for @code{scm_from_latin1_stringn} and
@code{scm_from_utf8_stringn}; it is the number of elements (code points)
in @var{str} in the case of @code{scm_from_utf32_stringn}.
@end deftypefn

@deftypefn {C function} char *scm_to_latin1_stringn (SCM str, size_t *lenp)
@deftypefnx {C function} char *scm_to_utf8_stringn (SCM str, size_t *lenp)
@deftypefnx {C function} scm_t_wchar *scm_to_utf32_stringn (SCM str, size_t *lenp)
Return a newly allocated, ISO-8859-1-, UTF-8-, or UTF-32-encoded C string
from Scheme string @var{str}.  An error is thrown when @var{str}
cannot be converted to the specified encoding.  If @var{lenp} is
@code{NULL}, the returned C string will be null terminated, and an error
will be thrown if the C string would otherwise contain null
characters.  If @var{lenp} is not @code{NULL}, the string is not null terminated,
and the length of the returned string is returned in @var{lenp}.  The length
returned is the number of bytes for @code{scm_to_latin1_stringn} and
@code{scm_to_utf8_stringn}; it is the number of elements (code points)
for @code{scm_to_utf32_stringn}.
@end deftypefn

It is not often the case, but sometimes when you are dealing with the
implementation details of a port, you need to encode and decode strings
according to the encoding and conversion strategy of the port.  There
are some convenience functions for that purpose as well.

@deftypefn {C Function} SCM scm_from_port_string (const char *str, SCM port)
@deftypefnx {C Function} SCM scm_from_port_stringn (const char *str, size_t len, SCM port)
@deftypefnx {C Function} char* scm_to_port_string (SCM str, SCM port)
@deftypefnx {C Function} char* scm_to_port_stringn (SCM str, size_t *lenp, SCM port)
Like @code{scm_from_stringn} and friends, except they take their
encoding and conversion strategy from a given port object.
@end deftypefn

@node String Internals
@subsubsection Внутренности строки

Guile хранит каждую строку в памяти как непрерывный массив кодовых
точек Unicode связанных с набором атрибутов. Если все кодовые точки
имеют целочисленный диапазон от 0 до 255 включительно, массив кодовых
точек храниться как один байт на кодовую точку: такое сохранение является
строкой в коде ISO-8859-1 (т.е Latin-1).  Если какая-либо из кодовых
точек стороки имеет целочисленное значение больше 255, мвссив кодовых
точек храниться как четыре байта на кодовую точку: он сохраняется
как строка UTF-32.

Преобразование между представлениями в один байт на код и четыре
байта на кодовую точку происходит автоматически по мере необходимости.

API для установки внутреннего представления строк не предоставляется,
однако существуют две процедуры для доступа к ней. Это процедуры
отладки. Использовать их в рабочем коде крайне не рекомендуется,
так как детали внутреннего представления строк Guile могут измениться
в последующих выпусках.

@deffn {Scheme Procedure} string-bytes-per-char str
@deffnx {C Function} scm_string_bytes_per_char (str)
Return the number of bytes used to encode a Unicode code point in string
@var{str}.  The result is one or four.
@end deffn

@deffn {Scheme Procedure} %string-dump str
@deffnx {C Function} scm_sys_string_dump (str)
Returns an association list containing debugging information for
@var{str}. The association list has the following entries.
@table @code

@item string
The string itself.

@item start
The start index of the string into its stringbuf

@item length
The length of the string

@item shared
If this string is a substring, it returns its
parent string.  Otherwise, it returns @code{#f}

@item read-only
@code{#t} if the string is read-only

@item stringbuf-chars
A new string containing this string's stringbuf's characters

@item stringbuf-length
The number of characters in this stringbuf

@item stringbuf-shared
@code{#t} if this stringbuf is shared

@item stringbuf-wide
@code{#t} if this stringbuf's characters are stored in a 32-bit buffer,
or @code{#f} if they are stored in an 8-bit buffer
@end table
@end deffn

@node Symbols
@subsection Символы
@tpindex Symbols

Символы в Scheme широко используются тремя способами: как элементы
дискретных данных, как ключи для поиска в ассоциативных списках alist
и хеш-таблиц, а также для обозначения ссылок на переменные.

@dfn{Символ} похож на строку, поскольку она определяется последовательностью
символов. Последовательность символов называется @dfn{Именем} символа.
В обычном случае, т.е когда имя символа не содержит букв, которые можно
было бы спутать с другими элементами синтаксиса Scheme --- символ
записывается в программе Scheme последовательностью букв(цифр и др. символов),
которые составляют  имя, @emph{без кавычек} или какого другого специального
синтаксиса.  Например, символ имя которого ``multiply-by-2'' записывается,
просто:

@lisp
multiply-by-2
@end lisp

Обратите внимание, что объявление отличается от @emph{строки} с содержимым
``multiply-by-2'', которое записано с двойными кавычками, например:

@lisp
"multiply-by-2"
@end lisp

Выходя за рамки того, как они описаны, символы отличаются от строк в двух
важных отношениях.

Первым важным отличием является уникальность. Если однотипная строка
читается дважды в двух разных местах программы, результатом будут
два разных строковых объекта, содержимое которых будет одно и тоже.
Если, с другой стороны, один и тот же символ читается дважды из двух
разных мест программы, результат будет один и тот же символьный объект.

Получив два прочитанных символа, вы можете использовать @code{eq?}
для проверки их идентичности (т.е имеют ли они одно и тоже имя).
Оператор @code{eq?} является наиболее эффективным оператором
сравнения в Scheme, и сравнивает два таких символа так же быстро
как сравнивают, например числа.  Получая две строки, с другой
стороны, вы должны использовать оператор @code{equal?} или
@code{string=?}, которые значительно медленне оператора eq,
что бы определить имеют строки одно и тоже содержимое.

@lisp
(define sym1 (quote hello))
(define sym2 (quote hello))
(eq? sym1 sym2) @result{} #t

(define str1 "hello")
(define str2 "hello")
(eq? str1 str2) @result{} #f
(equal? str1 str2) @result{} #t
@end lisp

Второе важное отличие состоит в том, что символы, в отличие от строк,
не являются самовычисляемыми объектами.  Вот почему нам нужена операция
@code{(quote @dots{})}s в примере выше: @code{(quote hello)} блокирует
вычисление символа с именем "hello", тогда как бескавычек @code{hello}
@emph{читается} как символ с именем "hello" и вычисляется как ссылка
на переменную @dots{} о чем мы расскажем ниже (@pxref{Symbol Variables}).

@menu
* Symbol Data::                 Symbols as discrete data.
* Symbol Keys::                 Symbols as lookup keys.
* Symbol Variables::            Symbols as denoting variables.
* Symbol Primitives::           Operations related to symbols.
* Symbol Props::                Function slots and property lists.
* Symbol Read Syntax::          Extended read syntax for symbols.
* Symbol Uninterned::           Uninterned symbols.
@end menu

@node Symbol Data
@subsubsection Символ как дискретные данные

Числа и символы сходны в том отношении, что оба типа поддаются
сравнению с помощью  @code{eq?}.  Но символы более наглядны,
чем цифры, поэтому имя символа может использоваться непосредственно
для описания концепции, для которой используется этот символ.

Например, представьте, что вам нужно представить несколько цветов
в компьютерной программе. Используя числа, вы должны выбрать
произвольно некоторое сопоставление между числами и цветом, а затем
позаботиться о том, чтобы использовать это сопоставление корректно.

@lisp
;; 1=red, 2=green, 3=purple

(if (eq? (colour-of vehicle) 1)
    ...)
@end lisp

@noindent
Вы можете сделать это сопоставление более явным, а код более читабельным,
определяя константы:

@lisp
(define red 1)
(define green 2)
(define purple 3)

(if (eq? (colour-of vehicle) red)
    ...)
@end lisp

@noindent
Но самый простой и ясный подход - не испоьзовать числа вообще, а только
символы, чьи имена определяют цвета, на которые они ссылаются:

@lisp
(if (eq? (colour-of vehicle) 'red)
    ...)
@end lisp

Описательные преимущества символов над числами возрастают как набор
понятий, которые вы хотите описать. Предположим, что объект автомобиль,
может иметь и другие свойтсва, например имеет или использует:

@itemize @bullet
@item
automatic or manual transmission
@item
leaded or unleaded fuel
@item
power steering (or not).
@end itemize

@noindent
Тогда совокупный набор свойств автомобиля может быть представлен
естественным образом и управляться как список символов:

@lisp
(properties-of vehicle1)
@result{}
(red manual unleaded power-steering)

(if (memq 'power-steering (properties-of vehicle1))
    (display "Unfit people can drive this vehicle.\n")
    (display "You'll need strong arms to drive this vehicle!\n"))
@print{}
Unfit people can drive this vehicle.
@end lisp

Запомните, что основное свойство символов, на которое мы полагаеся, 
состоит в том что появление @code{'red} в одной части программы
является неотличимым символом от появления @code{'red} в другой
части программы; это означает, что символы можно эффективно
сравнивать с использованием @code{eq?}.  В то же время символы
имеют естественные описательные имена.  Это сочетание эффективности
и описательной мощи делает их идельными для использования в качестве
дискретных данных.

@node Symbol Keys
@subsubsection Символы как Ключи Поиска

Учитывая их эффективность и описательную силу, естественно использовать
символы в качестве ключей в ассоциативном списке или хеш-таблицах.

Чтобы проилюстрировать это, рассмотрим более структурированное представление
свойств автомобиля из предыдущего подраздела. Вместо того, чтобы смешивать
все свойства вместе в простом списке, мы могли бы использовать ассоциативный
список следующим образом:

@lisp
(define car1-properties '((colour . red)
                          (transmission . manual)
                          (fuel . unleaded)
                          (steering . power-assisted)))
@end lisp

Обратите внимание, что эта структура более ясная и расширяемая, чем
плоский список. Например он ясно показывает, что ручное относиться к
передаче, а не к окнам или блокировке автомобиля. Он также позволяет
другим свойствам использовать одни и те же символы среди своих возможных
значений, не становясь двусмысленными.

@lisp
(define car1-properties '((colour . red)
                          (transmission . manual)
                          (fuel . unleaded)
                          (steering . power-assisted)
                          (seat-colour . red)
                          (locking . manual)))
@end lisp

С таким представлением легко использовать эффективное семейство
процедур @code{assq-XXX} из списка операций с ассоцированными
списками (@pxref{Association Lists}) для извлечения или
изменения отдельных фрагментов информации:

@lisp
(assq-ref car1-properties 'fuel) @result{} unleaded
(assq-ref car1-properties 'transmission) @result{} manual

(assq-set! car1-properties 'seat-colour 'black)
@result{}
((colour . red)
 (transmission . manual)
 (fuel . unleaded)
 (steering . power-assisted)
 (seat-colour . black)
 (locking . manual)))
@end lisp

Хеш-таблицы также имеют ключи, и точно такие же аргументы применяются при
использовании символов в хеш-таблицах, как и в ассоциативных списках. 
Хэш-значение, которое использует Guile, чтобы решить, где добавить запись
в виде символа в хеш-таблицу, можно получить, вызвав процедуру @code{symbol-hash}


@deffn {Scheme Procedure} symbol-hash symbol
@deffnx {C Function} scm_symbol_hash (symbol)
Return a hash value for @var{symbol}.
@end deffn

Смотри @ref{Hash Tables} для получения информации о хеш-таблицах  и почему
лучше использовать хеш-таблицу, а не ассоциированный список.

@node Symbol Variables
@subsubsection Символы, обозначающие Переменные

Когда вычисляется неквотируемый символ в пограмме  Scheme, он 
интерпретируется как ссылка на переменную, а результат вычисления
--- значение соответствующей переменной.


Например, когда выражение @code{(string-length "abcd")} считывается и
вычисляется, последовательность символов @code{string-length} считывается
как символ, имя которого "string-length".  Этот символ связан с переменной,
значением которой является процедура, которая выполняет вычисление
длины стоки.  Поэтому вычисление @code{string-length} приводит к выполнению
этой процедуры.

Детали объединения символа без кавычек и переменной, отностися к другому
разделу. Смотри @ref{Binding Constructs}, для ознакомления как создаются
ассоциации между символами и переменными, и раздел @ref{Modules}, для
ознакомления как эти ассоциации влияют на модульную систему Guile.

@node Symbol Primitives
@subsubsection Операции связанные с символами

В любой Scheme, вы можете определить, является ли некий объект символом
используя примитив @code{symbol?}:

@rnindex symbol?
@deffn {Scheme Procedure} symbol? obj
@deffnx {C Function} scm_symbol_p (obj)
Return @code{#t} if @var{obj} is a symbol, otherwise return
@code{#f}.
@end deffn

@deftypefn {C Function} int scm_is_symbol (SCM val)
Equivalent to @code{scm_is_true (scm_symbol_p (val))}.
@end deftypefn

Once you know that you have a symbol, you can obtain its name as a
string by calling @code{symbol->string}.  Note that Guile differs by
default from R5RS on the details of @code{symbol->string} as regards
case-sensitivity:

@rnindex symbol->string
@deffn {Scheme Procedure} symbol->string s
@deffnx {C Function} scm_symbol_to_string (s)
Return the name of symbol @var{s} as a string.  By default, Guile reads
symbols case-sensitively, so the string returned will have the same case
variation as the sequence of characters that caused @var{s} to be
created.

If Guile is set to read symbols case-insensitively (as specified by
R5RS), and @var{s} comes into being as part of a literal expression
(@pxref{Literal expressions,,,r5rs, The Revised^5 Report on Scheme}) or
by a call to the @code{read} or @code{string-ci->symbol} procedures,
Guile converts any alphabetic characters in the symbol's name to
lower case before creating the symbol object, so the string returned
here will be in lower case.

If @var{s} was created by @code{string->symbol}, the case of characters
in the string returned will be the same as that in the string that was
passed to @code{string->symbol}, regardless of Guile's case-sensitivity
setting at the time @var{s} was created.

It is an error to apply mutation procedures like @code{string-set!} to
strings returned by this procedure.
@end deffn

Most symbols are created by writing them literally in code.  However it
is also possible to create symbols programmatically using the following
procedures:

@deffn {Scheme Procedure} symbol char@dots{}
@rnindex symbol
Return a newly allocated symbol made from the given character arguments.

@example
(symbol #\x #\y #\z) @result{} xyz
@end example
@end deffn

@deffn {Scheme Procedure} list->symbol lst
@rnindex list->symbol
Return a newly allocated symbol made from a list of characters.

@example
(list->symbol '(#\a #\b #\c)) @result{} abc
@end example
@end deffn

@rnindex symbol-append
@deffn {Scheme Procedure} symbol-append arg @dots{}
Return a newly allocated symbol whose characters form the
concatenation of the given symbols, @var{arg} @enddots{}.

@example
(let ((h 'hello))
  (symbol-append h 'world))
@result{} helloworld
@end example
@end deffn

@rnindex string->symbol
@deffn {Scheme Procedure} string->symbol string
@deffnx {C Function} scm_string_to_symbol (string)
Return the symbol whose name is @var{string}.  This procedure can create
symbols with names containing special characters or letters in the
non-standard case, but it is usually a bad idea to create such symbols
because in some implementations of Scheme they cannot be read as
themselves.
@end deffn

@deffn {Scheme Procedure} string-ci->symbol str
@deffnx {C Function} scm_string_ci_to_symbol (str)
Return the symbol whose name is @var{str}.  If Guile is currently
reading symbols case-insensitively, @var{str} is converted to lowercase
before the returned symbol is looked up or created.
@end deffn

The following examples illustrate Guile's detailed behaviour as regards
the case-sensitivity of symbols:

@lisp
(read-enable 'case-insensitive)   ; R5RS compliant behaviour

(symbol->string 'flying-fish)    @result{} "flying-fish"
(symbol->string 'Martin)         @result{} "martin"
(symbol->string
   (string->symbol "Malvina"))   @result{} "Malvina"

(eq? 'mISSISSIppi 'mississippi)  @result{} #t
(string->symbol "mISSISSIppi")   @result{} mISSISSIppi
(eq? 'bitBlt (string->symbol "bitBlt")) @result{} #f
(eq? 'LolliPop
  (string->symbol (symbol->string 'LolliPop))) @result{} #t
(string=? "K. Harper, M.D."
  (symbol->string
    (string->symbol "K. Harper, M.D."))) @result{} #t

(read-disable 'case-insensitive)   ; Guile default behaviour

(symbol->string 'flying-fish)    @result{} "flying-fish"
(symbol->string 'Martin)         @result{} "Martin"
(symbol->string
   (string->symbol "Malvina"))   @result{} "Malvina"

(eq? 'mISSISSIppi 'mississippi)  @result{} #f
(string->symbol "mISSISSIppi")   @result{} mISSISSIppi
(eq? 'bitBlt (string->symbol "bitBlt")) @result{} #t
(eq? 'LolliPop
  (string->symbol (symbol->string 'LolliPop))) @result{} #t
(string=? "K. Harper, M.D."
  (symbol->string
    (string->symbol "K. Harper, M.D."))) @result{} #t
@end lisp

From C, there are lower level functions that construct a Scheme symbol
from a C string in the current locale encoding.

When you want to do more from C, you should convert between symbols
and strings using @code{scm_symbol_to_string} and
@code{scm_string_to_symbol} and work with the strings.

@deftypefn {C Function} SCM scm_from_latin1_symbol (const char *name)
@deftypefnx {C Function} SCM scm_from_utf8_symbol (const char *name)
Construct and return a Scheme symbol whose name is specified by the
null-terminated C string @var{name}.  These are appropriate when
the C string is hard-coded in the source code.
@end deftypefn

@deftypefn {C Function} SCM scm_from_locale_symbol (const char *name)
@deftypefnx {C Function} SCM scm_from_locale_symboln (const char *name, size_t len)
Construct and return a Scheme symbol whose name is specified by
@var{name}.  For @code{scm_from_locale_symbol}, @var{name} must be null
terminated; for @code{scm_from_locale_symboln} the length of @var{name} is
specified explicitly by @var{len}.

Note that these functions should @emph{not} be used when @var{name} is a
C string constant, because there is no guarantee that the current locale
will match that of the execution character set, used for string and
character constants.  Most modern C compilers use UTF-8 by default, so
in such cases we recommend @code{scm_from_utf8_symbol}.
@end deftypefn

@deftypefn  {C Function} SCM scm_take_locale_symbol (char *str)
@deftypefnx {C Function} SCM scm_take_locale_symboln (char *str, size_t len)
Like @code{scm_from_locale_symbol} and @code{scm_from_locale_symboln},
respectively, but also frees @var{str} with @code{free} eventually.
Thus, you can use this function when you would free @var{str} anyway
immediately after creating the Scheme string.  In certain cases, Guile
can then use @var{str} directly as its internal representation.
@end deftypefn

The size of a symbol can also be obtained from C:

@deftypefn {C Function} size_t scm_c_symbol_length (SCM sym)
Return the number of characters in @var{sym}.
@end deftypefn

Наконец, некоторым приложениям, особенно тем, кторые генерируют новый
код схемы Scheme динамически, необходимо создавать символы для 
использования в сгенерированном коде. Примитив @code{gensym} 
позволяет это сделать:

@deffn {Scheme Procedure} gensym [prefix]
@deffnx {C Function} scm_gensym (prefix)
Create a new symbol with a name constructed from a prefix and a counter
value.  The string @var{prefix} can be specified as an optional
argument.  Default prefix is @samp{@w{ g}}.  The counter is increased by 1
at each call.  There is no provision for resetting the counter.
@end deffn

Символы, генерируемые @code{gensym} скорее всего будут уникальными,
поскольку их имена начинабются с пробелов, и неуникальными если
программист найдет способ создать подобные символы. Уникальность
может быть гарантирована, вместо этого, использванием
неинтерминированных символов (@pxref{Symbol Uninterned}), хоти
они не могут быть корректно выведены и считаны обратно.

@node Symbol Props
@subsubsection Функциональные слоты и Списки Свойств

В традиционных диалектах Lisp, символы часто понимаются как имеющие
одновременно три вида значений:

@itemize @bullet
@item
значение переменной@dfn{variable}, которое используется, когда
символ отображается в контексте кода как ссылка на переменную.

@item
Значение функции @dfn{function}, которое используется, когда символ
появляется в коде в имени функции (т.е @: как первый элемент в
неквотируемом списке)

@item
Значение списка свойств@dfn{property list}, которое используется, когда
символ указан в качестве первого аргумента для функции Lisp @code{put}
или @code{get}.
@end itemize

Хотя Scheme (как одно из упрощений в отошении Lisp) убирает различия
между пространствами имен переменных и функций, в настоящее время 
Guile сохраняет некоторые элементы традиционной структуры в случае 
если они окажутся полезными при реализации перевода для других
языков, в частности Emacs Lisp.

В частности, символы Guile имеют два дополнительных слота: один для
символа списка свойств и один для ``значения функции''. Для доступа
к этим слотам предоставляются следующие процедуры.

@deffn {Scheme Procedure} symbol-fref symbol
@deffnx {C Function} scm_symbol_fref (symbol)
Return the contents of @var{symbol}'s @dfn{function slot}.
@end deffn

@deffn {Scheme Procedure} symbol-fset! symbol value
@deffnx {C Function} scm_symbol_fset_x (symbol, value)
Set the contents of @var{symbol}'s function slot to @var{value}.
@end deffn

@deffn {Scheme Procedure} symbol-pref symbol
@deffnx {C Function} scm_symbol_pref (symbol)
Return the @dfn{property list} currently associated with @var{symbol}.
@end deffn

@deffn {Scheme Procedure} symbol-pset! symbol value
@deffnx {C Function} scm_symbol_pset_x (symbol, value)
Set @var{symbol}'s property list to @var{value}.
@end deffn

@deffn {Scheme Procedure} symbol-property sym prop
From @var{sym}'s property list, return the value for property
@var{prop}.  The assumption is that @var{sym}'s property list is an
association list whose keys are distinguished from each other using
@code{equal?}; @var{prop} should be one of the keys in that list.  If
the property list has no entry for @var{prop}, @code{symbol-property}
returns @code{#f}.
@end deffn

@deffn {Scheme Procedure} set-symbol-property! sym prop val
In @var{sym}'s property list, set the value for property @var{prop} to
@var{val}, or add a new entry for @var{prop}, with value @var{val}, if
none already exists.  For the structure of the property list, see
@code{symbol-property}.
@end deffn

@deffn {Scheme Procedure} symbol-property-remove! sym prop
From @var{sym}'s property list, remove the entry for property
@var{prop}, if there is one.  For the structure of the property list,
see @code{symbol-property}.
@end deffn

Поддержка этих дополнительных слотов может быть удалена в будущих
версиях, поэтому лучше избегать их использования. Для более
современного и комплексного подхода к свойствам см 
@ref{Object Properties}.

@node Symbol Read Syntax
@subsubsection Синтаксис Расширенного Чтения для Символов

@cindex r7rs-symbols

Синтаксисом для чтения символов является последовательность букв,
цифр и расширенного алфавита символов, начинающегося с символа
с которого не может начинаться число.  Кроме того, символы
@code{+}, @code{-}, и @code{...} представляют собой особый случай,
и считаются символами, хотя числа могут начинаться с  @code{+}, 
@code{-} или @code{.}.

Расширенные буквенные символы могут использваться в идентификаторах,
как если бы они были буквами. Набор расширенных буквенных символов:

@example
! $ % & * + - . / : < = > ? @@ ^ _ ~
@end example

В дополнение к стандартному синтаксису чтения определенному выше(который взят
из R5RS (@pxref{Formal syntax,,,r5rs,The Revised^5 Report on Scheme})), Guile
предоставляет расширенный синтаксис чтения символов, который позволяет
включать необычные символы, такие как символы пробела, новой строки и круглые
скобки. Если (по какой-либо причине) вам нужно написать символ, содержащий
буквы, не упомянутые выше, вы можете сделать это следующим образом.

@itemize @bullet
@item
Начните символ с сочетания симолов @code{#@{},

@item
напишите буквы имени символа и

@item
завершите имя символа сочетанием символов @code{@}#}.
@end itemize

Вот несколько примеров использования этой формы синтаксиса чтения.
Первый символ должен использовать расширенный синтаксис, поскольку он 
содержит пробельный символ. Второй - потому что он содержит символ 
line break, и последний, потому что он похож на число.

@lisp
#@{foo bar@}#

#@{what
ever@}#

#@{4242@}#
@end lisp

Although Guile provides this extended read syntax for symbols,
widespread usage of it is discouraged because it is not portable and not
very readable.

Alternatively, if you enable the @code{r7rs-symbols} read option (see
@pxref{Scheme Read}), you can write arbitrary symbols using the same
notation used for strings, except delimited by vertical bars instead of
double quotes.

@example
|foo bar|
|\x3BB; is a greek lambda|
|\| is a vertical bar|
@end example

Note that there's also an @code{r7rs-symbols} print option
(@pxref{Scheme Write}).  To enable the use of this notation, evaluate
one or both of the following expressions:

@example
(read-enable  'r7rs-symbols)
(print-enable 'r7rs-symbols)
@end example

@node Symbol Uninterned
@subsubsection Уникальные(uninterned) символы

Что делает символы полезными, так это то, что они автоматически
сохраняются уникальными. нет двух символов, которые являются
отдельными объектами и имеют одинаковое имя. Но конечно нет
правила без исключения. В дополнении к обычным символам, которые
обсуждались до сих пор, вы так же можете создавать специальные
неограниченные символы, которые ведут себя несколько иначе.

Чтобы понять, чем эти символы отличаются и почему они полезны, мы
посмотрим, как обычные символы сохраняют свою уникальность.

Всякий раз когда Guile необходимо найти символ с определенным именем,
например во время четения @code{read} или при выполнении функции
@code{string->symbol}, он сначала просматривает таблицу всех 
существующих символов, чтобы найти символ с указанным именем.
Когда такой символ найден, Guile просто возвращает этот символ.
Когда нет, создается новый символ с именем и вводиться в таблицу,
чтобы его можно было найти позже.

Иногда вам может понадобиться создать символ, который был бы гарантированно
`новым', т.е ранее не существовал. Вы также можете както гарантировать, что 
никто другой когда-нибудь непреднамеренно не пересечется с вашим символом
в будущем. Эти свойства символу часто необходимы при создании кода во время
расширения макроса. При введении новых временных переменных, вы хотите
гарантировать, что они не будут конфликтовать с переменными в коде других
людей.

Самый простой способ организовать это - создать новый символ, но
не вводить его в глобальную таблицу всех символов. Таким образом,
никто никогда не получит доступ к вашему символу случайно. Символы
которые не указаны в таблице, называются @dfn{uninterned}.  Конечно
символы находящиеся в таблице называются @dfn{интернированными(interned)}.

Вы можете создать новый uninterned символ функцией @code{make-symbol}.
Вы можете проверить является ли символ интернированным или нет
функцией @code{symbol-interned?}.

Uninterned символы нарушают правило, согласно которому имя символа
однозначно идентифицирует символьный объект.  Из-за этого они
не могуть быть выведены и прочитаны обратно, как интернированные
символы. В настоящее время Guile не поддерживает чтение uninterned 
символов.  Обратите внимание, что функция @code{gensym} не возвращает
uninterned символов по этой причине.

@deffn {Scheme Procedure} make-symbol name
@deffnx {C Function} scm_make_symbol (name)
Return a new uninterned symbol with the name @var{name}.  The returned
symbol is guaranteed to be unique and future calls to
@code{string->symbol} will not return it.
@end deffn

@deffn {Scheme Procedure} symbol-interned? symbol
@deffnx {C Function} scm_symbol_interned_p (symbol)
Return @code{#t} if @var{symbol} is interned, otherwise return
@code{#f}.
@end deffn

For example:

@lisp
(define foo-1 (string->symbol "foo"))
(define foo-2 (string->symbol "foo"))
(define foo-3 (make-symbol "foo"))
(define foo-4 (make-symbol "foo"))

(eq? foo-1 foo-2)
@result{} #t
; Two interned symbols with the same name are the same object,

(eq? foo-1 foo-3)
@result{} #f
; but a call to make-symbol with the same name returns a
; distinct object.

(eq? foo-3 foo-4)
@result{} #f
; A call to make-symbol always returns a new object, even for
; the same name.

foo-3
@result{} #<uninterned-symbol foo 8085290>
; Uninterned symbols print differently from interned symbols,

(symbol? foo-3)
@result{} #t
; but they are still symbols,

(symbol-interned? foo-3)
@result{} #f
; just not interned.
@end lisp

@node Keywords
@subsection Ключевые слова
@tpindex Keywords

Ключевые слова являются самовычислимым объектом с удобным синтаксисом
чтения, что упращает их печать.

Поддержка ключевых слов Guile соответствует R5RS, и добавляет
(с возможностью переключения) расширение синтаксиса чтения чтобы
разрешить начинаться ключевым словам с @code{:} а так же с
@code{#:}, или завершаться  @code{:}.

@menu
* Why Use Keywords?::           Motivation for keyword usage.
* Coding With Keywords::        How to use keywords.
* Keyword Read Syntax::         Read syntax for keywords.
* Keyword Procedures::          Procedures for dealing with keywords.
@end menu

@node Why Use Keywords?
@subsubsection Зачем использовать ключевые слова?

Ключевые слова полезны в контексте, где программе или процедуре необходимо
принимать большое количество необязательных аргументов, не делая интерфес
к процедуре неуправляемым.

Чтобы проилюстрировать это, рассмотрим гипотетическую процедуру
создания окна  @code{make-window}, которая создает новое окно
на экране для рисования с использованием какого либо графического
инструментария. Здесь очень много параметров, которые вызывающий
может пожелать указать, но которые также могуть быть установлены
поумолчанию, Например:

@itemize @bullet
@item
color depth -- Default: the color depth for the screen

@item
background color -- Default: white

@item
width -- Default: 600

@item
height -- Default: 400
@end itemize

Если в процедуре  @code{make-window} не использовались ключевые слова,
вызывающий должен был бы передать значение для каждого возможного
аргумента, соблюдая правильный порядок аргументов и используя
специальные значения для указания на значение по умолчанию для
этого аргумента.

@lisp
(make-window 'default              ;; Color depth
             'default              ;; Background color
             800                   ;; Width
             100                   ;; Height
             @dots{})                  ;; More make-window arguments
@end lisp

С ключевыми словами, с другой стороны, дефолтные аргументы опускаются,
а аргументы не по умолчанию четко помечены соответствующими ключевыми
словами. В результате вызов становиться намного яснее:

@lisp
(make-window #:width 800 #:height 100)
@end lisp

С другой стороны, для простой процедуры с несколькими аргументами
использование ключевых слов было бы помехой, а не помощью. Например,
примитивные процедуры, не следует улучшать вот так:

@lisp
(cons #:car x #:cdr y)
@end lisp

Поэтому решение о том, использовать ли ключевые слова или нет, чисто
прогматичное: используйте их, если они будут разъяснять вызов 
процедуры в точке вызова.

@node Coding With Keywords
@subsubsection Кодирование с использованием ключевых слов

Если процедуре необходимо поддерживать ключевые слова, она должна принять
последний аргумент, а затем использовать любые удобные средства для извлечения
ключевых слов и их соответствующих аргументов из содержимого этого
последнего аргумента.

The following example illustrates the principle: the code for
@code{make-window} uses a helper procedure called
@code{get-keyword-value} to extract individual keyword arguments from
the rest argument.

@lisp
(define (get-keyword-value args keyword default)
  (let ((kv (memq keyword args)))
    (if (and kv (>= (length kv) 2))
        (cadr kv)
        default)))

(define (make-window . args)
  (let ((depth  (get-keyword-value args #:depth  screen-depth))
        (bg     (get-keyword-value args #:bg     "white"))
        (width  (get-keyword-value args #:width  800))
        (height (get-keyword-value args #:height 100))
        @dots{})
    @dots{}))
@end lisp

Но вам не нужно создавать @code{get-keyword-value}.  Модуль @code{(ice-9
optargs)} поставляет набор мощных макросов, которые можно использовать
для реализации процедур поддержки работы с ключевыми словами, таких как:

@lisp
(use-modules (ice-9 optargs))

(define (make-window . args)
  (let-keywords args #f ((depth  screen-depth)
                         (bg     "white")
                         (width  800)
                         (height 100))
    ...))
@end lisp

@noindent
Или, еще более экономно, вот так:

@lisp
(use-modules (ice-9 optargs))

(define* (make-window #:key (depth  screen-depth)
                            (bg     "white")
                            (width  800)
                            (height 100))
  ...)
@end lisp

Для получения дополнительной информации о @code{let-keywords}, @code{define*} 
и других возможностях поставляемых модулем @code{(ice-9 optargs)}, смотри
@ref{Optional Arguments}.

Чтобы обрабатывать аргументы ключевых слов из процедур реализованных
на Си, используйте @code{scm_c_bind_keyword_arguments} 
(@pxref{Keyword Procedures}).

@node Keyword Read Syntax
@subsubsection Синтаксис чтения Ключевых Слов

Guile, по умолчанию, распознает только синтаксис ключевых слов, 
совместимый с  R5RS.  Токен формы @code{#:NAME}, где @code{NAME} 
имеет тот же синтаксис, что и символы Scheme (@pxref{Symbol Read Syntax}),
является внешним представлением ключевого слова с именем @code{NAME}.
Кроме того, объекты ключевые слова печатются с использованием этого
синтаксиса, поэтому значения, содержащие объекты ключых слов, могут
быть прочитаными Guile.  При использовании в выражении ключевые слова
являются самоквотирующимися выражениями.

Если для параметра чтения ключевых слов @code{keywords} устновлено
значение префикс @code{'prefix}, Guile также распрознает альтернативный
синтаксис чтения @code{:NAME}.  В противном случае маркеры формы @code{:NAME}
считаются символами, как это требует R5RS.

@cindex SRFI-88 keyword syntax

Если для параметра чтения ключевого слова @code{keywords} установлено
значение @code{'postfix}, Guile распознает синтаксис чтения SRFI-88 
@code{NAME:} (@pxref{SRFI-88}).
В противном случае токены этой формы читаются как символы.

Чтобы включить или отключить альтернативный синтаксис чтения ключевых
слов, отличный от R5RS, используйте процедуру @code{read-set!} описанную
@ref{Scheme Read}.  Обратите внимание синтаксисы @code{prefix} и 
@code{postfix} являются взаимоисключающими.

@lisp
(read-set! keywords 'prefix)

#:type
@result{}
#:type

:type
@result{}
#:type

(read-set! keywords 'postfix)

type:
@result{}
#:type

:type
@result{}
:type

(read-set! keywords #f)

#:type
@result{}
#:type

:type
@print{}
ERROR: In expression :type:
ERROR: Unbound variable: :type
ABORT: (unbound-variable)
@end lisp

@node Keyword Procedures
@subsubsection Процедуры работы с Ключевыми Словами

@deffn {Scheme Procedure} keyword? obj
@deffnx {C Function} scm_keyword_p (obj)
Return @code{#t} if the argument @var{obj} is a keyword, else
@code{#f}.
@end deffn

@deffn {Scheme Procedure} keyword->symbol keyword
@deffnx {C Function} scm_keyword_to_symbol (keyword)
Return the symbol with the same name as @var{keyword}.
@end deffn

@deffn {Scheme Procedure} symbol->keyword symbol
@deffnx {C Function} scm_symbol_to_keyword (symbol)
Return the keyword with the same name as @var{symbol}.
@end deffn

@deftypefn {C Function} int scm_is_keyword (SCM obj)
Equivalent to @code{scm_is_true (scm_keyword_p (@var{obj}))}.
@end deftypefn

@deftypefn {C Function} SCM scm_from_locale_keyword (const char *name)
@deftypefnx {C Function} SCM scm_from_locale_keywordn (const char *name, size_t len)
Equivalent to @code{scm_symbol_to_keyword (scm_from_locale_symbol
(@var{name}))} and @code{scm_symbol_to_keyword (scm_from_locale_symboln
(@var{name}, @var{len}))}, respectively.

Note that these functions should @emph{not} be used when @var{name} is a
C string constant, because there is no guarantee that the current locale
will match that of the execution character set, used for string and
character constants.  Most modern C compilers use UTF-8 by default, so
in such cases we recommend @code{scm_from_utf8_keyword}.
@end deftypefn

@deftypefn {C Function} SCM scm_from_latin1_keyword (const char *name)
@deftypefnx {C Function} SCM scm_from_utf8_keyword (const char *name)
Equivalent to @code{scm_symbol_to_keyword (scm_from_latin1_symbol
(@var{name}))} and @code{scm_symbol_to_keyword (scm_from_utf8_symbol
(@var{name}))}, respectively.
@end deftypefn

@deftypefn {C Function} void scm_c_bind_keyword_arguments (const char *subr, @
                             SCM rest, scm_t_keyword_arguments_flags flags, @
                             SCM keyword1, SCM *argp1, @
                             @dots{}, @
                             SCM keywordN, SCM *argpN, @
                             @nicode{SCM_UNDEFINED})

Extract the specified keyword arguments from @var{rest}, which is not
modified.  If the keyword argument @var{keyword1} is present in
@var{rest} with an associated value, that value is stored in the
variable pointed to by @var{argp1}, otherwise the variable is left
unchanged.  Similarly for the other keywords and argument pointers up to
@var{keywordN} and @var{argpN}.  The argument list to
@code{scm_c_bind_keyword_arguments} must be terminated by
@code{SCM_UNDEFINED}.

Note that since the variables pointed to by @var{argp1} through
@var{argpN} are left unchanged if the associated keyword argument is not
present, they should be initialized to their default values before
calling @code{scm_c_bind_keyword_arguments}.  Alternatively, you can
initialize them to @code{SCM_UNDEFINED} before the call, and then use
@code{SCM_UNBNDP} after the call to see which ones were provided.

If an unrecognized keyword argument is present in @var{rest} and
@var{flags} does not contain @code{SCM_ALLOW_OTHER_KEYS}, or if
non-keyword arguments are present and @var{flags} does not contain
@code{SCM_ALLOW_NON_KEYWORD_ARGUMENTS}, an exception is raised.
@var{subr} should be the name of the procedure receiving the keyword
arguments, for purposes of error reporting.

For example:

@example
SCM k_delimiter;
SCM k_grammar;
SCM sym_infix;

SCM my_string_join (SCM strings, SCM rest)
@{
  SCM delimiter = SCM_UNDEFINED;
  SCM grammar   = sym_infix;

  scm_c_bind_keyword_arguments ("my-string-join", rest, 0,
                                k_delimiter, &delimiter,
                                k_grammar, &grammar,
                                SCM_UNDEFINED);

  if (SCM_UNBNDP (delimiter))
    delimiter = scm_from_utf8_string (" ");

  return scm_string_join (strings, delimiter, grammar);
@}

void my_init ()
@{
  k_delimiter = scm_from_utf8_keyword ("delimiter");
  k_grammar   = scm_from_utf8_keyword ("grammar");
  sym_infix   = scm_from_utf8_symbol  ("infix");
  scm_c_define_gsubr ("my-string-join", 1, 0, 1, my_string_join);
@}
@end example
@end deftypefn

@node Pairs
@subsection Пары
@tpindex Pairs

Пары используются для объединения двух объектов Scheme в один
составной объект.
Отсюда и название: Пара хранит пару объектов.

Тип данных Пара @dfn{pair} чрезвычайно важен в Scheme, как и в любом
другом диалекте Lisp.  Причина в том, что пары используются не только
для того чтобы сделать два значения доступными как один объект, но
эти пары используются для построения списков значений.  Поскольку
списки так важны в Scheme, они описаны в отдельном разделе 
(@pxref{Lists}).

Пары могут буквально вводиться в исходный код или в REPL, в так называемом
точечном синтаксисе списка @dfn{dotted list}.  Этот синтаксис состоит из
открывающей круглой скобки, первого элемента пары, точки, второго элемента,
закрывающей круглой скобки.  В следующем примере показано, формирование 
пары из двух чисел 1 и 2, и пары содержащей символы @code{foo} и @code{bar}.
Очень важно писать пробелы до и после точки, потому что в противном случае
анализатор Scheme не сможет определить, где разделять токены.

@lisp
(1 . 2)
(foo . bar)
@end lisp

Но будьте осторожны, если вы хотите попробовать эти примеры, вам
нужно квотировать@dfn{quote} эти выражения.  Более подробную информацию
можно найти в разделе @ref{Expression Syntax}.  Правильный способ
использовать эти примеры состоит в следующем.

@lisp
'(1 . 2)
@result{}
(1 . 2)
'(foo . bar)
@result{}
(foo . bar)
@end lisp

Новая пара создается путем вызова процедуры @code{cons} с двумя
аргументами.  Затем значения аргументов сохраняются во вновь
выделенную пару, и пара возвращается.  Имя @code{cons} означает
"Конструировать(construct)".  Используйте процедуру @code{pair?}
что бы проверить является ли данный объект Scheme парой или нет.

@rnindex cons
@deffn {Scheme Procedure} cons x y
@deffnx {C Function} scm_cons (x, y)
Return a newly allocated pair whose car is @var{x} and whose
cdr is @var{y}.  The pair is guaranteed to be different (in the
sense of @code{eq?}) from every previously existing object.
@end deffn

@rnindex pair?
@deffn {Scheme Procedure} pair? x
@deffnx {C Function} scm_pair_p (x)
Return @code{#t} if @var{x} is a pair; otherwise return
@code{#f}.
@end deffn

@deftypefn {C Function} int scm_is_pair (SCM x)
Return 1 when @var{x} is a pair; otherwise return 0.
@end deftypefn

The two parts of a pair are traditionally called @dfn{car} and
@dfn{cdr}.  They can be retrieved with procedures of the same name
(@code{car} and @code{cdr}), and can be modified with the procedures
@code{set-car!} and @code{set-cdr!}.

Since a very common operation in Scheme programs is to access the car of
a car of a pair, or the car of the cdr of a pair, etc., the procedures
called @code{caar}, @code{cadr} and so on are also predefined.  However,
using these procedures is often detrimental to readability, and
error-prone.  Thus, accessing the contents of a list is usually better
achieved using pattern matching techniques (@pxref{Pattern Matching}).

@rnindex car
@rnindex cdr
@deffn {Scheme Procedure} car pair
@deffnx {Scheme Procedure} cdr pair
@deffnx {C Function} scm_car (pair)
@deffnx {C Function} scm_cdr (pair)
Return the car or the cdr of @var{pair}, respectively.
@end deffn

@deftypefn  {C Macro} SCM SCM_CAR (SCM pair)
@deftypefnx {C Macro} SCM SCM_CDR (SCM pair)
These two macros are the fastest way to access the car or cdr of a
pair; they can be thought of as compiling into a single memory
reference.

These macros do no checking at all.  The argument @var{pair} must be a
valid pair.
@end deftypefn

@deffn  {Scheme Procedure} cddr pair
@deffnx {Scheme Procedure} cdar pair
@deffnx {Scheme Procedure} cadr pair
@deffnx {Scheme Procedure} caar pair
@deffnx {Scheme Procedure} cdddr pair
@deffnx {Scheme Procedure} cddar pair
@deffnx {Scheme Procedure} cdadr pair
@deffnx {Scheme Procedure} cdaar pair
@deffnx {Scheme Procedure} caddr pair
@deffnx {Scheme Procedure} cadar pair
@deffnx {Scheme Procedure} caadr pair
@deffnx {Scheme Procedure} caaar pair
@deffnx {Scheme Procedure} cddddr pair
@deffnx {Scheme Procedure} cdddar pair
@deffnx {Scheme Procedure} cddadr pair
@deffnx {Scheme Procedure} cddaar pair
@deffnx {Scheme Procedure} cdaddr pair
@deffnx {Scheme Procedure} cdadar pair
@deffnx {Scheme Procedure} cdaadr pair
@deffnx {Scheme Procedure} cdaaar pair
@deffnx {Scheme Procedure} cadddr pair
@deffnx {Scheme Procedure} caddar pair
@deffnx {Scheme Procedure} cadadr pair
@deffnx {Scheme Procedure} cadaar pair
@deffnx {Scheme Procedure} caaddr pair
@deffnx {Scheme Procedure} caadar pair
@deffnx {Scheme Procedure} caaadr pair
@deffnx {Scheme Procedure} caaaar pair
@deffnx {C Function} scm_cddr (pair)
@deffnx {C Function} scm_cdar (pair)
@deffnx {C Function} scm_cadr (pair)
@deffnx {C Function} scm_caar (pair)
@deffnx {C Function} scm_cdddr (pair)
@deffnx {C Function} scm_cddar (pair)
@deffnx {C Function} scm_cdadr (pair)
@deffnx {C Function} scm_cdaar (pair)
@deffnx {C Function} scm_caddr (pair)
@deffnx {C Function} scm_cadar (pair)
@deffnx {C Function} scm_caadr (pair)
@deffnx {C Function} scm_caaar (pair)
@deffnx {C Function} scm_cddddr (pair)
@deffnx {C Function} scm_cdddar (pair)
@deffnx {C Function} scm_cddadr (pair)
@deffnx {C Function} scm_cddaar (pair)
@deffnx {C Function} scm_cdaddr (pair)
@deffnx {C Function} scm_cdadar (pair)
@deffnx {C Function} scm_cdaadr (pair)
@deffnx {C Function} scm_cdaaar (pair)
@deffnx {C Function} scm_cadddr (pair)
@deffnx {C Function} scm_caddar (pair)
@deffnx {C Function} scm_cadadr (pair)
@deffnx {C Function} scm_cadaar (pair)
@deffnx {C Function} scm_caaddr (pair)
@deffnx {C Function} scm_caadar (pair)
@deffnx {C Function} scm_caaadr (pair)
@deffnx {C Function} scm_caaaar (pair)
These procedures are compositions of @code{car} and @code{cdr}, where
for example @code{caddr} could be defined by

@lisp
(define caddr (lambda (x) (car (cdr (cdr x)))))
@end lisp

@code{cadr}, @code{caddr} and @code{cadddr} pick out the second, third
or fourth elements of a list, respectively.  SRFI-1 provides the same
under the names @code{second}, @code{third} and @code{fourth}
(@pxref{SRFI-1 Selectors}).
@end deffn

@rnindex set-car!
@deffn {Scheme Procedure} set-car! pair value
@deffnx {C Function} scm_set_car_x (pair, value)
Stores @var{value} in the car field of @var{pair}.  The value returned
by @code{set-car!} is unspecified.
@end deffn

@rnindex set-cdr!
@deffn {Scheme Procedure} set-cdr! pair value
@deffnx {C Function} scm_set_cdr_x (pair, value)
Stores @var{value} in the cdr field of @var{pair}.  The value returned
by @code{set-cdr!} is unspecified.
@end deffn

@node Lists
@subsection Списки
@tpindex Lists

Очень важным типом данных в Scheme, а также во всех других диалектах
Lisp, является тип данных типа Список@dfn{list}.@footnote{Строго говоря,
Scheme не имеет реально сущетствующего типа данных @dfn{list}.  Список представляет
собой @dfn{цепочки пар(chained pairs)}, и используется только как определение ---
список это цепочка пар выглядящая как список.}

Это краткое определение того, что такое список:

@itemize @bullet
@item
Либо пустой список @code{()},

@item
либо пара, которая имеет списко в своем cdr.
@end itemize

@c FIXME::martin: Describe the pair chaining in more detail.

@c FIXME::martin: What is a proper, what an improper list?
@c What is a circular list?

@c FIXME::martin: Maybe steal some graphics from the Elisp reference 
@c manual?

@menu
* List Syntax::                 Writing literal lists.
* List Predicates::             Testing lists.
* List Constructors::           Creating new lists.
* List Selection::              Selecting from lists, getting their length.
* Append/Reverse::              Appending and reversing lists.
* List Modification::           Modifying existing lists.
* List Searching::              Searching for list elements
* List Mapping::                Applying procedures to lists.
@end menu

@node List Syntax
@subsubsection Синтаксис чтения Списка

Синтаксис списка - это открывающая круглая скобка, затем все элементы списка
(разделяемые пробелами) и наконец, закрывающая круглая скобка.
@footnote{Обратите внимание, что между элементами списка нет разделительного
символа, например запятой или точки с запятой.}.

@lisp
(1 2 3)            ; @r{a list of the numbers 1, 2 and 3}
("foo" bar 3.1415) ; @r{a string, a symbol and a real number}
()                 ; @r{the empty list}
@end lisp

В последнем примере требуется немного объяснений. Список без элементов,
называемый Пустой список @dfn{empty list}, используется особенным образом.
Он используется для завершения списков, сохраняя его в  cdr последнй пары,
составляющих список.  Приведем пример:

@lisp
(car '(1))
@result{}
1
(cdr '(1))
@result{}
()
@end lisp

Этот пример также показывает. что списки должны квотироваться 
при записи(@pxref{Expression Syntax}), потому что иначе они 
были бы ошибочно приняты как вызов процедуры (@pxref{Simple
Invocation}).

@node List Predicates
@subsubsection Списковые предикаты

Часто полезно проверить, является ли данный объект Scheme списком
или нет. Процедуры Обработки Списков могут использовать эту 
информацию, чтобы проверить, действительно ли им на вход подали 
список, или они могут выполнять различные действия в зависимости
от типа данных аргументов.

@rnindex list?
@deffn {Scheme Procedure} list? x
@deffnx {C Function} scm_list_p (x)
Return @code{#t} if @var{x} is a proper list, else @code{#f}.
@end deffn

The predicate @code{null?} is often used in list-processing code to
tell whether a given list has run out of elements.  That is, a loop
somehow deals with the elements of a list until the list satisfies
@code{null?}.  Then, the algorithm terminates.

@rnindex null?
@deffn {Scheme Procedure} null? x
@deffnx {C Function} scm_null_p (x)
Return @code{#t} if @var{x} is the empty list, else @code{#f}.
@end deffn

@deftypefn {C Function} int scm_is_null (SCM x)
Return 1 when @var{x} is the empty list; otherwise return 0.
@end deftypefn

@node List Constructors
@subsubsection Конструкторы Списков

В этом разделе описываются процедуры построения новых списков.
Функция @code{list} просто возвращает список, переданных ей
аргументов, аналогично работает @code{cons*}, но последний
аргумент сохраняется в cdr последней пары списка.

@c  C Function scm_list(rest) used to be documented here, but it's a
@c  no-op since it does nothing but return the list the caller must
@c  have already created.
@c
@deffn {Scheme Procedure} list elem @dots{}
@deffnx {C Function} scm_list_1 (elem1)
@deffnx {C Function} scm_list_2 (elem1, elem2)
@deffnx {C Function} scm_list_3 (elem1, elem2, elem3)
@deffnx {C Function} scm_list_4 (elem1, elem2, elem3, elem4)
@deffnx {C Function} scm_list_5 (elem1, elem2, elem3, elem4, elem5)
@deffnx {C Function} scm_list_n (elem1, @dots{}, elemN, @nicode{SCM_UNDEFINED})
@rnindex list
Return a new list containing elements @var{elem} @enddots{}.

@code{scm_list_n} takes a variable number of arguments, terminated by
the special @code{SCM_UNDEFINED}.  That final @code{SCM_UNDEFINED} is
not included in the list.  None of @var{elem} @dots{} can
themselves be @code{SCM_UNDEFINED}, or @code{scm_list_n} will
terminate at that point.
@end deffn

@c  C Function scm_cons_star(arg1,rest) used to be documented here,
@c  but it's not really a useful interface, since it expects the
@c  caller to have already consed up all but the first argument
@c  already.
@c
@deffn {Scheme Procedure} cons* arg1 arg2 @dots{}
Like @code{list}, but the last arg provides the tail of the
constructed list, returning @code{(cons @var{arg1} (cons
@var{arg2} (cons @dots{} @var{argn})))}.  Requires at least one
argument.  If given one argument, that argument is returned as
result.  This function is called @code{list*} in some other
Schemes and in Common LISP.
@end deffn

@deffn {Scheme Procedure} list-copy lst
@deffnx {C Function} scm_list_copy (lst)
Return a (newly-created) copy of @var{lst}.
@end deffn

@deffn {Scheme Procedure} make-list n [init]
Create a list containing of @var{n} elements, where each element is
initialized to @var{init}.  @var{init} defaults to the empty list
@code{()} if not given.
@end deffn

Обратите внимание, что в процедуре @code{list-copy} делается только
копирование пар, составляющих основу списка. Элементы списка не 
копируются, что означает, что изменение элементов нового списка,
также изменит и элементы старого списка.  С другой стороны, применяя
такие процедуры как @code{set-cdr!} или @code{delv!} для нового
списка, старый список не будет изменен. Если вам также необходимо
скопировать элементы списка(сделать глубокую копию), используйте 
процедуру @code{copy-tree} (@pxref{Copying}).

@node List Selection
@subsubsection Операции Выбора в Списке

Эти процедуры используются для получения некоторой информации о списке
или для извлечения одного или нескольких элементов списка.

@rnindex length
@deffn {Scheme Procedure} length lst
@deffnx {C Function} scm_length (lst)
Return the number of elements in list @var{lst}.
@end deffn

@deffn {Scheme Procedure} last-pair lst
@deffnx {C Function} scm_last_pair (lst)
Return the last pair in @var{lst}, signalling an error if
@var{lst} is circular.
@end deffn

@rnindex list-ref
@deffn {Scheme Procedure} list-ref list k
@deffnx {C Function} scm_list_ref (list, k)
Return the @var{k}th element from @var{list}.
@end deffn

@rnindex list-tail
@deffn {Scheme Procedure} list-tail lst k
@deffnx {Scheme Procedure} list-cdr-ref lst k
@deffnx {C Function} scm_list_tail (lst, k)
Return the "tail" of @var{lst} beginning with its @var{k}th element.
The first element of the list is considered to be element 0.

@code{list-tail} and @code{list-cdr-ref} are identical.  It may help to
think of @code{list-cdr-ref} as accessing the @var{k}th cdr of the list,
or returning the results of cdring @var{k} times down @var{lst}.
@end deffn

@deffn {Scheme Procedure} list-head lst k
@deffnx {C Function} scm_list_head (lst, k)
Copy the first @var{k} elements from @var{lst} into a new list, and
return it.
@end deffn

@node Append/Reverse
@subsubsection Добавление и Переворачивание

@code{append} и @code{append!} используются для объединения двух и более
списков, что бы сформировать новый список.  @code{reverse} и @code{reverse!}
возвращаеют списки с теми же элементами, но идущими в обратном порядке.
Варианты процедур с @code{!} непосредственно изменяют пары, которые образуют
список, а другие процедуры создают новые пары. Вот почему вы должны быть
осторожны, когда используете побочные эффекты процедур.

@rnindex append
@deffn {Scheme Procedure} append lst @dots{} obj
@deffnx {Scheme Procedure} append
@deffnx {Scheme Procedure} append! lst @dots{} obj
@deffnx {Scheme Procedure} append!
@deffnx {C Function} scm_append (lstlst)
@deffnx {C Function} scm_append_x (lstlst)
Return a list comprising all the elements of lists @var{lst} @dots{}
@var{obj}.  If called with no arguments, return the empty list.

@lisp
(append '(x) '(y))          @result{}  (x y)
(append '(a) '(b c d))      @result{}  (a b c d)
(append '(a (b)) '((c)))    @result{}  (a (b) (c))
@end lisp

The last argument @var{obj} may actually be any object; an improper
list results if the last argument is not a proper list.

@lisp
(append '(a b) '(c . d))    @result{}  (a b c . d)
(append '() 'a)             @result{}  a
@end lisp

@code{append} doesn't modify the given lists, but the return may share
structure with the final @var{obj}.  @code{append!} is permitted, but
not required, to modify the given lists to form its return.

For @code{scm_append} and @code{scm_append_x}, @var{lstlst} is a list
of the list operands @var{lst} @dots{} @var{obj}.  That @var{lstlst}
itself is not modified or used in the return.
@end deffn

@rnindex reverse
@deffn {Scheme Procedure} reverse lst
@deffnx {Scheme Procedure} reverse! lst [newtail]
@deffnx {C Function} scm_reverse (lst)
@deffnx {C Function} scm_reverse_x (lst, newtail)
Return a list comprising the elements of @var{lst}, in reverse order.

@code{reverse} constructs a new list.  @code{reverse!} is permitted, but
not required, to modify @var{lst} in constructing its return.

For @code{reverse!}, the optional @var{newtail} is appended to the
result.  @var{newtail} isn't reversed, it simply becomes the list
tail.  For @code{scm_reverse_x}, the @var{newtail} parameter is
mandatory, but can be @code{SCM_EOL} if no further tail is required.
@end deffn

@node List Modification
@subsubsection Изменение Списка

Следующие процедуры изменяют существующий список либо путем
изменения элементов списка, либо путем изменения самой
структуры списка.

@deffn {Scheme Procedure} list-set! list k val
@deffnx {C Function} scm_list_set_x (list, k, val)
Устанавливает @var{k}-тый элемент списка @var{list} значением @var{val}.
@end deffn
@lisp
;;ВНИМАНИЕ!!! меня ждал тут сюрприз!!!
(define t1 '(1 2 3 4 5))
(list-set! t1 0 100)  @result{} 
@result{} ERROR: In procedure list-set!:
 set-car!: Wrong type argument in position 1 (expecting mutable pair)
;; А так РАБОТАЕТ!!! значит важно различить mutable и imutable list
(define t1 (list 1 2 3 4 5))
(list-set! t1 0 100) (display t1)  @result{}  (100 2 3 4 5)
@end lisp

@deffn {Scheme Procedure} list-cdr-set! list k val
@deffnx {C Function} scm_list_cdr_set_x (list, k, val)
Set the @var{k}th cdr of @var{list} to @var{val}.
@end deffn

@deffn {Scheme Procedure} delq item lst
@deffnx {C Function} scm_delq (item, lst)
Return a newly-created copy of @var{lst} with elements
@code{eq?} to @var{item} removed.  This procedure mirrors
@code{memq}: @code{delq} compares elements of @var{lst} against
@var{item} with @code{eq?}.
@end deffn

@deffn {Scheme Procedure} delv item lst
@deffnx {C Function} scm_delv (item, lst)
Return a newly-created copy of @var{lst} with elements
@code{eqv?} to @var{item} removed.  This procedure mirrors
@code{memv}: @code{delv} compares elements of @var{lst} against
@var{item} with @code{eqv?}.
@end deffn

@deffn {Scheme Procedure} delete item lst
@deffnx {C Function} scm_delete (item, lst)
Return a newly-created copy of @var{lst} with elements
@code{equal?} to @var{item} removed.  This procedure mirrors
@code{member}: @code{delete} compares elements of @var{lst}
against @var{item} with @code{equal?}.

See also SRFI-1 which has an extended @code{delete} (@ref{SRFI-1
Deleting}), and also an @code{lset-difference} which can delete
multiple @var{item}s in one call (@ref{SRFI-1 Set Operations}).
@end deffn

@deffn {Scheme Procedure} delq! item lst
@deffnx {Scheme Procedure} delv! item lst
@deffnx {Scheme Procedure} delete! item lst
@deffnx {C Function} scm_delq_x (item, lst)
@deffnx {C Function} scm_delv_x (item, lst)
@deffnx {C Function} scm_delete_x (item, lst)
These procedures are destructive versions of @code{delq}, @code{delv}
and @code{delete}: they modify the pointers in the existing @var{lst}
rather than creating a new list.  Caveat evaluator: Like other
destructive list functions, these functions cannot modify the binding of
@var{lst}, and so cannot be used to delete the first element of
@var{lst} destructively.
@end deffn

@deffn {Scheme Procedure} delq1! item lst
@deffnx {C Function} scm_delq1_x (item, lst)
Like @code{delq!}, but only deletes the first occurrence of
@var{item} from @var{lst}.  Tests for equality using
@code{eq?}.  See also @code{delv1!} and @code{delete1!}.
@end deffn

@deffn {Scheme Procedure} delv1! item lst
@deffnx {C Function} scm_delv1_x (item, lst)
Like @code{delv!}, but only deletes the first occurrence of
@var{item} from @var{lst}.  Tests for equality using
@code{eqv?}.  See also @code{delq1!} and @code{delete1!}.
@end deffn

@deffn {Scheme Procedure} delete1! item lst
@deffnx {C Function} scm_delete1_x (item, lst)
Like @code{delete!}, but only deletes the first occurrence of
@var{item} from @var{lst}.  Tests for equality using
@code{equal?}.  See also @code{delq1!} and @code{delv1!}.
@end deffn

@deffn {Scheme Procedure} filter pred lst
@deffnx {Scheme Procedure} filter! pred lst
Return a list containing all elements from @var{lst} which satisfy the
predicate @var{pred}.  The elements in the result list have the same
order as in @var{lst}.  The order in which @var{pred} is applied to
the list elements is not specified.

@code{filter} does not change @var{lst}, but the result may share a
tail with it.  @code{filter!} may modify @var{lst} to construct its
return.
@end deffn

@node List Searching
@subsubsection Поиск по Списку

Следующие процедуры выполняют поиск по конкретным элементам. Они используют
различные типы предикатов сравнения элементов списка с объектом, подлежащем
поиску. Когда поиск неудачен, функции возвращают @code{#f}, иначе они
возвращают подсписок, car для которого равен искомому объекту, результат
сравнения(и поиска) зависит от используемого предиката равенства.

@rnindex memq
@deffn {Scheme Procedure} memq x lst
@deffnx {C Function} scm_memq (x, lst)
Return the first sublist of @var{lst} whose car is @code{eq?}
to @var{x} where the sublists of @var{lst} are the non-empty
lists returned by @code{(list-tail @var{lst} @var{k})} for
@var{k} less than the length of @var{lst}.  If @var{x} does not
occur in @var{lst}, then @code{#f} (not the empty list) is
returned.
@end deffn

@rnindex memv
@deffn {Scheme Procedure} memv x lst
@deffnx {C Function} scm_memv (x, lst)
Return the first sublist of @var{lst} whose car is @code{eqv?}
to @var{x} where the sublists of @var{lst} are the non-empty
lists returned by @code{(list-tail @var{lst} @var{k})} for
@var{k} less than the length of @var{lst}.  If @var{x} does not
occur in @var{lst}, then @code{#f} (not the empty list) is
returned.
@end deffn

@rnindex member
@deffn {Scheme Procedure} member x lst
@deffnx {C Function} scm_member (x, lst)
Return the first sublist of @var{lst} whose car is
@code{equal?} to @var{x} where the sublists of @var{lst} are
the non-empty lists returned by @code{(list-tail @var{lst}
@var{k})} for @var{k} less than the length of @var{lst}.  If
@var{x} does not occur in @var{lst}, then @code{#f} (not the
empty list) is returned.

See also SRFI-1 which has an extended @code{member} function
(@ref{SRFI-1 Searching}).
@end deffn

@node List Mapping
@subsubsection Поэлементная обработка Списка

Обработка списков очень удобна в Scheme, потому что, процесс итерации
по элементам списка может быть сильно абстрагирован. Процедуры описанные
в этом разделе являются базовыми процедурами итерации для списков.
Они принимают процедуру и один или несколько списков в качесве
аргументов, и применяют процедуру к каждому элементу списка. Процедуры
отличаются значением которое они возвращают.

@rnindex map
@c begin (texi-doc-string "guile" "map")
@deffn {Scheme Procedure} map proc arg1 arg2 @dots{}
@deffnx {Scheme Procedure} map-in-order proc arg1 arg2 @dots{}
@deffnx {C Function} scm_map (proc, arg1, args)
Apply @var{proc} to each element of the list @var{arg1} (if only two
arguments are given), or to the corresponding elements of the argument
lists (if more than two arguments are given).  The result(s) of the
procedure applications are saved and returned in a list.  For
@code{map}, the order of procedure applications is not specified,
@code{map-in-order} applies the procedure from left to right to the list
elements.
@end deffn

@rnindex for-each
@c begin (texi-doc-string "guile" "for-each")
@deffn {Scheme Procedure} for-each proc arg1 arg2 @dots{}
Like @code{map}, but the procedure is always applied from left to right,
and the result(s) of the procedure applications are thrown away.  The
return value is not specified.
@end deffn

See also SRFI-1 which extends these functions to take lists of unequal
lengths (@ref{SRFI-1 Fold and Map}).

@node Vectors
@subsection Векторы
@tpindex Vectors

Векторы - это последовательности объектов Scheme.  В отличие от списков длина
вектора, после создания вектора, не может быть изменена. Преимущество
векторов над списками заключается в том, что требуемое время для доступа
к одному элементу вектора, с учетом его положения(синоним индекса) относительно
нулевой позиции, является константой, тогда как списки имеют время доступа
линейное по отношению к позиции доступа элемета в списке.

Векторы могут содержать любой объект Scheme; возможно даже иметь
разные типы объектов в одном и том же векторе. Для векторов,
содержащих векторы, вместо них вы можете использовать Массивы.
Заметим также, что векторы являются частным случаем одномерных
неоднородных массивов и большинство процедур для Массивов успешно
работают и на Векорах. (@pxref{Arrays})

Also see @ref{SRFI-43}, for a comprehensive vector library.

@menu
* Vector Syntax::               Read syntax for vectors.
* Vector Creation::             Dynamic vector creation and validation.
* Vector Accessors::            Accessing and modifying vector contents.
* Vector Accessing from C::     Ways to work with vectors from C.
* Uniform Numeric Vectors::     Vectors of unboxed numeric values.
@end menu

@node Vector Syntax
@subsubsection Синтаксис чтения для Векторов

Векторы можно определить в исходном коде, подобно строкам, символам или 
некоторым другим типам данных. Синтаксис чтения для векторов слеюдующий:
символ решетки (@code{#}), за которым следует открывающая круглая скобка,
далее все элементы вектора в соотвествующем им синтаксисе чтения и, 
наконец, закрывающая круглая скобка. Подобно строкам векторам не нужно
указывать знак квотирования.



Ниже приведены примеры синтаксиса чтения для векторов; где только первый
вектор содержит числа и три разных типа объекта: строку, символ и
число в шестнадцатеричной форме.

@lisp
#(1 2 3)
#("Hello" foo #xdeadbeef)
@end lisp

@node Vector Creation
@subsubsection Динамическое создание и проверка Вектора

Вместо того, чтобы создавать векторы неявно, используя только что 
описанный синтаксис чтения, вы можете создать вектор динамически, 
вызывая одну из процедур @code{vector} и @code{list->vector} со
списком значений Scheme, которые вы хотите поместить в вектор.
Размер вектора созданный таким образом, определяется неявно
количеством доступных аргументов.

@rnindex vector
@rnindex list->vector
@deffn {Scheme Procedure} vector arg @dots{}
@deffnx {Scheme Procedure} list->vector l
@deffnx {C Function} scm_vector (l)
Return a newly allocated vector composed of the
given arguments.  Analogous to @code{list}.

@lisp
(vector 'a 'b 'c) @result{} #(a b c)
@end lisp
@end deffn

The inverse operation is @code{vector->list}:

@rnindex vector->list
@deffn {Scheme Procedure} vector->list v
@deffnx {C Function} scm_vector_to_list (v)
Return a newly allocated list composed of the elements of @var{v}.

@lisp
(vector->list #(dah dah didah)) @result{}  (dah dah didah)
(list->vector '(dididit dah)) @result{}  #(dididit dah)
@end lisp
@end deffn

To allocate a vector with an explicitly specified size, use
@code{make-vector}.  With this primitive you can also specify an initial
value for the vector elements (the same value for all elements, that
is):

@rnindex make-vector
@deffn {Scheme Procedure} make-vector len [fill]
@deffnx {C Function} scm_make_vector (len, fill)
Return a newly allocated vector of @var{len} elements.  If a
second argument is given, then each position is initialized to
@var{fill}.  Otherwise the initial contents of each position is
unspecified.
@end deffn

@deftypefn {C Function} SCM scm_c_make_vector (size_t k, SCM fill)
Like @code{scm_make_vector}, but the length is given as a @code{size_t}.
@end deftypefn

To check whether an arbitrary Scheme value @emph{is} a vector, use the
@code{vector?} primitive:

@rnindex vector?
@deffn {Scheme Procedure} vector? obj
@deffnx {C Function} scm_vector_p (obj)
Return @code{#t} if @var{obj} is a vector, otherwise return
@code{#f}.
@end deffn

@deftypefn {C Function} int scm_is_vector (SCM obj)
Return non-zero when @var{obj} is a vector, otherwise return
@code{zero}.
@end deftypefn

@node Vector Accessors
@subsubsection Доступ и Модификация содержимого Вектора

процедуры @code{vector-length} и @code{vector-ref} возвращают информацию
об определенном векторе, соответственно длину вектора и элементы,
которые содержит вектор.

@rnindex vector-length
@deffn {Scheme Procedure} vector-length vector
@deffnx {C Function} scm_vector_length (vector)
Return the number of elements in @var{vector} as an exact integer.
@end deffn

@deftypefn {C Function} size_t scm_c_vector_length (SCM vec)
Return the number of elements in @var{vec} as a @code{size_t}.
@end deftypefn

@rnindex vector-ref
@deffn {Scheme Procedure} vector-ref vec k
@deffnx {C Function} scm_vector_ref (vec, k)
Return the contents of position @var{k} of @var{vec}.
@var{k} must be a valid index of @var{vec}.
@lisp
(vector-ref #(1 1 2 3 5 8 13 21) 5) @result{} 8
(vector-ref #(1 1 2 3 5 8 13 21)
    (let ((i (round (* 2 (acos -1)))))
      (if (inexact? i)
        (inexact->exact i)
           i))) @result{} 13
@end lisp
@end deffn

@deftypefn {C Function} SCM scm_c_vector_ref (SCM vec, size_t k)
Return the contents of position @var{k} (a @code{size_t}) of
@var{vec}.
@end deftypefn

A vector created by one of the dynamic vector constructor procedures
(@pxref{Vector Creation}) can be modified using the following
procedures.

@emph{NOTE:} According to R5RS, it is an error to use any of these
procedures on a literally read vector, because such vectors should be
considered as constants.  Currently, however, Guile does not detect this
error.

@rnindex vector-set!
@deffn {Scheme Procedure} vector-set! vec k obj
@deffnx {C Function} scm_vector_set_x (vec, k, obj)
Store @var{obj} in position @var{k} of @var{vec}.
@var{k} must be a valid index of @var{vec}.
The value returned by @samp{vector-set!} is unspecified.
@lisp
(let ((vec (vector 0 '(2 2 2 2) "Anna")))
  (vector-set! vec 1 '("Sue" "Sue"))
  vec) @result{}  #(0 ("Sue" "Sue") "Anna")
@end lisp
@end deffn

@deftypefn {C Function} void scm_c_vector_set_x (SCM vec, size_t k, SCM obj)
Store @var{obj} in position @var{k} (a @code{size_t}) of @var{vec}.
@end deftypefn

@rnindex vector-fill!
@deffn {Scheme Procedure} vector-fill! vec fill
@deffnx {C Function} scm_vector_fill_x (vec, fill)
Store @var{fill} in every position of @var{vec}.  The value
returned by @code{vector-fill!} is unspecified.
@end deffn

@deffn {Scheme Procedure} vector-copy vec
@deffnx {C Function} scm_vector_copy (vec)
Return a copy of @var{vec}.
@end deffn

@deffn {Scheme Procedure} vector-move-left! vec1 start1 end1 vec2 start2
@deffnx {C Function} scm_vector_move_left_x (vec1, start1, end1, vec2, start2)
Copy elements from @var{vec1}, positions @var{start1} to @var{end1},
to @var{vec2} starting at position @var{start2}.  @var{start1} and
@var{start2} are inclusive indices; @var{end1} is exclusive.

@code{vector-move-left!} copies elements in leftmost order.
Therefore, in the case where @var{vec1} and @var{vec2} refer to the
same vector, @code{vector-move-left!} is usually appropriate when
@var{start1} is greater than @var{start2}.
@end deffn

@deffn {Scheme Procedure} vector-move-right! vec1 start1 end1 vec2 start2
@deffnx {C Function} scm_vector_move_right_x (vec1, start1, end1, vec2, start2)
Copy elements from @var{vec1}, positions @var{start1} to @var{end1},
to @var{vec2} starting at position @var{start2}.  @var{start1} and
@var{start2} are inclusive indices; @var{end1} is exclusive.

@code{vector-move-right!} copies elements in rightmost order.
Therefore, in the case where @var{vec1} and @var{vec2} refer to the
same vector, @code{vector-move-right!} is usually appropriate when
@var{start1} is less than @var{start2}.
@end deffn

@node Vector Accessing from C
@subsubsection Доступк в Вектору из Си

Вектор можно считывать и изменять из Си ,например, с помощью функций
@code{scm_c_vector_ref} и @code{scm_c_vector_set_x}.  В дополнение
к этим функциям есть еще два способа доступа к векторам из Си,
которые могут быть эффективными в определенных ситуациях: вы можете
ограничить себя работой с простыми векторами @dfn{simple vectors} и
затем использовать очень быстрые простые векторные макросы; или вы
можете воспользоваться базовым доступом ко всем типам Массивов
(@pxref{Accessing Arrays from C}), более подробно, но может 
эффективно работать со всеми видами векторов(и массивов).  
Для векторов, вы можете использовать функции @code{scm_vector_elements} 
и  @code{scm_vector_writable_elements}.


@deftypefn {C Function} int scm_is_simple_vector (SCM obj)
Return non-zero if @var{obj} is a simple vector, else return zero.  A
simple vector is a vector that can be used with the @code{SCM_SIMPLE_*}
macros below.

The following functions are guaranteed to return simple vectors:
@code{scm_make_vector}, @code{scm_c_make_vector}, @code{scm_vector},
@code{scm_list_to_vector}.
@end deftypefn

@deftypefn {C Macro} size_t SCM_SIMPLE_VECTOR_LENGTH (SCM vec)
Evaluates to the length of the simple vector @var{vec}.  No type
checking is done.
@end deftypefn

@deftypefn {C Macro} SCM SCM_SIMPLE_VECTOR_REF (SCM vec, size_t idx)
Evaluates to the element at position @var{idx} in the simple vector
@var{vec}.  No type or range checking is done.
@end deftypefn

@deftypefn {C Macro} void SCM_SIMPLE_VECTOR_SET (SCM vec, size_t idx, SCM val)
Sets the element at position @var{idx} in the simple vector
@var{vec} to @var{val}.  No type or range checking is done.
@end deftypefn

@deftypefn {C Function} {const SCM *} scm_vector_elements (SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
Acquire a handle for the vector @var{vec} and return a pointer to the
elements of it.  This pointer can only be used to read the elements of
@var{vec}.  When @var{vec} is not a vector, an error is signaled.  The
handle must eventually be released with
@code{scm_array_handle_release}.

The variables pointed to by @var{lenp} and @var{incp} are filled with
the number of elements of the vector and the increment (number of
elements) between successive elements, respectively.  Successive
elements of @var{vec} need not be contiguous in their underlying
``root vector'' returned here; hence the increment is not necessarily
equal to 1 and may well be negative too (@pxref{Shared Arrays}).

The following example shows the typical way to use this function.  It
creates a list of all elements of @var{vec} (in reverse order).

@example
scm_t_array_handle handle;
size_t i, len;
ssize_t inc;
const SCM *elt;
SCM list;

elt = scm_vector_elements (vec, &handle, &len, &inc);
list = SCM_EOL;
for (i = 0; i < len; i++, elt += inc)
  list = scm_cons (*elt, list);
scm_array_handle_release (&handle);
@end example

@end deftypefn

@deftypefn {C Function} {SCM *} scm_vector_writable_elements (SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)
Like @code{scm_vector_elements} but the pointer can be used to modify
the vector.

The following example shows the typical way to use this function.  It
fills a vector with @code{#t}.

@example
scm_t_array_handle handle;
size_t i, len;
ssize_t inc;
SCM *elt;

elt = scm_vector_writable_elements (vec, &handle, &len, &inc);
for (i = 0; i < len; i++, elt += inc)
  *elt = SCM_BOOL_T;
scm_array_handle_release (&handle);
@end example

@end deftypefn

@node Uniform Numeric Vectors
@subsubsection Унифицированные Числовые Вектора

Унифицированным числовым вектором является вектор, элементы которого 
представляют собой один числовой тип. Guile предоставляет унифицированные
числовые вектора для знаковых и бесзнаковых 8-битных, 16-битных, 32 и 64
битных целых, чисел с плавающей точкой, комплексных чисел. Дополнительная 
информация @xref{SRFI-4}

Для многих целей, байтовые векторы работают также, как и унифицированные
векторы, и имеют преимущество тем что хорошо интегрируются с 
двоичным вводом и выводом. Для получения дополнительной информации
о байтовых векторах @xref{Bytevectors}.

@node Bit Vectors
@subsection Битовые Вектора

@noindent
Битовыми векторами являются с нулевого индекса одномерные булевые 
массивы. Они отображаются как последовательность @code{0} и @code{1} 
с префиксом @code{#*}, например,

@example
(make-bitvector 8 #f) @result{}
#*00000000
@end example

Битовые векторы являются частным случаем одномерных битовых массивов
и поэтому к ним могут быть применены процедуры для работы с Массивами,
@xref{Arrays}.

@deffn {Scheme Procedure} bitvector? obj
@deffnx {C Function} scm_bitvector_p (obj)
Return @code{#t} when @var{obj} is a bitvector, else
return @code{#f}.
@end deffn

@deftypefn {C Function} int scm_is_bitvector (SCM obj)
Return @code{1} when @var{obj} is a bitvector, else return @code{0}.
@end deftypefn

@deffn {Scheme Procedure} make-bitvector len [fill]
@deffnx {C Function} scm_make_bitvector (len, fill)
Create a new bitvector of length @var{len} and
optionally initialize all elements to @var{fill}.
@end deffn

@deftypefn {C Function} SCM scm_c_make_bitvector (size_t len, SCM fill)
Like @code{scm_make_bitvector}, but the length is given as a
@code{size_t}.
@end deftypefn

@deffn {Scheme Procedure} bitvector bit @dots{}
@deffnx {C Function} scm_bitvector (bits)
Create a new bitvector with the arguments as elements.
@end deffn

@deffn {Scheme Procedure} bitvector-length vec
@deffnx {C Function} scm_bitvector_length (vec)
Return the length of the bitvector @var{vec}.
@end deffn

@deftypefn {C Function} size_t scm_c_bitvector_length (SCM vec)
Like @code{scm_bitvector_length}, but the length is returned as a
@code{size_t}.
@end deftypefn

@deffn {Scheme Procedure} bitvector-ref vec idx
@deffnx {C Function} scm_bitvector_ref (vec, idx)
Return the element at index @var{idx} of the bitvector
@var{vec}.
@end deffn

@deftypefn {C Function} SCM scm_c_bitvector_ref (SCM vec, size_t idx)
Return the element at index @var{idx} of the bitvector
@var{vec}.
@end deftypefn

@deffn {Scheme Procedure} bitvector-set! vec idx val
@deffnx {C Function} scm_bitvector_set_x (vec, idx, val)
Set the element at index @var{idx} of the bitvector
@var{vec} when @var{val} is true, else clear it.
@end deffn

@deftypefn {C Function} SCM scm_c_bitvector_set_x (SCM vec, size_t idx, SCM val)
Set the element at index @var{idx} of the bitvector
@var{vec} when @var{val} is true, else clear it.
@end deftypefn

@deffn {Scheme Procedure} bitvector-fill! vec val
@deffnx {C Function} scm_bitvector_fill_x (vec, val)
Set all elements of the bitvector
@var{vec} when @var{val} is true, else clear them.
@end deffn

@deffn {Scheme Procedure} list->bitvector list
@deffnx {C Function} scm_list_to_bitvector (list)
Return a new bitvector initialized with the elements
of @var{list}.
@end deffn

@deffn {Scheme Procedure} bitvector->list vec
@deffnx {C Function} scm_bitvector_to_list (vec)
Return a new list initialized with the elements
of the bitvector @var{vec}.
@end deffn

@deffn {Scheme Procedure} bit-count bool bitvector
@deffnx {C Function} scm_bit_count (bool, bitvector)
Return a count of how many entries in @var{bitvector} are equal to
@var{bool}.  For example,

@example
(bit-count #f #*000111000)  @result{} 6
@end example
@end deffn

@deffn {Scheme Procedure} bit-position bool bitvector start
@deffnx {C Function} scm_bit_position (bool, bitvector, start)
Return the index of the first occurrence of @var{bool} in
@var{bitvector}, starting from @var{start}.  If there is no @var{bool}
entry between @var{start} and the end of @var{bitvector}, then return
@code{#f}.  For example,

@example
(bit-position #t #*000101 0)  @result{} 3
(bit-position #f #*0001111 3) @result{} #f
@end example
@end deffn

@deffn {Scheme Procedure} bit-invert! bitvector
@deffnx {C Function} scm_bit_invert_x (bitvector)
Modify @var{bitvector} by replacing each element with its negation.
@end deffn

@deffn {Scheme Procedure} bit-set*! bitvector uvec bool
@deffnx {C Function} scm_bit_set_star_x (bitvector, uvec, bool)
Set entries of @var{bitvector} to @var{bool}, with @var{uvec}
selecting the entries to change.  The return value is unspecified.

If @var{uvec} is a bit vector, then those entries where it has
@code{#t} are the ones in @var{bitvector} which are set to @var{bool}.
@var{uvec} and @var{bitvector} must be the same length.  When
@var{bool} is @code{#t} it's like @var{uvec} is OR'ed into
@var{bitvector}.  Or when @var{bool} is @code{#f} it can be seen as an
ANDNOT.

@example
(define bv #*01000010)
(bit-set*! bv #*10010001 #t)
bv
@result{} #*11010011
@end example

If @var{uvec} is a uniform vector of unsigned long integers, then
they're indexes into @var{bitvector} which are set to @var{bool}.  

@example
(define bv #*01000010)
(bit-set*! bv #u(5 2 7) #t)
bv
@result{} #*01100111
@end example
@end deffn

@deffn {Scheme Procedure} bit-count* bitvector uvec bool
@deffnx {C Function} scm_bit_count_star (bitvector, uvec, bool)
Return a count of how many entries in @var{bitvector} are equal to
@var{bool}, with @var{uvec} selecting the entries to consider.

@var{uvec} is interpreted in the same way as for @code{bit-set*!}
above.  Namely, if @var{uvec} is a bit vector then entries which have
@code{#t} there are considered in @var{bitvector}.  Or if @var{uvec}
is a uniform vector of unsigned long integers then it's the indexes in
@var{bitvector} to consider.

For example,

@example
(bit-count* #*01110111 #*11001101 #t) @result{} 3
(bit-count* #*01110111 #u32(7 0 4) #f)  @result{} 2
@end example
@end deffn

@deftypefn {C Function} {const scm_t_uint32 *} scm_bitvector_elements (SCM vec, scm_t_array_handle *handle, size_t *offp, size_t *lenp, ssize_t *incp)
Like @code{scm_vector_elements} (@pxref{Vector Accessing from C}), but
for bitvectors.  The variable pointed to by @var{offp} is set to the
value returned by @code{scm_array_handle_bit_elements_offset}.  See
@code{scm_array_handle_bit_elements} for how to use the returned
pointer and the offset.
@end deftypefn

@deftypefn {C Function} {scm_t_uint32 *} scm_bitvector_writable_elements (SCM vec, scm_t_array_handle *handle, size_t *offp, size_t *lenp, ssize_t *incp)
Like @code{scm_bitvector_elements}, but the pointer is good for reading
and writing.
@end deftypefn

@node Bytevectors
@subsection Байтовые вектора

@cindex bytevector
@cindex R6RS

A @dfn{bytevector}байтовый вектор это чистая байтовая строка.  
Модуль @code{(rnrs bytevectors)} обеспечивает программный интерфес, 
указанный в @uref{http://www.r6rs.org/, Revised^6 Report on the Algorithmic
 Language Scheme (R6RS)}.  Он содержит процедуры манипулирования байтовыми
векторами и функции их интерпретации различными способами: байтовый вектор
может представить как знаковое или беззнаковое целое различной длины и
порядка следования байт, как число с плавающей точкой представленное по стандарту
IEEE-754, или как стороку.  Это полезный инструмент для кодирования и декодирования
двоичных данных.

R6RS (Section 4.3.4) определяет внешнее представление для байтовых векторов,
в соответствии с которым октеты (целые числа в пределах 0--255) содержащиеся
в байтовом векторе представляются в виде списка с префиксом @code{#vu8}:

@lisp
#vu8(1 53 204)
@end lisp

обозначает 3-байтовый байтовый вектор содержащий октеты 1, 53, и 204.  Подобно
строковым литералам, булевым знчениям и др., байтовые векторы являюстя
``само-квотируемыми'', т.е. им не нужно указвать квотирование:

@lisp
#vu8(1 53 204)
@result{} #vu8(1 53 204)
@end lisp

Байтовые вектора могут использоваться с двоичными входными/выходными
примитивами (@pxref{Binary I/O}).

@menu
* Bytevector Endianness::       Dealing with byte order.
* Bytevector Manipulation::     Creating, copying, manipulating bytevectors.
* Bytevectors as Integers::     Interpreting bytes as integers.
* Bytevectors and Integer Lists::  Converting to/from an integer list.
* Bytevectors as Floats::       Interpreting bytes as real numbers.
* Bytevectors as Strings::      Interpreting bytes as Unicode strings.
* Bytevectors as Arrays::       Guile extension to the bytevector API.
* Bytevectors as Uniform Vectors::  Bytevectors and SRFI-4.
@end menu

@node Bytevector Endianness
@subsubsection Порядок байтов

@cindex endianness
@cindex byte order
@cindex word order

Некоторые из следующих процедур принимают параметр порядок байтов
@var{endianness}. Порядок байтов @dfn{endianness} определяет какой
порядок у байтов в многобайтовых числах: числа кодированные как
@dfn{big endian} имеют свои самые значащие байты записанными первыми,
тогда как числа кодированные как @dfn{little endian} первыми имеют
самые младшие байты@footnote{Big-endian и little-endian являются 
наиболее распространенными способами упорядочения байт в многобайтовых
числах, но существуют и другие. Например библиотека  GNU MP
допускает @dfn{порядок слов} независимый от @dfn{порядка байтов} 
(@pxref{Integer Import and Export,,, gmp, The GNU
Multiple Precision Arithmetic Library Manual}).}.

Little-endian -это внутренняя спецификация порядка байтов архитектуры
IA32 и ее производных, в то время как big-endian является родным для
SPARC и PowerPC, среди прочих. Процедура @code{native-endianness} 
возвращает внутреннюю спецификацию машины, на которой она работает.

@deffn {Scheme Procedure} native-endianness
@deffnx {C Function} scm_native_endianness ()
Return a value denoting the native endianness of the host machine.
@end deffn

@deffn {Scheme Macro} endianness symbol
Return an object denoting the endianness specified by @var{symbol}.  If
@var{symbol} is neither @code{big} nor @code{little} then an error is
raised at expand-time.
@end deffn

@defvr {C Variable} scm_endianness_big
@defvrx {C Variable} scm_endianness_little
The objects denoting big- and little-endianness, respectively.
@end defvr

@node Bytevector Manipulation
@subsubsection Манипулирование Байтовыми Векторами

Байтовый вектор может быть создан, скопирован и проанализирован и передан
процедурам и функциям Си.

@deffn {Scheme Procedure} make-bytevector len [fill]
@deffnx {C Function} scm_make_bytevector (len, fill)
@deffnx {C Function} scm_c_make_bytevector (size_t len)
Return a new bytevector of @var{len} bytes.  Optionally, if @var{fill}
is given, fill it with @var{fill}; @var{fill} must be in the range
[-128,255].
@end deffn

@deffn {Scheme Procedure} bytevector? obj
@deffnx {C Function} scm_bytevector_p (obj)
Return true if @var{obj} is a bytevector.
@end deffn

@deftypefn {C Function} int scm_is_bytevector (SCM obj)
Equivalent to @code{scm_is_true (scm_bytevector_p (obj))}.
@end deftypefn

@deffn {Scheme Procedure} bytevector-length bv
@deffnx {C Function} scm_bytevector_length (bv)
Return the length in bytes of bytevector @var{bv}.
@end deffn

@deftypefn {C Function} size_t scm_c_bytevector_length (SCM bv)
Likewise, return the length in bytes of bytevector @var{bv}.
@end deftypefn

@deffn {Scheme Procedure} bytevector=? bv1 bv2
@deffnx {C Function} scm_bytevector_eq_p (bv1, bv2)
Return is @var{bv1} equals to @var{bv2}---i.e., if they have the same
length and contents.
@end deffn

@deffn {Scheme Procedure} bytevector-fill! bv fill
@deffnx {C Function} scm_bytevector_fill_x (bv, fill)
Fill bytevector @var{bv} with @var{fill}, a byte.
@end deffn

@deffn {Scheme Procedure} bytevector-copy! source source-start target target-start len
@deffnx {C Function} scm_bytevector_copy_x (source, source_start, target, target_start, len)
Copy @var{len} bytes from @var{source} into @var{target}, starting
reading from @var{source-start} (a positive index within @var{source})
and start writing at @var{target-start}.  It is permitted for the
@var{source} and @var{target} regions to overlap.
@end deffn

@deffn {Scheme Procedure} bytevector-copy bv
@deffnx {C Function} scm_bytevector_copy (bv)
Return a newly allocated copy of @var{bv}.
@end deffn

@deftypefn {C Function} scm_t_uint8 scm_c_bytevector_ref (SCM bv, size_t index)
Return the byte at @var{index} in bytevector @var{bv}.
@end deftypefn

@deftypefn {C Function} void scm_c_bytevector_set_x (SCM bv, size_t index, scm_t_uint8 value)
Set the byte at @var{index} in @var{bv} to @var{value}.
@end deftypefn

Low-level C macros are available.  They do not perform any
type-checking; as such they should be used with care.

@deftypefn {C Macro} size_t SCM_BYTEVECTOR_LENGTH (bv)
Return the length in bytes of bytevector @var{bv}.
@end deftypefn

@deftypefn {C Macro} {signed char *} SCM_BYTEVECTOR_CONTENTS (bv)
Return a pointer to the contents of bytevector @var{bv}.
@end deftypefn

@node Bytevectors as Integers
@subsubsection Интерпретация Байтового Вектора как Целого

Содержимое байтовго вектора можно интерпретировать как последовательность
целых чисел любого заданного размера, знака и порядка следования байтов.

@lisp
(let ((bv (make-bytevector 4)))
  (bytevector-u8-set! bv 0 #x12)
  (bytevector-u8-set! bv 1 #x34)
  (bytevector-u8-set! bv 2 #x56)
  (bytevector-u8-set! bv 3 #x78)

  (map (lambda (number)
         (number->string number 16))
       (list (bytevector-u8-ref bv 0)
             (bytevector-u16-ref bv 0 (endianness big))
             (bytevector-u32-ref bv 0 (endianness little)))))

@result{} ("12" "1234" "78563412")
@end lisp

Ниже описаны наиболее общие процедуры для интерпретации содержимого в виде
целых чисел.

@deffn {Scheme Procedure} bytevector-uint-ref bv index endianness size
@deffnx {C Function} scm_bytevector_uint_ref (bv, index, endianness, size)
Return the @var{size}-byte long unsigned integer at index @var{index} in
@var{bv}, decoded according to @var{endianness}.
@end deffn

@deffn {Scheme Procedure} bytevector-sint-ref bv index endianness size
@deffnx {C Function} scm_bytevector_sint_ref (bv, index, endianness, size)
Return the @var{size}-byte long signed integer at index @var{index} in
@var{bv}, decoded according to @var{endianness}.
@end deffn

@deffn {Scheme Procedure} bytevector-uint-set! bv index value endianness size
@deffnx {C Function} scm_bytevector_uint_set_x (bv, index, value, endianness, size)
Set the @var{size}-byte long unsigned integer at @var{index} to
@var{value}, encoded according to @var{endianness}.
@end deffn

@deffn {Scheme Procedure} bytevector-sint-set! bv index value endianness size
@deffnx {C Function} scm_bytevector_sint_set_x (bv, index, value, endianness, size)
Set the @var{size}-byte long signed integer at @var{index} to
@var{value}, encoded according to @var{endianness}.
@end deffn

The following procedures are similar to the ones above, but specialized
to a given integer size:

@deffn {Scheme Procedure} bytevector-u8-ref bv index
@deffnx {Scheme Procedure} bytevector-s8-ref bv index
@deffnx {Scheme Procedure} bytevector-u16-ref bv index endianness
@deffnx {Scheme Procedure} bytevector-s16-ref bv index endianness
@deffnx {Scheme Procedure} bytevector-u32-ref bv index endianness
@deffnx {Scheme Procedure} bytevector-s32-ref bv index endianness
@deffnx {Scheme Procedure} bytevector-u64-ref bv index endianness
@deffnx {Scheme Procedure} bytevector-s64-ref bv index endianness
@deffnx {C Function} scm_bytevector_u8_ref (bv, index)
@deffnx {C Function} scm_bytevector_s8_ref (bv, index)
@deffnx {C Function} scm_bytevector_u16_ref (bv, index, endianness)
@deffnx {C Function} scm_bytevector_s16_ref (bv, index, endianness)
@deffnx {C Function} scm_bytevector_u32_ref (bv, index, endianness)
@deffnx {C Function} scm_bytevector_s32_ref (bv, index, endianness)
@deffnx {C Function} scm_bytevector_u64_ref (bv, index, endianness)
@deffnx {C Function} scm_bytevector_s64_ref (bv, index, endianness)
Return the unsigned @var{n}-bit (signed) integer (where @var{n} is 8,
16, 32 or 64) from @var{bv} at @var{index}, decoded according to
@var{endianness}.
@end deffn

@deffn {Scheme Procedure} bytevector-u8-set! bv index value
@deffnx {Scheme Procedure} bytevector-s8-set! bv index value
@deffnx {Scheme Procedure} bytevector-u16-set! bv index value endianness
@deffnx {Scheme Procedure} bytevector-s16-set! bv index value endianness
@deffnx {Scheme Procedure} bytevector-u32-set! bv index value endianness
@deffnx {Scheme Procedure} bytevector-s32-set! bv index value endianness
@deffnx {Scheme Procedure} bytevector-u64-set! bv index value endianness
@deffnx {Scheme Procedure} bytevector-s64-set! bv index value endianness
@deffnx {C Function} scm_bytevector_u8_set_x (bv, index, value)
@deffnx {C Function} scm_bytevector_s8_set_x (bv, index, value)
@deffnx {C Function} scm_bytevector_u16_set_x (bv, index, value, endianness)
@deffnx {C Function} scm_bytevector_s16_set_x (bv, index, value, endianness)
@deffnx {C Function} scm_bytevector_u32_set_x (bv, index, value, endianness)
@deffnx {C Function} scm_bytevector_s32_set_x (bv, index, value, endianness)
@deffnx {C Function} scm_bytevector_u64_set_x (bv, index, value, endianness)
@deffnx {C Function} scm_bytevector_s64_set_x (bv, index, value, endianness)
Store @var{value} as an @var{n}-bit (signed) integer (where @var{n} is
8, 16, 32 or 64) in @var{bv} at @var{index}, encoded according to
@var{endianness}.
@end deffn

Finally, a variant specialized for the host's endianness is available
for each of these functions (with the exception of the @code{u8} and
@code{s8} accessors, as endianness is about byte order and there is only
1 byte):

@deffn {Scheme Procedure} bytevector-u16-native-ref bv index
@deffnx {Scheme Procedure} bytevector-s16-native-ref bv index
@deffnx {Scheme Procedure} bytevector-u32-native-ref bv index
@deffnx {Scheme Procedure} bytevector-s32-native-ref bv index
@deffnx {Scheme Procedure} bytevector-u64-native-ref bv index
@deffnx {Scheme Procedure} bytevector-s64-native-ref bv index
@deffnx {C Function} scm_bytevector_u16_native_ref (bv, index)
@deffnx {C Function} scm_bytevector_s16_native_ref (bv, index)
@deffnx {C Function} scm_bytevector_u32_native_ref (bv, index)
@deffnx {C Function} scm_bytevector_s32_native_ref (bv, index)
@deffnx {C Function} scm_bytevector_u64_native_ref (bv, index)
@deffnx {C Function} scm_bytevector_s64_native_ref (bv, index)
Return the unsigned @var{n}-bit (signed) integer (where @var{n} is 8,
16, 32 or 64) from @var{bv} at @var{index}, decoded according to the
host's native endianness.
@end deffn

@deffn {Scheme Procedure} bytevector-u16-native-set! bv index value
@deffnx {Scheme Procedure} bytevector-s16-native-set! bv index value
@deffnx {Scheme Procedure} bytevector-u32-native-set! bv index value
@deffnx {Scheme Procedure} bytevector-s32-native-set! bv index value
@deffnx {Scheme Procedure} bytevector-u64-native-set! bv index value
@deffnx {Scheme Procedure} bytevector-s64-native-set! bv index value
@deffnx {C Function} scm_bytevector_u16_native_set_x (bv, index, value)
@deffnx {C Function} scm_bytevector_s16_native_set_x (bv, index, value)
@deffnx {C Function} scm_bytevector_u32_native_set_x (bv, index, value)
@deffnx {C Function} scm_bytevector_s32_native_set_x (bv, index, value)
@deffnx {C Function} scm_bytevector_u64_native_set_x (bv, index, value)
@deffnx {C Function} scm_bytevector_s64_native_set_x (bv, index, value)
Store @var{value} as an @var{n}-bit (signed) integer (where @var{n} is
8, 16, 32 or 64) in @var{bv} at @var{index}, encoded according to the
host's native endianness.
@end deffn

@node Bytevectors and Integer Lists
@subsubsection Преобразование байтового вектора в/из списка целых чисел

Содержимое байтового вектора может быть легко преобразовано в/из спис(ок/ка)
знаковых или беззнаковых целых чисел:

@lisp
(bytevector->sint-list (u8-list->bytevector (make-list 4 255))
                       (endianness little) 2)
@result{} (-1 -1)
@end lisp

@deffn {Scheme Procedure} bytevector->u8-list bv
@deffnx {C Function} scm_bytevector_to_u8_list (bv)
Return a newly allocated list of unsigned 8-bit integers from the
contents of @var{bv}.
@end deffn

@deffn {Scheme Procedure} u8-list->bytevector lst
@deffnx {C Function} scm_u8_list_to_bytevector (lst)
Return a newly allocated bytevector consisting of the unsigned 8-bit
integers listed in @var{lst}.
@end deffn

@deffn {Scheme Procedure} bytevector->uint-list bv endianness size
@deffnx {C Function} scm_bytevector_to_uint_list (bv, endianness, size)
Return a list of unsigned integers of @var{size} bytes representing the
contents of @var{bv}, decoded according to @var{endianness}.
@end deffn

@deffn {Scheme Procedure} bytevector->sint-list bv endianness size
@deffnx {C Function} scm_bytevector_to_sint_list (bv, endianness, size)
Return a list of signed integers of @var{size} bytes representing the
contents of @var{bv}, decoded according to @var{endianness}.
@end deffn

@deffn {Scheme Procedure} uint-list->bytevector lst endianness size
@deffnx {C Function} scm_uint_list_to_bytevector (lst, endianness, size)
Return a new bytevector containing the unsigned integers listed in
@var{lst} and encoded on @var{size} bytes according to @var{endianness}.
@end deffn

@deffn {Scheme Procedure} sint-list->bytevector lst endianness size
@deffnx {C Function} scm_sint_list_to_bytevector (lst, endianness, size)
Return a new bytevector containing the signed integers listed in
@var{lst} and encoded on @var{size} bytes according to @var{endianness}.
@end deffn

@node Bytevectors as Floats
@subsubsection Интерпретация Байтового Вектора как Числа с плавающей точкой

@cindex IEEE-754 floating point numbers

Содержимое Байтового Вектора можно получить в виде числа с плавающей
точкой одиночной или двойной точности IEEE-754 (соответственно длиной 
32 и 64-бита) используя процедуры описанные здесь.

@deffn {Scheme Procedure} bytevector-ieee-single-ref bv index endianness
@deffnx {Scheme Procedure} bytevector-ieee-double-ref bv index endianness
@deffnx {C Function} scm_bytevector_ieee_single_ref (bv, index, endianness)
@deffnx {C Function} scm_bytevector_ieee_double_ref (bv, index, endianness)
Return the IEEE-754 single-precision floating point number from @var{bv}
at @var{index} according to @var{endianness}.
@end deffn

@deffn {Scheme Procedure} bytevector-ieee-single-set! bv index value endianness
@deffnx {Scheme Procedure} bytevector-ieee-double-set! bv index value endianness
@deffnx {C Function} scm_bytevector_ieee_single_set_x (bv, index, value, endianness)
@deffnx {C Function} scm_bytevector_ieee_double_set_x (bv, index, value, endianness)
Store real number @var{value} in @var{bv} at @var{index} according to
@var{endianness}.
@end deffn

Specialized procedures are also available:

@deffn {Scheme Procedure} bytevector-ieee-single-native-ref bv index
@deffnx {Scheme Procedure} bytevector-ieee-double-native-ref bv index
@deffnx {C Function} scm_bytevector_ieee_single_native_ref (bv, index)
@deffnx {C Function} scm_bytevector_ieee_double_native_ref (bv, index)
Return the IEEE-754 single-precision floating point number from @var{bv}
at @var{index} according to the host's native endianness.
@end deffn

@deffn {Scheme Procedure} bytevector-ieee-single-native-set! bv index value
@deffnx {Scheme Procedure} bytevector-ieee-double-native-set! bv index value
@deffnx {C Function} scm_bytevector_ieee_single_native_set_x (bv, index, value)
@deffnx {C Function} scm_bytevector_ieee_double_native_set_x (bv, index, value)
Store real number @var{value} in @var{bv} at @var{index} according to
the host's native endianness.
@end deffn

@node Bytevectors as Strings
@subsubsection Итерпретация содержимого Байтового Вектора как строки Unicode

@cindex Unicode string encoding

Содержимое байтового вектора также может быть интерпретировано как
строки Unicode, закодированные в одном из самых широко распространенных
форматов кодирования.
@xref{Representing Strings as Bytes}, для более общего интерфейса.

@lisp
(utf8->string (u8-list->bytevector '(99 97 102 101)))
@result{} "cafe"

(string->utf8 "caf@'e") ;; SMALL LATIN LETTER E WITH ACUTE ACCENT
@result{} #vu8(99 97 102 195 169)
@end lisp

@deftypefn {Scheme Procedure} {} string-utf8-length str
@deftypefnx {C function} SCM scm_string_utf8_length (str)
@deftypefnx {C function} size_t scm_c_string_utf8_length (str)
Return the number of bytes in the UTF-8 representation of @var{str}.
@end deftypefn

@deffn {Scheme Procedure} string->utf8 str
@deffnx {Scheme Procedure} string->utf16 str [endianness]
@deffnx {Scheme Procedure} string->utf32 str [endianness]
@deffnx {C Function} scm_string_to_utf8 (str)
@deffnx {C Function} scm_string_to_utf16 (str, endianness)
@deffnx {C Function} scm_string_to_utf32 (str, endianness)
Return a newly allocated bytevector that contains the UTF-8, UTF-16, or
UTF-32 (aka. UCS-4) encoding of @var{str}.  For UTF-16 and UTF-32,
@var{endianness} should be the symbol @code{big} or @code{little}; when omitted,
it defaults to big endian.
@end deffn

@deffn {Scheme Procedure} utf8->string utf
@deffnx {Scheme Procedure} utf16->string utf [endianness]
@deffnx {Scheme Procedure} utf32->string utf [endianness]
@deffnx {C Function} scm_utf8_to_string (utf)
@deffnx {C Function} scm_utf16_to_string (utf, endianness)
@deffnx {C Function} scm_utf32_to_string (utf, endianness)
Return a newly allocated string that contains from the UTF-8-, UTF-16-,
or UTF-32-decoded contents of bytevector @var{utf}.  For UTF-16 and UTF-32,
@var{endianness} should be the symbol @code{big} or @code{little}; when omitted,
it defaults to big endian.
@end deffn

@node Bytevectors as Arrays
@subsubsection Доступ к Байтовому вектору через API работы с Массивами

В качестве расширения для R6RS, Guile позволяет управлять байтовыми
векторами с помощью процедур работы с массивами (@pxref{Arrays}).  
При использовании этого API, байты доспупны по одному как 8-битовы
целые числа без знака:

@example
(define bv #vu8(0 1 2 3))

(array? bv)
@result{} #t

(array-rank bv)
@result{} 1

(array-ref bv 2)
@result{} 2

;; Note the different argument order on array-set!.
(array-set! bv 77 2)
(array-ref bv 2)
@result{} 77

(array-type bv)
@result{} vu8
@end example

@node Bytevectors as Uniform Vectors
@subsubsection Доступ к Байтовому Вектору через SRFI-4 API

Доступ к байтовым векторам также возможен с помощью SRFI-4 API. @xref{SRFI-4 and
Bytevectors}, для получения более подробной информации.

@node Arrays
@subsection Массивы(Arrays)
@tpindex Arrays

@dfn{Arrays} Массивы представляют собой набор ячеек, организованных в
произвольное число измерений. Каждую ячейку можно получить в течении
фиксированного времени, указав индекс для каждого измерения.

В текущей реализации массив использует какой либо вектор для реального
хранения своих элементов. Любой вектор будет работать, поэтому вы можете
иметь массивы единых числовых значений, массивы символов, массивы бит
и конечно массивы произвольных значений Scheme.  Например, массивы
с базовым типом @code{c64vector} могут быть хороши для обработки 
цифровых сигналов, в то время как массивы созданные из @code{u8vector},
могут использоваться для хранения изображений в серой шкалой цветности.

Число измерений массива называется его рангом @dfn{rank}.  Таким
образом, матрица представляет собой массив ранга 2, а вектор имеет
ранг 1. При доступе к элементу массива вы должны указать одно точное
целое для каждого его измерения. Эти целые числа называются индексами
элемента массива. Массив задает допустимый диапазон индексов для каждого
измерения через инклюзивные нижние и верхнии границы. Эти границы
могут быть отритцательными, но верхняя граница должна быть больше нижней 
границы минус 1. Когад все нижние границы равны нулю, он называется
массивом с нулевым началом. @dfn{zero-origin}.

Массивы могут иметь ранг 0, который можно интерпретировать как скаляр.
Таким образом, массив нулевого ранга может хранить ровно один объект,
а список индексов этого элемента - пустой список.

Массивы содержат 0 элементов, когда одна из размерностей равна нулю.
Эти пустые массивы сохраняют информацию об их форме: матрица с нулевыми
столбцами и 3 строками отличается от матрицы с тремя столбцами и
нулем строк, что в свою очередь отличается от вектора нулевой длины.

Процедуры работающие с массивами являются полиморфными, они обрабатывают
строки, унифицированные числовые вектора, байтовые вектора, и обычные
вектора как одномерные массивы.

@menu
* Array Syntax::                
* Array Procedures::            
* Shared Arrays::               
* Arrays as arrays of arrays::
* Accessing Arrays from C::     
@end menu

@node Array Syntax
@subsubsection Синтаксис определения Массивов

Массив отображается как решетка @code{#}, за которой следует ранг,
за которым следует тег, который описывает основной вектор, необязательно
сопровождаемый информацией о его форме, и наконце следуют ячейки, 
организованные по размерностям с помощью круглых скобок.

Другими словами, тег массива имеет вид:

@example
  #<rank><vectag><@@lower><:len><@@lower><:len>...
@end example

где @code{<rank>} - положительное целое число в десятичном значении, задающее
ранг массива. Он может быть опущен когда ранг равен 1, а массив не разделен
и имеет начальный элемент с нулевым индексом (см. ниже).  Для разделяемых
массивов и массивов с ненулевым начальным индексом, ранг указывается всегда, 
даже когда он единичный, и их отличают от обычных векторов.

Часть @code{<vectag>} является тегом для унифицированного числовго вектора,
такого как @code{u8}, @code{s16}, и др., @code{b} для битового вектора, или 
@code{a} для стороки.  Он пуст для обычных векторов.

Часть @code{<@@lower>} начинается с символа @samp{@@} за которым следует
целое число со знаком десятичном значении, которое дает нижнюю границу
размерности массива.  Для каждого измерения существует один @code{<@@lower>} 
Когда все нижние границы равны нулю, все части @code{<@@lower>} опускаются.

Часть @code{<:len>} начинается символом @samp{:}, за которым следует
целое число без знака в десятичном значении, дающее длину размерности.
Как и для нижних границ, для каждого измерения существует только одна
длина @code{<:len>}, и часть @code{<:len>} всегда следует за частью
@code{<@@lower>} для каждого измерения.  Только длины печатаются,
когда массив не может быть выведен из за вложенных списков элементов
массива, что может произойти когда длина хотя бы одной размерности
равна нулю.

В качестве специального случая, массив с рангом равным 0 печтатется
как @code{#0<vectag>(<scalar>)}, где  @code{<scalar>} - это результат
печати одного элемента массива.

Таким образом,

@table @code
@item #(1 2 3)
это обычный массив ранга 1 с нижней границей 0 в размерности 0
(т.е, a это обычный вектор)

@item #@@2(1 2 3)
это обычный массив ранга 1 с нижней границей равной 2 в размерности 0.

@item #2((1 2 3) (4 5 6))
это не унифицированный(содержащий элементы различных типов) массив ранга 2; 
матрица 2@cross{}3 с индексами в области 0..1 и 0..2.

@item #u32(0 1 2)
унифицированный массив типа u32 ранга 1.

@item #2u32@@2@@3((1 2) (2 3))
унифицированный массив с элементами типа u32 ранга 2 с индексами
в пределах 2..3 и 3..4.

@item #2()
представляет собой двухмерный массив с диапазонами индексов 0..-1 и
 0..-1, т.е обе размерности имеют нулевую длину.

@item #2:0:2()
представляет собой двумерный массив с индексами 0..-1 и 0..1, т.е.
первая размрность имеет нулевую длину, а вторая имеет длину 2.

@item #0(12)
это массив с рангом 0 содержащий число 12.

@end table

Кроме того, байтовый вектор (bytevectors) также является массивом, но
использует другой синтаксис:
(@pxref{Bytevectors}):

@table @code

@item #vu8(1 2 3)
представляет собой байтовый вектор длиной в 3-байта, содержащий 1, 2, 3.

@end table

@node Array Procedures
@subsubsection Процедуры работающие с Массивами

Когда создается массив, диапазон каждго измерения должен быть
определен, например, для создания массива 2@cross{}3 с
индексами начинающимися с нуля:

@example
(make-array 'ho 2 3) @result{} #2((ho ho ho) (ho ho ho))
@end example

Диапазон каждого измерения также может быть задан явно, другой способ
создания тогоже массива:

@example
(make-array 'ho '(0 1) '(0 2)) @result{} #2((ho ho ho) (ho ho ho))
@end example

Следующие процедуры могут использоваться с массивами(или векторами).
Аргумент, показанный как @var{idx}@dots{} означает один параметр для каждого
измерения в массива.  Аргумент @var{idxlist} означает список таких значений,
по одному для каждого измерения.

@deffn {Scheme Procedure} array? obj
@deffnx {C Function} scm_array_p (obj, unused)
Return @code{#t} if the @var{obj} is an array, and @code{#f} if
not.

The second argument to scm_array_p is there for historical reasons,
but it is not used.  You should always pass @code{SCM_UNDEFINED} as
its value.
@end deffn

@deffn {Scheme Procedure} typed-array? obj type
@deffnx {C Function} scm_typed_array_p (obj, type)
Return @code{#t} if the @var{obj} is an array of type @var{type}, and
@code{#f} if not.
@end deffn

@deftypefn {C Function} int scm_is_array (SCM obj)
Return @code{1} if the @var{obj} is an array and @code{0} if not.
@end deftypefn

@deftypefn {C Function} int scm_is_typed_array (SCM obj, SCM type)
Return @code{0} if the @var{obj} is an array of type @var{type}, and
@code{1} if not.
@end deftypefn

@deffn {Scheme Procedure} make-array fill bound @dots{}
@deffnx {C Function} scm_make_array (fill, bounds)
Equivalent to @code{(make-typed-array #t @var{fill} @var{bound} ...)}.
@end deffn

@deffn {Scheme Procedure} make-typed-array type fill bound @dots{}
@deffnx {C Function} scm_make_typed_array (type, fill, bounds)
Create and return an array that has as many dimensions as there are
@var{bound}s and (maybe) fill it with @var{fill}.

The underlying storage vector is created according to @var{type},
which must be a symbol whose name is the `vectag' of the array as
explained above, or @code{#t} for ordinary, non-specialized arrays.

For example, using the symbol @code{f64} for @var{type} will create an
array that uses a @code{f64vector} for storing its elements, and
@code{a} will use a string.

When @var{fill} is not the special @emph{unspecified} value, the new
array is filled with @var{fill}.  Otherwise, the initial contents of
the array is unspecified.  The special @emph{unspecified} value is
stored in the variable @code{*unspecified*} so that for example
@code{(make-typed-array 'u32 *unspecified* 4)} creates a uninitialized
@code{u32} vector of length 4.

Each @var{bound} may be a positive non-zero integer @var{n}, in which
case the index for that dimension can range from 0 through @var{n}-1; or
an explicit index range specifier in the form @code{(LOWER UPPER)},
where both @var{lower} and @var{upper} are integers, possibly less than
zero, and possibly the same number (however, @var{lower} cannot be
greater than @var{upper}).
@end deffn

@deffn {Scheme Procedure} list->array dimspec list
Equivalent to @code{(list->typed-array #t @var{dimspec}
@var{list})}.
@end deffn

@deffn {Scheme Procedure} list->typed-array type dimspec list
@deffnx {C Function} scm_list_to_typed_array (type, dimspec, list)
Return an array of the type indicated by @var{type} with elements the
same as those of @var{list}.

The argument @var{dimspec} determines the number of dimensions of the
array and their lower bounds.  When @var{dimspec} is an exact integer,
it gives the number of dimensions directly and all lower bounds are
zero.  When it is a list of exact integers, then each element is the
lower index bound of a dimension, and there will be as many dimensions
as elements in the list.
@end deffn

@deffn {Scheme Procedure} array-type array
@deffnx {C Function} scm_array_type (array)
Return the type of @var{array}.  This is the `vectag' used for
printing @var{array} (or @code{#t} for ordinary arrays) and can be
used with @code{make-typed-array} to create an array of the same kind
as @var{array}.
@end deffn

@deffn {Scheme Procedure} array-ref array idx @dots{}
@deffnx {C Function} scm_array_ref (array, idxlist)
Return the element at @code{(idx @dots{})} in @var{array}.

@example
(define a (make-array 999 '(1 2) '(3 4)))
(array-ref a 2 4) @result{} 999
@end example
@end deffn

@deffn {Scheme Procedure} array-in-bounds? array idx @dots{}
@deffnx {C Function} scm_array_in_bounds_p (array, idxlist)
Return @code{#t} if the given indices would be acceptable to
@code{array-ref}.

@example
(define a (make-array #f '(1 2) '(3 4)))
(array-in-bounds? a 2 3) @result{} #t
(array-in-bounds? a 0 0) @result{} #f
@end example
@end deffn

@deffn {Scheme Procedure} array-set! array obj idx @dots{}
@deffnx {C Function} scm_array_set_x (array, obj, idxlist)
Set the element at @code{(idx @dots{})} in @var{array} to @var{obj}.
The return value is unspecified.

@example
(define a (make-array #f '(0 1) '(0 1)))
(array-set! a #t 1 1)
a @result{} #2((#f #f) (#f #t))
@end example
@end deffn

@deffn {Scheme Procedure} array-shape array
@deffnx {Scheme Procedure} array-dimensions array
@deffnx {C Function} scm_array_dimensions (array)
Return a list of the bounds for each dimension of @var{array}.

@code{array-shape} gives @code{(@var{lower} @var{upper})} for each
dimension.  @code{array-dimensions} instead returns just
@math{@var{upper}+1} for dimensions with a 0 lower bound.  Both are
suitable as input to @code{make-array}.

For example,

@example
(define a (make-array 'foo '(-1 3) 5))
(array-shape a)      @result{} ((-1 3) (0 4))
(array-dimensions a) @result{} ((-1 3) 5)
@end example
@end deffn

@deffn {Scheme Procedure} array-length array
@deffnx {C Function} scm_array_length (array)
@deffnx {C Function} size_t scm_c_array_length (array)
Return the length of an array: its first dimension. It is an error to
ask for the length of an array of rank 0.
@end deffn

@deffn {Scheme Procedure} array-rank array
@deffnx {C Function} scm_array_rank (array)
Return the rank of @var{array}.
@end deffn

@deftypefn {C Function} size_t scm_c_array_rank (SCM array)
Return the rank of @var{array} as a @code{size_t}.
@end deftypefn

@deffn {Scheme Procedure} array->list array
@deffnx {C Function} scm_array_to_list (array)
Return a list consisting of all the elements, in order, of
@var{array}.
@end deffn

@c  FIXME: Describe how the order affects the copying (it matters for
@c  shared arrays with the same underlying root vector, presumably).
@c
@deffn {Scheme Procedure} array-copy! src dst
@deffnx {Scheme Procedure} array-copy-in-order! src dst
@deffnx {C Function} scm_array_copy_x (src, dst)
Copy every element from vector or array @var{src} to the corresponding
element of @var{dst}.  @var{dst} must have the same rank as @var{src},
and be at least as large in each dimension.  The return value is
unspecified.
@end deffn

@deffn {Scheme Procedure} array-fill! array fill
@deffnx {C Function} scm_array_fill_x (array, fill)
Store @var{fill} in every element of @var{array}.  The value returned
is unspecified.
@end deffn

@c begin (texi-doc-string "guile" "array-equal?")
@deffn {Scheme Procedure} array-equal? array @dots{}
Return @code{#t} if all arguments are arrays with the same shape, the
same type, and have corresponding elements which are either
@code{equal?} or @code{array-equal?}.  This function differs from
@code{equal?} (@pxref{Equality}) in that all arguments must be arrays.
@end deffn

@c  FIXME: array-for-each doesn't say what happens if the sources have
@c  different index ranges.  The code currently iterates over the
@c  indices of the first and expects the others to cover those.  That
@c  at least vaguely matches array-map!, but is it meant to be a
@c  documented feature?

@deffn {Scheme Procedure} array-map! dst proc src @dots{}
@deffnx {Scheme Procedure} array-map-in-order! dst proc src @dots{}
@deffnx {C Function} scm_array_map_x (dst, proc, srclist)
Set each element of the @var{dst} array to values obtained from calls to
@var{proc}.  The list of @var{src} arguments may be empty.  The value
returned is unspecified.

Each call is @code{(@var{proc} @var{elem} @dots{})}, where each
@var{elem} is from the corresponding @var{src} array, at the
@var{dst} index.  @code{array-map-in-order!} makes the calls in
row-major order, @code{array-map!} makes them in an unspecified order.

The @var{src} arrays must have the same number of dimensions as
@var{dst}, and must have a range for each dimension which covers the
range in @var{dst}.  This ensures all @var{dst} indices are valid in
each @var{src}.
@end deffn

@deffn {Scheme Procedure} array-for-each proc src1 src2 @dots{}
@deffnx {C Function} scm_array_for_each (proc, src1, srclist)
Apply @var{proc} to each tuple of elements of @var{src1} @var{src2}
@dots{}, in row-major order.  The value returned is unspecified.
@end deffn

@deffn {Scheme Procedure} array-index-map! dst proc
@deffnx {C Function} scm_array_index_map_x (dst, proc)
Set each element of the @var{dst} array to values returned by calls to
@var{proc}.  The value returned is unspecified.

Each call is @code{(@var{proc} @var{i1} @dots{} @var{iN})}, where
@var{i1}@dots{}@var{iN} is the destination index, one parameter for
each dimension.  The order in which the calls are made is unspecified.

For example, to create a @m{4\times4, 4x4} matrix representing a
cyclic group,

@tex
\advance\leftskip by 2\lispnarrowing {
$\left(\matrix{%
0 & 1 & 2 & 3 \cr
1 & 2 & 3 & 0 \cr
2 & 3 & 0 & 1 \cr
3 & 0 & 1 & 2 \cr
}\right)$} \par
@end tex
@ifnottex
@example
    / 0 1 2 3 \
    | 1 2 3 0 |
    | 2 3 0 1 |
    \ 3 0 1 2 /
@end example
@end ifnottex

@example
(define a (make-array #f 4 4))
(array-index-map! a (lambda (i j)
                      (modulo (+ i j) 4)))
@end example
@end deffn

An additional array function is available in the module
@code{(ice-9 arrays)}. It can be used with:

@example
(use-modules (ice-9 arrays))
@end example

@deffn {Scheme Procedure} array-copy src
Return a new array with the same elements, type and shape as
@var{src}. However, the array increments may not be the same as those of
@var{src}. In the current implementation, the returned array will be in
row-major order, but that might change in the future. Use
@code{array-copy!} on an array of known order if that is a concern.
@end deffn

@node Shared Arrays
@subsubsection Общие Массивы

@deffn {Scheme Procedure} make-shared-array oldarray mapfunc bound @dots{}
@deffnx {C Function} scm_make_shared_array (oldarray, mapfunc, boundlist)
Возвращает новый массив, который разделяет хранилище @var{oldarray}.
Изменения, произведенные в нем, влияют на общее хранилище.  Аргументы
@var{bound} @dots{} определяют границы нового массива, такие же как и в
@code{make-array} (@pxref{Array Procedures}).

@var{mapfunc} переводит координаты из нового массива в старый
@var{oldarray}. Она вызывается как @code{(@var{mapfunc} newidx1 @dots{})}
с одним параметром для каждого измерения нового массива, и должна возращать
список индексов для старого массива @var{oldarray}, по одному для каждого
измерения @var{oldarray}.

@var{mapfunc} должна быть афинно линейной, что означает, что каждый
индекс в старом массиве @var{oldarray} должен быть сформирован 
добавлением (возможно отритцательным) целочисленных множителей, 
некоторых или всех новых индексов @var{newidx1} etc, плюс 
возможно целочисленное мещение.
В каждом вызове множители и смещения должны быть одинаковыми.

@sp 1
Одно полезное использование для разделяемого массива - это ограничение
диапазона некоторых измерений, чтобы применить функцию 
@code{array-for-each} или @code{array-fill!} только к части массива.  
Функции @code{list} может использоваться как @var{mapfunc},  в этом 
случае не изменяются значения индексов массива.
Например,

@example
(make-shared-array #2((a b c) (d e f) (g h i)) list 3 2)
@result{} #2((a b) (d e) (g h))
@end example

The new array can have fewer dimensions than @var{oldarray}, for
example to take a column from an array.

@example
(make-shared-array #2((a b c) (d e f) (g h i))
                   (lambda (i) (list i 2))
                   '(0 2))
@result{} #1(c f i)
@end example

A diagonal can be taken by using the single new array index for both
row and column in the old array.  For example,

@example
(make-shared-array #2((a b c) (d e f) (g h i))
                   (lambda (i) (list i i))
                   '(0 2))
@result{} #1(a e i)
@end example

Dimensions can be increased by for instance considering portions of a
one dimensional array as rows in a two dimensional array.
(@code{array-contents} below can do the opposite, flattening an
array.)

@example
(make-shared-array #1(a b c d e f g h i j k l)
                   (lambda (i j) (list (+ (* i 3) j)))
                   4 3)
@result{} #2((a b c) (d e f) (g h i) (j k l))
@end example

By negating an index the order that elements appear can be reversed.
The following just reverses the column order,

@example
(make-shared-array #2((a b c) (d e f) (g h i))
                   (lambda (i j) (list i (- 2 j)))
                   3 3)
@result{} #2((c b a) (f e d) (i h g))
@end example

A fixed offset on indexes allows for instance a change from a 0 based
to a 1 based array,

@example
(define x #2((a b c) (d e f) (g h i)))
(define y (make-shared-array x
                             (lambda (i j) (list (1- i) (1- j)))
                             '(1 3) '(1 3)))
(array-ref x 0 0) @result{} a
(array-ref y 1 1) @result{} a
@end example

A multiple on an index allows every Nth element of an array to be
taken.  The following is every third element,

@example
(make-shared-array #1(a b c d e f g h i j k l)
                   (lambda (i) (list (* i 3)))
                   4)
@result{} #1(a d g j)
@end example

The above examples can be combined to make weird and wonderful
selections from an array, but it's important to note that because
@var{mapfunc} must be affine linear, arbitrary permutations are not
possible.

In the current implementation, @var{mapfunc} is not called for every
access to the new array but only on some sample points to establish a
base and stride for new array indices in @var{oldarray} data.  A few
sample points are enough because @var{mapfunc} is linear.
@end deffn

@deffn {Scheme Procedure} shared-array-increments array
@deffnx {C Function} scm_shared_array_increments (array)
For each dimension, return the distance between elements in the root vector.
@end deffn

@deffn {Scheme Procedure} shared-array-offset array
@deffnx {C Function} scm_shared_array_offset (array)
Return the root vector index of the first element in the array.
@end deffn

@deffn {Scheme Procedure} shared-array-root array
@deffnx {C Function} scm_shared_array_root (array)
Return the root vector of a shared array.
@end deffn

@deffn {Scheme Procedure} array-contents array [strict]
@deffnx {C Function} scm_array_contents (array, strict)
If @var{array} may be @dfn{unrolled} into a one dimensional shared array
without changing their order (last subscript changing fastest), then
@code{array-contents} returns that shared array, otherwise it returns
@code{#f}.  All arrays made by @code{make-array} and
@code{make-typed-array} may be unrolled, some arrays made by
@code{make-shared-array} may not be.

If the optional argument @var{strict} is provided, a shared array will
be returned only if its elements are stored internally contiguous in
memory.
@end deffn

@deffn {Scheme Procedure} transpose-array array dim1 dim2 @dots{}
@deffnx {C Function} scm_transpose_array (array, dimlist)
Return an array sharing contents with @var{array}, but with
dimensions arranged in a different order.  There must be one
@var{dim} argument for each dimension of @var{array}.
@var{dim1}, @var{dim2}, @dots{} should be integers between 0
and the rank of the array to be returned.  Each integer in that
range must appear at least once in the argument list.

The values of @var{dim1}, @var{dim2}, @dots{} correspond to
dimensions in the array to be returned, and their positions in the
argument list to dimensions of @var{array}.  Several @var{dim}s
may have the same value, in which case the returned array will
have smaller rank than @var{array}.

@lisp
(transpose-array '#2((a b) (c d)) 1 0) @result{} #2((a c) (b d))
(transpose-array '#2((a b) (c d)) 0 0) @result{} #1(a d)
(transpose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 1 0) @result{}
                #2((a 4) (b 5) (c 6))
@end lisp
@end deffn

@node Arrays as arrays of arrays
@subsubsection Массивы как массивы массивов

@cindex array cell

Математически, можно увидеть массив ранга @math{n} (н-мерный массив @math{n}-array)
как массив более низкого ранга, где сами элементы представляют собой массивы
(`ячейки').

@cindex array frame
@cindex frame rank

Мы говорим о первых @math{n-k} размерностях массива как о
@math{n-k}-`каркасе' массива, тогда как последние @math{k} размерностей
являются @math{k}- измерениями `ячеек'. Например, можно видеть 3х мерный
массив может быть рассмотрен как 2 мерный -массив векторов (1-мерный массив)
или как 1-мерный массив матриц размером(2-мерный массив). В каждом случае
векторы или матрицы являются 1 мерными ячеками или двумерными ячеками 
массива.  Эта терминология возникает в J языке.

@cindex array slice
@cindex prefix slice

Более неопределенная концепция `среза' относится к подмножеству 
массвов, где некоторые индексы фиксируются, а другие остаются 
свбодными. В качестве объекта данных Guile ячейка совпадает
с префиксом срез `prefix slice' (первые @math{n-k} индексов
в исходном массиве фиксируются), за исключением того, что 0-ячека
не может являтся общим массивом исходного массива, но 0-срез 
(где все индексы в исходном массиве фиксированы) является.

@cindex enclosed array

До версси @w{version 2.0}, у Guile была функция называемая закрытытием
масссива `enclosed arrays' для создания специального объекта массива массивов.
Функции в этом разделе не нуждаются в специальных типах, весто этого ранг
каркаса(frame) указывается в каждом вызове функции, либо неявно либо явно.

@deffn {Scheme Procedure} array-cell-ref array idx @dots{}
@deffnx {C Function} scm_array_cell_ref (array, idxlist)
If the length of @var{idxlist} equals the rank @math{n} of @var{array},
return the element at @code{(idx @dots{})}, just like @code{(array-ref
array idx @dots{})}. If, however, the length @math{k} of @var{idxlist}
is smaller than @math{n}, then return the @math{(n-k)}-cell of
@var{array} given by @var{idxlist}, as a shared array.

For example:

@lisp
(array-cell-ref #2((a b) (c d)) 0) @result{} #(a b)
(array-cell-ref #2((a b) (c d)) 1) @result{} #(c d)
(array-cell-ref #2((a b) (c d)) 1 1) @result{} d
(array-cell-ref #2((a b) (c d))) @result{} #2((a b) (c d))
@end lisp

@code{(apply array-cell-ref array indices)} is equivalent to

@lisp
(let ((len (length indices)))
  (if (= (array-rank a) len)
    (apply array-ref a indices)
    (apply make-shared-array a
           (lambda t (append indices t))
           (drop (array-dimensions a) len))))
@end lisp

@end deffn

@deffn {Scheme Procedure} array-slice array idx @dots{}
@deffnx {C Function} scm_array_slice (array, idxlist)
Like @code{(array-cell-ref array idx @dots{})}, but return a 0-rank
shared array into @var{ARRAY} if the length of @var{idxlist} matches the
rank of @var{array}. This can be useful when using @var{ARRAY} as a
place to write to.

Compare:

@lisp
(array-cell-ref #2((a b) (c d)) 1 1) @result{} d
(array-slice #2((a b) (c d)) 1 1) @result{} #0(d)
(define a (make-array 'a 2 2))
(array-fill! (array-slice a 1 1) 'b)
a @result{} #2((a a) (a b)).
(array-fill! (array-cell-ref a 1 1) 'b) @result{} error: not an array
@end lisp

@code{(apply array-slice array indices)} is equivalent to

@lisp
(apply make-shared-array a
  (lambda t (append indices t))
  (drop (array-dimensions a) (length indices)))
@end lisp
@end deffn

@deffn {Scheme Procedure} array-cell-set! array x idx @dots{}
@deffnx {C Function} scm_array_cell_set_x (array, x, idxlist)
If the length of @var{idxlist} equals the rank @math{n} of
@var{array}, set the element at @code{(idx @dots{})} of @var{array} to
@var{x}, just like @code{(array-set! array x idx @dots{})}. If,
however, the length @math{k} of @var{idxlist} is smaller than
@math{n}, then copy the @math{(n-k)}-rank array @var{x}
into the @math{(n-k)}-cell of @var{array} given by
@var{idxlist}. In this case, the last @math{(n-k)} dimensions of
@var{array} and the dimensions of @var{x} must match exactly.

This function returns the modified @var{array}.

For example:

@lisp
(array-cell-set! (make-array 'a 2 2) b 1 1)
  @result{} #2((a a) (a b))
(array-cell-set! (make-array 'a 2 2) #(x y) 1)
  @result{} #2((a a) (x y))
@end lisp

Note that @code{array-cell-set!} will expect elements, not arrays, when
the destination has rank 0. Use @code{array-slice} for the opposite
behavior.

@lisp
(array-cell-set! (make-array 'a 2 2) #0(b) 1 1)
  @result{} #2((a a) (a #0(b)))
(let ((a (make-array 'a 2 2)))
  (array-copy! #0(b) (array-slice a 1 1)) a)
  @result{} #2((a a) (a b))
@end lisp

@code{(apply array-cell-set! array x indices)} is equivalent to

@lisp
(let ((len (length indices)))
  (if (= (array-rank array) len)
    (apply array-set! array x indices)
    (array-copy! x (apply array-cell-ref array indices)))
  array)
@end lisp

@end deffn

@deffn {Scheme Procedure} array-slice-for-each frame-rank op x @dots{}
@deffnx {C Function} scm_array_slice_for_each (array, frame_rank, op, xlist)
Each @var{x} must be an array of rank ≥ @var{frame-rank}, and
the first @var{frame-rank} dimensions of each @var{x} must all be the
same. @var{array-slice-for-each} calls @var{op} with each set of
(rank(@var{x}) - @var{frame-rank})-cells from @var{x}, in unspecified order.

@var{array-slice-for-each} allows you to loop over cells of any rank
without having to carry an index list or construct shared arrays
manually. The slices passed to @var{op} are always shared arrays of
@var{X}, even if they are of rank 0, so it is possible to write to them.

This function returns an unspecified value.

For example, to sort the rows of rank-2 array @code{a}:

@lisp
(array-slice-for-each 1 (lambda (x) (sort! x <)) a)
@end lisp

As another example, let @code{a} be a rank-2 array where each row is a
2-element vector @math{(x,y)}.  Let's compute the arguments of these
vectors and store them in rank-1 array @code{b}.
@lisp
(array-slice-for-each 1
  (lambda (a b)
    (array-set! b (atan (array-ref a 1) (array-ref a 0))))
  a b)
@end lisp

@code{(apply array-slice-for-each frame-rank op x)} is equivalent to

@lisp
(let ((frame (take (array-dimensions (car x)) frank)))
  (unless (every (lambda (x)
                   (equal? frame (take (array-dimensions x) frank)))
                 (cdr x))
    (error))
  (array-index-map!
    (apply make-shared-array (make-array #t) (const '()) frame)
    (lambda i (apply op (map (lambda (x) (apply array-slice x i)) x)))))
@end lisp

@end deffn

@deffn {Scheme Procedure} array-slice-for-each-in-order frame-rank op x @dots{}
@deffnx {C Function} scm_array_slice_for_each_in_order (array, frame_rank, op, xlist)
Same as @code{array-slice-for-each}, but the arguments are traversed
sequentially and in row-major order.
@end deffn

@node Accessing Arrays from C
@subsubsection Доступ к Массивам из Си

Для взаимодействия с внешним кодом Си Guile предоставляет API, позволяющий
Си-коду получать доступ к элементам массивов Scheme. В частности, для
унифицированных числовых массивов API предоставляет лежащие в их основе
данные как Си массив чисел соответствующего типа.

Хотя указатели на элементы массива используются, сам массив должен
быть защищен, так что указатель остается в силе. Говорят что такой
защищенный массив зарезервирован. Зарезервированный массив может
быть прочитан, но изменения в нем, указываемых ссылкой элементов,
недопустимы. При попытке такой модификации выдается сигнал ошибки.

(Это похоже на блокировку массива во время его использования,
но без опасности "смертельной" блокировки. В многопоточной программе
вам потребуется дополнительная синхронизация, что бы избежать
изменения зарезервированных массивов.)

Вы должны позаботиться о том что бы всегда востанавливать из
резерва массив после его резервирования, даже если имеются нелокальные
выходы. Если между двумя этими вызовами может произойти
нелокальный выход, вы должны установить контекст dynwind, который
освобождает массив когда он оставлен. (@pxref{Dynamic Wind}).

Кроме того, резрвирование и восстановление из резерва должны
быть сопряжены. Например при резервировании двух и более 
массивов в определенном порядке вам необходимо осовбодить
(востановить из резерва) их
в противоположном порядке.

После того как вы зарезервировали массив и извлекли указатель на его
элементы, вы должны определить расположение элементов в памяти.
Guile позволяет вырезать фрагменты из массива без фактического 
создания копии, например, создание псевдонима для диагонали матрицы
который можно рассматривать как вектор. Массивы, которые не
являются результатом такой операции, не сохраняются в памяти и при
работе с их элементами на прямую, нужно обращать на это внимание.

Размещение элементов массива в памяти можно определить с помощью функции
@emph{mapping function} отображения, которая вычисляет позицию из вектора
индексов. Тогда скалярное положение будет смещением элемента с указанными
индексами от начала блока хранилища массива.

В Guile, эта функция отображения ограниченна аффинным преобразованием
@dfn{affine}: все функции отображения массивов в  Guile могут быть
записаны как @code{p = b + c[0]*i[0] + c[1]*i[1] + ... 
+ c[n-1]*i[n-1]} где @code{i[k]} это @nicode{k}й индекс и @code{n} это
ранг массива.  Например, матрица размера  3x3 будет иметь @code{b == 0}, 
@code{c[0] == 3} и @code{c[1] == 1}.  Когда вы перенесете эту матрицу
(с помощью скажем @code{transpose-array}), вы получите массив, функция
отображения которого будет @code{b == 0}, @code{c[0] == 1} и @code{c[1] == 3}.

Функция @code{scm_array_handle_dims} дает вамu (косвенный) доступ к 
коэффциэнтам  @code{c[k]}.

@c XXX
Обратите внимание: нет функций для доступа к элементам массива символов.
После того, как строковая реализация в Guile была изменена для использования
Unicode, мы используем ее.

@deftp {C Type} scm_t_array_handle
This is a structure type that holds all information necessary to manage
the reservation of arrays as explained above.  Structures of this type
must be allocated on the stack and must only be accessed by the
functions listed below.
@end deftp

@deftypefn {C Function} void scm_array_get_handle (SCM array, scm_t_array_handle *handle)
Reserve @var{array}, which must be an array, and prepare @var{handle} to
be used with the functions below.  You must eventually call
@code{scm_array_handle_release} on @var{handle}, and do this in a
properly nested fashion, as explained above.  The structure pointed to
by @var{handle} does not need to be initialized before calling this
function.
@end deftypefn

@deftypefn {C Function} void scm_array_handle_release (scm_t_array_handle *handle)
End the array reservation represented by @var{handle}.  After a call to
this function, @var{handle} might be used for another reservation.
@end deftypefn

@deftypefn {C Function} size_t scm_array_handle_rank (scm_t_array_handle *handle)
Return the rank of the array represented by @var{handle}.
@end deftypefn

@deftp {C Type} scm_t_array_dim
This structure type holds information about the layout of one dimension
of an array.  It includes the following fields:

@table @code
@item  ssize_t lbnd
@itemx ssize_t ubnd
The lower and upper bounds (both inclusive) of the permissible index
range for the given dimension.  Both values can be negative, but
@var{lbnd} is always less than or equal to @var{ubnd}.

@item ssize_t inc
The distance from one element of this dimension to the next.  Note, too,
that this can be negative.
@end table
@end deftp

@deftypefn {C Function} {const scm_t_array_dim *} scm_array_handle_dims (scm_t_array_handle *handle)
Return a pointer to a C vector of information about the dimensions of
the array represented by @var{handle}.  This pointer is valid as long as
the array remains reserved.  As explained above, the
@code{scm_t_array_dim} structures returned by this function can be used
calculate the position of an element in the storage block of the array
from its indices.

This position can then be used as an index into the C array pointer
returned by the various @code{scm_array_handle_<foo>_elements}
functions, or with @code{scm_array_handle_ref} and
@code{scm_array_handle_set}.

Here is how one can compute the position @var{pos} of an element given
its indices in the vector @var{indices}:

@example
ssize_t indices[RANK];
scm_t_array_dim *dims;
ssize_t pos;
size_t i;

pos = 0;
for (i = 0; i < RANK; i++)
  @{
    if (indices[i] < dims[i].lbnd || indices[i] > dims[i].ubnd)
      out_of_range ();
    pos += (indices[i] - dims[i].lbnd) * dims[i].inc;
  @}
@end example
@end deftypefn

@deftypefn {C Function} ssize_t scm_array_handle_pos (scm_t_array_handle *handle, SCM indices)
Compute the position corresponding to @var{indices}, a list of
indices.  The position is computed as described above for
@code{scm_array_handle_dims}.  The number of the indices and their
range is checked and an appropriate error is signalled for invalid
indices.
@end deftypefn

@deftypefn {C Function} SCM scm_array_handle_ref (scm_t_array_handle *handle, ssize_t pos)
Return the element at position @var{pos} in the storage block of the
array represented by @var{handle}.  Any kind of array is acceptable.  No
range checking is done on @var{pos}.
@end deftypefn

@deftypefn {C Function} void scm_array_handle_set (scm_t_array_handle *handle, ssize_t pos, SCM val)
Set the element at position @var{pos} in the storage block of the array
represented by @var{handle} to @var{val}.  Any kind of array is
acceptable.  No range checking is done on @var{pos}.  An error is
signalled when the array can not store @var{val}.
@end deftypefn

@deftypefn {C Function} {const SCM *} scm_array_handle_elements (scm_t_array_handle *handle)
Return a pointer to the elements of a ordinary array of general Scheme
values (i.e., a non-uniform array) for reading.  This pointer is valid
as long as the array remains reserved.
@end deftypefn

@deftypefn {C Function} {SCM *} scm_array_handle_writable_elements (scm_t_array_handle *handle)
Like @code{scm_array_handle_elements}, but the pointer is good for
reading and writing.
@end deftypefn

@deftypefn {C Function} {const void *} scm_array_handle_uniform_elements (scm_t_array_handle *handle)
Return a pointer to the elements of a uniform numeric array for reading.
This pointer is valid as long as the array remains reserved.  The size
of each element is given by @code{scm_array_handle_uniform_element_size}.
@end deftypefn

@deftypefn {C Function} {void *} scm_array_handle_uniform_writable_elements (scm_t_array_handle *handle)
Like @code{scm_array_handle_uniform_elements}, but the pointer is good
reading and writing.
@end deftypefn

@deftypefn {C Function} size_t scm_array_handle_uniform_element_size (scm_t_array_handle *handle)
Return the size of one element of the uniform numeric array represented
by @var{handle}.
@end deftypefn

@deftypefn  {C Function} {const scm_t_uint8 *} scm_array_handle_u8_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {const scm_t_int8 *} scm_array_handle_s8_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {const scm_t_uint16 *} scm_array_handle_u16_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {const scm_t_int16 *} scm_array_handle_s16_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {const scm_t_uint32 *} scm_array_handle_u32_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {const scm_t_int32 *} scm_array_handle_s32_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {const scm_t_uint64 *} scm_array_handle_u64_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {const scm_t_int64 *} scm_array_handle_s64_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {const float *} scm_array_handle_f32_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {const double *} scm_array_handle_f64_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {const float *} scm_array_handle_c32_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {const double *} scm_array_handle_c64_elements (scm_t_array_handle *handle)
Return a pointer to the elements of a uniform numeric array of the
indicated kind for reading.  This pointer is valid as long as the array
remains reserved.

The pointers for @code{c32} and @code{c64} uniform numeric arrays point
to pairs of floating point numbers.  The even index holds the real part,
the odd index the imaginary part of the complex number.
@end deftypefn

@deftypefn {C Function} {scm_t_uint8 *} scm_array_handle_u8_writable_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {scm_t_int8 *} scm_array_handle_s8_writable_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {scm_t_uint16 *} scm_array_handle_u16_writable_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {scm_t_int16 *} scm_array_handle_s16_writable_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {scm_t_uint32 *} scm_array_handle_u32_writable_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {scm_t_int32 *} scm_array_handle_s32_writable_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {scm_t_uint64 *} scm_array_handle_u64_writable_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {scm_t_int64 *} scm_array_handle_s64_writable_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {float *} scm_array_handle_f32_writable_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {double *} scm_array_handle_f64_writable_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {float *} scm_array_handle_c32_writable_elements (scm_t_array_handle *handle)
@deftypefnx {C Function} {double *} scm_array_handle_c64_writable_elements (scm_t_array_handle *handle)
Like @code{scm_array_handle_<kind>_elements}, but the pointer is good
for reading and writing.
@end deftypefn

@deftypefn {C Function} {const scm_t_uint32 *} scm_array_handle_bit_elements (scm_t_array_handle *handle)
Return a pointer to the words that store the bits of the represented
array, which must be a bit array.

Unlike other arrays, bit arrays have an additional offset that must be
figured into index calculations.  That offset is returned by
@code{scm_array_handle_bit_elements_offset}.

To find a certain bit you first need to calculate its position as
explained above for @code{scm_array_handle_dims} and then add the
offset.  This gives the absolute position of the bit, which is always a
non-negative integer.

Each word of the bit array storage block contains exactly 32 bits, with
the least significant bit in that word having the lowest absolute
position number.  The next word contains the next 32 bits.

Thus, the following code can be used to access a bit whose position
according to @code{scm_array_handle_dims} is given in @var{pos}:

@example
SCM bit_array;
scm_t_array_handle handle;
scm_t_uint32 *bits;
ssize_t pos;
size_t abs_pos;
size_t word_pos, mask;

scm_array_get_handle (&bit_array, &handle);
bits = scm_array_handle_bit_elements (&handle);

pos = ...
abs_pos = pos + scm_array_handle_bit_elements_offset (&handle);
word_pos = abs_pos / 32;
mask = 1L << (abs_pos % 32);

if (bits[word_pos] & mask)
  /* bit is set. */

scm_array_handle_release (&handle);
@end example

@end deftypefn

@deftypefn {C Function} {scm_t_uint32 *} scm_array_handle_bit_writable_elements (scm_t_array_handle *handle)
Like @code{scm_array_handle_bit_elements} but the pointer is good for
reading and writing.  You must take care not to modify bits outside of
the allowed index range of the array, even for contiguous arrays.
@end deftypefn

@node VLists
@subsection VLists

@cindex vlist

Модуль @code{(ice-9 vlist)} обеспечивает реализацию структуры данных @dfn{VList},
разработанной Phil Bagwell в 2002.  VLists это неизменяемые списки, которые
могут содержать любой объект  Scheme.  Он улучшает стандартные связаные списки
Scheme в нескольких областях:

@itemize
@item
Произвольный доступ выполняется за постоянное время.

@item
Вычисление длины VList имеет логарифмическую сложность от числа элементов.

@item
VLists использует меньше места для хранения, чем
стандартные списки.

@item
Элементы VList хранятся в смежных областях, что улучшает распределение памяти
и приводит к более эффективному использованию аппаратных кэшей.
@end itemize

Идея VLists заключается в том, чтобы хранить элементы vlist в более крупных
смежных блоках (реализованных здесь как векторы).  Эти блоки связаны друг с
другом с помощью указателя на следующий блок и смещения внутри этого блока.
Размер этих блоков формирует геометрический ряд с коэффициэнтом роста:
@code{block-growth-factor} (по умолчанию 2).

Структура VList также служит основой для хэш-списков на основе @dfn{хэш-список
на осонове VList} или ``vhashes'', неизменный тип словаря (@pxref{VHashes}).

Однако текущая реализация @code{(ice-9 vlist)} имеет несколько
примечательных недостатков:

@itemize

@item
Он не является потокобезопасным.  Хотя операции с vlists все 
@dfn{ссылочно прозрачны} (т.е. чисто функциональны), добавление элементов в
vlist с помощью @code{vlist-cons} изменяет часть внутренней структуры, которая
делает его потоко небезопасным.  Это может быть исправлено, но это замедлит
@code{vlist-cons}.

@item
@code{vlist-cons} всегда выделяет как минимум столько же памяти, сколько и @code{cons}.
Опять же, Phil Bagwell описывает как это исправить, но это потребует настройки 
сборщика мусора способом который может быть не совсем полезен.

@item
@code{vlist-cons} это процедура Scheme компилируемая в байт-код, и оне не может
конкурировать с простой Си реализациейand операции @code{cons}, и тем, что VM 
имеет специальную инструкцию  @code{cons}.

@end itemize

Мы надеемся их решить в будущем.

Интерфейс программирования, экспортируемый @code{(ice-9 vlist)} определен ниже.
Большая часть так же как SRFI-1 с добавлением префикса  @code{vlist-} в имена
функций.

@deffn {Scheme Procedure} vlist? obj
Return true if @var{obj} is a VList.
@end deffn

@defvr {Scheme Variable} vlist-null
The empty VList.  Note that it's possible to create an empty VList not
@code{eq?} to @code{vlist-null}; thus, callers should always use
@code{vlist-null?} when testing whether a VList is empty.
@end defvr

@deffn {Scheme Procedure} vlist-null? vlist
Return true if @var{vlist} is empty.
@end deffn

@deffn {Scheme Procedure} vlist-cons item vlist
Return a new vlist with @var{item} as its head and @var{vlist} as its tail.
@end deffn

@deffn {Scheme Procedure} vlist-head vlist
Return the head of @var{vlist}.
@end deffn

@deffn {Scheme Procedure} vlist-tail vlist
Return the tail of @var{vlist}.
@end deffn

@defvr {Scheme Variable} block-growth-factor
A fluid that defines the growth factor of VList blocks, 2 by default.
@end defvr

The functions below provide the usual set of higher-level list operations.

@deffn {Scheme Procedure} vlist-fold proc init vlist
@deffnx {Scheme Procedure} vlist-fold-right proc init vlist
Fold over @var{vlist}, calling @var{proc} for each element, as for SRFI-1
@code{fold} and @code{fold-right} (@pxref{SRFI-1, @code{fold}}).
@end deffn

@deffn {Scheme Procedure} vlist-ref vlist index
Return the element at index @var{index} in @var{vlist}.  This is typically a
constant-time operation.
@end deffn

@deffn {Scheme Procedure} vlist-length vlist
Return the length of @var{vlist}.  This is typically logarithmic in the number
of elements in @var{vlist}.
@end deffn

@deffn {Scheme Procedure} vlist-reverse vlist
Return a new @var{vlist} whose content are those of @var{vlist} in reverse
order.
@end deffn

@deffn {Scheme Procedure} vlist-map proc vlist
Map @var{proc} over the elements of @var{vlist} and return a new vlist.
@end deffn

@deffn {Scheme Procedure} vlist-for-each proc vlist
Call @var{proc} on each element of @var{vlist}.  The result is unspecified.
@end deffn

@deffn {Scheme Procedure} vlist-drop vlist count
Return a new vlist that does not contain the @var{count} first elements of
@var{vlist}.  This is typically a constant-time operation.
@end deffn

@deffn {Scheme Procedure} vlist-take vlist count
Return a new vlist that contains only the @var{count} first elements of
@var{vlist}.
@end deffn

@deffn {Scheme Procedure} vlist-filter pred vlist
Return a new vlist containing all the elements from @var{vlist} that satisfy
@var{pred}.
@end deffn

@deffn {Scheme Procedure} vlist-delete x vlist [equal?]
Return a new vlist corresponding to @var{vlist} without the elements
@var{equal?} to @var{x}.
@end deffn

@deffn {Scheme Procedure} vlist-unfold p f g seed [tail-gen]
@deffnx {Scheme Procedure} vlist-unfold-right p f g seed [tail]
Return a new vlist, as for SRFI-1 @code{unfold} and @code{unfold-right}
(@pxref{SRFI-1, @code{unfold}}).
@end deffn

@deffn {Scheme Procedure} vlist-append vlist @dots{}
Append the given vlists and return the resulting vlist.
@end deffn

@deffn {Scheme Procedure} list->vlist lst
Return a new vlist whose contents correspond to @var{lst}.
@end deffn

@deffn {Scheme Procedure} vlist->list vlist
Return a new list whose contents match those of @var{vlist}.
@end deffn

@node Record Overview
@subsection Записи Обзор(Record Overview)

@cindex record
@cindex structure

@dfn{Записи(Records)}, также называемые @dfn{Структурами(structures)}, 
являются основным механизмом Scheme для определения новых типов.  
@dfn{Тип записи} определяет списко полей, из которых состоят экземпляры
этого типа. Это похоже на структыры Си.

Исторически сложилось так, что Guile предлагае несколько различных
способов определения типов записей и создания записи, предлагая
разные функции и идя на разные компромисы. На протяжении многих
лет каждый ``Стандарт'' также имеет свой собственный новый интерфес
работы с записями. что привело к лабиринту API интерфейсов для работы
с записями.

На самом высшем уровне стоит SRFI-9, высокоуровневый интерфес работы
с записями, реализованный в большинстве реализаций Scheme 
(@pxref{SRFI-9 Records}).  Он определяет простую и эффективную синтаксическую
абстракцию типо записей и связанных ними типов полей и функцй доступа к этим
полям.  SRFI-9 подходит для большинства применений, и рекомендуется для 
создания записей в  Guile.  Аналогичные высокоуровневые интерфесы включают
SRFI-35 (@pxref{SRFI-35}) и записи R6RS (@pxref{rnrs records syntactic}).

Затем(исторически) появился Guile API ``records'' (@pxref{Records}).  
Типы записей определенные таким образом, являются первыми классовыми
объектами. Имеются интроспективные объекты позволяющие пользователям
запрашивать список полей или значение определенного поля во время
выполнения без предварительного знания его типа.

Наконец, общим знаменателем этих интерфесов является  Guile API
@dfn{Структуры(structure)}  (@pxref{Structures}).  Структуры Guile
это низкоуровневый строительный блок для всех других API работы с 
записями.  Пользователям приложений как правило не нужно будет их
использовать.

Записи, созданные с помощью этих APIs могут быть все сопоставлены с 
образцом используемым Guile стандартным поиском по шаблону.
(@pxref{Pattern Matching}).

@node SRFI-9 Records
@subsection Записи по спецификации (SRFI-9)

@cindex SRFI-9
@cindex record

SRFI-9 стандартиризует синтаксис для определения новых типов записей и
создания предикатов, конструкторов и функций доступа к полям(get, set).
В Guile это рекомендуемый вариант создания новых типов записей  
(@pxref{Record Overview}).  Его можно использовать загрузив модуль:

@example
(use-modules (srfi srfi-9))
@end example

@deffn {Scheme Syntax} define-record-type type @* (constructor fieldname @dots{}) @* predicate @* (fieldname accessor [modifier]) @dots{}
@sp 1
Создает новый тип записи и создает для этого различные определения.
Этот синтаксис работает только на верхнем уровне, и не подходит для
вложения в какую либо другую форму.

@var{type} связь с символом типа записи, который соотвествует возвращаемому
из функции @code{make-record-type}.  @var{type} также предоставляет имя
записи, согласно @code{record-type-name}.

@var{constructor} связь с функцией, которая будет вызываться как
@code{(@var{constructor} fieldval @dots{})}, чтобы создать новую
запись этого типа. Аргументы представляют собой начальные значения
 для полей, один аргумент для каждого поля, в том порядке, в котором
они появляются в форме определения типа записи 
@code{define-record-type}.

Имена полей @var{fieldname}s представляют имена для полей записи,
в соответствии с  @code{record-type-fields} и т.д., и упоминаются
в последующих формах  доступа/изменения (accessor/modifier).

@var{predicate} связан с функцией, которая будет вызываться как:
@code{(@var{predicate} obj)}.  Он возвращает @code{#t} или @code{#f}
в зависимости от того, является ли @var{obj} записью этого типа
или нет.

Каждый @var{accessor} привязан к функции, которая должна быть вызвана как:
@code{(@var{accessor} record)}, что бы получить соответствующее поле из
@var{record}.  Аналогично, каждый @var{modifier} привязан к функции вызываемой
как: @code{(@var{modifier} record val)}, чтобы установить соответствующее
значение поля в записи @var{record}.
@end deffn

@noindent
Пример иллюстрирует типичное использование,

@example
(define-record-type <employee>
  (make-employee name age salary)
  employee?
  (name    employee-name)
  (age     employee-age    set-employee-age!)
  (salary  employee-salary set-employee-salary!))
@end example

Он создает новый тип данных СОТРУДНИК employee с полями имени, возраста
и заработной платы. Функции доступа создаются для каждого поля, но нет 
функции модификатора для имени (цель заключается в том, чтобы оно
устнавливалось только при создании объекта employee)  Объекты этого
типа могут быть созданы и использованы, например:

@example
<employee> @result{} #<record-type <employee>>

(define fred (make-employee "Fred" 45 20000.00))

(employee? fred)        @result{} #t
(employee-age fred)     @result{} 45
(set-employee-salary! fred 25000.00)  ;; pay rise
@end example

Функции, созданные методом @code{define-record-type} являются обычными
определениями верхнего уровня.  Их можно переопределять или устанавливать
по желанию, экспортировать из модуля и т.д.

@unnumberedsubsubsec Определение записей не на верхнем уровне.

Спецификация SRFI-9 явно запрещает определения записей в контексте
отличном от верхнего уровня, например внутри тела лямбда@code{lambda}
блока или внутри блока @var{let}.  Однако рализация Guile не соблюдает
это ограничение.

@unnumberedsubsubsec Пользовательская Печать

Вы можете использовать @code{set-record-type-printer!} для настройки поведения
печати по умолчанию для записей.  Это расширение  Guile и не является частью
SRFI-9.  Оно расположено в модуле @nicode{(srfi srfi-9 gnu)}.

@deffn {Scheme Syntax} set-record-type-printer! type proc
Где @var{type} соответствует первому аргументу @code{define-record-type},
а @var{proc} процедура, принимающая два аргумента, запись(record) для печати и
выходной порт.
@end deffn

@noindent
Этот пример печатает имя сотрудника в скобках, например @code{[Fred]}.

@example
(set-record-type-printer! <employee>
  (lambda (record port)
    (write-char #\[ port)
    (display (employee-name record) port)
    (write-char #\] port)))
@end example

@unnumberedsubsubsec Functional ``Setters''

@cindex functional setters

При написании кода в функциональном стиле желательно никогда не изменять
содержимое записей. Для такого кода простой способ возврата новых экземпляров
записей желательно выполнять на основе сущетствующих.

Модуль @code{(srfi srfi-9 gnu)} расширеяет SRFI-9 возможностью возврата
новой записи экземпляра на основе существующей, с только одним или 
несколькими значениями полей, изменненными с помощью функции ---
@dfn{functional setters}.  Во-первых,  тип @code{define-immutable-record-type}
работает как @code{define-record-type}, за исключением того что эти поля
являются не изменяемыми, а функции изменния определяются как функциональные
functional setters.

@deffn {Scheme Syntax} define-immutable-record-type type @* (constructor fieldname @dots{}) @* predicate @* (fieldname accessor [modifier]) @dots{}
Определяет @var{type} как новый тип записи, подобно @code{define-record-type}.
Однако, запись type станоиться не изменяемой @emph{immutable} (записи не могут
быть изменены даже с помощью функции @code{struct-set!}), и любой модификатор
@var{modifier} определеяется как функциональный установщик(functional setter)
---процедура которая возвращает новый экземпляр записи с указанным изменненым
значением поля и оставляет исходную запись неизменной.(См пример ниже.)
@end deffn

@noindent
Кроме того, общие макросы @code{set-field} и @code{set-fields} могут 
применяться к любой записи SRFI-9.

@deffn {Scheme Syntax} set-field record (field sub-fields ...) value
Возвращает новую запись типа @var{record}, поля которой равны
соответствующим полям записи @var{record}, кроме поля указанного
@var{field}.

@var{field} must be the name of the getter corresponding to the field of
@var{record} being ``set''.  Subsequent @var{sub-fields} must be record
getters designating sub-fields within that field value to be set (see
example below.)
@end deffn

@deffn {Scheme Syntax} set-fields record ((field sub-fields ...) value) ...
Like @code{set-field}, but can be used to set more than one field at a
time.  This expands to code that is more efficient than a series of
single @code{set-field} calls.
@end deffn

Чтобы проилюстрировать использование функциональных установщиков(functional setters)
давайте предположим эти два определения типа записей:

@example
(define-record-type <address>
  (address street city country)
  address?
  (street  address-street)
  (city    address-city)
  (country address-country))

(define-immutable-record-type <person>
  (person age email address)
  person?
  (age     person-age set-person-age)
  (email   person-email set-person-email)
  (address person-address set-person-address))
@end example

@noindent
Во-первых, обратите внимание, что определение типа записи @code{<person>}
вводит именнованные функциональные установщики.
Они могут быть использованы следующим образом:

@example
(define fsf-address
  (address "Franklin Street" "Boston" "USA"))

(define rms
  (person 30 "rms@@gnu.org" fsf-address))

(and (equal? (set-person-age rms 60)
             (person 60 "rms@@gnu.org" fsf-address))
     (= (person-age rms) 30))
@result{} #t
@end example

@noindent
Здесь, исходная запись @code{<person>}, к которой привязана @var{rms},
остается неизменной.

Теперь предположим, что мы хотим изменить как улицу, так и возраст @var{rms}.
Это может быть достигнуто использованием @code{set-fields}:

@example
(set-fields rms
  ((person-age) 60)
  ((person-address address-street) "Temple Place"))
@result{} #<<person> age: 60 email: "rms@@gnu.org"
  address: #<<address> street: "Temple Place" city: "Boston" country: "USA">>
@end example

@noindent
Обратите внимание, как вышеизложенное изменило два поля @var{rms}, включая
поле улицы @code{street} в его адресе @code{address}.  Также обратите
внимание, что @code{set-fields} работает одинаково для типов, определенных
с помощью @code{define-record-type}.

@node Records
@subsection Записи(Records)

Тип Запись @dfn{record type} это первый объект класса представляющего
пользовательский тип данных.  Запись @dfn{record} это экземпляр типа
записи.

Обратите внимание, что во многих отношениях этот интерфейс слишком
низкоуровневый для повседневного использования.  Большинство примениней
записи лучше обслживаются записями SRFI-9.
@xref{SRFI-9 Records}.

@deffn {Scheme Procedure} record? obj
Return @code{#t} if @var{obj} is a record of any type and @code{#f}
otherwise.

Note that @code{record?} may be true of any Scheme value; there is no
promise that records are disjoint with other Scheme types.
@end deffn

@deffn {Scheme Procedure} make-record-type type-name field-names [print]
Create and return a new @dfn{record-type descriptor}.

@var{type-name} is a string naming the type.  Currently it's only used
in the printed representation of records, and in diagnostics.
@var{field-names} is a list of symbols naming the fields of a record
of the type.  Duplicates are not allowed among these symbols.

@example
(make-record-type "employee" '(name age salary))
@end example

The optional @var{print} argument is a function used by
@code{display}, @code{write}, etc, for printing a record of the new
type.  It's called as @code{(@var{print} record port)} and should look
at @var{record} and write to @var{port}.
@end deffn

@deffn {Scheme Procedure} record-constructor rtd [field-names]
Return a procedure for constructing new members of the type represented
by @var{rtd}.  The returned procedure accepts exactly as many arguments
as there are symbols in the given list, @var{field-names}; these are
used, in order, as the initial values of those fields in a new record,
which is returned by the constructor procedure.  The values of any
fields not named in that list are unspecified.  The @var{field-names}
argument defaults to the list of field names in the call to
@code{make-record-type} that created the type represented by @var{rtd};
if the @var{field-names} argument is provided, it is an error if it
contains any duplicates or any symbols not in the default list.
@end deffn

@deffn {Scheme Procedure} record-predicate rtd
Return a procedure for testing membership in the type represented by
@var{rtd}.  The returned procedure accepts exactly one argument and
returns a true value if the argument is a member of the indicated record
type; it returns a false value otherwise.
@end deffn

@deffn {Scheme Procedure} record-accessor rtd field-name
Return a procedure for reading the value of a particular field of a
member of the type represented by @var{rtd}.  The returned procedure
accepts exactly one argument which must be a record of the appropriate
type; it returns the current value of the field named by the symbol
@var{field-name} in that record.  The symbol @var{field-name} must be a
member of the list of field-names in the call to @code{make-record-type}
that created the type represented by @var{rtd}.
@end deffn

@deffn {Scheme Procedure} record-modifier rtd field-name
Return a procedure for writing the value of a particular field of a
member of the type represented by @var{rtd}.  The returned procedure
accepts exactly two arguments: first, a record of the appropriate type,
and second, an arbitrary Scheme value; it modifies the field named by
the symbol @var{field-name} in that record to contain the given value.
The returned value of the modifier procedure is unspecified.  The symbol
@var{field-name} must be a member of the list of field-names in the call
to @code{make-record-type} that created the type represented by
@var{rtd}.
@end deffn

@deffn {Scheme Procedure} record-type-descriptor record
Return a record-type descriptor representing the type of the given
record.  That is, for example, if the returned descriptor were passed to
@code{record-predicate}, the resulting predicate would return a true
value when passed the given record.  Note that it is not necessarily the
case that the returned descriptor is the one that was passed to
@code{record-constructor} in the call that created the constructor
procedure that created the given record.
@end deffn

@deffn {Scheme Procedure} record-type-name rtd
Return the type-name associated with the type represented by rtd.  The
returned value is @code{eqv?} to the @var{type-name} argument given in
the call to @code{make-record-type} that created the type represented by
@var{rtd}.
@end deffn

@deffn {Scheme Procedure} record-type-fields rtd
Return a list of the symbols naming the fields in members of the type
represented by @var{rtd}.  The returned value is @code{equal?} to the
field-names argument given in the call to @code{make-record-type} that
created the type represented by @var{rtd}.
@end deffn

@node Structures
@subsection Структуры(Structures)
@tpindex Structures

Структура@dfn{structure} - это первый класс, тип данных, который содержит
значения Scheme или слова Си в полях, пронумерованных от нуля и выше.
@dfn{vtable} - это структура, представляющая тип структуры, предоставляющей
типы полей и разрешений доступа и дополнительной функции печати для
@code{write} и т.д.

Структуры(Structures) представляют более низкий уровень абстракций
по сравнению с записями (@pxref{Records}).  Как правило,
когда вам нужно представлять структурированные данные, вы просто хотите
использовать записи. Но иногда вам необходимо реализовать новые виды
абстракций структурированных данных, и для этой цели структуры полезны.
Действительно, записи в Guile реализованы со структурами.

@menu
* Vtables::
* Structure Basics::
* Vtable Contents::
* Meta-Vtables::
* Vtable Example::
@end menu

@node Vtables
@subsubsection Vtables

vtable это тип структуры, определяющий ее схему, и другую информацию.
Фактически vtable сама является структурой, но в здесь не нужно беспокоиться
об этом. (@pxref{Vtable Contents}.)

@deffn {Scheme Procedure} make-vtable fields [print]
Create a new vtable.

@var{fields} is a string describing the fields in the structures to be
created.  Each field is represented by two characters, a type letter
and a permissions letter, for example @code{"pw"}.  The types are as
follows.

@itemize @bullet{}
@item
@code{p} -- a Scheme value.  ``p'' stands for ``protected'' meaning
it's protected against garbage collection.

@item
@code{u} -- an arbitrary word of data (an @code{scm_t_bits}).  At the
Scheme level it's read and written as an unsigned integer.  ``u'' stands
for ``unboxed'', as it's stored as a raw value without additional type
annotations.
@end itemize

The second letter for each field is a permission code,

@itemize @bullet{}
@item
@code{w} -- writable, the field can be read and written.
@item
@code{r} -- read-only, the field can be read but not written.
@item
@end itemize

Here are some examples.

@example
(make-vtable "pw")      ;; one writable field
(make-vtable "prpw")    ;; one read-only and one writable
(make-vtable "pwuwuw")  ;; one scheme and two unboxed
@end example

The optional @var{print} argument is a function called by
@code{display} and @code{write} (etc) to give a printed representation
of a structure created from this vtable.  It's called
@code{(@var{print} struct port)} and should look at @var{struct} and
write to @var{port}.  The default print merely gives a form like
@samp{#<struct ADDR:ADDR>} with a pair of machine addresses.

The following print function for example shows the two fields of its
structure.

@example
(make-vtable "prpw"
             (lambda (struct port)
               (format port "#<~a and ~a>"
                       (struct-ref struct 0)
                       (struct-ref struct 1))))
@end example
@end deffn

@node Structure Basics
@subsubsection Structure Basics

This section describes the basic procedures for working with structures.
@code{make-struct/no-tail} creates a structure, and @code{struct-ref}
and @code{struct-set!} access its fields.

@deffn {Scheme Procedure} make-struct/no-tail vtable init @dots{}
Create a new structure, with layout per the given @var{vtable}
(@pxref{Vtables}).

The optional @var{init}@dots{} arguments are initial values for the
fields of the structure.  This is the only way to
put values in read-only fields.  If there are fewer @var{init}
arguments than fields then the defaults are @code{#f} for a Scheme
field (type @code{p}) or 0 for an unboxed field (type @code{u}).

The name is a bit strange, we admit.  The reason for it is that Guile
used to have a @code{make-struct} that took an additional argument;
while we deprecate that old interface, @code{make-struct/no-tail} is the
new name for this functionality.

For example,

@example
(define v (make-vtable "prpwpw"))
(define s (make-struct/no-tail v 123 "abc" 456))
(struct-ref s 0) @result{} 123
(struct-ref s 1) @result{} "abc"
@end example
@end deffn

@deftypefn {C Function} SCM scm_make_struct (SCM vtable, SCM tail_size, SCM init_list)
@deftypefnx {C Function} SCM scm_c_make_struct (SCM vtable, SCM tail_size, SCM init, ...)
@deftypefnx {C Function} SCM scm_c_make_structv (SCM vtable, SCM tail_size, size_t n_inits, scm_t_bits init[])
There are a few ways to make structures from C.  @code{scm_make_struct}
takes a list, @code{scm_c_make_struct} takes variable arguments
terminated with SCM_UNDEFINED, and @code{scm_c_make_structv} takes a
packed array.

For all of these, @var{tail_size} should be zero (as a SCM value).
@end deftypefn

@deffn {Scheme Procedure} struct? obj
@deffnx {C Function} scm_struct_p (obj)
Return @code{#t} if @var{obj} is a structure, or @code{#f} if not.
@end deffn

@deffn {Scheme Procedure} struct-ref struct n
@deffnx {C Function} scm_struct_ref (struct, n)
Return the contents of field number @var{n} in @var{struct}.  The
first field is number 0.

An error is thrown if @var{n} is out of range.
@end deffn

@deffn {Scheme Procedure} struct-set! struct n value
@deffnx {C Function} scm_struct_set_x (struct, n, value)
Set field number @var{n} in @var{struct} to @var{value}.  The first
field is number 0.

An error is thrown if @var{n} is out of range, or if the field cannot
be written because it's @code{r} read-only.
@end deffn

Unboxed fields (those with type @code{u}) need to be accessed with
special procedures.

@deffn {Scheme Procedure} struct-ref/unboxed struct n
@deffnx {Scheme Procedure} struct-set!/unboxed struct n value
@deffnx {C Function} scm_struct_ref_unboxed (struct, n)
@deffnx {C Function} scm_struct_set_x_unboxed (struct, n, value)
Like @code{struct-ref} and @code{struct-set!}, except that these may
only be used on unboxed fields.  @code{struct-ref/unboxed} will always
return a positive integer.  Likewise, @code{struct-set!/unboxed} takes
an unsigned integer as the @var{value} argument, and will signal an
error otherwise.
@end deffn

@deffn {Scheme Procedure} struct-vtable struct
@deffnx {C Function} scm_struct_vtable (struct)
Return the vtable that describes @var{struct}.

The vtable is effectively the type of the structure.  See @ref{Vtable
Contents}, for more on vtables.
@end deffn

@node Vtable Contents
@subsubsection Vtable Contents

A vtable is itself a structure.  It has a specific set of fields
describing various aspects of its @dfn{instances}: the structures
created from a vtable.  Some of the fields are internal to Guile, some
of them are part of the public interface, and there may be additional
fields added on by the user.

Every vtable has a field for the layout of their instances, a field for
the procedure used to print its instances, and a field for the name of
the vtable itself.  Access to the layout and printer is exposed directly
via field indexes.  Access to the vtable name is exposed via accessor
procedures.

@defvr {Scheme Variable} vtable-index-layout
@defvrx {C Macro} scm_vtable_index_layout
The field number of the layout specification in a vtable.  The layout
specification is a symbol like @code{pwpw} formed from the fields
string passed to @code{make-vtable}, or created by
@code{make-struct-layout} (@pxref{Meta-Vtables}).

@example
(define v (make-vtable "pwpw" 0))
(struct-ref v vtable-index-layout) @result{} pwpw
@end example

This field is read-only, since the layout of structures using a vtable
cannot be changed.
@end defvr

@defvr {Scheme Variable} vtable-index-printer
@defvrx {C Macro} scm_vtable_index_printer
The field number of the printer function.  This field contains @code{#f}
if the default print function should be used.

@example
(define (my-print-func struct port)
  ...)
(define v (make-vtable "pwpw" my-print-func))
(struct-ref v vtable-index-printer) @result{} my-print-func
@end example

This field is writable, allowing the print function to be changed
dynamically.
@end defvr

@deffn {Scheme Procedure} struct-vtable-name vtable
@deffnx {Scheme Procedure} set-struct-vtable-name! vtable name
@deffnx {C Function} scm_struct_vtable_name (vtable)
@deffnx {C Function} scm_set_struct_vtable_name_x (vtable, name)
Get or set the name of @var{vtable}.  @var{name} is a symbol and is
used in the default print function when printing structures created
from @var{vtable}.

@example
(define v (make-vtable "pw"))
(set-struct-vtable-name! v 'my-name)

(define s (make-struct v 0))
(display s) @print{} #<my-name b7ab3ae0:b7ab3730>
@end example
@end deffn

@node Meta-Vtables
@subsubsection Meta-Vtables

As a structure, a vtable also has a vtable, which is also a structure.
Structures, their vtables, the vtables of the vtables, and so on form a
tree of structures.  Making a new structure adds a leaf to the tree, and
if that structure is a vtable, it may be used to create other leaves.

If you traverse up the tree of vtables, via calling
@code{struct-vtable}, eventually you reach a root which is the vtable of
itself:

@example
scheme@@(guile-user)> (current-module)
$1 = #<directory (guile-user) 221b090>
scheme@@(guile-user)> (struct-vtable $1)
$2 = #<record-type module>
scheme@@(guile-user)> (struct-vtable $2)
$3 = #<<standard-vtable> 12c30a0>
scheme@@(guile-user)> (struct-vtable $3)
$4 = #<<standard-vtable> 12c3fa0>
scheme@@(guile-user)> (struct-vtable $4)
$5 = #<<standard-vtable> 12c3fa0>
scheme@@(guile-user)> <standard-vtable>
$6 = #<<standard-vtable> 12c3fa0>
@end example

In this example, we can say that @code{$1} is an instance of @code{$2},
@code{$2} is an instance of @code{$3}, @code{$3} is an instance of
@code{$4}, and @code{$4}, strangely enough, is an instance of itself.
The value bound to @code{$4} in this console session also bound to
@code{<standard-vtable>} in the default environment.

@defvr {Scheme Variable} <standard-vtable>
A meta-vtable, useful for making new vtables.
@end defvr

All of these values are structures.  All but @code{$1} are vtables.  As
@code{$2} is an instance of @code{$3}, and @code{$3} is a vtable, we can
say that @code{$3} is a @dfn{meta-vtable}: a vtable that can create
vtables.

With this definition, we can specify more precisely what a vtable is: a
vtable is a structure made from a meta-vtable.  Making a structure from
a meta-vtable runs some special checks to ensure that the first field of
the structure is a valid layout.  Additionally, if these checks see that
the layout of the child vtable contains all the required fields of a
vtable, in the correct order, then the child vtable will also be a
meta-table, inheriting a magical bit from the parent.

@deffn {Scheme Procedure} struct-vtable? obj
@deffnx {C Function} scm_struct_vtable_p (obj)
Return @code{#t} if @var{obj} is a vtable structure: an instance of a
meta-vtable.
@end deffn

@code{<standard-vtable>} is a root of the vtable tree.  (Normally there
is only one root in a given Guile process, but due to some legacy
interfaces there may be more than one.)

The set of required fields of a vtable is the set of fields in the
@code{<standard-vtable>}, and is bound to @code{standard-vtable-fields}
in the default environment.  It is possible to create a meta-vtable that
with additional fields in its layout, which can be used to create
vtables with additional data:

@example
scheme@@(guile-user)> (struct-ref $3 vtable-index-layout)
$6 = pruhsruhpwphuhuhprprpw
scheme@@(guile-user)> (struct-ref $4 vtable-index-layout)
$7 = pruhsruhpwphuhuh
scheme@@(guile-user)> standard-vtable-fields 
$8 = "pruhsruhpwphuhuh"
scheme@@(guile-user)> (struct-ref $2 vtable-offset-user)
$9 = module
@end example

In this continuation of our earlier example, @code{$2} is a vtable that
has extra fields, because its vtable, @code{$3}, was made from a
meta-vtable with an extended layout.  @code{vtable-offset-user} is a
convenient definition that indicates the number of fields in
@code{standard-vtable-fields}.

@defvr {Scheme Variable} standard-vtable-fields
A string containing the ordered set of fields that a vtable must have.
@end defvr

@defvr {Scheme Variable} vtable-offset-user
The first index in a vtable that is available for a user.
@end defvr

@deffn {Scheme Procedure} make-struct-layout fields
@deffnx {C Function} scm_make_struct_layout (fields)
Return a structure layout symbol, from a @var{fields} string.
@var{fields} is as described under @code{make-vtable}
(@pxref{Vtables}).  An invalid @var{fields} string is an error.
@end deffn

With these definitions, one can define @code{make-vtable} in this way:

@example
(define* (make-vtable fields #:optional printer)
  (make-struct/no-tail <standard-vtable>
    (make-struct-layout fields)
    printer))
@end example

@node Vtable Example
@subsubsection Vtable Example

Let us bring these points together with an example.  Consider a simple
object system with single inheritance.  Objects will be normal
structures, and classes will be vtables with three extra class fields:
the name of the class, the parent class, and the list of fields.

So, first we need a meta-vtable that allocates instances with these
extra class fields.

@example
(define <class>
  (make-vtable
   (string-append standard-vtable-fields "pwpwpw")
   (lambda (x port)
     (format port "<<class> ~a>" (class-name x)))))

(define (class? x)
  (and (struct? x)
       (eq? (struct-vtable x) <class>)))
@end example

To make a structure with a specific meta-vtable, we will use
@code{make-struct/no-tail}, passing it the computed instance layout and
printer, as with @code{make-vtable}, and additionally the extra three
class fields.

@example
(define (make-class name parent fields)
  (let* ((fields (compute-fields parent fields))
         (layout (compute-layout fields)))
    (make-struct/no-tail <class>
      layout 
      (lambda (x port)
        (print-instance x port))
      name
      parent
      fields)))
@end example

Instances will store their associated data in slots in the structure: as
many slots as there are fields.  The @code{compute-layout} procedure
below can compute a layout, and @code{field-index} returns the slot
corresponding to a field.

@example
(define-syntax-rule (define-accessor name n)
  (define (name obj)
    (struct-ref obj n)))

;; Accessors for classes
(define-accessor class-name (+ vtable-offset-user 0))
(define-accessor class-parent (+ vtable-offset-user 1))
(define-accessor class-fields (+ vtable-offset-user 2))

(define (compute-fields parent fields)
  (if parent
      (append (class-fields parent) fields)
      fields))

(define (compute-layout fields)
  (make-struct-layout
   (string-concatenate (make-list (length fields) "pw"))))

(define (field-index class field)
  (list-index (class-fields class) field))

(define (print-instance x port)
  (format port "<~a" (class-name (struct-vtable x)))
  (for-each (lambda (field idx)
              (format port " ~a: ~a" field (struct-ref x idx)))
            (class-fields (struct-vtable x))
            (iota (length (class-fields (struct-vtable x)))))
  (format port ">"))
@end example

So, at this point we can actually make a few classes:

@example
(define-syntax-rule (define-class name parent field ...)
  (define name (make-class 'name parent '(field ...))))

(define-class <surface> #f
  width height)

(define-class <window> <surface>
  x y)
@end example

And finally, make an instance:

@example
(make-struct/no-tail <window> 400 300 10 20)
@result{} <<window> width: 400 height: 300 x: 10 y: 20>
@end example

And that's that.  Note that there are many possible optimizations and
feature enhancements that can be made to this object system, and the
included GOOPS system does make most of them.  For more simple use
cases, the records facility is usually sufficient.  But sometimes you
need to make new kinds of data abstractions, and for that purpose,
structs are here.

@node Dictionary Types
@subsection Тип Словарь(Dictionary Types)

Объект Словарь @dfn{dictionary} - это структура данных, используемая
для индексирования информации способом определяемым пользователем.
В стандартном Scheme, основными агрегирующими типами данных являются
списки и вектора. Списки не индексируются вообще, а векторы индексируются
только по числу (например@: @code{(vector-ref foo 5)}).  Часто вам
будет полезно проиндексировать ваши данные по другому типу,
например, в библиотеке вы можете захотеть найти книгу по имени ее
автора.  Использование Словаря поможет вам организовать информацию
таким образом.

Ассоциативный список @dfn{association list} (или кратко @dfn{alist})
представляет собой список пар ключ-значение. Каждая пара представляет
собой единую величину или объект; @code{car} для пары - дает ключ,
который используется для идентификации объекта, а @code{cdr} дает
значение объекта.

Хеш-таблица @dfn{hash table} также позволяет вам индексировать объекты
с помощью произвольных ключей, но таким образом, чтобы сделать поиск
любого объекта чрезвычайно быстрым. Хрошо разработанная хеш-система
делает хэш таблицы почти такими же быстрыми, как и обычные массивы или
вектры ссылок.

Alists популярны среди программистов Lisp, потому что они используют
только примитивные оперции языка:(lists, @dfn{car}, @dfn{cdr}
и примитивы равенства).  Никаких изменений в ядре языка.
Поэтому, благодаря встроенным средствам управления списками Scheme
очень удобно обрабатывать данные хранящиеся в ассоциативном списке
Также, alist отличается высокой переносимостью и могут быть реализованы
даже в самых минимальных системах Lisp.

Однако, alist неэффективен, особенно для хранения большого количества данных.
Поскольку мы(разработчки) хотим, чтобы Guile был полезен для больших
программных систем, а также для небольших, Guile предоставляет богатый
набор инструментов для использования ассоциативных списков или хеш-таблиц.

@node Association Lists
@subsection Ассоциативные списки(Association Lists)
@tpindex Association Lists
@tpindex Alist
@cindex association List
@cindex alist
@cindex database

Ассоциативный список представляет собой обычную структуру данных,
которая часто используется для реализации баз данных со структурой
ключ-значение. Она состоит из списка полей, в которых каждая запись
представляет собой пару.  Ключ @dfn{key} каждой записи, содержиться в
начале пары @code{car}, а значение @dfn{value} в конце каждой записи @code{cdr}.

@example
ASSOCIATION LIST ::=  '( (KEY1 . VALUE1)
                         (KEY2 . VALUE2)
                         (KEY3 . VALUE3)
                         @dots{}
                       )
@end example

@noindent
Ассоциативный список также исвестен, как @dfn{alists}.

Структура списка ассоциаций - всего лишь один пример бесконечного числа
возможных структур, которые могут быть построены с использованием
пар и списков. Таким образом, ключами и значениями в списке ассоциаций
можно манипулировать с использованием общих процедур управления списками:
@code{cons}, @code{car}, @code{cdr}, @code{set-car!}, @code{set-cdr!} и
так далее. Однако, поскольку списки ассоциаций настолько полезны, Guile
также предоставляет конкретные процедуры для манипулирования ими.

@menu
* Alist Key Equality::
* Adding or Setting Alist Entries::
* Retrieving Alist Entries::
* Removing Alist Entries::
* Sloppy Alist Functions::
* Alist Example::
@end menu

@node Alist Key Equality
@subsubsection Сравнение ключей (Alist Key Equality)

Все связанные с Guile процедуры работы с ассоциативными списками, представленны
в трех вариантах, в зависимости от уровня равенства, необходимого для принятия
решения о том, существует ли соответствующий ключ в списке ассоциаций совпадающий
с ключем, который используется вызовом процедуры для идентификации требуемой
записи.

@itemize @bullet
@item
Процедуры с @dfn{assq} в их имени используется @code{eq?} для определения
равенства с ключем.

@item
Процедуры с @dfn{assv} в их имени используют @code{eqv?} для определения
равенстваа с ключем.

@item
Процедуры с @dfn{assoc} в их имени используется @code{equal?} для определения
равенства с ключем.
@end itemize

@code{acons} - исключение, поскольку она используется для создания
списков ассоциаций, которые не требуют что бы ключи записей были
уникальны.

@node Adding or Setting Alist Entries
@subsubsection Добавление или Установка записей AList(Adding or Setting Alist Entries)

@code{acons} добавляет новую запись в списко ассоциаций и возвращает
объединенный список ассоциаций. Объединенный список ассоциаций формируется
путем вставки новой записи в начало alist указанного в вызове процедуры
@code{acons}.  Таким образом, указанный  alist не изменяется, но его 
содержимое становиться разделяемым окончанием объединенного списка
ассоциаций  alist который возвращает @code{acons}.

При более общем использовании @code{acons}, переменная содержащая исходный
список ассоциаций изменяется при создании общего alist:

@example
(set! address-list (acons name address address-list))
@end example

В таких случаях не имеет значения, что старые и новые значения
@code{address-list} разделены в их контексте, поскольку старое
значение, как правило, больше не доступно, по независимой ссылке.

Обратите внимание, что @code{acons} добавляет указанную запись независимо
от того, что alist уже может содержать запись с таким же ключем.  Таким
образом @code{acons} идеально подходит для создания alists, где нет 
требования уникальности ключей.

@example
(set! task-list (acons 3 "pay gas bill" '()))
task-list
@result{}
((3 . "pay gas bill"))

(set! task-list (acons 3 "tidy bedroom" task-list))
task-list
@result{}
((3 . "tidy bedroom") (3 . "pay gas bill"))
@end example

@code{assq-set!}, @code{assv-set!} и @code{assoc-set!} используются для
добавления или замены записи в ассоциативном списке в котором есть требование
ункиальности ключей.  Если список указанный как ассоциативный уже содержит
запись, ключ которой совпадает с тем, который указан в вызове процедуры,
существующая запись заменяется новой. Иначе новая запись заноситься в начало
старого списка ассоциаций для создания объединенного  alist.  Во всех случаях,
эти процедуры возвращают объединенный  alist.

@code{assq-set!} и друзья @emph{могут} разрушить структуру старого
списка ассоциаций таким образом, чтобы существующая переменная
была правильно обновлена без необходимости вызывать @code{set!}
для возвращаемого значения:

@example
address-list
@result{}
(("mary" . "34 Elm Road") ("james" . "16 Bow Street"))

(assoc-set! address-list "james" "1a London Road")
@result{}
(("mary" . "34 Elm Road") ("james" . "1a London Road"))

address-list
@result{}
(("mary" . "34 Elm Road") ("james" . "1a London Road"))
@end example

Или они не могут:

@example
(assoc-set! address-list "bob" "11 Newington Avenue")
@result{}
(("bob" . "11 Newington Avenue") ("mary" . "34 Elm Road")
 ("james" . "1a London Road"))

address-list
@result{}
(("mary" . "34 Elm Road") ("james" . "1a London Road"))
@end example

Единственный безопасный способ обновить переменную список ассоциаций
при добавлении или замене записей, вызвать @code{set!} к переменной
для возвращаемого значения:

@example
(set! address-list
      (assoc-set! address-list "bob" "11 Newington Avenue"))
address-list
@result{}
(("bob" . "11 Newington Avenue") ("mary" . "34 Elm Road")
 ("james" . "1a London Road"))
@end example

Из-за этого небольшого неудобства вам может быть удобнее использовать
хеш-таблицы для хранения данных словаря. Если ваше приложение не
будет изменять содержимое alist очень часто это может не иметь большого
значения для вас.

Если вам необходимо сохранить старое значение списка ассоциаций в 
форме, независимой от списка, который будет результатом модификации
@code{acons}, @code{assq-set!}, @code{assv-set!} или @code{assoc-set!},
используйте @code{list-copy}, чтобы скопировать старый список ассоциаций,
прежде чем изменять его.

@deffn {Scheme Procedure} acons key value alist
@deffnx {C Function} scm_acons (key, value, alist)
Add a new key-value pair to @var{alist}.  A new pair is
created whose car is @var{key} and whose cdr is @var{value}, and the
pair is consed onto @var{alist}, and the new list is returned.  This
function is @emph{not} destructive; @var{alist} is not modified.
@end deffn

@deffn {Scheme Procedure} assq-set! alist key val
@deffnx {Scheme Procedure} assv-set! alist key value
@deffnx {Scheme Procedure} assoc-set! alist key value
@deffnx {C Function} scm_assq_set_x (alist, key, val)
@deffnx {C Function} scm_assv_set_x (alist, key, val)
@deffnx {C Function} scm_assoc_set_x (alist, key, val)
Reassociate @var{key} in @var{alist} with @var{value}: find any existing
@var{alist} entry for @var{key} and associate it with the new
@var{value}.  If @var{alist} does not contain an entry for @var{key},
add a new one.  Return the (possibly new) alist.

These functions do not attempt to verify the structure of @var{alist},
and so may cause unusual results if passed an object that is not an
association list.
@end deffn

@node Retrieving Alist Entries
@subsubsection Получение записей Alist (Retrieving Alist Entries)
@rnindex assq
@rnindex assv
@rnindex assoc

@code{assq}, @code{assv} и @code{assoc} ищут запись в  alist
для заданного ключа(key), и возвращают пару @code{(@var{key} . @var{value})}.
@code{assq-ref}, @code{assv-ref} и @code{assoc-ref} делают аналогичный
поиск, но возвращают только значение @var{value}.

@deffn {Scheme Procedure} assq key alist
@deffnx {Scheme Procedure} assv key alist
@deffnx {Scheme Procedure} assoc key alist
@deffnx {C Function} scm_assq (key, alist)
@deffnx {C Function} scm_assv (key, alist)
@deffnx {C Function} scm_assoc (key, alist)
Return the first entry in @var{alist} with the given @var{key}.  The
return is the pair @code{(KEY . VALUE)} from @var{alist}.  If there's
no matching entry the return is @code{#f}.

@code{assq} compares keys with @code{eq?}, @code{assv} uses
@code{eqv?} and @code{assoc} uses @code{equal?}.  See also SRFI-1
which has an extended @code{assoc} (@ref{SRFI-1 Association Lists}).
@end deffn

@deffn {Scheme Procedure} assq-ref alist key
@deffnx {Scheme Procedure} assv-ref alist key
@deffnx {Scheme Procedure} assoc-ref alist key
@deffnx {C Function} scm_assq_ref (alist, key)
@deffnx {C Function} scm_assv_ref (alist, key)
@deffnx {C Function} scm_assoc_ref (alist, key)
Return the value from the first entry in @var{alist} with the given
@var{key}, or @code{#f} if there's no such entry.

@code{assq-ref} compares keys with @code{eq?}, @code{assv-ref} uses
@code{eqv?} and @code{assoc-ref} uses @code{equal?}.

Notice these functions have the @var{key} argument last, like other
@code{-ref} functions, but this is opposite to what @code{assq}
etc above use.

When the return is @code{#f} it can be either @var{key} not found, or
an entry which happens to have value @code{#f} in the @code{cdr}.  Use
@code{assq} etc above if you need to differentiate these cases.
@end deffn

@node Removing Alist Entries
@subsubsection Удаление записей Alist (Removing Alist Entries)

Чтобы удалить элемент из списка ассоциаций, ключ которого соответствует
указанному ключу, ипсользуйте @code{assq-remove!}, @code{assv-remove!} или
@code{assoc-remove!} (в зависимости, как обычно, от уровня требуемого
равенства между указанным ключем и ключами из списка ассоциаций).

Как и с @code{assq-set!} и друзьями, указываемый alist может или не может
быть разрушающе изменен, и единственный безопасный способ обновить
переменную, содержащую alist использовать @code{set!} чтобы установить
значение, которое возрващает @code{assq-remove!} и друзья.

@example
address-list
@result{}
(("bob" . "11 Newington Avenue") ("mary" . "34 Elm Road")
 ("james" . "1a London Road"))

(set! address-list (assoc-remove! address-list "mary"))
address-list
@result{}
(("bob" . "11 Newington Avenue") ("james" . "1a London Road"))
@end example

Note that, when @code{assq/v/oc-remove!} is used to modify an
association list that has been constructed only using the corresponding
@code{assq/v/oc-set!}, there can be at most one matching entry in the
alist, so the question of multiple entries being removed in one go does
not arise.  If @code{assq/v/oc-remove!} is applied to an association
list that has been constructed using @code{acons}, or an
@code{assq/v/oc-set!} with a different level of equality, or any mixture
of these, it removes only the first matching entry from the alist, even
if the alist might contain further matching entries.  For example:

@example
(define address-list '())
(set! address-list (assq-set! address-list "mary" "11 Elm Street"))
(set! address-list (assq-set! address-list "mary" "57 Pine Drive"))
address-list
@result{}
(("mary" . "57 Pine Drive") ("mary" . "11 Elm Street"))

(set! address-list (assoc-remove! address-list "mary"))
address-list
@result{}
(("mary" . "11 Elm Street"))
@end example

In this example, the two instances of the string "mary" are not the same
when compared using @code{eq?}, so the two @code{assq-set!} calls add
two distinct entries to @code{address-list}.  When compared using
@code{equal?}, both "mary"s in @code{address-list} are the same as the
"mary" in the @code{assoc-remove!} call, but @code{assoc-remove!} stops
after removing the first matching entry that it finds, and so one of the
"mary" entries is left in place.

@deffn {Scheme Procedure} assq-remove! alist key
@deffnx {Scheme Procedure} assv-remove! alist key
@deffnx {Scheme Procedure} assoc-remove! alist key
@deffnx {C Function} scm_assq_remove_x (alist, key)
@deffnx {C Function} scm_assv_remove_x (alist, key)
@deffnx {C Function} scm_assoc_remove_x (alist, key)
Delete the first entry in @var{alist} associated with @var{key}, and return
the resulting alist.
@end deffn

@node Sloppy Alist Functions
@subsubsection Пренебрегающие ошибками функции Alist

@code{sloppy-assq}, @code{sloppy-assv} и @code{sloppy-assoc} ведут себя
также как соответствующие не пренебрежительные@code{sloppy-} функцкии, 
за исключением того, что они возвращают @code{#f}, если указанный им 
список ассоциаций не является корректным, где не-@code{sloppy-} версии 
функций выбрасывают сигнал ошибки.

В частности, существуют два условия, при которых не пренебрегабщие@code{sloppy-}
функции сигнализируют об ошибке, которую пренебрежительные @code{sloppy-} 
процедуры обрабатывают возвращая @code{#f}.  Во-первых, если указанный alist
в целом не является правильным списком:

@example
(assoc "mary" '((1 . 2) ("key" . "door") . "open sesame"))
@result{}
ERROR: In procedure assoc in expression (assoc "mary" (quote #)):
ERROR: Wrong type argument in position 2 (expecting
   association list): ((1 . 2) ("key" . "door") . "open sesame")

(sloppy-assoc "mary" '((1 . 2) ("key" . "door") . "open sesame"))
@result{}
#f
@end example

@noindent
Во-вторых, если одна из записей в указанном alist не является парой:

@example
(assoc 2 '((1 . 1) 2 (3 . 9)))
@result{}
ERROR: In procedure assoc in expression (assoc 2 (quote #)):
ERROR: Wrong type argument in position 2 (expecting
   association list): ((1 . 1) 2 (3 . 9))

(sloppy-assoc 2 '((1 . 1) 2 (3 . 9)))
@result{}
#f
@end example

Unless you are explicitly working with badly formed association lists,
it is much safer to use the non-@code{sloppy-} procedures, because they
help to highlight coding and data errors that the @code{sloppy-}
versions would silently cover up.

@deffn {Scheme Procedure} sloppy-assq key alist
@deffnx {C Function} scm_sloppy_assq (key, alist)
Behaves like @code{assq} but does not do any error checking.
Recommended only for use in Guile internals.
@end deffn

@deffn {Scheme Procedure} sloppy-assv key alist
@deffnx {C Function} scm_sloppy_assv (key, alist)
Behaves like @code{assv} but does not do any error checking.
Recommended only for use in Guile internals.
@end deffn

@deffn {Scheme Procedure} sloppy-assoc key alist
@deffnx {C Function} scm_sloppy_assoc (key, alist)
Behaves like @code{assoc} but does not do any error checking.
Recommended only for use in Guile internals.
@end deffn

@node Alist Example
@subsubsection Пример Alist

Вот более длинный пример того, как списки ассоциаций могут 
использоваться на практике.

@lisp
(define capitals '(("New York" . "Albany")
                   ("Oregon"   . "Salem")
                   ("Florida"  . "Miami")))

;; What's the capital of Oregon?
(assoc "Oregon" capitals)       @result{} ("Oregon" . "Salem")
(assoc-ref capitals "Oregon")   @result{} "Salem"

;; We left out South Dakota.
(set! capitals
      (assoc-set! capitals "South Dakota" "Pierre"))
capitals
@result{} (("South Dakota" . "Pierre")
    ("New York" . "Albany")
    ("Oregon" . "Salem")
    ("Florida" . "Miami"))

;; And we got Florida wrong.
(set! capitals
      (assoc-set! capitals "Florida" "Tallahassee"))
capitals
@result{} (("South Dakota" . "Pierre")
    ("New York" . "Albany")
    ("Oregon" . "Salem")
    ("Florida" . "Tallahassee"))

;; After Oregon secedes, we can remove it.
(set! capitals
      (assoc-remove! capitals "Oregon"))
capitals
@result{} (("South Dakota" . "Pierre")
    ("New York" . "Albany")
    ("Florida" . "Tallahassee"))
@end lisp

@node VHashes
@subsection Базирующийся на VList Хеш-Список или ``VHashes''

@cindex VList-based hash lists
@cindex VHash

Модуль @code{(ice-9 vlist)} предоставляет реализацию хеш списка на основе
@dfn{VList} (@pxref{VLists}).  Базирующийся на VList  хеш список, или @dfn{vhashes},
является типом неизменяемого словаря, аналогичный списку ассоциаций, который
сопоставляет ключу@dfn{keys} - значение@dfn{values}.  Однако, в отличие от
списка ассоцаций, доступ к значению с учетом его ключа, как правило, является
операцией с постоянным временем выполнения.

Программный интерфейс VHash @code{(ice-9 vlist)} в основном такой же, как у 
списка ассоциаций, из SRFI-1, с именами процедур предваряемыми @code{vhash-}
вместо @code{alist-} (@pxref{SRFI-1 Association Lists}).

Кроме того, vhashes можно манипулировать с помощью операций
VList:

@example
(vlist-head (vhash-consq 'a 1 vlist-null))
@result{} (a . 1)

(define vh1 (vhash-consq 'b 2 (vhash-consq 'a 1 vlist-null)))
(define vh2 (vhash-consq 'c 3 (vlist-tail vh1)))

(vhash-assq 'a vh2)
@result{} (a . 1)
(vhash-assq 'b vh2)
@result{} #f
(vhash-assq 'c vh2)
@result{} (c . 3)
(vlist->list vh2)
@result{} ((c . 3) (a . 1))
@end example

However, keep in mind that procedures that construct new VLists
(@code{vlist-map}, @code{vlist-filter}, etc.) return raw VLists, not vhashes:

@example
(define vh (alist->vhash '((a . 1) (b . 2) (c . 3)) hashq))
(vhash-assq 'a vh)
@result{} (a . 1)

(define vl
  ;; This will create a raw vlist.
  (vlist-filter (lambda (key+value) (odd? (cdr key+value))) vh))
(vhash-assq 'a vl)
@result{} ERROR: Wrong type argument in position 2

(vlist->list vl)
@result{} ((a . 1) (c . 3))
@end example

@deffn {Scheme Procedure} vhash? obj
Return true if @var{obj} is a vhash.
@end deffn

@deffn {Scheme Procedure} vhash-cons key value vhash [hash-proc]
@deffnx {Scheme Procedure} vhash-consq key value vhash
@deffnx {Scheme Procedure} vhash-consv key value vhash
Return a new hash list based on @var{vhash} where @var{key} is associated with
@var{value}, using @var{hash-proc} to compute the hash of @var{key}.
@var{vhash} must be either @code{vlist-null} or a vhash returned by a previous
call to @code{vhash-cons}.  @var{hash-proc} defaults to @code{hash} (@pxref{Hash
Table Reference, @code{hash} procedure}).  With @code{vhash-consq}, the
@code{hashq} hash function is used; with @code{vhash-consv} the @code{hashv}
hash function is used.

All @code{vhash-cons} calls made to construct a vhash should use the same
@var{hash-proc}.  Failing to do that, the result is undefined.
@end deffn

@deffn {Scheme Procedure} vhash-assoc key vhash [equal? [hash-proc]]
@deffnx {Scheme Procedure} vhash-assq key vhash
@deffnx {Scheme Procedure} vhash-assv key vhash
Return the first key/value pair from @var{vhash} whose key is equal to @var{key}
according to the @var{equal?} equality predicate (which defaults to
@code{equal?}), and using @var{hash-proc} (which defaults to @code{hash}) to
compute the hash of @var{key}.  The second form uses @code{eq?} as the equality
predicate and @code{hashq} as the hash function; the last form uses @code{eqv?}
and @code{hashv}.

Note that it is important to consistently use the same hash function for
@var{hash-proc} as was passed to @code{vhash-cons}.  Failing to do that, the
result is unpredictable.
@end deffn

@deffn {Scheme Procedure} vhash-delete key vhash [equal? [hash-proc]]
@deffnx {Scheme Procedure} vhash-delq key vhash
@deffnx {Scheme Procedure} vhash-delv key vhash
Remove all associations from @var{vhash} with @var{key}, comparing keys with
@var{equal?} (which defaults to @code{equal?}), and computing the hash of
@var{key} using @var{hash-proc} (which defaults to @code{hash}).  The second
form uses @code{eq?} as the equality predicate and @code{hashq} as the hash
function; the last one uses @code{eqv?} and @code{hashv}.

Again the choice of @var{hash-proc} must be consistent with previous calls to
@code{vhash-cons}.
@end deffn

@deffn {Scheme Procedure} vhash-fold proc init vhash
@deffnx {Scheme Procedure} vhash-fold-right proc init vhash
Fold over the key/value elements of @var{vhash} in the given direction,
with each call to @var{proc} having the form @code{(@var{proc} key value
result)}, where @var{result} is the result of the previous call to
@var{proc} and @var{init} the value of @var{result} for the first call
to @var{proc}.
@end deffn

@deffn {Scheme Procedure} vhash-fold* proc init key vhash [equal? [hash]]
@deffnx {Scheme Procedure} vhash-foldq* proc init key vhash
@deffnx {Scheme Procedure} vhash-foldv* proc init key vhash
Fold over all the values associated with @var{key} in @var{vhash}, with each
call to @var{proc} having the form @code{(proc value result)}, where
@var{result} is the result of the previous call to @var{proc} and @var{init} the
value of @var{result} for the first call to @var{proc}.

Keys in @var{vhash} are hashed using @var{hash} are compared using @var{equal?}.
The second form uses @code{eq?} as the equality predicate and @code{hashq} as
the hash function; the third one uses @code{eqv?} and @code{hashv}.

Example:

@example
(define vh
  (alist->vhash '((a . 1) (a . 2) (z . 0) (a . 3))))

(vhash-fold* cons '() 'a vh)
@result{} (3 2 1)

(vhash-fold* cons '() 'z vh)
@result{} (0)
@end example
@end deffn

@deffn {Scheme Procedure} alist->vhash alist [hash-proc]
Return the vhash corresponding to @var{alist}, an association list, using
@var{hash-proc} to compute key hashes.  When omitted, @var{hash-proc} defaults
to @code{hash}.
@end deffn

@node Hash Tables
@subsection Хеш Таблица(Hash Tables)
@tpindex Hash Tables

Хеш-таблицы это словари, которые пердлагают функциональность аналогичную
спискам ассоциций: предоставлять сопоставление от ключей к значениям. 
Разница в том, что спики ассоциаций требует время линейно зависящее от
количества элементов в списке, тогда как хеш-таблицы обычно могут
искать за постоянное время. Недостатком является то, что хеш-таблицы
требуеют немного больше памяти, и что вы не можете испльзовать
обычные процедуры работы со списками (@pxref{Lists}) для работы 
с ними.

@menu
* Hash Table Examples::         Demonstration of hash table usage.
* Hash Table Reference::        Hash table procedure descriptions.
@end menu

@node Hash Table Examples
@subsubsection Пример Хеш-Таблицы

Для демонстрационных целей в этом разделе приведены несколько примеров
использования некоторых процедур работы с хеш-таблицами, а также некоторое
объяснение того, что они делают.

Сначала мы начинаем с создания новой хеш-таблицы с 31-им слотом, 
и заполняем ее двумя парами  ключ/значение.

@lisp
(define h (make-hash-table 31))

;; This is an opaque object
h
@result{}
#<hash-table 0/31>

;; Inserting into a hash table can be done with hashq-set!
(hashq-set! h 'foo "bar")
@result{}
"bar"

(hashq-set! h 'braz "zonk")
@result{}
"zonk"

;; Or with hash-create-handle!
(hashq-create-handle! h 'frob #f)
@result{}
(frob . #f)
@end lisp

Вы можете получить значение для данного ключа с помощью процедуры
@code{hashq-ref}, но проблема с этой процедурой заключается в том,
что вы не можете надежно определить, существует ли ключ в таблице.
Причина в том, что процедура возвращает @code{#f} если ключа нет
в таблице, но она будет возвращать тоже значение, если ключ находиться
в таблице, а значение просто  равно @code{#f}, что вы можете увидеть
в следующих примерах.

@lisp
(hashq-ref h 'foo)
@result{}
"bar"

(hashq-ref h 'frob)
@result{}
#f

(hashq-ref h 'not-there)
@result{}
#f
@end lisp

Зачастую лучше использовать процедуру @code{hashq-get-handle}, которая
делает различие между двумя случаями. Как и  @code{assq}, эта процедура
возвращает пару ключ/значение(key/value) при успешном завершении, и @code{#f}
если ключ не найден.

@lisp
(hashq-get-handle h 'foo)
@result{}
(foo . "bar")

(hashq-get-handle h 'not-there)
@result{}
#f
@end lisp

Интересные результаты могут быть вычислены с помощью @code{hash-fold}
работающей с каждым элементом хеш-таблицы. В этом примере будет подсчитано
общее количество элементов.

@lisp
(hash-fold (lambda (key value seed) (+ 1 seed)) 0 h)
@result{}
3
@end lisp

То же самое можно сделать с помощью процедуры @code{hash-count}, которая
также может подсчитать количество элементов, соответствующих определенному
предикату. Например, подсчитаем количество элементов со строковыми значениями:

@lisp
(hash-count (lambda (key value) (string? value)) h)
@result{}
2
@end lisp

Подсчет всех элементов - простая задача, использующая @code{const}:

@lisp
(hash-count (const #t) h)
@result{}
3
@end lisp

@node Hash Table Reference
@subsubsection Справочник по Хеш-Таблицам

@c  FIXME: Describe in broad terms what happens for resizing, and what
@c  the initial size means for this.

Подобно функциям списка ассоциаций, функции хеш-таблицы делятся на 
несколько разновидностей, согласно теста равенства, испльзуемого
для сравнения ключей. Обычные хеш-@code{hash-} функции используют @code{equal?}, 
функции с префиксом @code{hashq-} используют @code{eq?}, с префиксом @code{hashv-}
испльзуют @code{eqv?}, и функции @code{hashx-} испльзуют приложение
предоставляющее для тест.

Простой вызов @code{make-hash-table} создает хеш-таблицу, подходящую
для использования с любым набором функций, но очень важно, чтобы только
один набор использовался с данной таблице, или результаты будут
непредсказуемыми.

Хеш-таблицы реализуются как вектор, индексированный хеш-значением,
сформированным из ключа, с ассоциативным списком пар ключ/значение
для каждой ячейки в случае конфликта значений хеша ключа. Прямой
доступ к парам в этих спиках обеспечивается с помощью @code{-handle-}
функций.

Когда количество записей в хэш-таблице превышает пороговое значение, вектор
увеличивается, и записи перезаписываются, чтобы списки ячеек не становились
слишком длинными и замедлся доступ. Когда количество записей становиться
ниже порогового значения, вектор сокращается, чтобы сэкономить место.

Для расширенных функций @code{hashx-}, приложение предоставляет
хеш-@var{hash} функцию, вычисляющую целочисленный индекс, например
@code{hashq} и т.д., а также функцию поиска по ключу подобную 
@var{assoc} для alist или как @code{assq} и т.д.
(@pxref{Retrieving Alist Entries}).  Вот пример таких функций
внедрения нечувствительных к регистру хэширования строковых ключей.

@example
(use-modules (srfi srfi-1)
             (srfi srfi-13))

(define (my-hash str size)
  (remainder (string-hash-ci str) size))
(define (my-assoc str alist)
  (find (lambda (pair) (string-ci=? str (car pair))) alist))

(define my-table (make-hash-table))
(hashx-set! my-hash my-assoc my-table "foo" 123)

(hashx-ref my-hash my-assoc my-table "FOO")
@result{} 123
@end example

В @code{hashx-} цель функции @var{hash} состоит в том, чтобы рапределять
ключи по вектору, поэтому списки ячеек вектора не становятся длинными.
Но фактические значения произвольны, если они находятся в диапазоне от 0 
до @math{@var{size}-1}.  Полезные функции для формирования хеш-значения,
в дополнение к @code{hashq} и т.д, включают @code{symbol-hash}
(@pxref{Symbol Keys}), @code{string-hash} и @code{string-hash-ci}
(@pxref{String Comparison}), и @code{char-set-hash}
(@pxref{Character Set Predicates/Comparison}).

@sp 1
@deffn {Scheme Procedure} make-hash-table [size]
Create a new hash table object, with an optional minimum
vector @var{size}.

Когда задан размер @var{size}, вектор таблицы будет расти и автоматически
сокращаться, как описано выше, но размер будет минимум @var{size}.
Если приложение, знает как много записей будет удерживать таблица, тогда
оно может размер, чтобы избежать повторного рехеширования когда будут
добавляться записи.
@end deffn

@deffn {Scheme Procedure} alist->hash-table alist
@deffnx {Scheme Procedure} alist->hashq-table alist
@deffnx {Scheme Procedure} alist->hashv-table alist
@deffnx {Scheme Procedure} alist->hashx-table hash assoc alist
Convert @var{alist} into a hash table. When keys are repeated in
@var{alist}, the leftmost association takes precedence.

@example
(use-modules (ice-9 hash-table))
(alist->hash-table '((foo . 1) (bar . 2)))
@end example

When converting to an extended hash table, custom @var{hash} and
@var{assoc} procedures must be provided.

@example
(alist->hashx-table hash assoc '((foo . 1) (bar . 2)))
@end example

@end deffn

@deffn {Scheme Procedure} hash-table? obj
@deffnx {C Function} scm_hash_table_p (obj)
Return @code{#t} if @var{obj} is a abstract hash table object.
@end deffn

@deffn {Scheme Procedure} hash-clear! table
@deffnx {C Function} scm_hash_clear_x (table)
Remove all items from @var{table} (without triggering a resize).
@end deffn

@deffn {Scheme Procedure} hash-ref table key [dflt]
@deffnx {Scheme Procedure} hashq-ref table key [dflt]
@deffnx {Scheme Procedure} hashv-ref table key [dflt]
@deffnx {Scheme Procedure} hashx-ref hash assoc table key [dflt]
@deffnx {C Function} scm_hash_ref (table, key, dflt)
@deffnx {C Function} scm_hashq_ref (table, key, dflt)
@deffnx {C Function} scm_hashv_ref (table, key, dflt)
@deffnx {C Function} scm_hashx_ref (hash, assoc, table, key, dflt)
Lookup @var{key} in the given hash @var{table}, and return the
associated value.  If @var{key} is not found, return @var{dflt}, or
@code{#f} if @var{dflt} is not given.
@end deffn

@deffn {Scheme Procedure} hash-set! table key val
@deffnx {Scheme Procedure} hashq-set! table key val
@deffnx {Scheme Procedure} hashv-set! table key val
@deffnx {Scheme Procedure} hashx-set! hash assoc table key val
@deffnx {C Function} scm_hash_set_x (table, key, val)
@deffnx {C Function} scm_hashq_set_x (table, key, val)
@deffnx {C Function} scm_hashv_set_x (table, key, val)
@deffnx {C Function} scm_hashx_set_x (hash, assoc, table, key, val)
Associate @var{val} with @var{key} in the given hash @var{table}.  If
@var{key} is already present then it's associated value is changed.
If it's not present then a new entry is created.
@end deffn

@deffn {Scheme Procedure} hash-remove! table key
@deffnx {Scheme Procedure} hashq-remove! table key
@deffnx {Scheme Procedure} hashv-remove! table key
@deffnx {Scheme Procedure} hashx-remove! hash assoc table key
@deffnx {C Function} scm_hash_remove_x (table, key)
@deffnx {C Function} scm_hashq_remove_x (table, key)
@deffnx {C Function} scm_hashv_remove_x (table, key)
@deffnx {C Function} scm_hashx_remove_x (hash, assoc, table, key)
Remove any association for @var{key} in the given hash @var{table}.
If @var{key} is not in @var{table} then nothing is done.
@end deffn

@deffn {Scheme Procedure} hash key size
@deffnx {Scheme Procedure} hashq key size
@deffnx {Scheme Procedure} hashv key size
@deffnx {C Function} scm_hash (key, size)
@deffnx {C Function} scm_hashq (key, size)
@deffnx {C Function} scm_hashv (key, size)
Return a hash value for @var{key}.  This is a number in the range
@math{0} to @math{@var{size}-1}, which is suitable for use in a hash
table of the given @var{size}.

Note that @code{hashq} and @code{hashv} may use internal addresses of
objects, so if an object is garbage collected and re-created it can
have a different hash value, even when the two are notionally
@code{eq?}.  For instance with symbols,

@example
(hashq 'something 123)   @result{} 19
(gc)
(hashq 'something 123)   @result{} 62
@end example

In normal use this is not a problem, since an object entered into a
hash table won't be garbage collected until removed.  It's only if
hashing calculations are somehow separated from normal references that
its lifetime needs to be considered.
@end deffn

@deffn {Scheme Procedure} hash-get-handle table key
@deffnx {Scheme Procedure} hashq-get-handle table key
@deffnx {Scheme Procedure} hashv-get-handle table key
@deffnx {Scheme Procedure} hashx-get-handle hash assoc table key
@deffnx {C Function} scm_hash_get_handle (table, key)
@deffnx {C Function} scm_hashq_get_handle (table, key)
@deffnx {C Function} scm_hashv_get_handle (table, key)
@deffnx {C Function} scm_hashx_get_handle (hash, assoc, table, key)
Return the @code{(@var{key} . @var{value})} pair for @var{key} in the
given hash @var{table}, or @code{#f} if @var{key} is not in
@var{table}.
@end deffn

@deffn {Scheme Procedure} hash-create-handle! table key init
@deffnx {Scheme Procedure} hashq-create-handle! table key init
@deffnx {Scheme Procedure} hashv-create-handle! table key init
@deffnx {Scheme Procedure} hashx-create-handle! hash assoc table key init
@deffnx {C Function} scm_hash_create_handle_x (table, key, init)
@deffnx {C Function} scm_hashq_create_handle_x (table, key, init)
@deffnx {C Function} scm_hashv_create_handle_x (table, key, init)
@deffnx {C Function} scm_hashx_create_handle_x (hash, assoc, table, key, init)
Return the @code{(@var{key} . @var{value})} pair for @var{key} in the
given hash @var{table}.  If @var{key} is not in @var{table} then
create an entry for it with @var{init} as the value, and return that
pair.
@end deffn

@deffn {Scheme Procedure} hash-map->list proc table
@deffnx {Scheme Procedure} hash-for-each proc table
@deffnx {C Function} scm_hash_map_to_list (proc, table)
@deffnx {C Function} scm_hash_for_each (proc, table)
Apply @var{proc} to the entries in the given hash @var{table}.  Each
call is @code{(@var{proc} @var{key} @var{value})}.  @code{hash-map->list}
returns a list of the results from these calls, @code{hash-for-each}
discards the results and returns an unspecified value.

Calls are made over the table entries in an unspecified order, and for
@code{hash-map->list} the order of the values in the returned list is
unspecified.  Results will be unpredictable if @var{table} is modified
while iterating.

For example the following returns a new alist comprising all the
entries from @code{mytable}, in no particular order.

@example
(hash-map->list cons mytable)
@end example
@end deffn

@deffn {Scheme Procedure} hash-for-each-handle proc table
@deffnx {C Function} scm_hash_for_each_handle (proc, table)
Apply @var{proc} to the entries in the given hash @var{table}.  Each
call is @code{(@var{proc} @var{handle})}, where @var{handle} is a
@code{(@var{key} . @var{value})} pair. Return an unspecified value.

@code{hash-for-each-handle} differs from @code{hash-for-each} only in
the argument list of @var{proc}.
@end deffn

@deffn {Scheme Procedure} hash-fold proc init table
@deffnx {C Function} scm_hash_fold (proc, init, table)
Accumulate a result by applying @var{proc} to the elements of the
given hash @var{table}.  Each call is @code{(@var{proc} @var{key}
@var{value} @var{prior-result})}, where @var{key} and @var{value} are
from the @var{table} and @var{prior-result} is the return from the
previous @var{proc} call.  For the first call, @var{prior-result} is
the given @var{init} value.

Calls are made over the table entries in an unspecified order.
Results will be unpredictable if @var{table} is modified while
@code{hash-fold} is running.

For example, the following returns a count of how many keys in
@code{mytable} are strings.

@example
(hash-fold (lambda (key value prior)
             (if (string? key) (1+ prior) prior))
           0 mytable)
@end example
@end deffn

@deffn {Scheme Procedure} hash-count pred table
@deffnx {C Function} scm_hash_count (pred, table)
Return the number of elements in the given hash @var{table} that cause
@code{(@var{pred} @var{key} @var{value})} to return true.  To quickly
determine the total number of elements, use @code{(const #t)} for
@var{pred}.
@end deffn

@node Other Types
@subsection Другие Типы

Процедуры описаны в их собственном разделе.  @xref{Procedures}.

Переменные документируются как часть описания модульной системы Guile:
См. @ref{Variables}.

@xref{Scheduling}, для обсуждения потоков, мьютексов и т.д.

Порты описаны в разделе I/O: см. @ref{Input and Output}.

Регулярные выражения описаны в их собственном разделе: см. @ref{Regular
Expressions}.

Существует целый ряд дополнительных  типов данных, задокументированных
в этом руководстве, если вы думаете что здесь отсутствует ссылка, сообщите
об ошибке.

@c Local Variables:
@c TeX-master: "guile.texi"
@c End: