@c -*-texinfo-*-
@c This is part of the GNU Guile Reference Manual.
@c Copyright (C)  2008, 2010, 2011, 2013
@c   Free Software Foundation, Inc.
@c See the file guile.texi for copying conditions.

@node History
@section Краткая история Guile

Guile это артефакт исторических процессов, как кода, так и сообщества
хакеров.  Эту историю иногда полезно знать при изучении исходного кода,
знать о прошлых решениях и о будущих направлениях.

Конечно, настоящая история Guile пишется хакерами, а не писателями
поэтому мы завершаем раздел с описанием текущего статуса и будущих
направлений.

@menu
* The Emacs Thesis::  
* Early Days::                  
* A Scheme of Many Maintainers::  
* A Timeline of Selected Guile Releases::  
* Status::
@end menu

@node The Emacs Thesis
@subsection Тезисы Emacs

История Guile - это рассказа о том, как перенести опыт  Emacs
в развитие программ в системе GNU.

Emacs, когда он впервыпе был создан в форме GNU в 1984, стал новым
решением проблемы ``как сделать программу''. Тезис Emacs заключается
в том, что очень приятно создавать сложные программы на основе 
ортогонального ядра, написанного на низкоуровневом языке, вместе с 
мощным, высокоуровневым языком расширения.

Язык Расширения способствует расширению программ, программ которые
легко адаптируются к различным пользователям и временным изменениям.
Доказательство этого можно увидеть в текущем  Emacs и продолжении
его существования, охватывающем более четверти века.

Помимо предоставления модификации программы другими, язык расширения
хороши также для усиления. Программы, созданные в ``Emacs стиле'' 
приятны и легки для их авторов, что бы понять, какие функции им нужны.

После того как опыт Emacs был оценен более широко, ряд хакеров начали
рассмотрение вопроса, как распространить этот опыт на остальную часть
системы GNU. Было ясно, что самый простой способ  Emacsify(емаксировать)
программы - это внедрить в них реализацию общего языка.

@node Early Days
@subsection Первые Дни

Tom Lord был первым, кто полностью сконцентрировал свои усилия на внедрение
языка времени выполнения, который он назвал ``GEL'', языком расширения GNU.

GEL был продуктом преобразования SCM, реализации Scheme Aubrey Jaffer,
в нечто более подходящее для внедрения в качестве библиотеки.
(Сам SCM базировался на реализации выполненной  George Carrette, SIOD.)

Lord удалось убедить Richard Stallman перевести GEL в статус
официального языка расширений для проекта GNU. Это было естественным
подходом, учитывая что Scheme был более чистым, более современным
Lisp чем Emacs Lisp. Часть аргументов заключалась в том, что в конечном
итоге, когда  GEL станет более мощным, он могбы научиться выполнять
программы на других языках, особенно  Emacs Lisp.

Из-за конфликта имен с другим языком програмирования, Jim Blandy
предложил новое название для GEL: ``Guile''. Помимо рекурсивного
акронима, ``Guile'' хитрое следование имен его предков,
``Planner'', ``Conniver'', и ``Schemer''. (Последний был усечен до
 ``Scheme'' из-за ограничений длины имени файлов в 6-символов на
старой операционной системе.) Наконец, ``Guile'' созвучен ``guy-ell'',
или ``Guy L. Steele'', который вместе с Gerald Sussman, первоначально
создали схему.

Примерно в тоже время, когда Guile (GEL) готовился к публичному выпуску,
другой язык расширения набирал популярность,Tcl. Многие разработчики
нашли преимущества в Tcl из-за его shell-подобного синтаксиса и его
хорошо развитой библиотеки графических виджетов, Tk. Кроме того, в то
время был большой маркетинговый толчок, представлявший Tcl как 
``универсальный язык расширений''.

Richard Stallman, как главный автор GNU Emacs, имел особое виденье
какие языки расширения должны быть, и  Tcl не казался ему столь же
способным как Emacs Lisp. Он отправил критику в группу новостей 
comp.lang.tcl, вызвав одну из легендарных интернет дискуссий. 
В части эти рассуждения окрестили как ``Tcl Войны'', он объявил
о намерении фонда СПО продвигать Guile как язык расширений для
проекта GNU.

Это распространенное заблуждение, что Guile был создан как реакция на
Tcl. Хотя это правда, что публичное объявление Guile произошло одновременно
с  ``Tcl войнами'', Guile был создан из условий которые существовали вне
полемики. Действительно, требование необходимости наличия мощного языка,
что бы преодолеть разрыв между расширением существующих приложений и
динамической средой программирования, по прежнему остается с нами и сегодня.

@node A Scheme of Many Maintainers
@subsection A Scheme of Many Maintainers

Обследовав поле, кажеться, что число реализаций Scheme соответствует
числу их сопровождаеющих maintainers в отношении N-to-1. То есть, те 
люди которые реализуют Schemes, могут делать это несколько раз, но 
время жизни данной Scheme связано с сопровождением одного человека.

В этом отношении Guile не типично.

Tom Lord поддерживал Guile в течении первых полутора лет или около
того, что соответствует концу 1994 года до середины 1996. Выпуски,
сделанные за это время, составляют дугу от SCM к Guile как автономной
программе, переиспользуемой, внедряемой библиотеки, но проходящей
через взрыв характеристик: встроенные  Tcl и Tk, инструментальная
цепочка для дизассемблирования Java, добавление Си подобного синтаксиса,
создания модульной системы и запуска богатого интерфейса POSIX.

Только некоторые из этих функций остались в Guile. Постоянное напряжение
между предоставлением небольшого вложенного языка, и того, который имеет
все функции(например графический инструментарий), что может понадобиться
современному Emacs. В конце концов, по мере того как Guile формировалась,
команда разработчиков решила сосредоточится на глубине, документации и
ортогональности, чем на широте. С тех пор это было в центре внимания Guile,
хотя существует широкий диапазон библиотек для Guile.

Джим Бленди председательствовал на этот период стабилизации, за три года,
до конца 1999 года, когда он тоже перешел к другим проектам. С тех пор
у Guile была группа сопровождающих. Первой группой были Мацей Стаховак,
Микаэль Джульфельд и Мариус Фоллмер, с Воллмером, остающимся надолго.
К концу 2007 года Фолмер в основном перешел к другим вещам, поэтому Нейл
Джеррам и Людовик Курт взяли на себя основную ответственность за 
сопровождение. В конце 2009 года к Джерри и Курту присоединился Энди
Винго.

Конечно, значительная часть фактической работы с Guile исходит от
других участников которых слишком много, чтобы упомянуть, но без 
которых мир был бы беднее.

@node A Timeline of Selected Guile Releases
@subsection Временная шкала выпусков Guile

@table @asis
@item guile-i --- 4 February 1995
SCM, превратился в библиотеку.

@item guile-ii --- 6 April 1995
Была добавлена низкоуровневая модульная система. Добавлена поддержка Tcl/Tk,
позволяющая расширение Scheme через Tcl и наоборот. Поддержка POSIX была 
улучешна, и была предпринята эксперементальная попытка интеграции с Java.

@item guile-iii --- 18 August 1995
Си-подобный синткасис был улучшен, но в основном этот выпуск
обозначил начало разбиения Guile на части.

@item 1.0 --- 5 January 1997
@code{#f} теперь отличается от @code{'()}. Добавлена многопоточность 
на уровне пользователя. Отладка исходного кода стала более удобной,
было начато написание руководства для программистов и пользователей.
Модульная система получила интерфейс высокого уровня, который до сих 
пор в более менее неизменной форме.

@item 1.1 --- 16 May 1997
@itemx 1.2 --- 24 June 1997
Поддержка Tcl/Tk и ctax была разделена по отдельным пакетам и с тех пор
остается там. Guile стал более совместимым с SCSH, и стал более полезным
как язык сценариев UNIX. Теперь Libguile может быть построена как общая
библиотека и сторонние расширения, написанные на Си, могут загружаться
через динамическую линковку.

@item 1.3.0 --- 19 October 1998
Редактирование командной строки стало намного приятнее благодаря
использованию библиотеки readline. Первоначальная поддержка 
интернационализацииThe с помощью многобайтовых строк была удалена;
Прошло 10 лет, прежде чем надлежащая интернационализация вернулась.
Начата поддержка Emacs Lisp, порты получили лучшую поддержку для
файловых дескрипторов, и добавлены fluids.

@item 1.3.2 --- 20 August 1999
@itemx 1.3.4 --- 25 September 1999
@itemx 1.4 --- 21 June 2000
Добавлен длинный список лисповых реализаций: hooks, Common Lisp's
@code{format}, необязательные и ключевые слова в аргументах процедур,
@code{getopt-long}, сортировка, случайные числа, и много других изменений
и улучшений. Guile также получил интерактивный дебагер, интерактивную
справку и трассировщик.

@item 1.6 --- 6 September 2002
Guile получила поддержку стандарта R5RS, и добавила ряд модулей SRFI.
Модульная ситема была расширена программной продержкой для
выбора и переименования индентификаторов. Объектная система GOOPS
была объединена с ядром Guile.

@item 1.8 --- 20 February 2006
Guile переключилась на использование библиотеки GMP в расчетах
арифметики произвольной точности и добавлена поддержка
точных рациональных чисел. Встраивание  пользовательского пространства
Guile было удалено в пользу упреждающих потоков POSIX, обеспечивающих
истинную много процессорность. Добавлена поддержка Gettext,
и  Guile Си интерфейс API был очищен и ортогонализирован.

@item 2.0 --- 16 February 2010
Виртуальная машина была добавлена в Guile, вместе с соотвествующим
компилятором и набором утилит. Впоследствии поддержка интернационализации
 была вновь реализована в терминах unicode, locales, и libunistring. Запуск
экземпляров Guile стал управляемым и отлаживаемый из Emacs через Geiser. 
Guile добавил функции обнаруженные в других Schemes: SRFI-18 потоки, 
module-hygienic macros, профайлер, трассировщик, отладчик, 
интеграция SSAX XML, байтовые вектора, и динамический FFI,
delimited continuations, версии модулей, и частичная поддержка R6RS.

@item 2.2 --- mid-2014
Виртуальная машина, введенная в версии 2.0 была полностью переписана
вместе с большей частью копилятора и набора утилит.  Это ускорило многие
программы Guile, а также сократило время запуска и использование памяти.
Инструментарий анализатора PEG был добавлен, что упростило работу с другими
языковыми интерфейсами.
@end table

@node Status
@subsection Состояние, или: Необходима Ваша Помощь.

Guile добилась многого, но многое еще предстоит сделать.

Есть еще старая проблема приведения существующих приложений в более
подобные  Emacs опыту. В этом отношении у Guile были некоторые успехи,
но все же, большинство приложений в системе GNU находятся без интеграции
с Guile.

Внедрение  Guile в эти приложения требует инвестиций ``хакерской энергии''
для подключение Guile к программе, которая рассчитывается только тогда,
когда она уже достаточно хороша, чтобы внедрить в нее новые виды поведения.
Это было бы отличным способом для новых хакеров: приложение которое вы 
испльзуете, и которое вы хорошо знаете, придумать что оно еще не может
сделать и выяснить способ интеграции с Guile и реализовать эту задачу
в Guile.

Со временем, возможно, эта экспозиция может перевернуть сама себя,
в результате чего программы смогут работать под Guile, что в конечном
итоге приведет к Емаксификации(Emacsification) всей системы GNU. 
В самом деле, это причина для обозначения многих модулей Guile, которые
живут в пространстве имен @code{ice-9}, как реверанс к вымышленной
субстанции Льда из новел Kurt Vonnegut, "Колыбель кошки", способной
действовать в качестве затравочного кристала для кристализации массы
программного обеспечения.

Неявной для всего этого обсуждения является идея о том, что динамические
языки как-то лучше чем такие языки как Си. Хотя такие языки как Си, 
имеют свое место. Guile отвечает на этот вопрос - да, Scheme более 
выразительна чем Си, и на ней более интересно писать. Эта реализация
несет в себе обязательство писать как можно больше кода на  Scheme, не на
других языках.

В наши дни можно писать расширяемые приложения почти полностью из языков
высокого уровня, через байт-код и собственную компиляцию, обеспчивающих 
прирост скорости выполнения в базовых аппратных и внешних интерфейсах 
вызовов высокоуровневых языков. Сисетмы Smalltalk похожи на это, как и 
обычные системы на основе  Common Lisp.  Хотя еще существует ряд 
чистокровных приложений там, где пользователям по-прежнему необходимо 
опускаться до Си для выполнения некоторых задач: сопряжения системных 
библиотек, у которых нет готовых интерфейсов к Guile, и для некоторых 
задач, требующих высокого  быстродействия. Нативная компиляция времени 
выполнения запланирована для Guile 3.0, должна помочь в этом.

Тем, не менее при использовании приложения все-в-Guile, иногда
вы хотите предоставить возможность для пользователей, чтобы расширить
вашу программу языком, синтаксисом который ближе к Си или Python.
Еще одна интересная идея, которую стоит рассмотреть, заключается в
компиляци, например Python в Guile. Это не надуманная идея:
см. например  IronPython или JRuby.

И тогда есть Emacs. Поддержка Guile Emacs Lisp достигла отличного уровня
правильности, надежности и скорости. Однако попрежнему предстоит сделать 
работу, чтобы закончить интеграцию в Emacs. Это даст много интересного
Emacs: родные(для архитектуры процессора) потоки, реальную объектную систему,
более сложные типы данных, более чистый синтаксис и доступ ко всем Guile
расширениям.

Наконец, существует еще одна ось кристализации, ось между различными
реализациями Scheme. Guile еще не поддерживает последний стандарт
Scheme, R7RS, и должен еще это реализовать. Как и все стандарты, 
R7RS является несовершенным, но его поддержка позволит большему коду
работать на Guile без изменений и позволит хакерам Guile создавать
код, совместимый с другими версиями scheme. Помощь в этом отношении
будет высоко оценена.