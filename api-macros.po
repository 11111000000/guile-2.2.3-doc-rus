#
# Gagin <mikhail-gagin@yandex.ru>, 2018.
# NuINu <don't@send.my>, 2018, 2019.
#
#. extracted from /home/bear/work/guile/doc/guile/en/api-macros.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-07 12:36+0300\n"
"PO-Revision-Date: 2019-02-28 11:10+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C)  1996, 1997, 2000-2004, 2009-2015\n"
"@c   Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:9
msgid ""
"@node Macros\n"
"@section Macros"
msgstr ""
"@node Macros\n"
"@section Макросы"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:14
msgid ""
"At its best, programming in Lisp is an iterative process of building up a\n"
"language appropriate to the problem at hand, and then solving the problem "
"in\n"
"that language. Defining new procedures is part of that, but Lisp also "
"allows\n"
"the user to extend its syntax, with its famous @dfn{macros}."
msgstr ""
"В лучшем случае, программирование на Lisp это итеративный процесс создания \n"
"соответствующего языка к имеющейся проблеме, и затем решение этой проблемы\n"
"на этом языке. Определение новой процедуры является частью этого, но Lisp \n"
"также позволяет пользователю расширять свой синтаксис используя широко\n"
"известные Макросы(@dfn{macros})."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:21
msgid ""
"@cindex macros\n"
"@cindex transformation\n"
"Macros are syntactic extensions which cause the expression that they appear "
"in\n"
"to be transformed in some way @emph{before} being evaluated. In expressions "
"that\n"
"are intended for macro transformation, the identifier that names the "
"relevant\n"
"macro must appear as the first element, like this:"
msgstr ""
"@cindex macros\n"
"@cindex transformation\n"
"Макросы - это синтаксические расширения, которые вызывают трансформацию "
"выражений,\n"
"в которых они появляются каким либо образом, перед(@emph{before}) их "
"вычислением.\n"
"В выражениях, которые предназначены для преобразования макросов, "
"идентификатор,\n"
"который  именует соответствующий макрос, должен быть первым элементом, "
"например:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:25
msgid ""
"@lisp\n"
"(@var{macro-name} @var{macro-args} @dots{})\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:36
msgid ""
"@cindex macro expansion\n"
"@cindex domain-specific language\n"
"@cindex embedded domain-specific language\n"
"@cindex DSL\n"
"@cindex EDSL\n"
"Macro expansion is a separate phase of evaluation, run before code is\n"
"interpreted or compiled. A macro is a program that runs on programs, "
"translating\n"
"an embedded language into core Scheme@footnote{These days such embedded\n"
"languages are often referred to as @dfn{embedded domain-specific\n"
"languages}, or EDSLs.}."
msgstr ""
"@cindex macro expansion\n"
"@cindex domain-specific language\n"
"@cindex embedded domain-specific language\n"
"@cindex DSL\n"
"@cindex EDSL\n"
"Расширение макросов это отдельная фаза вычислений, запускаемый до "
"интерпретации кода или\n"
"компиляции. Макрос это программа работающая над программами, переводящая "
"встроенный язык\n"
"в базовый язык Scheme@footnote{В наши дни такие встроенные языки часто "
"упоминаются\n"
"как встроенные специфичные языки(@dfn{embedded domain-specific\n"
"languages}, or EDSLs.})."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:50
msgid ""
"@menu\n"
"* Defining Macros::             Binding macros, globally and locally.\n"
"* Syntax Rules::                Pattern-driven macros.\n"
"* Syntax Case::                 Procedural, hygienic macros.\n"
"* Syntax Transformer Helpers::  Helpers for use in procedural macros.\n"
"* Defmacros::                   Lisp-style macros.\n"
"* Identifier Macros::           Identifier macros.\n"
"* Syntax Parameters::           Syntax Parameters.\n"
"* Eval When::                   Affecting the expand-time environment.\n"
"* Macro Expansion::             Procedurally expanding macros.\n"
"* Hygiene and the Top-Level::   A hack you might want to know about.\n"
"* Internal Macros::             Macros as first-class values.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:53
msgid ""
"@node Defining Macros\n"
"@subsection Defining Macros"
msgstr ""
"@node Defining Macros\n"
"@subsection Определение Макросов"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:57
msgid ""
"A macro is a binding between a keyword and a syntax transformer. Since it's\n"
"difficult to discuss @code{define-syntax} without discussing the format of\n"
"transformers, consider the following example macro definition:"
msgstr ""
"Макрос является связующим звеном между ключевыми словами и синтаксическим "
"преобразованием.\n"
"Поскольку трудно обсуждать @code{define-syntax} без обсуждения формата "
"преобразования,\n"
"рассмотрим следующий пример определения макроса:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:64
msgid ""
"@example\n"
"(define-syntax when\n"
"  (syntax-rules ()\n"
"    ((when condition exp ...)\n"
"     (if condition\n"
"         (begin exp ...)))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:71
msgid ""
"(when #t\n"
"  (display \"hey ho\\n\") \n"
"  (display \"let's go\\n\"))\n"
"@print{} hey ho\n"
"@print{} let's go\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:75
msgid ""
"In this example, the @code{when} binding is bound with @code{define-"
"syntax}.\n"
"Syntax transformers are discussed in more depth in @ref{Syntax Rules} and\n"
"@ref{Syntax Case}."
msgstr ""
"В этом примере, @code{when} связывается охватывающией формой @code{define-"
"syntax}.\n"
"Синтаксические преобразователи более подробно рассматриваются в @ref{Syntax "
"Rules}\n"
"и @ref{Syntax Case}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:79
msgid ""
"@deffn {Syntax} define-syntax keyword transformer\n"
"Bind @var{keyword} to the syntax transformer obtained by evaluating\n"
"@var{transformer}."
msgstr ""
"@deffn {Syntax} define-syntax keyword transformer\n"
"Связывает @var{keyword} к синтаксическому преобразованию, полученному путем\n"
"вычисления @var{transformer}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:83
msgid ""
"After a macro has been defined, further instances of @var{keyword} in "
"Scheme\n"
"source code will invoke the syntax transformer defined by "
"@var{transformer}.\n"
"@end deffn"
msgstr ""
"После определения макроса, дополнительные экземпляры @var{keyword} в "
"исходном\n"
"коде Scheme будут вызывать синтаксический преобразователь определенный в\n"
"@var{transformer}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:85
msgid "One can also establish local syntactic bindings with @code{let-syntax}."
msgstr ""
"Можно также устанавливать локальные синтаксические привязки используя "
"@code{let-syntax}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:89
msgid ""
"@deffn {Syntax} let-syntax ((keyword transformer) @dots{}) exp1 exp2 "
"@dots{}\n"
"Bind each @var{keyword} to its corresponding @var{transformer} while\n"
"expanding @var{exp1} @var{exp2} @enddots{}."
msgstr ""
"@deffn {Syntax} let-syntax ((keyword transformer) @dots{}) exp1 exp2 "
"@dots{}\n"
"Связывает каждое @var{keyword} с соответствующим "
"преобразователем(@var{transformer})\n"
"при рассширении @var{exp1} @var{exp2} @enddots{}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:91
msgid "A @code{let-syntax} binding only exists at expansion-time. "
msgstr ""
"Связывание @code{let-syntax} существует только во время\n"
"рассширения(локально). "

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:104
msgid ""
"@example\n"
"(let-syntax ((unless\n"
"              (syntax-rules ()\n"
"                ((unless condition exp ...)\n"
"                 (if (not condition)\n"
"                     (begin exp ...))))))\n"
"  (unless #t\n"
"    (primitive-exit 1))\n"
"  \"rock rock rock\")\n"
"@result{} \"rock rock rock\"\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:109
msgid ""
"A @code{define-syntax} form is valid anywhere a definition may appear: at "
"the\n"
"top-level, or locally. Just as a local @code{define} expands out to an "
"instance\n"
"of @code{letrec}, a local @code{define-syntax} expands out to\n"
"@code{letrec-syntax}."
msgstr ""
"Форма @code{define-syntax} действительна в любом месте, где может появиться\n"
"определение: на верхнем уровне или локально. Также как локальное "
"@code{define}\n"
"расширяется до экземпляра @code{letrec}, и локально заданное @code{define-"
"syntax}\n"
"расширяется до @code{letrec-syntax}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:113
msgid ""
"@deffn {Syntax} letrec-syntax ((keyword transformer) @dots{}) exp1 exp2 "
"@dots{}\n"
"Bind each @var{keyword} to its corresponding @var{transformer} while\n"
"expanding @var{exp1} @var{exp2} @enddots{}."
msgstr ""
"@deffn {Syntax} letrec-syntax ((keyword transformer) @dots{}) exp1 exp2 "
"@dots{}\n"
"Связывает каждое @var{keyword} с соответствующим "
"преобразователем(@var{transformer})\n"
"пока расширяются выражения @var{exp1} @var{exp2} @enddots{}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:117
msgid ""
"In the spirit of @code{letrec} versus @code{let}, an expansion produced by\n"
"@var{transformer} may reference a @var{keyword} bound by the\n"
"same @var{letrec-syntax}."
msgstr ""
"В духе @code{letrec} и @code{let}, расширение создаваемое трансформатором\n"
"синтаксиса(@var{transformer}) может выполняться упоминанием @var{keyword}\n"
"связванное в том же @var{letrec-syntax}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:134
msgid ""
"@example\n"
"(letrec-syntax ((my-or\n"
"                 (syntax-rules ()\n"
"                   ((my-or)\n"
"                    #t)\n"
"                   ((my-or exp)\n"
"                    exp)\n"
"                   ((my-or exp rest ...)\n"
"                    (let ((t exp))\n"
"                      (if t\n"
"                          t\n"
"                          (my-or rest ...)))))))\n"
"  (my-or #f \"rockaway beach\"))\n"
"@result{} \"rockaway beach\"\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:137
msgid ""
"@node Syntax Rules\n"
"@subsection Syntax-rules Macros"
msgstr ""
"@node Syntax Rules\n"
"@subsection Макрос Syntax-rules"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:140
msgid ""
"@code{syntax-rules} macros are simple, pattern-driven syntax transformers, "
"with\n"
"a beauty worthy of Scheme."
msgstr ""
"Макрос @code{syntax-rules} - очень простой, синтаксический преобразователь "
"управляемый\n"
"шаблоном, с достойной красотой  Scheme."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:145
msgid ""
"@deffn {Syntax} syntax-rules literals (pattern template) @dots{}\n"
"Create a syntax transformer that will rewrite an expression using the rules\n"
"embodied in the @var{pattern} and @var{template} clauses.\n"
"@end deffn"
msgstr ""
"@deffn {Syntax} syntax-rules literals (pattern template) @dots{}\n"
"Создает синтксисчекий преобразователь, который будет переписывать\n"
"выражение с использованием правил указанных в предложениях @var{pattern}\n"
"и @var{template}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:148
msgid ""
"A @code{syntax-rules} macro consists of three parts: the literals (if any), "
"the\n"
"patterns, and as many templates as there are patterns."
msgstr ""
"Макрос @code{syntax-rules} состоит из трех частей: литералов (если они "
"есть),\n"
"образцов(patterns) и столькоих же шаблонов(templates)."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:153
msgid ""
"When the syntax expander sees the invocation of a @code{syntax-rules} macro, "
"it\n"
"matches the expression against the patterns, in order, and rewrites the\n"
"expression using the template from the first matching pattern. If no "
"pattern\n"
"matches, a syntax error is signalled."
msgstr ""
"Когда расширитель синтаксиса видит вызов макроса @code{syntax-rules}, он\n"
"вычисляет выражение для образцов(patterns), в порядке следования, и "
"перезаписывает\n"
"выражения используя шаблон(template) для первого совпадающего образца. Если "
"нет\n"
"совпавших образцов, сигнализируется о синтаксической ошибке."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:155
msgid "@subsubsection Patterns"
msgstr "@subsubsection Образцы(Patterns)"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:162
msgid ""
"We have already seen some examples of patterns in the previous section:\n"
"@code{(unless condition exp ...)}, @code{(my-or exp)}, and so on. A pattern "
"is\n"
"structured like the expression that it is to match. It can have nested "
"structure\n"
"as well, like @code{(let ((var val) ...) exp exp* ...)}. Broadly speaking,\n"
"patterns are made of lists, improper lists, vectors, identifiers, and "
"datums.\n"
"Users can match a sequence of patterns using the ellipsis (@code{...})."
msgstr ""
"Мы уже видели некоторые примеры образцов в предыдущем разделе:\n"
"@code{(unless condition exp ...)}, @code{(my-or exp)}, и т.д.  Образец "
"структурирован\n"
"как выражение, которому он должен соответствовать. Он также может иметь "
"вложенную\n"
"структуру, подобно @code{(let ((var val) ...) exp exp* ...)}. Вообще "
"говоря,\n"
"образцы состоят из списков, неподходящих списков, векторов, идентификаторов, "
"и \n"
"исходных фактов. Пользователи могут сопоставлять последовательность "
"образцов\n"
"используя многоточия (@code{...})."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:167
msgid ""
"Identifiers in a pattern are called @dfn{literals} if they are present in "
"the\n"
"@code{syntax-rules} literals list, and @dfn{pattern variables} otherwise. "
"When\n"
"building up the macro output, the expander replaces instances of a pattern\n"
"variable in the template with the matched subexpression."
msgstr ""
"Идентификаторы в образце называются литералами(@dfn{literals}), если они "
"присутствуют\n"
"в списке литералов @code{syntax-rules}, и переменными образца(@dfn{pattern "
"variables})\n"
"если нет. При создании вывода макроса, макрорасширитель заменяет экземпляры "
"переменных\n"
"в образце на вычисленные подвыражения шаблона."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:176
msgid ""
"@example\n"
"(define-syntax kwote\n"
"  (syntax-rules ()\n"
"    ((kwote exp)\n"
"     (quote exp))))\n"
"(kwote (foo . bar))\n"
"@result{} (foo . bar)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:178
msgid "An improper list of patterns matches as rest arguments do:"
msgstr ""
"Список неправильных образцов соответствует остаточным(rest) аргументам:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:185
msgid ""
"@example\n"
"(define-syntax let1\n"
"  (syntax-rules ()\n"
"    ((_ (var val) . exps)\n"
"     (let ((var val)) . exps))))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:191
msgid ""
"However this definition of @code{let1} probably isn't what you want, as the "
"tail\n"
"pattern @var{exps} will match non-lists, like @code{(let1 (foo 'bar) . "
"baz)}. So\n"
"often instead of using improper lists as patterns, ellipsized patterns are\n"
"better. Instances of a pattern variable in the template must be followed by "
"an\n"
"ellipsis."
msgstr ""
"Однако это определение @code{let1}, вероятно, не то, что вы ожидали, так "
"как\n"
"хвостовой образец @var{exps} будет соответствовать не спискам, например\n"
"@code{(let1 (foo 'bar) . baz)}. Поэтому часто вместо использования списков\n"
"неправильных как образцов, лучше использовать образцы многоточия. За "
"экземпляром\n"
"переменной образца в шаблоне должно следовать многоточие."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:198
msgid ""
"@example\n"
"(define-syntax let1\n"
"  (syntax-rules ()\n"
"    ((_ (var val) exp ...)\n"
"     (let ((var val)) exp ...))))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:203
msgid ""
"This @code{let1} probably still doesn't do what we want, because the body\n"
"matches sequences of zero expressions, like @code{(let1 (foo 'bar))}. In "
"this\n"
"case we need to assert we have at least one body expression. A common idiom "
"for\n"
"this is to name the ellipsized pattern variable with an asterisk:"
msgstr ""
"Этот @code{let1} вероятно, все еще не делает того, что мы хотим получить, "
"потому\n"
"что тело сопоставляемых последовательностей является пустым выражением, "
"таким как\n"
"@code{(let1 (foo 'bar))}. В этом случае нам нужно проверят что мы имеем тело "
"хотябы\n"
"с одним выражением. Общей идиомой для этого является имя переменной "
"многоточечного\n"
"образца со звездочкой:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:210
msgid ""
"@example\n"
"(define-syntax let1\n"
"  (syntax-rules ()\n"
"    ((_ (var val) exp exp* ...)\n"
"     (let ((var val)) exp exp* ...))))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:213
msgid ""
"A vector of patterns matches a vector whose contents match the patterns,\n"
"including ellipsizing and tail patterns."
msgstr ""
"Вектор образцов соответствует вектору, содержимое которого соответствует\n"
"образцам включающим многоточия и  хвостовые образцы."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:222
msgid ""
"@example\n"
"(define-syntax letv\n"
"  (syntax-rules ()\n"
"    ((_ #((var val) ...) exp exp* ...)\n"
"     (let ((var val) ...) exp exp* ...))))\n"
"(letv #((foo 'bar)) foo)\n"
"@result{} bar\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:225
msgid ""
"Literals are used to match specific datums in an expression, like the use "
"of\n"
"@code{=>} and @code{else} in @code{cond} expressions."
msgstr ""
"Литералы используются для соответствия определенным данным в выражении, "
"например\n"
"испльзования @code{=>} и @code{else} в выражении @code{cond}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:236
msgid ""
"@example\n"
"(define-syntax cond1\n"
"  (syntax-rules (=> else)\n"
"    ((cond1 test => fun)\n"
"     (let ((exp test))\n"
"       (if exp (fun exp) #f)))\n"
"    ((cond1 test exp exp* ...)\n"
"     (if test (begin exp exp* ...)))\n"
"    ((cond1 else exp exp* ...)\n"
"     (begin exp exp* ...))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:244
msgid ""
"(define (square x) (* x x))\n"
"(cond1 10 => square)\n"
"@result{} 100\n"
"(let ((=> #t))\n"
"  (cond1 10 => square))\n"
"@result{} #<procedure square (x)>\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:250
msgid ""
"A literal matches an input expression if the input expression is an "
"identifier\n"
"with the same name as the literal, and both are unbound@footnote{Language\n"
"lawyers probably see the need here for use of @code{literal-identifier=?} "
"rather\n"
"than @code{free-identifier=?}, and would probably be correct. Patches\n"
"accepted.}."
msgstr ""
"Литерал соответствует входному выражению, если входное выраженине является\n"
"идентификатором тем же именем что и литерал, и оба являются несвязанными\n"
"@footnote{Языковые законники, вероятно, видят здесь необходимость "
"использования\n"
"@code{literal-identifier=?} в первую очередь, чем @code{free-identifier=?}, "
"и\n"
"вероятно будут правы. Поправки принимаются.}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:253
msgid ""
"If a pattern is not a list, vector, or an identifier, it matches as a "
"literal,\n"
"with @code{equal?}."
msgstr ""
"Если образец не является списком, вектором, или идентификатором, он "
"проверяется на\n"
"совпадение как литерал с помощью @code{equal?}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:262
msgid ""
"@example\n"
"(define-syntax define-matcher-macro\n"
"  (syntax-rules ()\n"
"    ((_ name lit)\n"
"     (define-syntax name\n"
"       (syntax-rules ()\n"
"        ((_ lit) #t)\n"
"        ((_ else) #f))))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:264
msgid "(define-matcher-macro is-literal-foo? \"foo\")"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:273
msgid ""
"(is-literal-foo? \"foo\")\n"
"@result{} #t\n"
"(is-literal-foo? \"bar\")\n"
"@result{} #f\n"
"(let ((foo \"foo\"))\n"
"  (is-literal-foo? foo))\n"
"@result{} #f\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:276
msgid ""
"The last example indicates that matching happens at expansion-time, not\n"
"at run-time."
msgstr ""
"В последнем примере показано, что сопоставление происходит во время "
"развертывания\n"
"макроса(на этапе компиляции), а не во время выполнения."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:282
msgid ""
"Syntax-rules macros are always used as @code{(@var{macro} . @var{args})}, "
"and\n"
"the @var{macro} will always be a symbol. Correspondingly, a @code{syntax-"
"rules}\n"
"pattern must be a list (proper or improper), and the first pattern in that "
"list\n"
"must be an identifier. Incidentally it can be any identifier -- it doesn't "
"have\n"
"to actually be the name of the macro. Thus the following three are "
"equivalent:"
msgstr ""
"Макросы синтаксических правил(Syntax-rules) всегда используются как \n"
"@code{(@var{macro} . @var{args})}, а @var{macro} всегда будет символом.\n"
"Соответственно, образец в @code{syntax-rules} должен быть списком "
"(правильным\n"
"или не правильным), и первый образец в этом списке должен быть "
"идентификатором.\n"
"Кстати, это может быть любой идентификатор -- он не обязательно должен быть\n"
"именем макроса. Таким обрзамо следующие три примера эквивалентны:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:288
msgid ""
"@example\n"
"(define-syntax when\n"
"  (syntax-rules ()\n"
"    ((when c e ...)\n"
"     (if c (begin e ...)))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:293
msgid ""
"(define-syntax when\n"
"  (syntax-rules ()\n"
"    ((_ c e ...)\n"
"     (if c (begin e ...)))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:299
msgid ""
"(define-syntax when\n"
"  (syntax-rules ()\n"
"    ((something-else-entirely c e ...)\n"
"     (if c (begin e ...)))))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:303
msgid ""
"For clarity, use one of the first two variants. Also note that since the "
"pattern\n"
"variable will always match the macro itself (e.g., @code{cond1}), it is "
"actually\n"
"left unbound in the template."
msgstr ""
"Для ясности используйте один из первых двух вариантов. Также обратите "
"внимание,\n"
"что поскольку переменная образца всегда будет соответствовать самому "
"макросу\n"
"(например @code{cond1}), она фактически остается не связанной в шаблоне."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:305
msgid "@subsubsection Hygiene"
msgstr "@subsubsection Гигиена"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:311
msgid ""
"@code{syntax-rules} macros have a magical property: they preserve "
"referential\n"
"transparency. When you read a macro definition, any free bindings in that "
"macro\n"
"are resolved relative to the macro definition; and when you read a macro\n"
"instantiation, all free bindings in that expression are resolved relative to "
"the\n"
"expression."
msgstr ""
"Макросы синтакисических правил(@code{syntax-rules}) имеют магическое "
"свойство:\n"
"они сохраняют ссылочную прозрачность. Когда вы читаете определение макроса, "
"любые\n"
"свободные привязки в этом макросе разрешаются относительно определения "
"макроса; и\n"
"когда вы читаете экземпляр макроса, все свободные привязки в этом выражении "
"разрешаются\n"
"относительно выражения."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:316
msgid ""
"This property is sometimes known as @dfn{hygiene}, and it does aid in code\n"
"cleanliness. In your macro definitions, you can feel free to introduce "
"temporary\n"
"variables, without worrying about inadvertently introducing bindings into "
"the\n"
"macro expansion."
msgstr ""
"Это свойство иногда называют гигиеной(@dfn{hygiene}), и оно помогает в "
"чистоте\n"
"кода В вашем макроопределении, вы можете свободно вводить временные "
"переменные, \n"
"не беспокоясь о непреднамеренном введении привязок в макрорасширение."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:318
msgid "Consider the definition of @code{my-or} from the previous section:"
msgstr "Рассмотрим определение @code{my-or} из предыдущего раздела:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:332
msgid ""
"@example\n"
"(define-syntax my-or\n"
"  (syntax-rules ()\n"
"    ((my-or)\n"
"     #t)\n"
"    ((my-or exp)\n"
"     exp)\n"
"    ((my-or exp rest ...)\n"
"     (let ((t exp))\n"
"       (if t\n"
"           t\n"
"           (my-or rest ...))))))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:334
msgid "A naive expansion of @code{(let ((t #t)) (my-or #f t))} would yield:"
msgstr "Наивное расширение @code{(let ((t #t)) (my-or #f t))} даст:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:341
msgid ""
"@example\n"
"(let ((t #t))\n"
"  (let ((t #f))\n"
"    (if t t t)))\n"
"@result{} #f\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:346
msgid ""
"@noindent\n"
"Which clearly is not what we want. Somehow the @code{t} in the definition "
"is\n"
"distinct from the @code{t} at the site of use; and it is indeed this "
"distinction\n"
"that is maintained by the syntax expander, when expanding hygienic macros."
msgstr ""
"@noindent\n"
"Это явно не то, что мы хотим. Так или иначе @code{t} в определении "
"отличается \n"
"от @code{t} в месте использования; и это действительно такое различие, "
"которое\n"
"поддерживается расширителем синтаксиса, при расширении макросов с гигиеной."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:350
msgid ""
"This discussion is mostly relevant in the context of traditional Lisp "
"macros\n"
"(@pxref{Defmacros}), which do not preserve referential transparency. "
"Hygiene\n"
"adds to the expressive power of Scheme."
msgstr ""
"Это обсуждение в основном актуально в контексте традиционных макросов Lisp\n"
"(@pxref{Defmacros}), которые не сохраняют ссылочную прозрачность.\n"
"Гигиена добавляет выразительной силы Scheme."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:352
msgid "@subsubsection Shorthands"
msgstr "@subsubsection Стенография(сокращение ввода)"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:356
msgid ""
"One often ends up writing simple one-clause @code{syntax-rules} macros.\n"
"There is a convenient shorthand for this idiom, in the form of\n"
"@code{define-syntax-rule}."
msgstr ""
"Часто пишут простые макросы с одним предложением @code{syntax-rules}.\n"
"Существует удобное сокращение для этой идиомы, в форме\n"
"@code{define-syntax-rule}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:360
msgid ""
"@deffn {Syntax} define-syntax-rule (keyword . pattern) [docstring] template\n"
"Define @var{keyword} as a new @code{syntax-rules} macro with one clause.\n"
"@end deffn"
msgstr ""
"@deffn {Syntax} define-syntax-rule (keyword . pattern) [docstring] template\n"
"Определяет ключевое слово(@var{keyword}) как новый макрос @code{syntax-"
"rules} с одним\n"
"предложением.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:362
msgid "Cast into this form, our @code{when} example is significantly shorter:"
msgstr "Вставка этой формы, делает наш пример @code{when} значительно короче:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:367
msgid ""
"@example\n"
"(define-syntax-rule (when c e ...)\n"
"  (if c (begin e ...)))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:369
msgid "@subsubsection Reporting Syntax Errors in Macros"
msgstr "@subsubsection Сообщения о синтаксических ошибках в Макросах"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:375
msgid ""
"@deffn {Syntax} syntax-error message [arg ...]\n"
"Report an error at macro-expansion time.  @var{message} must be a string\n"
"literal, and the optional @var{arg} operands can be arbitrary expressions\n"
"providing additional information.\n"
"@end deffn"
msgstr ""
"@deffn {Syntax} syntax-error message [arg ...]\n"
"Сообщение об ошибке во время макро-расширения  @var{message} должно быть \n"
"строковым литералом, а необязательные операнды @var{arg} могут быть "
"произвольными\n"
"выражениями, предоставляющими дополнительную информацию\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:378
msgid ""
"@code{syntax-error} is intended to be used within @code{syntax-rules}\n"
"templates.  For example:"
msgstr ""
"@code{syntax-error} предназначен для использования в шабалонах @code{syntax-"
"rules}\n"
"Например:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:391
msgid ""
"@example\n"
"(define-syntax simple-let\n"
"  (syntax-rules ()\n"
"    ((_ (head ... ((x . y) val) . tail)\n"
"        body1 body2 ...)\n"
"     (syntax-error\n"
"      \"expected an identifier but got\"\n"
"      (x . y)))\n"
"    ((_ ((name val) ...) body1 body2 ...)\n"
"     ((lambda (name ...) body1 body2 ...)\n"
"      val ...))))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:393
msgid "@subsubsection Specifying a Custom Ellipsis Identifier"
msgstr "@subsubsection Указание пользовательского идентификатора многоточия"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:398
msgid ""
"When writing macros that generate macro definitions, it is convenient to\n"
"use a different ellipsis identifier at each level.  Guile allows the\n"
"desired ellipsis identifier to be specified as the first operand to\n"
"@code{syntax-rules}, as specified by SRFI-46 and R7RS.  For example:"
msgstr ""
"При написании макросов, которые генерируют определения макросов, удобно\n"
"использовать разные идентификаторы многоточия на каждом уровне. Guile \n"
"позволяет указать желаемый идентификатор многточия как первый операнд в\n"
"@code{syntax-rules}, как указано в SRFI-46 и R7RS.  Например:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:411
msgid ""
"@example\n"
"(define-syntax define-quotation-macros\n"
"  (syntax-rules ()\n"
"    ((_ (macro-name head-symbol) ...)\n"
"     (begin (define-syntax macro-name\n"
"              (syntax-rules ::: ()\n"
"                ((_ x :::)\n"
"                 (quote (head-symbol x :::)))))\n"
"            ...))))\n"
"(define-quotation-macros (quote-a a) (quote-b b) (quote-c c))\n"
"(quote-a 1 2 3) @result{} (a 1 2 3)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:413
msgid "@subsubsection Further Information"
msgstr "@subsubsection Дальнейшая информация"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:417
msgid ""
"For a formal definition of @code{syntax-rules} and its pattern language, "
"see\n"
"@xref{Macros, , Macros, r5rs, Revised(5) Report on the Algorithmic Language\n"
"Scheme}."
msgstr ""
"Для формального определения @code{syntax-rules} и языка шаблонов, см.\n"
"@xref{Macros, , Macros, r5rs, Revised(5) Report on the Algorithmic Language\n"
"Scheme}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:425
msgid ""
"@code{syntax-rules} macros are simple and clean, but do they have "
"limitations.\n"
"They do not lend themselves to expressive error messages: patterns either "
"match\n"
"or they don't. Their ability to generate code is limited to template-driven\n"
"expansion; often one needs to define a number of helper macros to get real "
"work\n"
"done. Sometimes one wants to introduce a binding into the lexical context of "
"the\n"
"generated code; this is impossible with @code{syntax-rules}. Relatedly, "
"they\n"
"cannot programmatically generate identifiers."
msgstr ""
"Макрос @code{syntax-rules} простой и чистый, но имеют ограничения. Они "
"делают не\n"
"поддающиеся выражени сообщения об ошибках: образец либо совпадает, либо "
"нет.\n"
"Их способность генерировать код ограничивается расширением шаблонов; часто "
"нужно\n"
"определять ряд вспомогательных макросов, чтобы получить реальную работу. "
"Иногда\n"
"хочется предоставить привязку к лексическому контексту сгенерированного "
"кода; это\n"
"не возможно с @code{syntax-rules}. Кроме того, они не могут программно "
"генерировать\n"
"идентификаторы."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:431
msgid ""
"The solution to all of these problems is to use @code{syntax-case} if you "
"need\n"
"its features. But if for some reason you're stuck with @code{syntax-rules}, "
"you\n"
"might enjoy Joe Marshall's\n"
"@uref{http://sites.google.com/site/evalapply/eccentric.txt,@code{syntax-"
"rules}\n"
"Primer for the Merely Eccentric}."
msgstr ""
"Решение всех этих проблем использовать  @code{syntax-case} если вам нужны "
"его\n"
"функции. Но если по какой либо причине вы придерживаетесь @code{syntax-"
"rules},\n"
"вам может понравиться работа Joe Marshall\n"
"@uref{http://sites.google.com/site/evalapply/eccentric.txt,@code{syntax-"
"rules}\n"
"Primer for the Merely Eccentric}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:434
msgid ""
"@node Syntax Case\n"
"@subsection Support for the @code{syntax-case} System"
msgstr ""
"@node Syntax Case\n"
"@subsection Поддержка для системы @code{syntax-case}"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:437
msgid ""
"@code{syntax-case} macros are procedural syntax transformers, with a power\n"
"worthy of Scheme."
msgstr ""
"Макрос @code{syntax-case} это процедурный синтаксический преобразователь, "
"обладающий\n"
"мощью достойной Scheme."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:442
msgid ""
"@deffn {Syntax} syntax-case syntax literals (pattern [guard] exp) @dots{}\n"
"Match the syntax object @var{syntax} against the given patterns, in order. "
"If a\n"
"@var{pattern} matches, return the result of evaluating the associated "
"@var{exp}.\n"
"@end deffn"
msgstr ""
"@deffn {Syntax} syntax-case syntax literals (pattern [guard] exp) @dots{}\n"
"Сопоставляет синтаксический объект @var{syntax} с данными образцами, в "
"порядке\n"
"следования. Если @var{pattern} совпадает, возвращает результат вычисления\n"
"соответствующего выражения @var{exp}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:444
msgid "Compare the following definitions of @code{when}:"
msgstr "Сравните следующие определения @code{when}:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:450
msgid ""
"@example\n"
"(define-syntax when\n"
"  (syntax-rules ()\n"
"    ((_ test e e* ...)\n"
"     (if test (begin e e* ...)))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:457
msgid ""
"(define-syntax when\n"
"  (lambda (x)\n"
"    (syntax-case x ()\n"
"      ((_ test e e* ...)\n"
"       #'(if test (begin e e* ...))))))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:463
msgid ""
"Clearly, the @code{syntax-case} definition is similar to its @code{syntax-"
"rules}\n"
"counterpart, and equally clearly there are some differences. The\n"
"@code{syntax-case} definition is wrapped in a @code{lambda}, a function of "
"one\n"
"argument; that argument is passed to the @code{syntax-case} invocation; and "
"the\n"
"``return value'' of the macro has a @code{#'} prefix."
msgstr ""
"Очевидно, что определение @code{syntax-case} аналогично @code{syntax-rules}\n"
"и одинаково ясно, что есть несколько различий. Определение @code{syntax-"
"case}\n"
"обернуто в лямбда(@code{lambda}), функцию от одного аргумента; этот "
"аргумент\n"
"передается вызову @code{syntax-case}; и ``возвращаемое значение'' макроса\n"
"имеет префикс @code{#'}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:468
msgid ""
"All of these differences stem from the fact that @code{syntax-case} does "
"not\n"
"define a syntax transformer itself -- instead, @code{syntax-case} "
"expressions\n"
"provide a way to destructure a @dfn{syntax object}, and to rebuild syntax\n"
"objects as output."
msgstr ""
"Все эти различия связаны с тем, что @code{syntax-case} не определяет\n"
"преобразователь синтаксиса самостоятельно -- вместо этого выражение\n"
"@code{syntax-case} обеспечивает способ разрушить синтаксический объект\n"
"(@dfn{syntax object}), и перестроить синтаксический объект при выводе."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:475
msgid ""
"So the @code{lambda} wrapper is simply a leaky implementation detail, that\n"
"syntax transformers are just functions that transform syntax to syntax. "
"This\n"
"should not be surprising, given that we have already described macros as\n"
"``programs that write programs''. @code{syntax-case} is simply a way to "
"take\n"
"apart and put together program text, and to be a valid syntax transformer "
"it\n"
"needs to be wrapped in a procedure."
msgstr ""
"Таким образом, обертка @code{lambda} это просто проходная деталь "
"реализации,\n"
"чтобы преобразователь синтаксиса просто функция преобразовывающая синтаксис\n"
"в синтаксис. Это не должно удивлять, учитывая что мы уже описали макросы "
"как\n"
"``программы, которые пишут программы''. @code{syntax-case} это простой "
"способ\n"
"разобрать и скомпоновать текст программы, и допустимый преобразователь "
"синтаксиса\n"
"должен быть обернут в процедуру."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:479
msgid ""
"Unlike traditional Lisp macros (@pxref{Defmacros}), @code{syntax-case} "
"macros\n"
"transform syntax objects, not raw Scheme forms. Recall the naive expansion "
"of\n"
"@code{my-or} given in the previous section:"
msgstr ""
"В отличии от традиционных макросов Лисп (@pxref{Defmacros}), макросы "
"@code{syntax-case}\n"
"преобразуют синтаксический объект, а не необработанные формы Scheme. "
"Напомним наивное\n"
"расширение @code{my-or} заданное в предыдущем разделе:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:488
msgid ""
"@example\n"
"(let ((t #t))\n"
"  (my-or #f t))\n"
";; naive expansion:\n"
"(let ((t #t))\n"
"  (let ((t #f))\n"
"    (if t t t)))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:494
msgid ""
"Raw Scheme forms simply don't have enough information to distinguish the "
"first\n"
"two @code{t} instances in @code{(if t t t)} from the third @code{t}. So "
"instead\n"
"of representing identifiers as symbols, the syntax expander represents\n"
"identifiers as annotated syntax objects, attaching such information to "
"those\n"
"syntax objects as is needed to maintain referential transparency."
msgstr ""
"В необработанных формах Scheme просто не хватает информации чтобы отличить\n"
"первые два экземпляра @code{t} в форме @code{(if t t t)} из/от третьего "
"@code{t}. \n"
"Поэтому вместо предоставления идентификаторов в качестве символов, "
"расширитель\n"
"синтаксиса представляет идентификаторы как синтаксические объекты, "
"присоединяя\n"
"к ним информацию которая необходима синтаксическим объектам для поддержания\n"
"ссылочной прозрачности."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:498
msgid ""
"@deffn {Syntax} syntax form\n"
"Create a syntax object wrapping @var{form} within the current lexical "
"context.\n"
"@end deffn"
msgstr ""
"@deffn {Syntax} syntax form\n"
"создает синтаксический объект обернутый в форму @var{form} в текущем "
"лексическом контексет.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:501
msgid ""
"Syntax objects are typically created internally to the process of expansion, "
"but\n"
"it is possible to create them outside of syntax expansion:"
msgstr ""
"Синтаксические объекты обычно создаются внутри процесса расширения, но это\n"
"возможность создать их вне расширения синтаксиса."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:506
msgid ""
"@example\n"
"(syntax (foo bar baz))\n"
"@result{} #<some representation of that syntax>\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:510
msgid ""
"@noindent\n"
"However it is more common, and useful, to create syntax objects when "
"building\n"
"output from a @code{syntax-case} expression."
msgstr ""
"@noindent\n"
"Однако более часто и полезно, создавать синтаксические объекты при "
"посторении\n"
"вывода из выражения @code{syntax-case}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:518
msgid ""
"@example\n"
"(define-syntax add1\n"
"  (lambda (x)\n"
"    (syntax-case x ()\n"
"      ((_ exp)\n"
"       (syntax (+ exp 1))))))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:524
msgid ""
"It is not strictly necessary for a @code{syntax-case} expression to return "
"a\n"
"syntax object, because @code{syntax-case} expressions can be used in helper\n"
"functions, or otherwise used outside of syntax expansion itself. However a\n"
"syntax transformer procedure must return a syntax object, so most uses of\n"
"@code{syntax-case} do end up returning syntax objects."
msgstr ""
"Не обязательно, чтобы выражение @code{syntax-case} возвращало "
"синтаксический\n"
"объект, потому что выражения @code{syntax-case} могут использоваться "
"вспомогательными\n"
"функциями или использоваться иным образом вне самого расширения синтаксиса. "
"Однако\n"
"процедура преобразования синтаксиса должна возрвращать синтаксический "
"объект, поэтому\n"
"большинство применений @code{syntax-case} в конечном итоге возвращает "
"синтаксические\n"
"объекты."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:530
msgid ""
"Here in this case, the form that built the return value was @code{(syntax (+ "
"exp\n"
"1))}. The interesting thing about this is that within a @code{syntax}\n"
"expression, any appearance of a pattern variable is substituted into the\n"
"resulting syntax object, carrying with it all relevant metadata from the "
"source\n"
"expression, such as lexical identity and source location."
msgstr ""
"Здесь в этом случае форма, которая построила возвращаемое значение, была\n"
"@code{(syntax (+ exp 1))}. Интересная вещь заключается в том, что в "
"выражении\n"
"@code{syntax} любое появление образца переменной подставляется в "
"результирущий синтаксический\n"
"объект, перенося с собой все соответствующие метаданные из исходного "
"выражения, такого как\n"
"лексический идентификатор и местоположение источника."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:534
msgid ""
"Indeed, a pattern variable may only be referenced from inside a "
"@code{syntax}\n"
"form. The syntax expander would raise an error when defining @code{add1} if "
"it\n"
"found @var{exp} referenced outside a @code{syntax} form."
msgstr ""
"В самом деле, переменная шаблона может ссылаться только внутри формы "
"@code{syntax}.\n"
"Синтаксический расширитель  вызовет ошибку при определении @code{add1} если "
"он найдет\n"
"@var{exp} ссылающееся вовне @code{syntax} формы."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:538
msgid ""
"Since @code{syntax} appears frequently in macro-heavy code, it has a "
"special\n"
"reader macro: @code{#'}. @code{#'foo} is transformed by the reader into\n"
"@code{(syntax foo)}, just as @code{'foo} is transformed into @code{(quote "
"foo)}."
msgstr ""
"Поскольку @code{syntax} часто появляется в макро-тяжелом коде, он имеет "
"специальный\n"
"макрос чтения: @code{#'}. @code{#'foo} преобразуется читателем в "
"@code{(syntax foo)},\n"
"также как @code{'foo} преобразуется в @code{(quote foo)}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:542
msgid ""
"The pattern language used by @code{syntax-case} is conveniently the same\n"
"language used by @code{syntax-rules}. Given this, Guile actually defines\n"
"@code{syntax-rules} in terms of @code{syntax-case}:"
msgstr ""
"Язык шаблонов используемый @code{syntax-case} это удобный язык используемый\n"
"в @code{syntax-rules}. Учитывая это, Guile фактически определеят "
"@code{syntax-rules}\n"
"в терминах @code{syntax-case}:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:553
msgid ""
"@example\n"
"(define-syntax syntax-rules\n"
"  (lambda (x)\n"
"    (syntax-case x ()\n"
"      ((_ (k ...) ((keyword . pattern) template) ...)\n"
"       #'(lambda (x)\n"
"           (syntax-case x (k ...)\n"
"             ((dummy . pattern) #'template)\n"
"             ...))))))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:555
msgid "And that's that."
msgstr "И вот что."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:557
msgid "@subsubsection Why @code{syntax-case}?"
msgstr "@subsubsection Почему @code{syntax-case}?"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:563
msgid ""
"The examples we have shown thus far could just as well have been expressed "
"with\n"
"@code{syntax-rules}, and have just shown that @code{syntax-case} is more\n"
"verbose, which is true. But there is a difference: @code{syntax-case} "
"creates\n"
"@emph{procedural} macros, giving the full power of Scheme to the macro "
"expander.\n"
"This has many practical applications."
msgstr ""
"Данные нами до сих пор примеры можно было точно также выразить @code{syntax-"
"rules},\n"
"и только что показали, что @code{syntax-case} является более подробным, что "
"верно.\n"
"Но есть разница: @code{syntax-case} создает процедурный(@emph{procedural}) "
"макрос,\n"
"давая полную мощь Scheme макро-расширителю. Этому есть много практических\n"
"применений."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:567
msgid ""
"A common desire is to be able to match a form only if it is an identifier. "
"This\n"
"is impossible with @code{syntax-rules}, given the datum matching forms. But "
"with\n"
"@code{syntax-case} it is easy:"
msgstr ""
"Общее желание состоит в том, чтобы иметь возможность сопоставлять форму "
"только\n"
"в том случае, если она является идентификатором. Это невозможно с "
"@code{syntax-rules},\n"
"с учетом форм сопоставления данных. Но с @code{syntax-case} это легко:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:572
msgid ""
"@deffn {Scheme Procedure} identifier? syntax-object\n"
"Returns @code{#t} if @var{syntax-object} is an identifier, or @code{#f}\n"
"otherwise.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} identifier? syntax-object\n"
"Возвращает @code{#t} если @var{syntax-object} это идентификатор, или "
"@code{#f}\n"
"если нет.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:580
msgid ""
"@example\n"
";; relying on previous add1 definition\n"
"(define-syntax add1!\n"
"  (lambda (x)\n"
"    (syntax-case x ()\n"
"      ((_ var) (identifier? #'var)\n"
"       #'(set! var (add1 var))))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:586
msgid ""
"(define foo 0)\n"
"(add1! foo)\n"
"foo @result{} 1\n"
"(add1! \"not-an-identifier\") @result{} error\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:593
msgid ""
"With @code{syntax-rules}, the error for @code{(add1! \"not-an-identifier\")} "
"would\n"
"be something like ``invalid @code{set!}''. With @code{syntax-case}, it will "
"say\n"
"something like ``invalid @code{add1!}'', because we attach the @dfn{guard\n"
"clause} to the pattern: @code{(identifier? #'var)}. This becomes more "
"important\n"
"with more complicated macros. It is necessary to use @code{identifier?}, "
"because\n"
"to the expander, an identifier is more than a bare symbol."
msgstr ""
"С @code{syntax-rules}, ошибка для @code{(add1! \"not-an-identifier\")} была "
"бы\n"
"чем то похожим на ``invalid @code{set!}''. С @code{syntax-case}, он может "
"сказать\n"
"что то вроде ``invalid @code{add1!}'', потому что мы прикрепляем защитное "
"предложение\n"
"(@dfn{guard clause} к образцу: @code{(identifier? #'var)}. Это становиться "
"более важным\n"
"с более сложными макросами. Нижно использовать @code{identifier?}, потому "
"что расширитель,\n"
"идентифицирует более чем пустой символ."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:596
msgid ""
"Note that even in the guard clause, we reference the @var{var} pattern "
"variable\n"
"within a @code{syntax} form, via @code{#'var}."
msgstr ""
"Обратите внимание, что даже в защищающем предложении, мы сслыаемся на "
"переменную \n"
"@var{var} образца в форме @code{syntax}, через @code{#'var}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:602
msgid ""
"Another common desire is to introduce bindings into the lexical context of "
"the\n"
"output expression. One example would be in the so-called ``anaphoric "
"macros'',\n"
"like @code{aif}. Anaphoric macros bind some expression to a well-known\n"
"identifier, often @code{it}, within their bodies. For example, in "
"@code{(aif\n"
"(foo) (bar it))}, @code{it} would be bound to the result of @code{(foo)}."
msgstr ""
"Еще одно общее желание -- ввести привязки в лексический контекст выражений "
"вывода.\n"
"Один пример будет в так называемых ``anaphoric макросах'', таких как "
"@code{aif}.\n"
"Anaphoric макросы связывают некоторое выражение с известным идентификатором, "
"часто\n"
"он(@code{it}), внутри своих тел. Например, в @code{(aif (foo) (bar it))}, "
"@code{it}\n"
"будет связан с результатом @code{(foo)}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:604
msgid "To begin with, we should mention a solution that doesn't work:"
msgstr "Для начала следует упомянуть решение, которое не работает:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:614
msgid ""
"@example\n"
";; doesn't work\n"
"(define-syntax aif\n"
"  (lambda (x)\n"
"    (syntax-case x ()\n"
"      ((_ test then else)\n"
"       #'(let ((it test))\n"
"           (if it then else))))))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:618
msgid ""
"The reason that this doesn't work is that, by default, the expander will\n"
"preserve referential transparency; the @var{then} and @var{else} "
"expressions\n"
"won't have access to the binding of @code{it}."
msgstr ""
"Причина, по которой это не работает, заключается в том, что по умолчанию "
"расширитель\n"
"сохраняет ссылочную прозрачность; выражения @var{then} и @var{else} не будут "
"иметь\n"
"доступ к привязке @code{it}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:620
msgid ""
"But they can, if we explicitly introduce a binding via @code{datum->syntax}."
msgstr ""
"Но они смогут ее получить, если мы введем привязку через @code{datum-"
">syntax}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:625
msgid ""
"@deffn {Scheme Procedure} datum->syntax template-id datum\n"
"Create a syntax object that wraps @var{datum}, within the lexical context\n"
"corresponding to the identifier @var{template-id}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} datum->syntax template-id datum\n"
"Создает синтаксический объект, который оборачивает @var{datum} в лексическом "
"контексте,\n"
"соответствующим идентификатору @var{template-id}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:628
msgid ""
"For completeness, we should mention that it is possible to strip the "
"metadata\n"
"from a syntax object, returning a raw Scheme datum:"
msgstr ""
"Для полноты, следует отметить, что метаданные можно удалить из "
"синтаксического\n"
"объекта, вернув необработанные данные(datum) Scheme:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:633
msgid ""
"@deffn {Scheme Procedure} syntax->datum syntax-object\n"
"Strip the metadata from @var{syntax-object}, returning its contents as a "
"raw\n"
"Scheme datum.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} syntax->datum syntax-object\n"
"Убирает метаданные из @var{syntax-object}, возвращая его содержимое в виде\n"
"необработанных данных(datum) Scheme.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:637
msgid ""
"In this case we want to introduce @code{it} in the context of the whole\n"
"expression, so we can create a syntax object as @code{(datum->syntax x "
"'it)},\n"
"where @code{x} is the whole expression, as passed to the transformer "
"procedure."
msgstr ""
"В этом случае мы хотим пердставить @code{it} в контексте всего выражения, "
"поэтому\n"
"мы можем создать синтаксический объект как @code{(datum->syntax x 'it)},\n"
"где @code{x} это целое выражение, как прошедшее процедуру преоборазованиня."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:639
msgid "Here's another solution that doesn't work:"
msgstr "Вот еще одно решение которое не работает:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:650
msgid ""
"@example\n"
";; doesn't work either\n"
"(define-syntax aif\n"
"  (lambda (x)\n"
"    (syntax-case x ()\n"
"      ((_ test then else)\n"
"       (let ((it (datum->syntax x 'it)))\n"
"         #'(let ((it test))\n"
"             (if it then else)))))))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:659
msgid ""
"The reason that this one doesn't work is that there are really two\n"
"environments at work here -- the environment of pattern variables, as\n"
"bound by @code{syntax-case}, and the environment of lexical variables,\n"
"as bound by normal Scheme. The outer let form establishes a binding in\n"
"the environment of lexical variables, but the inner let form is inside a\n"
"syntax form, where only pattern variables will be substituted. Here we\n"
"need to introduce a piece of the lexical environment into the pattern\n"
"variable environment, and we can do so using @code{syntax-case} itself:"
msgstr ""
"Причина, по которой это не работает, состоит в том, что на самом деле здесь\n"
"работают две среды -- среда переменных образца, связываемых\n"
"@code{syntax-case}, и среда лексических переменных,\n"
"связываемых в обычной Scheme. Внешняя форма let устанавливает привязки в \n"
"среде лексических переменных, но внутренняя форма let находиться внутри\n"
"синтаксической формы, где будут заменены только переменные образца. Здесь "
"нам\n"
"нужно ввести кусочек лексической среды(окружения) в среду переменных "
"образца,\n"
"и мы можем сделать это используя сам @code{syntax-case}:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:672
msgid ""
"@example\n"
";; works, but is obtuse\n"
"(define-syntax aif\n"
"  (lambda (x)\n"
"    (syntax-case x ()\n"
"      ((_ test then else)\n"
"       ;; invoking syntax-case on the generated\n"
"       ;; syntax object to expose it to `syntax'\n"
"       (syntax-case (datum->syntax x 'it) ()\n"
"         (it\n"
"           #'(let ((it test))\n"
"               (if it then else))))))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:676
msgid ""
"(aif (getuid) (display it) (display \"none\")) (newline)\n"
"@print{} 500\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:679
msgid ""
"However there are easier ways to write this. @code{with-syntax} is often\n"
"convenient:"
msgstr ""
"Однако есть более простые способы написать это. @code{with-syntax} часто \n"
"удобно:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:683
msgid ""
"@deffn {Syntax} with-syntax ((pat val) @dots{}) exp @dots{}\n"
"Bind patterns @var{pat} from their corresponding values @var{val}, within "
"the\n"
"lexical context of @var{exp} @enddots{}."
msgstr ""
"@deffn {Syntax} with-syntax ((pat val) @dots{}) exp @dots{}\n"
"Связывает образцы @var{pat} с их соответствующими значениями @var{val}, в "
"лексическом\n"
"контексте @var{exp} @enddots{}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:695
msgid ""
"@example\n"
";; better\n"
"(define-syntax aif\n"
"  (lambda (x)\n"
"    (syntax-case x ()\n"
"      ((_ test then else)\n"
"       (with-syntax ((it (datum->syntax x 'it)))\n"
"         #'(let ((it test))\n"
"             (if it then else)))))))\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:701
msgid ""
"As you might imagine, @code{with-syntax} is defined in terms of\n"
"@code{syntax-case}. But even that might be off-putting to you if you are an "
"old\n"
"Lisp macro hacker, used to building macro output with @code{quasiquote}. "
"The\n"
"issue is that @code{with-syntax} creates a separation between the point of\n"
"definition of a value and its point of substitution."
msgstr ""
"Как вы можете себе представить, @code{with-syntax} определяется в терминах\n"
"@code{syntax-case}. Но даже это может быть неприятным если вы старый хакер\n"
"макросов на Lispе, привыкший к созданию с помощью @code{quasiquote}. "
"Проблема\n"
"в том, что @code{with-syntax} создает разделение между точкой определения\n"
"значения и точкой его подстановки."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:709
msgid ""
"@pindex quasisyntax\n"
"@pindex unsyntax\n"
"@pindex unsyntax-splicing\n"
"So for cases in which a @code{quasiquote} style makes more sense,\n"
"@code{syntax-case} also defines @code{quasisyntax}, and the related\n"
"@code{unsyntax} and @code{unsyntax-splicing}, abbreviated by the reader as\n"
"@code{#`}, @code{#,}, and @code{#,@@}, respectively."
msgstr ""
"@pindex quasisyntax\n"
"@pindex unsyntax\n"
"@pindex unsyntax-splicing\n"
"Так что для случаев, в которых стиль @code{quasiquote} имеет больше смысла,\n"
"@code{syntax-case} также определяет @code{quasisyntax}, и связанные с ним\n"
"@code{unsyntax} и @code{unsyntax-splicing}, сокращенно читаемые как\n"
"@code{#`}, @code{#,}, и @code{#,@@}, соответственно."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:712
msgid ""
"For example, to define a macro that inserts a compile-time timestamp into a\n"
"source file, one may write:"
msgstr ""
"Например, чтобы определить макрос, который вставляет метку времени "
"компиляции в\n"
"искходный файл, можно написать:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:723
msgid ""
"@example\n"
"(define-syntax display-compile-timestamp\n"
"  (lambda (x)\n"
"    (syntax-case x ()\n"
"      ((_)\n"
"       #`(begin\n"
"          (display \"The compile timestamp was: \")\n"
"          (display #,(current-time))\n"
"          (newline))))))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:729
msgid ""
"Readers interested in further information on @code{syntax-case} macros "
"should\n"
"see R. Kent Dybvig's excellent @cite{The Scheme Programming Language}, "
"either\n"
"edition 3 or 4, in the chapter on syntax. Dybvig was the primary author of "
"the\n"
"@code{syntax-case} system. The book itself is available online at\n"
"@uref{http://scheme.com/tspl4/}."
msgstr ""
"Читатели, интересующиеся дополнительной информацией о макросах @code{syntax-"
"case}\n"
"должны смотреть R. Kent Dybvig's отличную книгу  @cite{The Scheme "
"Programming Language}, \n"
"редакции 3 или 4, в главе о синтаксисе. Dybvig был основным автором системы\n"
"@code{syntax-case}. Сама книга доступна в интернете\n"
"@uref{http://scheme.com/tspl4/}. (ищите русский перевод)"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:731
msgid "@subsubsection Custom Ellipsis Identifiers for syntax-case Macros"
msgstr ""
"@subsubsection Пользовательские Идентификаторы Многоточий для макросов "
"syntax-case"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:736
msgid ""
"When writing procedural macros that generate macro definitions, it is\n"
"convenient to use a different ellipsis identifier at each level.  Guile\n"
"supports this for procedural macros using the @code{with-ellipsis}\n"
"special form:"
msgstr ""
"При написании процедурных макросов, которые генерируют определения "
"макросов,\n"
"удобно использовать различные идентификаторы многоточий на каждом уровне.  "
"Guile\n"
"поддерживает это для процедурных макросов используюзуя специальную форму \n"
"@code{with-ellipsis}:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:743
msgid ""
"@deffn {Syntax} with-ellipsis ellipsis body @dots{}\n"
"@var{ellipsis} must be an identifier.  Evaluate @var{body} in a special\n"
"lexical environment such that all macro patterns and templates within\n"
"@var{body} will use @var{ellipsis} as the ellipsis identifier instead of\n"
"the usual three dots (@code{...}).\n"
"@end deffn"
msgstr ""
"@deffn {Syntax} with-ellipsis ellipsis body @dots{}\n"
"@var{ellipsis} должен быть идентификатором.  Вычисляет @var{body} в\n"
"специальном лексическом окружении(среде), такой что все макро обрацзы и\n"
"шаблоны внутри тела @var{body} будут использовать @var{ellipsis} как\n"
"идентификатор многоточия вместо обычных трех точек (@code{...}).\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:745
msgid "For example:"
msgstr "Например:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:761
msgid ""
"@example\n"
"(define-syntax define-quotation-macros\n"
"  (lambda (x)\n"
"    (syntax-case x ()\n"
"      ((_ (macro-name head-symbol) ...)\n"
"       #'(begin (define-syntax macro-name\n"
"                  (lambda (x)\n"
"                    (with-ellipsis :::\n"
"                      (syntax-case x ()\n"
"                        ((_ x :::)\n"
"                         #'(quote (head-symbol x :::)))))))\n"
"                ...)))))\n"
"(define-quotation-macros (quote-a a) (quote-b b) (quote-c c))\n"
"(quote-a 1 2 3) @result{} (a 1 2 3)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:765
msgid ""
"Note that @code{with-ellipsis} does not affect the ellipsis identifier\n"
"of the generated code, unless @code{with-ellipsis} is included around\n"
"the generated code."
msgstr ""
"Обратите внимание, что @code{with-ellipsis} не влияет на идентификатор\n"
"многоточия генерируемого кода, разве что @code{with-ellipsis} будет включен\n"
"в сгенерированный код."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:768
msgid ""
"@node Syntax Transformer Helpers\n"
"@subsection Syntax Transformer Helpers"
msgstr ""
"@node Syntax Transformer Helpers\n"
"@subsection Вспомогательные функции Синтаксического Преобразования"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:774
msgid ""
"As noted in the previous section, Guile's syntax expander operates on\n"
"syntax objects.  Procedural macros consume and produce syntax objects.\n"
"This section describes some of the auxiliary helpers that procedural\n"
"macros can use to compare, generate, and query objects of this data\n"
"type."
msgstr ""
"Как отмечалось в предыдущем разделе, синтаксический расширитель Guile\n"
"работет с синтаксическими объектами. Процедурные макросы потребляют и\n"
"создают синтаксические объекты. В этом разделе описаны некоторые из\n"
"вспомогательных помощников, которые процедурные макросы могут использовать\n"
"для сравнения, генерации и запросов объектов этого типа данных."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:779
msgid ""
"@deffn {Scheme Procedure} bound-identifier=? a b\n"
"Return @code{#t} if the syntax objects @var{a} and @var{b} refer to the\n"
"same lexically-bound identifier, or @code{#f} otherwise.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} bound-identifier=? a b\n"
"Возвращает @code{#t} если синтаксический объект @var{a} и @var{b} ссылаются "
"на\n"
"один и тот же лексически связанный идентификатор, или @code{#f} в противном "
"случае.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:784
msgid ""
"@deffn {Scheme Procedure} free-identifier=? a b\n"
"Return @code{#t} if the syntax objects @var{a} and @var{b} refer to the\n"
"same free identifier, or @code{#f} otherwise.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} free-identifier=? a b\n"
"Возвращает @code{#t} если синтаксические объекты @var{a} и @var{b} "
"ссылаются\n"
"на один и тот же свободный идентификатор, или @code{#f} в противном случае.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:788
msgid ""
"@deffn {Scheme Procedure} generate-temporaries ls\n"
"Return a list of temporary identifiers as long as @var{ls} is long.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} generate-temporaries ls\n"
"Возвращает список временных идентификаторов такой же длины какой длины "
"список @var{ls}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:793
msgid ""
"@deffn {Scheme Procedure} syntax-source x\n"
"Return the source properties that correspond to the syntax object\n"
"@var{x}.  @xref{Source Properties}, for more information.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} syntax-source x\n"
"Возвращает исходные свойства, которые соответствуют синтаксическому объекту\n"
"@var{x}.  @xref{Source Properties}, для дальнейшей информации.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:801
msgid ""
"And now, a bit of confession time.  Guile's syntax expander originates\n"
"in code from Chez Scheme: a version of the expander in Chez Scheme that\n"
"was made portable to other Scheme systems.  Way back in the mid-1990s,\n"
"some Scheme systems didn't even have the ability to define new abstract\n"
"data types.  For this reason, the portable expander from Chez Scheme\n"
"that Guile inherited used tagged vectors as syntax objects: vectors\n"
"whose first element was the symbol, @code{syntax-object}."
msgstr ""
"А теперь уделим немного времения для исповеди.  Синтаксический расширитель\n"
"Guile берет свое начало в коде из Chez Scheme: версия расширителя в Chez "
"Scheme\n"
"которая была сделана переносимой в другую систему Scheme. Еще в середине "
"1990х,\n"
"некоторые системы Scheme даже не имели возможности определять новые "
"абстрактные\n"
"типы данных.  По этой причине, переносимый расширитель из Chez Scheme\n"
"который унаследовала Guile использовал тегированные вектора в качестве "
"синтаксических\n"
"объектов: вектора, первый элемент которых был символ, @code{syntax-object}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:805
msgid ""
"At the time of this writing it is 2017 and Guile still has support for\n"
"this strategy.  It worked for this long because no one ever puts a\n"
"literal vector in the operator position:"
msgstr ""
"На момент написания статьи это был 2017 и Guile все еще поддерживает эту\n"
"стратегию. Это работало долго, потому что никто не  помещал "
"буквальный(литеральныЙ)\n"
"вектор в положение оператора:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:809
msgid ""
"@example\n"
"(#(syntax-object ...) 1 2 3)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:818
msgid ""
"But this state of affairs was an error.  Because syntax objects are just\n"
"vectors, this makes it possible for any Scheme code to forge a syntax\n"
"object which might cause it to violate abstraction boundaries.  You\n"
"can't build a sandboxing facility that limits the set of bindings in\n"
"scope when one can always escape that limit just by evaluating a special\n"
"vector.  To fix this problem, Guile 2.2.1 finally migrated to represent\n"
"syntax objects as a distinct type with a distinct constructor that is\n"
"unavailable to user code."
msgstr ""
"Но такое положение дел было ошибкой. Поскольку синтаксические объекты "
"являлись\n"
"просто векторами, это дает возможность любому коду Scheme подделать\n"
"объект синтаксиса, которая может привести к нарушению границы абстракции.\n"
"В не можете построить средство для песочницы, которая ограничивает набор "
"привязок\n"
"в области, когда всегда можно избежать этого ограничения, просто вычислив\n"
"специальный вектор. Для устранения этой проблемы, Guile 2.2.1 наконец, "
"переносит\n"
"представление синтаксических объектов в виде отдельного типа с отдельным "
"конструктором,\n"
"который недоступен для пользовательского кода."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:824
msgid ""
"However, Guile still has to support ``legacy'' syntax objects, because\n"
"it could be that a file compiled with Guile 2.2.0 embeds syntax objects\n"
"of the vector kind.  Whether the expander treats the special tagged\n"
"vectors as syntax objects is now controllable by the\n"
"@code{allow-legacy-syntax-objects?} parameter:"
msgstr ""
"Тем не менее, Guile по прежнему должен поддерживать ``устаревшие'' "
"синтаксические\n"
"объекты, потому что это может быть файл скомпилированный с Guile 2.2.0, "
"который\n"
"встраивает синтаксические объекты векторного типа. Расширитель обрабатывает\n"
"специальные тегированные вектора, так как синтаксические объекты теперь "
"контролируются\n"
"с помощью параметра @code{allow-legacy-syntax-objects?}:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:831
msgid ""
"@deffn {Scheme Procedure} allow-legacy-syntax-objects?\n"
"A parameter that indicates whether the expander should support legacy\n"
"syntax objects, as described above.  For ABI stability reasons, the\n"
"default is @code{#t}.  Use @code{parameterize} to bind it to @code{#f}.\n"
"@xref{Parameters}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} allow-legacy-syntax-objects?\n"
"Параметр который указывает, должен ли расширитель поддерживать устаревшие "
"синтаксические\n"
"объекты, как описано выше.  По причинам стабильности ABI по умолчанию "
"используется\n"
"значение @code{#t}.  Используйте @code{parameterize}, чтобы связать его с "
"@code{#f}.\n"
"@xref{Parameters}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:839
msgid ""
"Guile also offers some more experimental interfaces in a separate\n"
"module.  As was the case with the Large Hadron Collider, it is unclear\n"
"to our senior macrologists whether adding these interfaces will result\n"
"in awesomeness or in the destruction of Guile via the creation of a\n"
"singularity.  We will preserve their functionality through the 2.0\n"
"series, but we reserve the right to modify them in a future stable\n"
"series, to a more than usual degree."
msgstr ""
"Guile также предлагает еще несколько экспериментальных интерфейсов в "
"отдельном\n"
"модуле.  Как было в случае большим адронным коллайдером, нашим ведущим\n"
"думателям(macrologists) неясно, добавление этих интерфейсов приведет к\n"
"потрясению или уничтожению Guile посредством создания сингулярности.\n"
"Мы сохраним их функциональность в серии 2.0, но мы оставляем за собой право\n"
"изменять их в будущих стабильных сериях, большей чем обычно степени."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:843
msgid ""
"@example\n"
"(use-modules (system syntax))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:848
msgid ""
"@deffn {Scheme Procedure} syntax-module id\n"
"Return the name of the module whose source contains the identifier\n"
"@var{id}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} syntax-module id\n"
"Возвращает имя модуля, источника содержащего идентификатор\n"
"@var{id}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:854
msgid ""
"@deffn {Scheme Procedure} syntax-local-binding id [#:resolve-syntax-"
"parameters?=#t]\n"
"Resolve the identifer @var{id}, a syntax object, within the current\n"
"lexical environment, and return two values, the binding type and a\n"
"binding value.  The binding type is a symbol, which may be one of the\n"
"following:"
msgstr ""
"@deffn {Scheme Procedure} syntax-local-binding id [#:resolve-syntax-"
"parameters?=#t]\n"
"Разыскивает(разрешает) идентификатор @var{id}, синтаксического объекта, в "
"текущей лексической среде и\n"
"возвращает два значения, тип привязки и значение привязки. Тип привязки "
"является символом, который\n"
"может быть одним из следующих:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:886
msgid ""
"@table @code\n"
"@item lexical\n"
"A lexically-bound variable.  The value is a unique token (in the sense\n"
"of @code{eq?}) identifying this binding.\n"
"@item macro\n"
"A syntax transformer, either local or global.  The value is the\n"
"transformer procedure.\n"
"@item syntax-parameter\n"
"A syntax parameter (@pxref{Syntax Parameters}).  By default,\n"
"@code{syntax-local-binding} will resolve syntax parameters, so that this\n"
"value will not be returned.  Pass @code{#:resolve-syntax-parameters? #f}\n"
"to indicate that you are interested in syntax parameters.  The value is\n"
"the default transformer procedure, as in @code{macro}.\n"
"@item pattern-variable\n"
"A pattern variable, bound via @code{syntax-case}.  The value is an\n"
"opaque object, internal to the expander.\n"
"@item ellipsis\n"
"An internal binding, bound via @code{with-ellipsis}.  The value is the\n"
"(anti-marked) local ellipsis identifier.\n"
"@item displaced-lexical\n"
"A lexical variable that has gone out of scope.  This can happen if a\n"
"badly-written procedural macro saves a syntax object, then attempts to\n"
"introduce it in a context in which it is unbound.  The value is\n"
"@code{#f}.\n"
"@item global\n"
"A global binding.  The value is a pair, whose head is the symbol, and\n"
"whose tail is the name of the module in which to resolve the symbol.\n"
"@item other\n"
"Some other binding, like @code{lambda} or other core bindings.  The\n"
"value is @code{#f}.\n"
"@end table"
msgstr ""
"@table @code\n"
"@item lexical\n"
"Лексически связанная переменная.  Значение является уникальным токеном (в "
"смысле\n"
"@code{eq?}) идетифицирующим эту привязку.\n"
"@item macro\n"
"Синтаксический преобразователь, локальный или глобальный. Значением "
"является\n"
"процедурой преобразования.\n"
"@item syntax-parameter\n"
"Синтаксический параметр (@pxref{Syntax Parameters}).  По умолчанию,\n"
"@code{syntax-local-binding} будет разрешать синтаксический параметр, так что "
"это\n"
"значение ну будет возвращено.  Передайте @code{#:resolve-syntax-parameters? "
"#f}\n"
"чтобы указать, что вас интересуют синтаксические параметры.  Значение "
"является\n"
"процедурой преобразования по умолчанию, как в @code{macro}.\n"
"@item pattern-variable\n"
"Переменная образца, связанная через @code{syntax-case}.  Значением является "
"непрозрачный\n"
"объект, внутренний для расширителя.\n"
"@item ellipsis\n"
"Внутренняя привязка, связанная через @code{with-ellipsis}.  Значением "
"является\n"
"(anti-marked) локальный идентификатор многоточия.\n"
"@item displaced-lexical\n"
"Лексическая переменная, вышедшая из области видимости. Это может произойти, "
"если плохо\n"
"написанный процедурный макрос сохраняет синтаксический объект, а затем "
"пытается\n"
"разместить его в контексте, в котором он не связан.  Значение равно\n"
"@code{#f}.\n"
"@item global\n"
"Глобальная привязка.  Значение представляет собой пару, чья голова является "
"символом,\n"
"и чей хвост - это имя модуля, в котором разрешается символ.\n"
"@item other\n"
"Некоторые другие привязки, такие как @code{lambda} или другие привязки в "
"ядре.  Значение\n"
"равно @code{#f}.\n"
"@end table"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:890
msgid ""
"This is a very low-level procedure, with limited uses.  One case in\n"
"which it is useful is to build abstractions that associate auxiliary\n"
"information with macros:"
msgstr ""
"Это очень низкоуровневая процедура с ограниченным использованием. Один\n"
"случай, когда она полезна это построение абстракций, которые связывают\n"
"вспомогательную информацию с макросами:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:915
msgid ""
"@example\n"
"(define aux-property (make-object-property))\n"
"(define-syntax-rule (with-aux aux value)\n"
"  (let ((trans value))\n"
"    (set! (aux-property trans) aux)\n"
"    trans))\n"
"(define-syntax retrieve-aux\n"
"  (lambda (x)\n"
"    (syntax-case x ()\n"
"      ((x id)\n"
"       (call-with-values (lambda () (syntax-local-binding #'id))\n"
"         (lambda (type val)\n"
"           (with-syntax ((aux (datum->syntax #'here\n"
"                                             (and (eq? type 'macro)\n"
"                                                  (aux-property val)))))\n"
"             #''aux)))))))\n"
"(define-syntax foo\n"
"  (with-aux 'bar\n"
"    (syntax-rules () ((_) 'foo))))\n"
"(foo)\n"
"@result{} foo\n"
"(retrieve-aux foo)\n"
"@result{} bar\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:919
msgid ""
"@code{syntax-local-binding} must be called within the dynamic extent of\n"
"a syntax transformer; to call it otherwise will signal an error.\n"
"@end deffn"
msgstr ""
"@code{syntax-local-binding} должна вызываться в пределах динамического \n"
"пространства синтаксического преобразователя; чтобы вызвать его в противном\n"
"случае сигнализировать об ошибке.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:923
msgid ""
"@deffn {Scheme Procedure} syntax-locally-bound-identifiers id\n"
"Return a list of identifiers that were visible lexically when the\n"
"identifier @var{id} was created, in order from outermost to innermost."
msgstr ""
"@deffn {Scheme Procedure} syntax-locally-bound-identifiers id\n"
"Возвращает список идентификаторов, которые были видны лексически при\n"
"создании идентификатора @var{id}, в порядке от самого внешнего, до самого\n"
"внутреннего."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:927
msgid ""
"This procedure is intended to be used in specialized procedural macros,\n"
"to provide a macro with the set of bound identifiers that the macro can\n"
"reference."
msgstr ""
"Эта процедура предназначена для использования в специализированных "
"процедурных\n"
"макросах, чтобы обеспечить макрос набором связанных идентификаторов, на "
"которые\n"
"может ссылаться макрос."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:935
msgid ""
"As a technical implementation detail, the identifiers returned by\n"
"@code{syntax-locally-bound-identifiers} will be anti-marked, like the\n"
"syntax object that is given as input to a macro.  This is to signal to\n"
"the macro expander that these bindings were present in the original\n"
"source, and do not need to be hygienically renamed, as would be the case\n"
"with other introduced identifiers.  See the discussion of hygiene in\n"
"section 12.1 of the R6RS, for more information on marks."
msgstr ""
"В качестве технической детали реализации, идентификаторы возвращаемые\n"
"@code{syntax-locally-bound-identifiers} будут помечены, как синтаксические\n"
"объекты, заданные в качестве входных данных в макрос.  Это сигнализирует\n"
"макро рассширителю, что эти привязки присутствуют в "
"первоисточнике(исходнике)\n"
"и не должны быть гигиенически переименованы, как было бы в случае с другими\n"
"введенными идентификаторами.  См. обсуждение гигиены в разделе\n"
" 12.1  R6RS, для получения дополнительной информации о маркировке."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:948
msgid ""
"@example\n"
"(define (local-lexicals id)\n"
"  (filter (lambda (x)\n"
"            (eq? (syntax-local-binding x) 'lexical))\n"
"          (syntax-locally-bound-identifiers id)))\n"
"(define-syntax lexicals\n"
"  (lambda (x)\n"
"    (syntax-case x ()\n"
"      ((lexicals) #'(lexicals lexicals))\n"
"      ((lexicals scope)\n"
"       (with-syntax (((id ...) (local-lexicals #'scope)))\n"
"         #'(list (cons 'id id) ...))))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:953
msgid ""
"(let* ((x 10) (x 20)) (lexicals))\n"
"@result{} ((x . 10) (x . 20))\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:957
msgid ""
"@node Defmacros\n"
"@subsection Lisp-style Macro Definitions"
msgstr ""
"@node Defmacros\n"
"@subsection Определение макросов в стиле Lisp"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:964
msgid ""
"The traditional way to define macros in Lisp is very similar to procedure\n"
"definitions. The key differences are that the macro definition body should\n"
"return a list that describes the transformed expression, and that the "
"definition\n"
"is marked as a macro definition (rather than a procedure definition) by the "
"use\n"
"of a different definition keyword: in Lisp, @code{defmacro} rather than\n"
"@code{defun}, and in Scheme, @code{define-macro} rather than @code{define}."
msgstr ""
"Традиционный способ определения макросов в Lisp очень похож на определение\n"
"процедур. Основные отличия заключаются в том, что тело определения макроса "
"должно\n"
"возвращать список, который описывает преобразованное выражение, и который "
"определен\n"
"как помеченное макроопределения (а не определение процедуры) с "
"использованием\n"
"отличного ключевого слова определения: в Lisp, @code{defmacro} а не\n"
"@code{defun}, и в Scheme, @code{define-macro} а не @code{define}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:970
msgid ""
"@fnindex defmacro\n"
"@fnindex define-macro\n"
"Guile supports this style of macro definition using both @code{defmacro}\n"
"and @code{define-macro}.  The only difference between them is how the\n"
"macro name and arguments are grouped together in the definition:"
msgstr ""
"@fnindex defmacro\n"
"@fnindex define-macro\n"
"Guile поддерживает этот стиль определения макросов, используя оба, и "
"@code{defmacro}\n"
"и @code{define-macro}.  Единственная разница между ними заключается в том, "
"как сгруппированы\n"
"имя макроса и аргументы в определении:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:974
msgid ""
"@lisp\n"
"(defmacro @var{name} (@var{args} @dots{}) @var{body} @dots{})\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:977
msgid ""
"@noindent\n"
"is the same as"
msgstr ""
"@noindent\n"
"такой же как"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:981
msgid ""
"@lisp\n"
"(define-macro (@var{name} @var{args} @dots{}) @var{body} @dots{})\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:985
msgid ""
"@noindent\n"
"The difference is analogous to the corresponding difference between\n"
"Lisp's @code{defun} and Scheme's @code{define}."
msgstr ""
"@noindent\n"
"Разница аналогична соответствующей разнице между\n"
"@code{defun} в Lisp и  @code{define} в Scheme."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:994
msgid ""
"Having read the previous section on @code{syntax-case}, it's probably clear "
"that\n"
"Guile actually implements defmacros in terms of @code{syntax-case}, applying "
"the\n"
"transformer on the expression between invocations of @code{syntax->datum} "
"and\n"
"@code{datum->syntax}. This realization leads us to the problem with "
"defmacros,\n"
"that they do not preserve referential transparency. One can be careful to "
"not\n"
"introduce bindings into expanded code, via liberal use of @code{gensym}, "
"but\n"
"there is no getting around the lack of referential transparency for free\n"
"bindings in the macro itself."
msgstr ""
"Прочитав предыдущий раздел @code{syntax-case}, вероятно вам ясно, что\n"
"Guile реализуетs defmacros в терминах @code{syntax-case}, применяя "
"преобразователь\n"
"выражений между вызовами @code{syntax->datum} и @code{datum->syntax}. \n"
"Эта реализация приводит нас к проблемам с  defmacros,\n"
"состоящих в том, что он не сохраняет ссылочную прозрачность. Можно, "
"остророжно,\n"
"чтобы не вводить привязки в расширенный код, через либеральное "
"использование\n"
"@code{gensym}, но здесь не обойтись без ссылочной прозрачности для "
"свободных\n"
"привязок в самом макросе."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:996
msgid ""
"Even a macro as simple as our @code{when} from before is difficult to get "
"right:"
msgstr ""
"Даже такой простой макрос как @code{when} из предыдущего разделаЮ было бы\n"
"трудно понять:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1001
msgid ""
"@example\n"
"(define-macro (when cond exp . rest)\n"
"  `(if ,cond\n"
"       (begin ,exp . ,rest)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1004
msgid ""
"(when #f (display \"Launching missiles!\\n\"))\n"
"@result{} #f"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1010
msgid ""
"(let ((if list))\n"
"  (when #f (display \"Launching missiles!\\n\")))\n"
"@print{} Launching missiles!\n"
"@result{} (#f #<unspecified>)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1017
msgid ""
"Guile's perspective is that defmacros have had a good run, but that modern\n"
"macros should be written with @code{syntax-rules} or @code{syntax-case}. "
"There\n"
"are still many uses of defmacros within Guile itself, but we will be "
"phasing\n"
"them out over time. Of course we won't take away @code{defmacro} or\n"
"@code{define-macro} themselves, as there is lots of code out there that "
"uses\n"
"them."
msgstr ""
"Перспектива Guile заключается в том, что defmacros отлично работает, но "
"современные\n"
"макросы должны быть написаны с помощью @code{syntax-rules} или @code{syntax-"
"case}. \n"
"Есть еще много примененений defmacros в самом Guil, но мы будем постепенно "
"сворачивать их.\n"
"Кончено, мы не будем убирать @code{defmacro} или @code{define-macro}, так "
"как есть много\n"
"кода, который использует их."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1021
msgid ""
"@node Identifier Macros\n"
"@subsection Identifier Macros"
msgstr ""
"@node Identifier Macros\n"
"@subsection Идентификатор Макросов"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1025
msgid ""
"When the syntax expander sees a form in which the first element is a macro, "
"the\n"
"whole form gets passed to the macro's syntax transformer. One may visualize "
"this\n"
"as:"
msgstr ""
"Когда расширитель синтаксиса видит форму, в которой первый элемент является "
"макросом,\n"
"вся форма передается преобразователю синтаксиса макроса. Можно представить "
"это как:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1032
msgid ""
"@example\n"
"(define-syntax foo foo-transformer)\n"
"(foo @var{arg}...)\n"
";; expands via\n"
"(foo-transformer #'(foo @var{arg}...))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1035
msgid ""
"If, on the other hand, a macro is referenced in some other part of a form, "
"the\n"
"syntax transformer is invoked with only the macro reference, not the whole "
"form."
msgstr ""
"Если, с другой стороны, макрос упоминается в какой либо другой части формы, "
"перобразователь\n"
"синтаксиса вызывается только со ссылкой на макрос, а не на всю форму."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1042
msgid ""
"@example\n"
"(define-syntax foo foo-transformer)\n"
"foo\n"
";; expands via\n"
"(foo-transformer #'foo)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1046
msgid ""
"This allows bare identifier references to be replaced programmatically via "
"a\n"
"macro. @code{syntax-rules} provides some syntax to effect this "
"transformation\n"
"more easily."
msgstr ""
"Это позволяет программно заменять голые ссылки на идентификаторы с помощью "
"макроса.\n"
"@code{syntax-rules} предоставлят несколько синтаксисов для более легкого "
"осуществления\n"
"этого преобразования."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1051
msgid ""
"@deffn {Syntax} identifier-syntax exp\n"
"Returns a macro transformer that will replace occurrences of the macro with\n"
"@var{exp}.\n"
"@end deffn"
msgstr ""
"@deffn {Syntax} identifier-syntax exp\n"
"Возвращает макро преобразователь, который заменит вхождение макроса на \n"
"@var{exp}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1055
msgid ""
"For example, if you are importing external code written in terms of @code{fx"
"+},\n"
"the fixnum addition operator, but Guile doesn't have @code{fx+}, you may use "
"the\n"
"following to replace @code{fx+} with @code{+}:"
msgstr ""
"Например, если вы импортируете внешний код написанный в терминах  @code{fx"
"+},\n"
"fixnum оператор сложения, но в Guile нет @code{fx+}, вы можете использовать\n"
"следующее для замены @code{fx+} на @code{+}:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1059
msgid ""
"@example\n"
"(define-syntax fx+ (identifier-syntax +))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1062
msgid ""
"There is also special support for recognizing identifiers on the\n"
"left-hand side of a @code{set!} expression, as in the following:"
msgstr ""
"Так же есть специальная поддержка распознавания идентификаторов в\n"
"левой части выражения @code{set!}, как в следующем примере:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1070
msgid ""
"@example\n"
"(define-syntax foo foo-transformer)\n"
"(set! foo @var{val})\n"
";; expands via\n"
"(foo-transformer #'(set! foo @var{val}))\n"
";; if foo-transformer is a \"variable transformer\"\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1074
msgid ""
"As the example notes, the transformer procedure must be explicitly\n"
"marked as being a ``variable transformer'', as most macros aren't\n"
"written to discriminate on the form in the operator position."
msgstr ""
"Как видно из примера, процедура преобразования должна быть явно помечена\n"
"как преобразователь переменной(``variable transformer''), так как "
"большинство\n"
"макросов не пишуться для распознавания в форме положения оператора."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1080
msgid ""
"@deffn {Scheme Procedure} make-variable-transformer transformer\n"
"Mark the @var{transformer} procedure as being a ``variable\n"
"transformer''. In practice this means that, when bound to a syntactic\n"
"keyword, it may detect references to that keyword on the left-hand-side\n"
"of a @code{set!}."
msgstr ""
"@deffn {Scheme Procedure} make-variable-transformer transformer\n"
"Помечает процедуру @var{transformer} как преобразователь "
"переменной(``variable\n"
"transformer''). На практике это означает, что при привязке к "
"синтаксическому\n"
"ключевому слову, он может обнаружить ссылки на это ключевое слово в левой "
"части\n"
"@code{set!}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1090
msgid ""
"@example\n"
"(define bar 10)\n"
"(define-syntax bar-alias\n"
"  (make-variable-transformer\n"
"   (lambda (x)\n"
"     (syntax-case x (set!)\n"
"       ((set! var val) #'(set! bar val))\n"
"       ((var arg ...) #'(bar arg ...))\n"
"       (var (identifier? #'var) #'bar)))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1098
msgid ""
"bar-alias @result{} 10\n"
"(set! bar-alias 20)\n"
"bar @result{} 20\n"
"(set! bar 30)\n"
"bar-alias @result{} 30\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1101
msgid ""
"There is an extension to identifier-syntax which allows it to handle the\n"
"@code{set!} case as well:"
msgstr ""
"Имеется расширение identifier-syntax которое позволяет ему обрабатывать\n"
"так же @code{set!}:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1106
msgid ""
"@deffn {Syntax} identifier-syntax (var exp1) ((set! var val) exp2)\n"
"Create a variable transformer. The first clause is used for references\n"
"to the variable in operator or operand position, and the second for\n"
"appearances of the variable on the left-hand-side of an assignment."
msgstr ""
"@deffn {Syntax} identifier-syntax (var exp1) ((set! var val) exp2)\n"
"Создает преобразователь переменной. Первое предложение используется для "
"ссылок\n"
"на переменную в положении оператора или операнда, а второе - для появления\n"
"переменной в левой стороне оператора присваивания."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1109
msgid ""
"For example, the previous @code{bar-alias} example could be expressed\n"
"more succinctly like this:"
msgstr ""
"Например, предыдущий пример @code{bar-alias} можно выразить более кратко,\n"
"подобно этому:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1116
msgid ""
"@example\n"
"(define-syntax bar-alias\n"
"  (identifier-syntax\n"
"    (var bar)\n"
"    ((set! var val) (set! bar val))))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1121
msgid ""
"@noindent\n"
"As before, the templates in @code{identifier-syntax} forms do not need\n"
"wrapping in @code{#'} syntax forms.\n"
"@end deffn"
msgstr ""
"@noindent\n"
"Как и прежде, шаблоны в формах @code{identifier-syntax} не нуждаются в\n"
"обертывании в @code{#'} синтаксических форм.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1125
msgid ""
"@node Syntax Parameters\n"
"@subsection Syntax Parameters"
msgstr ""
"@node Syntax Parameters\n"
"@subsection Синтаксические Параметры"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1134
msgid ""
"Syntax parameters@footnote{Described in the paper @cite{Keeping it Clean\n"
"with Syntax Parameters} by Barzilay, Culpepper and Flatt.} are a\n"
"mechanism for rebinding a macro definition within the dynamic extent of\n"
"a macro expansion.  This provides a convenient solution to one of the\n"
"most common types of unhygienic macro: those that introduce a unhygienic\n"
"binding each time the macro is used.  Examples include a @code{lambda}\n"
"form with a @code{return} keyword, or class macros that introduce a\n"
"special @code{self} binding."
msgstr ""
"Синтаксические параметры@footnote{Описанные в публикации @cite{Сохранение\n"
"чистоты с использованием синтаксических параметров(Keeping it Clean\n"
"with Syntax Parameters)} by Barzilay, Culpepper and Flatt.} представляют\n"
"собой механизм для повторного связывания определения макроса в пределах\n"
"динамического расширения макроса.  Это обеспечивает удобное решение для\n"
"одного из самых распространенных типов негигиенических макросов: те, "
"которые\n"
"вводят нигигиеническое связывание каждый раз когда макрос используется.\n"
"Например включение формы @code{lambda} с ключевым словом @code{return},\n"
"или макросов класса, которые вводят специальную привязку @code{self}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1143
msgid ""
"With syntax parameters, instead of introducing the binding\n"
"unhygienically each time, we instead create one binding for the keyword,\n"
"which we can then adjust later when we want the keyword to have a\n"
"different meaning.  As no new bindings are introduced, hygiene is\n"
"preserved. This is similar to the dynamic binding mechanisms we have at\n"
"run-time (@pxref{SRFI-39, parameters}), except that the dynamic binding\n"
"only occurs during macro expansion.  The code after macro expansion\n"
"remains lexically scoped."
msgstr ""
"С синтаксическими параметрами, вместо того, чтобы  негигиенично вводить \n"
"каждый раз привязу, вместо этого мы создаем одну привязку для ключевого "
"слова, которую\n"
"затем можем настроить позже, когда захотим, чтобы ключевое слово имело "
"другое\n"
"значение.  Поскольку новые привязки не вводяться, гигиена сохраняется.\n"
"Это похоже на механизмы динамического связывания, которые мы имеем во время\n"
"выполнения (@pxref{SRFI-39, parameters}), за исключением того, что "
"динамическое\n"
"связывание происходит только во время расширения макроса. Код после "
"расширения\n"
"макроса остается лексически ограниченным(охваченным)."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1158
msgid ""
"@deffn {Syntax} define-syntax-parameter keyword transformer\n"
"Binds @var{keyword} to the value obtained by evaluating\n"
"@var{transformer}.  The @var{transformer} provides the default expansion\n"
"for the syntax parameter, and in the absence of\n"
"@code{syntax-parameterize}, is functionally equivalent to\n"
"@code{define-syntax}.  Usually, you will just want to have the\n"
"@var{transformer} throw a syntax error indicating that the @var{keyword}\n"
"is supposed to be used in conjunction with another macro, for example:\n"
"@example\n"
"(define-syntax-parameter return\n"
"  (lambda (stx)\n"
"    (syntax-violation 'return \"return used outside of a lambda^\" stx)))\n"
"@end example\n"
"@end deffn"
msgstr ""
"@deffn {Syntax} define-syntax-parameter keyword transformer\n"
"Привязывает @var{keyword} к значению, полученному путем выполнения\n"
"преобразователя @var{transformer}.  @var{transformer} обеспечивает "
"расширение\n"
"по умолчанию для синтаксического параметра, а при отсутствии\n"
"@code{syntax-parameterize}, функционально эквивалентен\n"
"@code{define-syntax}.  Обычно вы просто хотите, что бы перобразователь\n"
"@var{transformer} выдал синтаксическую ошибку, указвающую что @var{keyword}\n"
"предполагается использовать вместе с другим макросом, например:\n"
"@example\n"
"(define-syntax-parameter return\n"
"  (lambda (stx)\n"
"    (syntax-violation 'return \"return used outside of a lambda^\" stx)))\n"
"@end example\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1168
msgid ""
"@deffn {Syntax} syntax-parameterize ((keyword transformer) @dots{}) exp "
"@dots{}\n"
"Adjusts @var{keyword} @dots{} to use the values obtained by evaluating\n"
"their @var{transformer} @dots{}, in the expansion of the @var{exp}\n"
"@dots{} forms.  Each @var{keyword} must be bound to a syntax-parameter.\n"
"@code{syntax-parameterize} differs from @code{let-syntax}, in that the\n"
"binding is not shadowed, but adjusted, and so uses of the keyword in the\n"
"expansion of @var{exp} @dots{} use the new transformers. This is\n"
"somewhat similar to how @code{parameterize} adjusts the values of\n"
"regular parameters, rather than creating new bindings."
msgstr ""
"@deffn {Syntax} syntax-parameterize ((keyword transformer) @dots{}) exp "
"@dots{}\n"
"Корректирует @var{keyword} @dots{} для использования значения полученного "
"путем\n"
"вычисления преобразователя @var{transformer} @dots{}, при расширении формы "
"@var{exp}\n"
"@dots{}.  Каждое @var{keyword} должно быть связано с синтаксическим "
"параметром.\n"
"@code{syntax-parameterize} отличается от @code{let-syntax}, тем что "
"привязка\n"
"не затеняется, а скорее корректируется, и поэтому использует keyword при\n"
"расширении @var{exp} @dots{} использует новый преобразователь. Это "
"несколько\n"
"похоже на то, как @code{parameterize} корректирует значения регулярных "
"параметров,\n"
"вместо того чтобы создавать новые привязки."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1183
msgid ""
"@example\n"
"(define-syntax lambda^\n"
"  (syntax-rules ()\n"
"    [(lambda^ argument-list body body* ...)\n"
"     (lambda argument-list\n"
"       (call-with-current-continuation\n"
"        (lambda (escape)\n"
"          ;; In the body we adjust the 'return' keyword so that calls\n"
"          ;; to 'return' are replaced with calls to the escape\n"
"          ;; continuation.\n"
"          (syntax-parameterize ([return (syntax-rules ()\n"
"                                          [(return vals (... ...))\n"
"                                           (escape vals (... ...))])])\n"
"            body body* ...))))]))"
msgstr ""
"@example\n"
"(define-syntax lambda^\n"
"  (syntax-rules ()\n"
"    [(lambda^ argument-list body body* ...)\n"
"     (lambda argument-list\n"
"       (call-with-current-continuation\n"
"        (lambda (escape)\n"
"          ;; В теле мы настраиваем ключевое слово 'return' так чтобы вызов\n"
"          ;; 'return' заменялся бы вызовом escape прекращения(побега)\n"
"          ;; продолжения.\n"
"          (syntax-parameterize ([return (syntax-rules ()\n"
"                                          [(return vals (... ...))\n"
"                                           (escape vals (... ...))])])\n"
"            body body* ...))))]))"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1196
msgid ""
";; Now we can write functions that return early.  Here, 'product' will\n"
";; return immediately if it sees any 0 element.\n"
"(define product\n"
"  (lambda^ (list)\n"
"           (fold (lambda (n o)\n"
"                   (if (zero? n)\n"
"                       (return 0)\n"
"                       (* n o)))\n"
"                 1\n"
"                 list)))\n"
"@end example\n"
"@end deffn"
msgstr ""
";; Теперь мы можем написать функции, которые возвращаются досрочно. Здесь, "
"результатом'product' будет\n"
";; немедленный возврат если он видит 0 элементов.\n"
"(define product\n"
"  (lambda^ (list)\n"
"           (fold (lambda (n o)\n"
"                   (if (zero? n)\n"
"                       (return 0)\n"
"                       (* n o)))\n"
"                 1\n"
"                 list)))\n"
"@end example\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1200
msgid ""
"@node Eval When\n"
"@subsection Eval-when"
msgstr ""
"@node Eval When\n"
"@subsection Eval-when"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1204
msgid ""
"As @code{syntax-case} macros have the whole power of Scheme available to "
"them,\n"
"they present a problem regarding time: when a macro runs, what parts of the\n"
"program are available for the macro to use?"
msgstr ""
"Так как макросам @code{syntax-case}  доступна вся сила Scheme,\n"
"они представляют проблему, связанную со временем: когда макрос запускается, "
"какие части\n"
"программы доступны для использования макросом?"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1211
msgid ""
"The default answer to this question is that when you import a module (via\n"
"@code{define-module} or @code{use-modules}), that module will be loaded up "
"at\n"
"expansion-time, as well as at run-time. Additionally, top-level syntactic\n"
"definitions within one compilation unit made by @code{define-syntax} are "
"also\n"
"evaluated at expansion time, in the order that they appear in the "
"compilation\n"
"unit (file)."
msgstr ""
"Ответ на этот вопрос по умолчанию, заключается в том, что при импортеа "
"модуля\n"
"(через @code{define-module} или @code{use-modules}), этот модуль будет "
"загружен\n"
"во время расширения, так же как и во время выполнения. Кроме того, "
"синтаксичсеские\n"
"определения верхнего уровня во время компиляции элемента(файла) созданные с "
"помощью\n"
" @code{define-syntax}, также вычисляются во время расширения в том порядке, "
"в котором\n"
"они появляются в компилируемом элементе(файле)."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1215
msgid ""
"But if a syntactic definition needs to call out to a normal procedure at\n"
"expansion-time, it might well need need special declarations to indicate "
"that\n"
"the procedure should be made available at expansion-time."
msgstr ""
"Но если синтаксическое определение должно вызвать нормальную процедуру во "
"время\n"
"расширения, вполне может потребоваться специальная декларация, указывающая "
"на \n"
"необходимость доступности процедуры во время расширения."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1217
msgid "For example, the following code will work at a REPL, but not in a file:"
msgstr "Например, следующий код будет работать в REPL, не не в файле:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1225
msgid ""
"@example\n"
";; incorrect\n"
"(use-modules (srfi srfi-19))\n"
"(define (date) (date->string (current-date)))\n"
"(define-syntax %date (identifier-syntax (date)))\n"
"(define *compilation-date* %date)\n"
"@end example"
msgstr ""
"@example\n"
";; не правильное\n"
"(use-modules (srfi srfi-19))\n"
"(define (date) (date->string (current-date)))\n"
"(define-syntax %date (identifier-syntax (date)))\n"
"(define *compilation-date* %date)\n"
"@end example"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1229
msgid ""
"It works at a REPL because the expressions are evaluated one-by-one, in "
"order,\n"
"but if placed in a file, the expressions are expanded one-by-one, but not\n"
"evaluated until the compiled file is loaded."
msgstr ""
"Это работает в REPL, потому что выражения вычисляются(обрабатываются) по "
"порядку, \n"
"но если они будут помещены в файл, выражения расширяются один за другим, но "
"не\n"
"вычисляются до того как скомпилированный файл будет загружен."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1231
msgid "The fix is to use @code{eval-when}."
msgstr "Исправление состоит в использовании @code{eval-when}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1240
msgid ""
"@example\n"
";; correct: using eval-when\n"
"(use-modules (srfi srfi-19))\n"
"(eval-when (expand load eval)\n"
"  (define (date) (date->string (current-date))))\n"
"(define-syntax %date (identifier-syntax (date)))\n"
"(define *compilation-date* %date)\n"
"@end example"
msgstr ""
"@example\n"
";; правильно: исползуя eval-when\n"
"(use-modules (srfi srfi-19))\n"
"(eval-when (expand load eval)\n"
"  (define (date) (date->string (current-date))))\n"
"(define-syntax %date (identifier-syntax (date)))\n"
"(define *compilation-date* %date)\n"
"@end example"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1244
msgid ""
"@deffn {Syntax} eval-when conditions exp...\n"
"Evaluate @var{exp...} under the given @var{conditions}.  Valid\n"
"conditions include:"
msgstr ""
"@deffn {Syntax} eval-when conditions exp...\n"
"Вычисляет @var{exp...} при данных условиях @var{conditions}.  "
"Действительные\n"
"условия включают в себя:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1248
msgid ""
"@table @code\n"
"@item expand\n"
"Evaluate during macro expansion, whether compiling or not."
msgstr ""
"@table @code\n"
"@item expand\n"
"Вычисление во время макро расширения, не зависимо от того скомпилирован он "
"или нет."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1252
msgid ""
"@item load\n"
"Evaluate during the evaluation phase of compiled code, e.g. when loading\n"
"a compiled module or running compiled code at the REPL."
msgstr ""
"@item load\n"
"Вычисление на этапе вычисления скомпилированного кода, т.е. при загрузке\n"
"скомпилированного модуля или запуске скомпилированного кода в  REPL."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1255
msgid ""
"@item eval\n"
"Evaluate during the evaluation phase of non-compiled code."
msgstr ""
"@item eval\n"
"Вычисление во время фазы вычисления не скомпилированного кода."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1259
msgid ""
"@item compile\n"
"Evaluate during macro expansion, but only when compiling.\n"
"@end table"
msgstr ""
"@item compile\n"
"Вычисление во время макро расширения, но только при компиляции.\n"
"@end table"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1263
msgid ""
"In other words, when using the primitive evaluator, @code{eval-when}\n"
"expressions with @code{expand} are run during macro expansion, and those\n"
"with @code{eval} are run during the evaluation phase."
msgstr ""
"Другими словами, при использовании примитивного исполнителя(evaluator), "
"выражение \n"
"@code{eval-when} с @code{expand} выполняются во время расширения макроса, а "
"те, которые\n"
"имеют @code{eval} запускаются во время этапа вычисления."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1267
msgid ""
"When using the compiler, @code{eval-when} expressions with either\n"
"@code{expand} or @code{compile} are run during macro expansion, and\n"
"those with @code{load} are run during the evaluation phase."
msgstr ""
"При использовании компилятора, выражение @code{eval-when} с\n"
"@code{expand} или @code{compile} запускаются во время макро\n"
"расширения, а те у кого есть @code{load} также запускаются\n"
"во время этапаа вычисления."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1272
msgid ""
"When in doubt, use the three conditions @code{(expand load eval)}, as in\n"
"the example above.  Other uses of @code{eval-when} may void your\n"
"warranty or poison your cat.\n"
"@end deffn"
msgstr ""
"Если вы сомневаетесь, исползуйте три условия @code{(expand load eval)}, как "
"в\n"
"примере выше.  Другие способы использования @code{eval-when} могут привести\n"
"к анулированию гарантий или отравлению вашего кота.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1275
msgid ""
"@node Macro Expansion\n"
"@subsection Macro Expansion"
msgstr ""
"@node Macro Expansion\n"
"@subsection Расширение Макроса"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1280
msgid ""
"Usually, macros are expanded on behalf of the user as needed.  Macro\n"
"expansion is an integral part of @code{eval} and @code{compile}.  Users\n"
"can also expand macros at the REPL prompt via the @code{expand} REPL\n"
"command; @xref{Compile Commands}."
msgstr ""
"Обычно, макросы расширяются по мере необходимости их использования."
"Расширение\n"
"макросов неотемлемая часть @code{eval} и @code{compile}.  Пользователи "
"также\n"
"могут расширять макросы в запросе REPL через команду REPL @code{expand}; \n"
"@xref{Compile Commands}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1283
msgid ""
"Macros can also be expanded programmatically, via @code{macroexpand},\n"
"but the details get a bit hairy for two reasons."
msgstr ""
"Макросы также могут быть расширены программно, через @code{macroexpand},\n"
"не детали получаются ужасными, по двум причинам."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1291
msgid ""
"The first complication is that the result of macro-expansion isn't\n"
"Scheme: it's Tree-IL, Guile's high-level intermediate language.\n"
"@xref{Tree-IL}.  As ``hygienic macros'' can produce identifiers that are\n"
"distinct but have the same name, the output format needs to be able to\n"
"represent distinctions between variable identities and names.  Again,\n"
"@xref{Tree-IL}, for all the details.  The easiest thing is to just run\n"
"@code{tree-il->scheme} on the result of macro-expansion:"
msgstr ""
"Первая трудность состоит в том, что результатом макрорасширения\n"
"является не Scheme: а Tree-IL, высокоуровневый промежуточный язык Guile.\n"
"@xref{Tree-IL}.  Как ``гигиенические макросы'' могут создавать "
"идентификаторы,\n"
"которые отличаются друг от друга, но имеют одинаковое имя, выходной формат\n"
"должен быть способен представлять различия между переменными и именами. Еще\n"
"раз @xref{Tree-IL}, для получаения детальной информации.  Самое простое -\n"
"просто запустить @code{tree-il->scheme} для результата макро-расширения:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1296
msgid ""
"@lisp\n"
"(macroexpand '(+ 1 2))\n"
"@result{}\n"
"#<tree-il (call (toplevel +) (const 1) (const 2))>"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1302
msgid ""
"(use-modules (language tree-il))\n"
"(tree-il->scheme (macroexpand '(+ 1 2)))\n"
"@result{}\n"
"(+ 1 2)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1305
msgid ""
"The second complication involves @code{eval-when}.  As an example, what\n"
"would it mean to macro-expand the definition of a macro?"
msgstr ""
"Вторая трудность заключена в @code{eval-when}.  В качестве примера, что "
"означает\n"
"для macro-expand определение макроса?"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1311
msgid ""
"@lisp\n"
"(macroexpand '(define-syntax qux (identifier-syntax 'bar)))\n"
"@result{}\n"
"?\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1318
msgid ""
"The answer is that it depends who is macro-expanding, and why.  Do you\n"
"define the macro in the current environment?  Residualize a macro\n"
"definition?  Both?  Neither?  The default is to expand in ``eval'' mode,\n"
"which means an @code{eval-when} clauses will only proceed when\n"
"@code{eval} (or @code{expand}) is in its condition set.  Top-level\n"
"macros will be @code{eval}'d in the top-level environment."
msgstr ""
"Ответ зависит от того, кто является расширителем макроса и почему. Вы\n"
"определяете макрос в текущей окружающей среде? Остаточное определение\n"
"макроса? И то и другое? Ни? По умолчанию это расширение в режиме ``eval'',\n"
"что означает, что предложения @code{eval-when} будет действовать только\n"
"когда @code{eval} (или @code{expand}) удовлетворяют набору условий. Макрос\n"
"верхнего уровня будет вычислен @code{eval} в среде верхнего уровня."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1324
msgid ""
"In this way @code{(macroexpand @var{foo})} is equivalent to\n"
"@code{(macroexpand @var{foo} 'e '(eval))}.  The second argument is the\n"
"mode (@code{'e} for ``eval'') and the second is the\n"
"eval-syntax-expanders-when parameter (only @code{eval} in this default\n"
"setting)."
msgstr ""
"Таким образом @code{(macroexpand @var{foo})} эквивалентно\n"
"@code{(macroexpand @var{foo} 'e '(eval))}.  вторым аргументом является\n"
"режим (@code{'e} for ``eval'') и второй параметр eval-syntax-expanders-when\n"
"(только @code{eval} в этой установке по умолчанию)."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1333
msgid ""
"But if you are compiling the macro definition, probably you want to\n"
"reify the macro definition itself.  In that case you pass @code{'c} as\n"
"the second argument to @code{macroexpand}.  But probably you want the\n"
"macro definition to be present at compile time as well, so you pass\n"
"@code{'(compile load eval)} as the @var{esew} parameter.  In fact\n"
"@code{(compile @var{foo} #:to 'tree-il)} is entirely equivalent to\n"
"@code{(macroexpand @var{foo} 'c '(compile load eval))}; @xref{The Scheme\n"
"Compiler}."
msgstr ""
"Но если вы компилируете определение макроса, возможн, вы захотите\n"
"восстановить само определение макроса. В этом случае вы передаете\n"
"@code{'c} в качестве второго параметра в @code{macroexpand}.  Но, \n"
"вероятно, вы хотите, чтобы определение макроса присутствовало во\n"
"врмея компиляции, так что вы передаете  @code{'(compile load eval)}\n"
"как параметр @var{esew}.  На самом деле @code{(compile @var{foo} #:to 'tree-"
"il)}\n"
"полностью эквивалентен @code{(macroexpand @var{foo} 'c '(compile load "
"eval))}; \n"
"@xref{The Scheme Compiler}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1337
msgid ""
"It's a terrible interface; we know.  The macroexpander is somewhat\n"
"tricksy regarding modes, so unless you are building a macro-expanding\n"
"tool, we suggest to avoid invoking it directly."
msgstr ""
"Это ужасный интерфейс; мы знаем.  Макрорасширитель(macroexpander) несколько\n"
"сложнее в этом отношении, поэтому, если вы не создаете утилиту макро-"
"расширения,\n"
"мы предлагаем избегать его вызова на прямую."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1341
msgid ""
"@node Hygiene and the Top-Level\n"
"@subsection Hygiene and the Top-Level"
msgstr ""
"@node Hygiene and the Top-Level\n"
"@subsection Гигиена и Верхний Уровень"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1343
msgid "Consider the following macro."
msgstr "Рассмотрим следующий макрос."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1350
msgid ""
"@lisp\n"
"(define-syntax-rule (defconst name val)\n"
"  (begin\n"
"    (define t val)\n"
"    (define-syntax-rule (name) t)))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1352
msgid "If we use it to make a couple of bindings:"
msgstr "Если мы используем его, чтобы сделать пару привязок:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1357
msgid ""
"@lisp\n"
"(defconst foo 42)\n"
"(defconst bar 37)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1359
msgid "The expansion would look something like this:"
msgstr "Его расширение будет выглядеть примерно так:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1368
msgid ""
"@lisp\n"
"(begin\n"
"  (define t 42)\n"
"  (define-syntax-rule (foo) t))\n"
"(begin\n"
"  (define t 37)\n"
"  (define-syntax-rule (bar) t))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1373
msgid ""
"As the two @code{t} bindings were introduced by the macro, they should\n"
"be introduced hygienically -- and indeed they are, inside a lexical\n"
"contour (a @code{let} or some other lexical scope).  The @code{t}\n"
"reference in @code{foo} is distinct to the reference in @code{bar}."
msgstr ""
"Поскольку два @code{t} привязки были введены макросом, они должны быть\n"
"введены гигиенически(hygienically) -- и действительно, они находяться "
"внутри\n"
"лексического контура (т.е. @code{let} или какой-то другой лексической "
"области охвата).\n"
"Ссылка @code{t} в @code{foo} отличается от ссылке в @code{bar}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1381
msgid ""
"At the top-level things are more complicated.  Before Guile 2.2, a use\n"
"of @code{defconst} at the top-level would not introduce a fresh binding\n"
"for @code{t}.  This was consistent with a weaselly interpretation of the\n"
"Scheme standard, in which all possible bindings may be assumed to exist,\n"
"at the top-level, and in which we merely take advantage of toplevel\n"
"@code{define} of an existing binding being equivalent to @code{set!}.\n"
"But it's not a good reason."
msgstr ""
"На верхнем уровне все сложнее.  До Guile 2.2, исползование @code{defconst}\n"
"на верхнем уровне не будет вводить новую привязку для @code{t}.  Это было\n"
"сделано в соответствии с гибкой интерпретацией стандарта Scheme, в котором\n"
"предполагалось, что все возможные привязки осуществляются на верхнем "
"уровне,\n"
"и в котором мы просто используем преимущества @code{define} верхнего уровня\n"
"для существующей привязки она эквивалентна @code{set!}.\n"
"Но это не веская причина."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1385
msgid ""
"The solution is to create fresh names for all bindings introduced by\n"
"macros -- not just bindings in lexical contours, but also bindings\n"
"introduced at the top-level."
msgstr ""
"Решение состоит в том, чтобы создать новые имена для всех привязок,\n"
"предоставленных макросами, а не только привязками в лексических контурах,\n"
"но и привязкам введенным на верхнем уровне."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1396
msgid ""
"However, the obvious strategy of just giving random names to introduced\n"
"toplevel identifiers poses a problem for separate compilation.  Consider\n"
"without loss of generality a @code{defconst} of @code{foo} in module\n"
"@code{a} that introduces the fresh top-level name @code{t-1}.  If we\n"
"then compile a module @code{b} that uses @code{foo}, there is now a\n"
"reference to @code{t-1} in module @code{b}.  If module @code{a} is then\n"
"expanded again, for whatever reason, for example in a simple\n"
"recompilation, the introduced @code{t} gets a fresh name; say,\n"
"@code{t-2}.  Now module @code{b} has broken because module @code{a} no\n"
"longer has a binding for @code{t-1}."
msgstr ""
"Однако, очевидно стратегия простого присвоения случайных имен "
"идентификаторам\n"
"верхнего уровня создает проблему для отдельной компиляции.  Рассмотрим без\n"
"ограничения общности @code{defconst} из @code{foo} в модуле\n"
"@code{a}, который вводит новое имя верхнего уровня @code{t-1}.  Если мы "
"тогда\n"
"скомпилируем модуль @code{b} который исползжует @code{foo}, теперь в модуле\n"
"@code{b} есть ссылка на @code{t-1}.  Если модуль @code{a} затем вновь "
"расширяется,\n"
"по любой причине, например при простой перекомпиляции, введенный  @code{t} "
"получает\n"
"новое имя; скажем, @code{t-2}.  Теперь модуль @code{b} ломается, потому что "
"в модуле\n"
"@code{a} нет больше привязки с именем @code{t-1}."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1408
msgid ""
"If introduced top-level identifiers ``escape'' a module, in whatever\n"
"way, they then form part of the binary interface (ABI) of a module.  It\n"
"is unacceptable from an engineering point of view to allow the ABI to\n"
"change randomly.  (It also poses practical problems in meeting the\n"
"recompilation conditions of the Lesser GPL license, for such modules.)\n"
"For this reason many people prefer to never use identifier-introducing\n"
"macros at the top-level, instead making those macros receive the names\n"
"for their introduced identifiers as part of their arguments, or to\n"
"construct them programmatically and use @code{datum->syntax}.  But this\n"
"approach requires omniscience as to the implementation of all macros one\n"
"might use, and also limits the expressive power of Scheme macros."
msgstr ""
"Если введенные идентификаторы верхнего уровня экранируются(``escape'') \n"
"модулем, то в любом случае они образуют часть двоичного интерфейса (ABI)\n"
"модуля.  С инженерной точки зрения не допустимо случайное изменение ABI.\n"
"(Это также создает практические проблемы в выполнении условий "
"перекомпиляции\n"
"лицензии Lesser GPL, для таких модулей.)\n"
"По этой причине многие люди предпочитают никогда не использовать макросы,\n"
"вводящие идентификаторы на верхнем уровне, вместо этого заставляя эти "
"макросы\n"
"получать имена для вводимых ими идентификаторов как часть их аргументов, "
"или\n"
"чтобы строить их программно и использовать @code{datum->syntax}.  Но этот "
"подход\n"
"требует всеведения в отношении реализации всех макросов, которые можно "
"использовать,\n"
"и также ограничивает выразительную силу макросов Scheme."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1414
msgid ""
"There is no perfect solution to this issue.  Guile does a terrible thing\n"
"here.  When it goes to introduce a top-level identifier, Guile gives the\n"
"identifier a pseudo-fresh name: a name that depends on the hash of the\n"
"source expression in which the name occurs.  The result in this case is\n"
"that the introduced definitions expand as:"
msgstr ""
"Идеального решения этой проблемы не существует.  Guile делает здесь ужасную\n"
"вещь.  Когда дело идет к введению идентификатора верхнего уровня, Guile "
"дает\n"
"идентификатору псевдо-чистое имя: имя это зависит от хеша исходного "
"выражения, в\n"
"котором встречается имя.  В этом случае введенные определения расширяются "
"как:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1423
msgid ""
"@lisp\n"
"(begin\n"
"  (define t-1dc5e42de7c1050c 42)\n"
"  (define-syntax-rule (foo) t-1dc5e42de7c1050c))\n"
"(begin\n"
"  (define t-10cb8ce9fdddd6e9 37)\n"
"  (define-syntax-rule (bar) t-10cb8ce9fdddd6e9))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1426
msgid ""
"However, note that as the hash depends solely on the expression\n"
"introducing the definition, we also have:"
msgstr ""
"Однако обратите внимание, что поскольку хеш зависит исключительно от "
"выражения, вводящего\n"
"определение, у нас также есть:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1433
msgid ""
"@lisp\n"
"(defconst baz 42)\n"
"@result{} (begin\n"
"    (define t-1dc5e42de7c1050c 42)\n"
"    (define-syntax-rule (baz) t-1dc5e42de7c1050c))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1439
msgid ""
"Note that the introduced binding has the same name!  This is because the\n"
"source expression, @code{(define t 42)}, was the same.  Probably you\n"
"will never see an error in this area, but it is important to understand\n"
"the components of the interface of a module, and that interface may\n"
"include macro-introduced identifiers."
msgstr ""
"Обратите внимание, что введенная привязка имеет тоже имя!  Это потому, что\n"
"исходное выражение, @code{(define t 42)}, было тоже самое.  Возможно, вы "
"никогда\n"
"не увидите ошибку в этой области, но важно понимать компоненты интерфейса "
"модуля,\n"
"и что интерфейс может включать в себя макро-введенные идентификаторы."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1443
msgid ""
"@node Internal Macros\n"
"@subsection Internal Macros"
msgstr ""
"@node Internal Macros\n"
"@subsection Внутренние Макросы"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1448
msgid ""
"@deffn {Scheme Procedure} make-syntax-transformer name type binding\n"
"Construct a syntax transformer object. This is part of Guile's low-level "
"support\n"
"for syntax-case.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} make-syntax-transformer name type binding\n"
"Строит объект синтаксического преобразования. Это часть низкоуровневой "
"поддержки \n"
"в Guile syntax-case.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1453
msgid ""
"@deffn {Scheme Procedure} macro? obj\n"
"@deffnx {C Function} scm_macro_p (obj)\n"
"Return @code{#t} if @var{obj} is a syntax transformer, or @code{#f}\n"
"otherwise."
msgstr ""
"@deffn {Scheme Procedure} macro? obj\n"
"@deffnx {C Function} scm_macro_p (obj)\n"
"Возвращает @code{#t} если @var{obj} является синтаксическим "
"преобразователем, или @code{#f}\n"
"otherwise."

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1457
msgid ""
"Note that it's a bit difficult to actually get a macro as a first-class "
"object;\n"
"simply naming it (like @code{case}) will produce a syntax error. But it is\n"
"possible to get these objects using @code{module-ref}:"
msgstr ""
"Обратите внимание, что немного сложно получить макрос как объект первого "
"класса(первоклассный);\n"
"простое именование его (такие как @code{case}) приведет к синтаксической "
"ошибке. Но можно получить\n"
"эти объекты используя @code{module-ref}:"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1463
msgid ""
"@example\n"
"(macro? (module-ref (current-module) 'case))\n"
"@result{} #t\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1469
msgid ""
"@deffn {Scheme Procedure} macro-type m\n"
"@deffnx {C Function} scm_macro_type (m)\n"
"Return the @var{type} that was given when @var{m} was constructed, via\n"
"@code{make-syntax-transformer}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} macro-type m\n"
"@deffnx {C Function} scm_macro_type (m)\n"
"Возвращает тип @var{type} который был задан, при создании @var{m}, с "
"помощью\n"
"преобразователя синтаксиса @code{make-syntax-transformer}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1474
msgid ""
"@deffn {Scheme Procedure} macro-name m\n"
"@deffnx {C Function} scm_macro_name (m)\n"
"Return the name of the macro @var{m}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} macro-name m\n"
"@deffnx {C Function} scm_macro_name (m)\n"
"Возвращает имя макроса @var{m}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1479
msgid ""
"@deffn {Scheme Procedure} macro-binding m\n"
"@deffnx {C Function} scm_macro_binding (m)\n"
"Return the binding of the macro @var{m}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} macro-binding m\n"
"@deffnx {C Function} scm_macro_binding (m)\n"
"Возвращает привязку макроса @var{m}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1486
msgid ""
"@deffn {Scheme Procedure} macro-transformer m\n"
"@deffnx {C Function} scm_macro_transformer (m)\n"
"Return the transformer of the macro @var{m}. This will return a procedure, "
"for\n"
"which one may ask the docstring. That's the whole reason this section is\n"
"documented. Actually a part of the result of @code{macro-binding}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} macro-transformer m\n"
"@deffnx {C Function} scm_macro_transformer (m)\n"
"Возвращает преобразователь макроса @var{m}. Возвращает процедуру, для "
"которой можно\n"
"запросить документацию(docstring). Вот и вся причина поо которой этот "
"раздел \n"
"задокументирован. На самом деле это часть результата @code{macro-binding}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-macros.texi:1490
msgid ""
"@c Local Variables:\n"
"@c TeX-master: \"guile.texi\"\n"
"@c End:"
msgstr ""
