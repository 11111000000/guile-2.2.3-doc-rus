#
# NuINu <don't@send.my>, 2019.
#
#. extracted from /home/bear/work/guile/doc/guile/en/scheme-scripts.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-07 12:37+0300\n"
"PO-Revision-Date: 2019-02-28 15:29+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2010, "
"2011\n"
"@c   Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:9
msgid ""
"@node Guile Scripting\n"
"@section Guile Scripting"
msgstr ""
"@node Guile Scripting\n"
"@section Скрипты Guile"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:14
msgid ""
"Like AWK, Perl, or any shell, Guile can interpret script files.  A Guile\n"
"script is simply a file of Scheme code with some extra information at\n"
"the beginning which tells the operating system how to invoke Guile, and\n"
"then tells Guile how to handle the Scheme code."
msgstr ""
"Подобно AWK, Perl, или другим оболочкам, Guile может интерпретировать файлы "
"сценариев.\n"
"Скрипт(Сценарий) Guile это просто файл с кодом Scheme с дополнительной "
"информацией в \n"
"начале, которая сообщает операционной системе, как вызывать Guile, а затем "
"говорит\n"
"Guile как обрабатывать код Scheme."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:22
msgid ""
"@menu\n"
"* The Top of a Script File::    How to start a Guile script.\n"
"* The Meta Switch::             Passing complex argument lists to Guile\n"
"                                from shell scripts.\n"
"* Command Line Handling::       Accessing the command line from a script.\n"
"* Scripting Examples::\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:26
msgid ""
"@node The Top of a Script File\n"
"@subsection The Top of a Script File"
msgstr ""
"@node The Top of a Script File\n"
"@subsection Начало Файла скрипта"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:30
msgid ""
"The first line of a Guile script must tell the operating system to use\n"
"Guile to evaluate the script, and then tell Guile how to go about doing\n"
"that.  Here is the simplest case:"
msgstr ""
"Первая строка скрипта Guile должна указывать операционной системе "
"использовать\n"
"Guile для вычисления скрипта, а затем указать Guile как это сделать. Вот\n"
"самый простой случай:"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:32
msgid "@itemize @bullet"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:35
msgid ""
"@item\n"
"The first two characters of the file must be @samp{#!}."
msgstr ""
"@item\n"
"Первые два символа должны быть @samp{#!}."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:42
msgid ""
"The operating system interprets this to mean that the rest of the line\n"
"is the name of an executable that can interpret the script.  Guile,\n"
"however, interprets these characters as the beginning of a multi-line\n"
"comment, terminated by the characters @samp{!#} on a line by themselves.\n"
"(This is an extension to the syntax described in R5RS, added to support\n"
"shell scripts.)"
msgstr ""
"Операционная система интерпретирует это, так что оставшаяся часть строки\n"
"является именем исполняемого файла, который может интерпретировать скрипт.\n"
"Guile, однако, интерпретирует эти символы как начало многострочного "
"коментария,\n"
"заканчивающегося символьными знаками @samp{!#} в своей последней строке.\n"
"(Это расширение синтаксиса описанного в R5RS, добавлено для поддержки\n"
"скриптов оболочки(shell).)"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:47
msgid ""
"@item\n"
"Immediately after those two characters must come the full pathname to\n"
"the Guile interpreter.  On most systems, this would be\n"
"@samp{/usr/local/bin/guile}."
msgstr ""
"@item\n"
"Сразу после этих двух знаков должен идти полный путь к интерпретатору\n"
"Guile.  В большинстве систем он будет\n"
"@samp{/usr/local/bin/guile}."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:54
msgid ""
"@item\n"
"Then must come a space, followed by a command-line argument to pass to\n"
"Guile; this should be @samp{-s}.  This switch tells Guile to run a\n"
"script, instead of soliciting the user for input from the terminal.\n"
"There are more elaborate things one can do here; see @ref{The Meta\n"
"Switch}."
msgstr ""
"@item\n"
"Затем должен идти пробел, за которым следует аргумент командной строки\n"
"для передачи в Guile; это должен быть @samp{-s}.  Этот переключатель "
"говорит\n"
"Guile запустить скрипт, вместо того чтобы просить пользователя вводить "
"команды\n"
"в окне терминала. Есть более сложные вещи, которые можно сделать здесь; "
"см. \n"
"@ref{The Meta Switch}."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:57
msgid ""
"@item\n"
"Follow this with a newline."
msgstr ""
"@item\n"
"Далее следует знак новой строки."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:63
msgid ""
"@item\n"
"The second line of the script should contain only the characters\n"
"@samp{!#} --- just like the top of the file, but reversed.  The\n"
"operating system never reads this far, but Guile treats this as the end\n"
"of the comment begun on the first line by the @samp{#!} characters."
msgstr ""
"@item\n"
"Вторая строка скриптам должна содержать только символьные знаки\n"
"@samp{!#} --- просто как верхняя строка файла, но в обратном порядке.\n"
"Операционная система никогда не читает так далеко, но Guile относится\n"
"к этому как к концу комментария, начатому в первой строке символьными\n"
"знаками @samp{#!}."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:69
msgid ""
"@item\n"
"If this source code file is not ASCII or ISO-8859-1 encoded, a coding\n"
"declaration such as @code{coding: utf-8} should appear in a comment\n"
"somewhere in the first five lines of the file: see @ref{Character\n"
"Encoding of Source Files}."
msgstr ""
"@item\n"
"Если файл исходного кода не является закодированным в ASCII или ISO-8859-1,\n"
"объявление кодировки, как @code{coding: utf-8} должно появиться в "
"комментарии\n"
"где-то в первых пяти строках файла: см @ref{Character\n"
"Encoding of Source Files}."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:72
msgid ""
"@item\n"
"The rest of the file should be a Scheme program."
msgstr ""
"@item\n"
"Остальная часть файла должна быть программой Scheme."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:74
msgctxt "/home/bear/work/guile/doc/guile/en/scheme-scripts.texi:74"
msgid "@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:77
msgid ""
"Guile reads the program, evaluating expressions in the order that they\n"
"appear.  Upon reaching the end of the file, Guile exits."
msgstr ""
"Guile читает программу, вычисляет выражения в порядке их появления. "
"Достигнув\n"
"конца файла Guile завершает работу."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:80
msgid ""
"@node The Meta Switch\n"
"@subsection The Meta Switch"
msgstr ""
"@node The Meta Switch\n"
"@subsection Мета переключатель"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:99
msgid ""
"Guile's command-line switches allow the programmer to describe\n"
"reasonably complicated actions in scripts.  Unfortunately, the POSIX\n"
"script invocation mechanism only allows one argument to appear on the\n"
"@samp{#!} line after the path to the Guile executable, and imposes\n"
"arbitrary limits on that argument's length.  Suppose you wrote a script\n"
"starting like this:\n"
"@example\n"
"#!/usr/local/bin/guile -e main -s\n"
"!#\n"
"(define (main args)\n"
"  (map (lambda (arg) (display arg) (display \" \"))\n"
"       (cdr args))\n"
"  (newline))\n"
"@end example\n"
"The intended meaning is clear: load the file, and then call @code{main}\n"
"on the command-line arguments.  However, the system will treat\n"
"everything after the Guile path as a single argument --- the string\n"
"@code{\"-e main -s\"} --- which is not what we want."
msgstr ""
"Переключатели командной строки Guile позволяют программисту описывать\n"
"достаточно сложные действия в скриптах. К сожалению, механизм вызова\n"
"скрипта POSIX допускает только один аргумент, который может появиться\n"
"в строке @samp{#!} после пути к исполняемому файлу Guile, и накладывает\n"
"произвольные ограничения на длину этого аргумента. Предположим вы написали\n"
"скрипт, начинающийся так:\n"
"@example\n"
"#!/usr/local/bin/guile -e main -s\n"
"!#\n"
"(define (main args)\n"
"  (map (lambda (arg) (display arg) (display \" \"))\n"
"       (cdr args))\n"
"  (newline))\n"
"@end example\n"
"Предполагаемое назначение ясно: грузим файл, и вызываем @code{main}\n"
"как аргумент командной строки.  Однако система будет относиться ко всему\n"
"после пути Guile как одному аргументу --- строка @code{\"-e main -s\"} --- \n"
"это не то что мы хотим."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:106
msgid ""
"As a workaround, the meta switch @code{\\} allows the Guile programmer to\n"
"specify an arbitrary number of options without patching the kernel.  If\n"
"the first argument to Guile is @code{\\}, Guile will open the script file\n"
"whose name follows the @code{\\}, parse arguments starting from the\n"
"file's second line (according to rules described below), and substitute\n"
"them for the @code{\\} switch."
msgstr ""
"В качестве обходного пути, мета переключатель @code{\\} позволяет "
"программисту\n"
"Guile определять произвольное количество опций без исправления ядра. Если\n"
"первым аргументом Guile является @code{\\}, Guile откроет файл скрипта имя "
"которого\n"
"следует за аргументом @code{\\}, и разберет аргументы для старта из файла "
"начиная\n"
"со второй строки(в соответствии с правилами описанными ниже), и заменит на "
"них\n"
"переключатель @code{\\}."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:112
msgid ""
"Working in concert with the meta switch, Guile treats the characters\n"
"@samp{#!} as the beginning of a comment which extends through the next\n"
"line containing only the characters @samp{!#}.  This sort of comment may\n"
"appear anywhere in a Guile program, but it is most useful at the top of\n"
"a file, meshing magically with the POSIX script invocation mechanism."
msgstr ""
"Работая вместе с мета-переключателем, Guile рассматривает символьные знаки\n"
"@samp{#!} как начало комментария, который простираетсся до следующей "
"строки,\n"
"содержащей только знаки @samp{!#}.  Комментарии такого рода могут появиться\n"
"в любом месте программы Guile, но они наиболее полезны в верхней части "
"файла,\n"
"волшебным образом объединяясь с механизмом вызова сценариев POSIX."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:123
msgid ""
"Thus, consider a script named @file{/u/jimb/ekko} which starts like this:\n"
"@example\n"
"#!/usr/local/bin/guile \\\n"
"-e main -s\n"
"!#\n"
"(define (main args)\n"
"        (map (lambda (arg) (display arg) (display \" \"))\n"
"             (cdr args))\n"
"        (newline))\n"
"@end example"
msgstr ""
"Итак, рассмотрим скрипт с именем @file{/u/jimb/ekko} который начинается "
"так:\n"
"@example\n"
"#!/usr/local/bin/guile \\\n"
"-e main -s\n"
"!#\n"
"(define (main args)\n"
"        (map (lambda (arg) (display arg) (display \" \"))\n"
"             (cdr args))\n"
"        (newline))\n"
"@end example"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:128
msgid ""
"Suppose a user invokes this script as follows:\n"
"@example\n"
"$ /u/jimb/ekko a b c\n"
"@end example"
msgstr ""
"Предположим, что пользователь вызывает этот скрипт следующим образом:\n"
"@example\n"
"$ /u/jimb/ekko a b c\n"
"@end example"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:131
msgid ""
"Here's what happens:\n"
"@itemize @bullet"
msgstr ""
"Вот что здесь происходит:\n"
"@itemize @bullet"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:139
msgid ""
"@item\n"
"the operating system recognizes the @samp{#!} token at the top of the\n"
"file, and rewrites the command line to:\n"
"@example\n"
"/usr/local/bin/guile \\ /u/jimb/ekko a b c\n"
"@end example\n"
"This is the usual behavior, prescribed by POSIX."
msgstr ""
"@item\n"
"операционная система распознает токен the @samp{#!} в верху файла и "
"переписывает\n"
"командную строку так:\n"
"@example\n"
"/usr/local/bin/guile \\ /u/jimb/ekko a b c\n"
"@end example\n"
"Это обычное поведение, предписанное POSIX."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:148
msgid ""
"@item\n"
"When Guile sees the first two arguments, @code{\\ /u/jimb/ekko}, it opens\n"
"@file{/u/jimb/ekko}, parses the three arguments @code{-e}, @code{main},\n"
"and @code{-s} from it, and substitutes them for the @code{\\} switch.\n"
"Thus, Guile's command line now reads:\n"
"@example\n"
"/usr/local/bin/guile -e main -s /u/jimb/ekko a b c\n"
"@end example"
msgstr ""
"@item\n"
"Когда Guile видит первые два аргумента, @code{\\ /u/jimb/ekko}, он "
"открывает\n"
"@file{/u/jimb/ekko}, анализирует три аргумента @code{-e}, @code{main},\n"
"and @code{-s} из него, и подставляет их вместо переключателя @code{\\}.\n"
"Таким образом, командная строка Guile теперь выглядит так:\n"
"@example\n"
"/usr/local/bin/guile -e main -s /u/jimb/ekko a b c\n"
"@end example"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:153
msgid ""
"@item\n"
"Guile then processes these switches: it loads @file{/u/jimb/ekko} as a\n"
"file of Scheme code (treating the first three lines as a comment), and\n"
"then performs the application @code{(main \"/u/jimb/ekko\" \"a\" \"b\" \"c"
"\")}."
msgstr ""
"@item\n"
"Затем Guile обрабатывает ключи: он загружает файл @file{/u/jimb/ekko} как\n"
"файл с кодом Scheme (обрабатывая первые три строки как комментраий), и\n"
"затем выполняет приложение @code{(main \"/u/jimb/ekko\" \"a\" \"b\" \"c\")}."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:155
msgctxt "/home/bear/work/guile/doc/guile/en/scheme-scripts.texi:155"
msgid "@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:160
msgid ""
"When Guile sees the meta switch @code{\\}, it parses command-line\n"
"argument from the script file according to the following rules:\n"
"@itemize @bullet"
msgstr ""
"Когда Guile видит метаперключатель @code{\\}, он анализирует аргументы "
"командной строки\n"
"из файла скрипта в соответствии со следующими правилами:\n"
"@itemize @bullet"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:164
msgid ""
"@item\n"
"Each space character terminates an argument.  This means that two\n"
"spaces in a row introduce an argument @code{\"\"}."
msgstr ""
"@item\n"
"Каждый символ пробела завершает аргумент.  Это означает что два пробела\n"
"подряд вводят аргумент(пустую строку) @code{\"\"}."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:168
msgid ""
"@item\n"
"The tab character is not permitted (unless you quote it with the\n"
"backslash character, as described below), to avoid confusion."
msgstr ""
"@item\n"
"Знак табуляции не допускается (если вы не заключите его в кавычки, как "
"описано ниже),\n"
"чтобы избежать путаницы."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:174
msgid ""
"@item\n"
"The newline character terminates the sequence of arguments, and will\n"
"also terminate a final non-empty argument.  (However, a newline\n"
"following a space will not introduce a final empty-string argument;\n"
"it only terminates the argument list.)"
msgstr ""
"@item\n"
"Знак новой строки завершает последовательность аргументов, а также "
"завершает\n"
"последний не пустой аргумент.  (Однако, новая строка после пробела не будет\n"
"вводить последний аргумент пустой строки; он только завершает список "
"аргументов.)"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:184
msgid ""
"@item\n"
"The backslash character is the escape character.  It escapes backslash,\n"
"space, tab, and newline.  The ANSI C escape sequences like @code{\\n} and\n"
"@code{\\t} are also supported.  These produce argument constituents; the\n"
"two-character combination @code{\\n} doesn't act like a terminating\n"
"newline.  The escape sequence @code{\\@var{NNN}} for exactly three octal\n"
"digits reads as the character whose ASCII code is @var{NNN}.  As above,\n"
"characters produced this way are argument constituents.  Backslash\n"
"followed by other characters is not allowed."
msgstr ""
"@item\n"
"Знак обратной косой черты являлется экранирующим(escape) символьным знаком.\n"
"Он экранирует обратную косую черту, пробел, знак табуляции и новой строки.\n"
"Экранирующий последовательности ANSI C такие как @code{\\n} и\n"
"@code{\\t} также поддерживаются.  Они дают составляющие аргументов; "
"комбинация\n"
"из двух знаков @code{\\n} не действует как завершающий перевод строки.  \n"
"Экранируемая последовательность @code{\\@var{NNN}} для ровно трех "
"восмеричных\n"
"цифр читает символ с ASCII кодом равным @var{NNN}.  Как и выше,\n"
"знаковый символ созданный таким образом является составляющим аргумента. "
"Обратная\n"
"косая черта, за которой следуют другие знаки не допускается."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:186
msgctxt "/home/bear/work/guile/doc/guile/en/scheme-scripts.texi:186"
msgid "@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:190
msgid ""
"@node Command Line Handling\n"
"@subsection Command Line Handling"
msgstr ""
"@node Command Line Handling\n"
"@subsection Обработка командной строки"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:192
msgid "@c This section was written and contributed by Martin Grabmueller."
msgstr "@c This section was written and contributed by Martin Grabmueller."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:200
msgid ""
"The ability to accept and handle command line arguments is very\n"
"important when writing Guile scripts to solve particular problems, such\n"
"as extracting information from text files or interfacing with existing\n"
"command line applications.  This chapter describes how Guile makes\n"
"command line arguments available to a Guile script, and the utilities\n"
"that Guile provides to help with the processing of command line\n"
"arguments."
msgstr ""
"Способность принимать и обрабатывать аргументы командной строки очень важна\n"
"при написании скриптов Guile для решения определенных задач, таких как "
"извлечение\n"
"информации из текстовых файлов или взаимодействие с существующими "
"приложениями\n"
"командной строки.  Эта глава описывает, как Guile делает аргументы "
"командной\n"
"строки доступными для скрипта Guile, и утилит которые Guile предоставляет в\n"
"помощь в обработке аргументов командной строки."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:204
msgid ""
"When a Guile script is invoked, Guile makes the command line arguments\n"
"accessible via the procedure @code{command-line}, which returns the\n"
"arguments as a list of strings."
msgstr ""
"Когда вызывается скрипт Guile, Guile делает аргументы командной строки "
"доступными\n"
"через процедуру @code{command-line}, которая возвращает аргументы в виде "
"списка строк."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:206
msgid "For example, if the script"
msgstr "Например, если скрипт"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:213
msgid ""
"@example\n"
"#! /usr/local/bin/guile -s\n"
"!#\n"
"(write (command-line))\n"
"(newline)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:218
msgid ""
"@noindent\n"
"is saved in a file @file{cmdline-test.scm} and invoked using the command\n"
"line @code{./cmdline-test.scm bar.txt -o foo -frumple grob}, the output\n"
"is"
msgstr ""
"@noindent\n"
"сохранить в файл @file{cmdline-test.scm} и вызывать используя командную "
"строку\n"
"@code{./cmdline-test.scm bar.txt -o foo -frumple grob}, вывод будет"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:222
msgid ""
"@example\n"
"(\"./cmdline-test.scm\" \"bar.txt\" \"-o\" \"foo\" \"-frumple\" \"grob\")\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:229
msgid ""
"If the script invocation includes a @code{-e} option, specifying a\n"
"procedure to call after loading the script, Guile will call that\n"
"procedure with @code{(command-line)} as its argument.  So a script that\n"
"uses @code{-e} doesn't need to refer explicitly to @code{command-line}\n"
"in its code.  For example, the script above would have identical\n"
"behaviour if it was written instead like this:"
msgstr ""
"Если вызов скрипта включает опцию @code{-e}, он указывает процедуру\n"
"вызываемую после загрузки скрипта, Guile вызовет эту процедуру с\n"
"@code{(command-line)} в качестве аргументов.  Итак, скрипту при "
"исползовании\n"
"@code{-e} нет необходимости явно ссылаться на @code{command-line}\n"
"в своем коде.  Например, скрипт выше будет иметь идентичное поведение, если "
"он\n"
"будет написан так:"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:238
msgid ""
"@example\n"
"#! /usr/local/bin/guile \\\n"
"-e main -s\n"
"!#\n"
"(define (main args)\n"
"  (write args)\n"
"  (newline))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:241
msgid ""
"(Note the use of the meta switch @code{\\} so that the script invocation\n"
"can include more than one Guile option: @xref{The Meta Switch}.)"
msgstr ""
"(Обратите внимание на использование мета переключателя @code{\\} чтоыб "
"вызов\n"
"скрипта мог включать более одной опции Guile: @xref{The Meta Switch}.)"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:247
msgid ""
"These scripts use the @code{#!} POSIX convention so that they can be\n"
"executed using their own file names directly, as in the example command\n"
"line @code{./cmdline-test.scm bar.txt -o foo -frumple grob}.  But they\n"
"can also be executed by typing out the implied Guile command line in\n"
"full, as in:"
msgstr ""
"Эти скрипты испольуют @code{#!} соглашение POSIX, чтобы они могли быть "
"выполнены\n"
"с использованием их собственного имени файла напрямую, как в примере "
"командной\n"
"строки @code{./cmdline-test.scm bar.txt -o foo -frumple grob}.  Но он также "
"может\n"
"быть выполнен, напечатав подразумеваемую командную строку  Guile полностью, "
"как в:"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:251
msgid ""
"@example\n"
"$ guile -s ./cmdline-test.scm bar.txt -o foo -frumple grob\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:254
msgid ""
"@noindent\n"
"or"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:258
msgid ""
"@example\n"
"$ guile -e main -s ./cmdline-test2.scm bar.txt -o foo -frumple grob\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:264
msgid ""
"Even when a script is invoked using this longer form, the arguments that\n"
"the script receives are the same as if it had been invoked using the\n"
"short form.  Guile ensures that the @code{(command-line)} or @code{-e}\n"
"arguments are independent of how the script is invoked, by stripping off\n"
"the arguments that Guile itself processes."
msgstr ""
"Даже когда сценарий вызывается с использованием этой более длинной формы,\n"
"аргументы этого скрипта получаются так же, как если бы они были вызваны\n"
"с использованием краткой формы.  Guile гарантирует, что @code{(command-"
"line)}\n"
"или аргументы  @code{-e} не зависят от того, как вызывается скрипт, путем\n"
"удаления аргументов, которые Guile обрабатывает сам."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:271
msgid ""
"A script is free to parse and handle its command line arguments in any\n"
"way that it chooses.  Where the set of possible options and arguments is\n"
"complex, however, it can get tricky to extract all the options, check\n"
"the validity of given arguments, and so on.  This task can be greatly\n"
"simplified by taking advantage of the module @code{(ice-9 getopt-long)},\n"
"which is distributed with Guile, @xref{getopt-long}."
msgstr ""
"Скрипт может анализировать и обрабатывать аргументы командной строки\n"
"любым способом, какой он выберет. Там где набор возможных опций и "
"аргументов\n"
"сложен, он может получить  сложное извлечение всех опций, проверить "
"правильность\n"
"задания аргументов и так далее. Эта задача может быть значительно упрощена\n"
"использованием модуля @code{(ice-9 getopt-long)},\n"
"который распространяется вместе с Guile, @xref{getopt-long}."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:275
msgid ""
"@node Scripting Examples\n"
"@subsection Scripting Examples"
msgstr ""
"@node Scripting Examples\n"
"@subsection Примеры Скриптов"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:277
msgid "To start with, here are some examples of invoking Guile directly:"
msgstr "Для начала приведем несколько примеров прямого вызова Guile:"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:279
msgid "@table @code"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:283
msgid ""
"@item guile -- a b c\n"
"Run Guile interactively; @code{(command-line)} will return @*\n"
"@code{(\"/usr/local/bin/guile\" \"a\" \"b\" \"c\")}."
msgstr ""
"@item guile -- a b c\n"
"Запуск Guile в интерактивном режиме; @code{(command-line)} должен вернуть "
"@*\n"
"@code{(\"/usr/local/bin/guile\" \"a\" \"b\" \"c\")}."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:287
msgid ""
"@item guile -s /u/jimb/ex2 a b c\n"
"Load the file @file{/u/jimb/ex2}; @code{(command-line)} will return @*\n"
"@code{(\"/u/jimb/ex2\" \"a\" \"b\" \"c\")}."
msgstr ""
"@item guile -s /u/jimb/ex2 a b c\n"
"Загрузить файл @file{/u/jimb/ex2}; @code{(command-line)} должен вернуть @*\n"
"@code{(\"/u/jimb/ex2\" \"a\" \"b\" \"c\")}."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:291
msgid ""
"@item guile -c '(write %load-path) (newline)'\n"
"Write the value of the variable @code{%load-path}, print a newline,\n"
"and exit."
msgstr ""
"@item guile -c '(write %load-path) (newline)'\n"
"Записывает значение переменной @code{%load-path}, печатает новую строку и "
"выходит."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:295
msgid ""
"@item guile -e main -s /u/jimb/ex4 foo\n"
"Load the file @file{/u/jimb/ex4}, and then call the function\n"
"@code{main}, passing it the list @code{(\"/u/jimb/ex4\" \"foo\")}."
msgstr ""
"@item guile -e main -s /u/jimb/ex4 foo\n"
"Загружает файл @file{/u/jimb/ex4}, и затем вызвает функцию\n"
"@code{main}, передавая в нее список @code{(\"/u/jimb/ex4\" \"foo\")}."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:300
msgid ""
"@item guile -e '(ex4)' -s /u/jimb/ex4.scm foo\n"
"Load the file @file{/u/jimb/ex4.scm}, and then call the function\n"
"@code{main} from the module '(ex4)', passing it the list\n"
"@code{(\"/u/jimb/ex4\" \"foo\")}."
msgstr ""
"@item guile -e '(ex4)' -s /u/jimb/ex4.scm foo\n"
"Загружает файл @file{/u/jimb/ex4.scm}, и затем вызывает функцию\n"
"@code{main} из модуля '(ex4)', передавая в нее список\n"
"@code{(\"/u/jimb/ex4\" \"foo\")}."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:305
msgid ""
"@item guile -l first -ds -l last -s script\n"
"Load the files @file{first}, @file{script}, and @file{last}, in that\n"
"order.  The @code{-ds} switch says when to process the @code{-s}\n"
"switch.  For a more motivated example, see the scripts below."
msgstr ""
"@item guile -l first -ds -l last -s script\n"
"Загружает файлы @file{first}, @file{script}, и @file{last}, в указанном "
"порядке.\n"
"Переключатель @code{-ds} говорит когда обрабатывать ключ the @code{-s}.\n"
"Для более мотивированного примера, смотри скрипты ниже."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:307
msgid "@end table"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:325
msgid ""
"Here is a very simple Guile script:\n"
"@example\n"
"#!/usr/local/bin/guile -s\n"
"!#\n"
"(display \"Hello, world!\")\n"
"(newline)\n"
"@end example\n"
"The first line marks the file as a Guile script.  When the user invokes\n"
"it, the system runs @file{/usr/local/bin/guile} to interpret the script,\n"
"passing @code{-s}, the script's filename, and any arguments given to the\n"
"script as command-line arguments.  When Guile sees @code{-s\n"
"@var{script}}, it loads @var{script}.  Thus, running this program\n"
"produces the output:\n"
"@example\n"
"Hello, world!\n"
"@end example"
msgstr ""
"Вот очень простой скрипт Guile:\n"
"@example\n"
"#!/usr/local/bin/guile -s\n"
"!#\n"
"(display \"Hello, world!\")\n"
"(newline)\n"
"@end example\n"
"Первая строка помечает файл как скрипт Guile.  Когда пользователь вызывает "
"его\n"
"система запускает интерпретатор скрипта @file{/usr/local/bin/guile} "
"передавая ему\n"
"параметры @code{-s}, с именем файла, и любые другие аргументы переданные "
"сценарию\n"
"в качестве аргументов командной строки.  Когда Guile видит @code{-s\n"
"@var{script}}, он загружает  @var{script}.  Таким образом, запуск этой "
"программы\n"
"приводит к выводу:\n"
"@example\n"
"Hello, world!\n"
"@end example"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:333
msgid ""
"Here is a script which prints the factorial of its argument:\n"
"@example\n"
"#!/usr/local/bin/guile -s\n"
"!#\n"
"(define (fact n)\n"
"  (if (zero? n) 1\n"
"    (* n (fact (- n 1)))))"
msgstr ""
"Вот скрипт, который печатает факториал своего аргумента:\n"
"@example\n"
"#!/usr/local/bin/guile -s\n"
"!#\n"
"(define (fact n)\n"
"  (if (zero? n) 1\n"
"    (* n (fact (- n 1)))))"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:343
msgid ""
"(display (fact (string->number (cadr (command-line)))))\n"
"(newline)\n"
"@end example\n"
"In action:\n"
"@example\n"
"$ ./fact 5\n"
"120\n"
"$\n"
"@end example"
msgstr ""
"(display (fact (string->number (cadr (command-line)))))\n"
"(newline)\n"
"@end example\n"
"В действии:\n"
"@example\n"
"$ ./fact 5\n"
"120\n"
"$\n"
"@end example"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:349
msgid ""
"However, suppose we want to use the definition of @code{fact} in this\n"
"file from another script.  We can't simply @code{load} the script file,\n"
"and then use @code{fact}'s definition, because the script will try to\n"
"compute and display a factorial when we load it.  To avoid this problem,\n"
"we might write the script this way:"
msgstr ""
"Однако, предположим, что мы хотим использовать определение @code{fact} в "
"этом\n"
"файле из другого скрипта.  Мы не можем просто загрузить(@code{load}) файл "
"сценария, а затем \n"
"использовать определение @code{fact}, потому что сценарий попытается "
"вычислить и отобразить\n"
"факториал, когда мы его загрузим. Чтобы избежать этой проблемы мы могли бы "
"написать скрипт\n"
"так:"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:357
msgid ""
"@example\n"
"#!/usr/local/bin/guile \\\n"
"-e main -s\n"
"!#\n"
"(define (fact n)\n"
"  (if (zero? n) 1\n"
"    (* n (fact (- n 1)))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:371
msgid ""
"(define (main args)\n"
"  (display (fact (string->number (cadr args))))\n"
"  (newline))\n"
"@end example\n"
"This version packages the actions the script should perform in a\n"
"function, @code{main}.  This allows us to load the file purely for its\n"
"definitions, without any extraneous computation taking place.  Then we\n"
"used the meta switch @code{\\} and the entry point switch @code{-e} to\n"
"tell Guile to call @code{main} after loading the script.\n"
"@example\n"
"$ ./fact 50\n"
"30414093201713378043612608166064768844377641568960512000000000000\n"
"@end example"
msgstr ""
"(define (main args)\n"
"  (display (fact (string->number (cadr args))))\n"
"  (newline))\n"
"@end example\n"
"Эта версия упаковывает действия, которые должен выполнять скрипт в функцию\n"
" @code{main}.  Это позволяет нам загружать файл исключительно ради его\n"
"определений, без выполнения каких либо посторонних вычислений.  Для чего\n"
"мы исползжуем метаперключатель @code{\\} и переключатель указывающий точку\n"
"входа @code{-e}, чтобы сообщить Guile что нужно вызвать @code{main} после\n"
"загрузки.\n"
"@example\n"
"$ ./fact 50\n"
"30414093201713378043612608166064768844377641568960512000000000000\n"
"@end example"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:377
msgid ""
"Suppose that we now want to write a script which computes the\n"
"@code{choose} function: given a set of @var{m} distinct objects,\n"
"@code{(choose @var{n} @var{m})} is the number of distinct subsets\n"
"containing @var{n} objects each.  It's easy to write @code{choose} given\n"
"@code{fact}, so we might write the script this way:"
msgstr ""
"Предположим, что теперь мы хотим написать скрипт, который вычисляет функцию\n"
"@code{choose}: давая множество @var{m} различных объектов,\n"
"@code{(choose @var{n} @var{m})} это число различных подмножеств содержащих\n"
" @var{n} объектов каждое.  Это просто написать @code{choose} используя "
"данное\n"
"определение @code{fact}, поэтому мы можем написать скрипт следующим образом:"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:384
msgid ""
"@example\n"
"#!/usr/local/bin/guile \\\n"
"-l fact -e main -s\n"
"!#\n"
"(define (choose n m)\n"
"  (/ (fact m) (* (fact (- m n)) (fact n))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:391
msgctxt "/home/bear/work/guile/doc/guile/en/scheme-scripts.texi:391"
msgid ""
"(define (main args)\n"
"  (let ((n (string->number (cadr args)))\n"
"        (m (string->number (caddr args))))\n"
"    (display (choose n m))\n"
"    (newline)))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:410
msgid ""
"The command-line arguments here tell Guile to first load the file\n"
"@file{fact}, and then run the script, with @code{main} as the entry\n"
"point.  In other words, the @code{choose} script can use definitions\n"
"made in the @code{fact} script.  Here are some sample runs:\n"
"@example\n"
"$ ./choose 0 4\n"
"1\n"
"$ ./choose 1 4\n"
"4\n"
"$ ./choose 2 4\n"
"6\n"
"$ ./choose 3 4\n"
"4\n"
"$ ./choose 4 4\n"
"1\n"
"$ ./choose 50 100\n"
"100891344545564193334812497256\n"
"@end example"
msgstr ""
"Аргументы командной строки здесь говорят Guile сначала загрузить файл\n"
"@file{fact}, и затем запустить сценарийt, с точкой входа в @code{main}.\n"
"Другими словами, скрипт @code{choose} может использовать определения в \n"
"скрипте @code{fact}.  Вот примеры некоторых запусков:\n"
"@example\n"
"$ ./choose 0 4\n"
"1\n"
"$ ./choose 1 4\n"
"4\n"
"$ ./choose 2 4\n"
"6\n"
"$ ./choose 3 4\n"
"4\n"
"$ ./choose 4 4\n"
"1\n"
"$ ./choose 50 100\n"
"100891344545564193334812497256\n"
"@end example"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:413
msgid ""
"To call a specific procedure from a given module, we can use the special\n"
"form @code{(@@ (@var{module}) @var{procedure})}:"
msgstr ""
"Чтобы вызвать определенную процедуру из данного модуля, мы можем "
"использовать специальную\n"
"форму @code{(@@ (@var{module}) @var{procedure})}:"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:420
msgid ""
"@example\n"
"#!/usr/local/bin/guile \\\n"
"-l fact -e (@@ (fac) main) -s\n"
"!#\n"
"(define-module (fac)\n"
"  #:export (main))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:423
msgctxt "/home/bear/work/guile/doc/guile/en/scheme-scripts.texi:423"
msgid ""
"(define (choose n m)\n"
"  (/ (fact m) (* (fact (- m n)) (fact n))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:430
msgctxt "/home/bear/work/guile/doc/guile/en/scheme-scripts.texi:430"
msgid ""
"(define (main args)\n"
"  (let ((n (string->number (cadr args)))\n"
"        (m (string->number (caddr args))))\n"
"    (display (choose n m))\n"
"    (newline)))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:434
msgid ""
"We can use @code{@@@@} to invoke non-exported procedures.  For exported\n"
"procedures, we can simplify this call with the shorthand\n"
"@code{(@var{module})}:"
msgstr ""
"Мы можем использовать @code{@@@@} для вызова неэкспортируемых процедур.  "
"Для\n"
"экспортируемых процедур, мы можем упростить этот вызов с помощью сокращения\n"
"@code{(@var{module})}:"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:441
msgid ""
"@example\n"
"#!/usr/local/bin/guile \\\n"
"-l fact -e (fac) -s\n"
"!#\n"
"(define-module (fac)\n"
"  #:export (main))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:444
msgctxt "/home/bear/work/guile/doc/guile/en/scheme-scripts.texi:444"
msgid ""
"(define (choose n m)\n"
"  (/ (fact m) (* (fact (- m n)) (fact n))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:451
msgctxt "/home/bear/work/guile/doc/guile/en/scheme-scripts.texi:451"
msgid ""
"(define (main args)\n"
"  (let ((n (string->number (cadr args)))\n"
"        (m (string->number (caddr args))))\n"
"    (display (choose n m))\n"
"    (newline)))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:455
msgid ""
"For maximum portability, we can instead use the shell to execute\n"
"@command{guile} with specified command line arguments.  Here we need to\n"
"take care to quote the command arguments correctly:"
msgstr ""
"Для максимальной переносимости, мы можем вместо этого использовать оболочку\n"
"для выполнения @command{guile} с указанными аргументами командной строки.\n"
"Здесь нужно позаботиться о правильном квотировании аргументов команды:"

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:462
msgid ""
"@example\n"
"#!/usr/bin/env sh\n"
"exec guile -l fact -e '(@@ (fac) main)' -s \"$0\" \"$@@\"\n"
"!#\n"
"(define-module (fac)\n"
"  #:export (main))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:465
msgctxt "/home/bear/work/guile/doc/guile/en/scheme-scripts.texi:465"
msgid ""
"(define (choose n m)\n"
"  (/ (fact m) (* (fact (- m n)) (fact n))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:472
msgctxt "/home/bear/work/guile/doc/guile/en/scheme-scripts.texi:472"
msgid ""
"(define (main args)\n"
"  (let ((n (string->number (cadr args)))\n"
"        (m (string->number (caddr args))))\n"
"    (display (choose n m))\n"
"    (newline)))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:476
msgid ""
"Finally, seasoned scripters are probably missing a mention of\n"
"subprocesses.  In Bash, for example, most shell scripts run other\n"
"programs like @code{sed} or the like to do the actual work."
msgstr ""
"Наконец, опытные сценаристы, вероятно упускают упоминание о подпроцессах.\n"
"В Bash, например, большинство сценариев оболочки запускают другие программы, "
"такие\n"
"как  @code{sed} или ему подобные для выполнения реальной работы."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:483
msgid ""
"In Guile it's often possible get everything done within Guile itself, so\n"
"do give that a try first.  But if you just need to run a program and\n"
"wait for it to finish, use @code{system*}.  If you need to run a\n"
"sub-program and capture its output, or give it input, use\n"
"@code{open-pipe}.  @xref{Processes}, and @xref{Pipes}, for more\n"
"information."
msgstr ""
"В Guile часто можно сделать все внутри самого Guile, так что пробуйте\n"
"первое.  Но если вам просто необходимо запустить программу и дождаться\n"
"ее завершения, используйте  @code{system*}.  Если вам необходимо запустить\n"
"подпрограмму и захватить ее выходные данные или вывести их, используйте\n"
"@code{open-pipe}.  @xref{Processes}, и @xref{Pipes}, для получения "
"подробной\n"
"информации."

#: /home/bear/work/guile/doc/guile/en/scheme-scripts.texi:487
msgid ""
"@c Local Variables:\n"
"@c TeX-master: \"guile.texi\"\n"
"@c End:"
msgstr ""
