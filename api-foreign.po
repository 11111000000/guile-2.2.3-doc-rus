#
# NuINu <don't@send.my>, 2018.
#
#. extracted from /home/bear/work/guile/doc/guile/en/api-foreign.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-07 12:36+0300\n"
"PO-Revision-Date: 2018-12-07 07:56+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C)  1996, 1997, 2000-2004, 2007-2014, 2016-2017\n"
"@c   Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:11
msgid ""
"@node Foreign Function Interface\n"
"@section Foreign Function Interface\n"
"@cindex foreign function interface\n"
"@cindex ffi"
msgstr ""
"@node Foreign Function Interface\n"
"@section Интерфейс Внешних Функций\n"
"@cindex foreign function interface\n"
"@cindex ffi"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:15
msgid ""
"The more one hacks in Scheme, the more one realizes that there are\n"
"actually two computational worlds: one which is warm and alive, that\n"
"land of parentheses, and one cold and dead, the land of C and its ilk."
msgstr ""
"Чем больше хакеров в Scheme, тем больше осознается, что на самом деле\n"
"существуют два мира вычислений: один теплый и живой, это мир круглых\n"
"скобок и один холодный и мертвый, это мир Си и ему подобный."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:21
msgid ""
"But yet we as programmers live in both worlds, and Guile itself is half\n"
"implemented in C. So it is that Guile's living half pays respect to its\n"
"dead counterpart, via a spectrum of interfaces to C ranging from dynamic\n"
"loading of Scheme primitives to dynamic binding of stock C library\n"
"procedures."
msgstr ""
"Но все же мы, как программисты живем в обоих мирах, а сам Guile частично\n"
"реализован на Си. Таким образом живая половина Guile платит дань уважения к\n"
"ее мертвой половине, через спектр интерфейсов к Си, начиная от динамической\n"
"загрузки примитивов Scheme до динамического связывания библиотечных Си "
"процедур."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:30
msgid ""
"@menu\n"
"* Foreign Libraries::           Dynamically linking to libraries.\n"
"* Foreign Functions::           Simple calls to C procedures.\n"
"* C Extensions::                Extending Guile in C with loadable modules.\n"
"* Modules and Extensions::      Loading C extensions into modules.\n"
"* Foreign Pointers::            Accessing global variables.\n"
"* Dynamic FFI::                 Calling arbitrary C functions.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:34
msgid ""
"@node Foreign Libraries\n"
"@subsection Foreign Libraries"
msgstr ""
"@node Foreign Libraries\n"
"@subsection Внешние Библиотеки"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:41
msgid ""
"Most modern Unices have something called @dfn{shared libraries}.  This\n"
"ordinarily means that they have the capability to share the executable\n"
"image of a library between several running programs to save memory and\n"
"disk space.  But generally, shared libraries give a lot of additional\n"
"flexibility compared to the traditional static libraries.  In fact,\n"
"calling them `dynamic' libraries is as correct as calling them `shared'."
msgstr ""
"У большинства современных Юниксов есть что-то, что называется разделяемыми\n"
"библиотеками(@dfn{shared libraries}).  Это обычно означает, что они имеют\n"
"возможность совместно использовать исполняемый образ библиотеки между "
"несколькими\n"
"запущенными программами для экономии памяти и дискового пространства. Но как "
"правило,\n"
"разделяемые(общие) библиотеки  дают большую дополнительную гибкость по "
"сравнению\n"
"с традиционными статическими библиотеками.  Фактически, название их\n"
"динмаическими(`dynamic') библиотеками так же корректно, как и название их "
"общими(`shared')."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:52
msgid ""
"Shared libraries really give you a lot of flexibility in addition to the\n"
"memory and disk space savings.  When you link a program against a shared\n"
"library, that library is not closely incorporated into the final\n"
"executable.  Instead, the executable of your program only contains\n"
"enough information to find the needed shared libraries when the program\n"
"is actually run.  Only then, when the program is starting, is the final\n"
"step of the linking process performed.  This means that you need not\n"
"recompile all programs when you install a new, only slightly modified\n"
"version of a shared library.  The programs will pick up the changes\n"
"automatically the next time they are run."
msgstr ""
"Разделяемые библиотеки действительно дают вам большую гибкость в дополнении\n"
"к экономии памяти и пространства диска. Когда вы связываете программу с\n"
"разделяемой библиотекой, эта библиотека не жестко включается в "
"окончательный\n"
"исполняемый файл. Вместо этого исполняемый файл вашей программы содержит "
"только\n"
"необходимую информацию для поиска необходимых разделяемых библиотек "
"необходимых\n"
"для запуска вашей программы. Только тогда, когда программа запускается, "
"происходит\n"
"последний шаг процесса связвания. Это означает, что вам не нужно "
"перекомпилировать все\n"
"программы при установке новой, только слегка изменной версии разделяемой "
"библиотеки.\n"
"Программы автоматически получат изменения при следующем запуске."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:64
msgid ""
"Now, when all the necessary machinery is there to perform part of the\n"
"linking at run-time, why not take the next step and allow the programmer\n"
"to explicitly take advantage of it from within their program?  Of course,\n"
"many operating systems that support shared libraries do just that, and\n"
"chances are that Guile will allow you to access this feature from within\n"
"your Scheme programs.  As you might have guessed already, this feature\n"
"is called @dfn{dynamic linking}.@footnote{Some people also refer to the\n"
"final linking stage at program startup as `dynamic linking', so if you\n"
"want to make yourself perfectly clear, it is probably best to use the\n"
"more technical term @dfn{dlopening}, as suggested by Gordon Matzigkeit\n"
"in his libtool documentation.}"
msgstr ""
"Теперь, когда все необходимое для машины должно выполнять часть связывания\n"
"во время выполнения, почему бы не сделать следующий шаг и позволить "
"программисту\n"
"явно воспользоваться преимуществами этого в рамках своей программы? Конечно, "
"многие\n"
"операционные системы поддерживающие разделяемые библиотеки делают именно "
"это, и\n"
"скорее всего, Guile позволит вам получить доступ к этой функции из ваших "
"программ\n"
"Scheme.  Как вы уже догадались эта функция называется динамическое "
"связывание(@dfn{dynamic linking}).\n"
"@footnote{Некоторые люди также ссылаются на конечный этап компоновки при "
"запуске\n"
"программы как на `динамическое связывание', поэтому если вы хотите "
"прояснить\n"
"этот вопрос окончательно, вероятно лучше использовать более технический "
"термин\n"
" @dfn{dlopening}, как было предложено Gordon Matzigkeit\n"
"в его документации по libtool.}"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:69
msgid ""
"We titled this section ``foreign libraries'' because although the name\n"
"``foreign'' doesn't leak into the API, the world of C really is foreign\n"
"to Scheme -- and that estrangement extends to components of foreign\n"
"libraries as well, as we see in future sections."
msgstr ""
"Мы назвали этот разде Внешние библиотеки(``foreign libraries''), потому что, "
"хотя\n"
"название Внешние(``foreign'') не является утечкой в API, мир Си "
"действительно внешний\n"
"по отношению к Scheme -- и это отчуждение распространяется и на компоненты "
"внешних \n"
"библиотек, как мы увидим в следующих разделах."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:77
msgid ""
"@deffn {Scheme Procedure} dynamic-link [library]\n"
"@deffnx {C Function} scm_dynamic_link (library)\n"
"Find the shared library denoted by @var{library} (a string) and link it\n"
"into the running Guile application.  When everything works out, return a\n"
"Scheme object suitable for representing the linked object file.\n"
"Otherwise an error is thrown.  How object files are searched is system\n"
"dependent."
msgstr ""
"@deffn {Scheme Procedure} dynamic-link [library]\n"
"@deffnx {C Function} scm_dynamic_link (library)\n"
"Ищет разделяемую библиотеку, указанную @var{library} (строка) и связывает\n"
"ее с текущим выполняемым приложением Guile.  Когда все сработает, "
"возвращает\n"
"объект Scheme подходящий для представления связванного объектного файла.\n"
"В противном случае возникает ошибка. Как объектные файлы ищутся зависит\n"
"от системы."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:81
msgid ""
"Normally, @var{library} is just the name of some shared library file\n"
"that will be searched for in the places where shared libraries usually\n"
"reside, such as in @file{/usr/lib} and @file{/usr/local/lib}."
msgstr ""
"Обычно, @var{library} это просто имя файла разделяемой библиотеки, которую\n"
"нужно искать в местах, где обычно находятся разделяемые библиотеки, "
"например\n"
"в @file{/usr/lib} и @file{/usr/local/lib}."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:87
msgid ""
"@var{library} should not contain an extension such as @code{.so}.  The\n"
"correct file name extension for the host operating system is provided\n"
"automatically, according to libltdl's rules (@pxref{Libltdl interface,\n"
"lt_dlopenext, @code{lt_dlopenext}, libtool, Shared Library Support for\n"
"GNU})."
msgstr ""
"@var{library} не должна содержать расширений, таких как @code{.so}.  "
"Правильное\n"
"расширение имени файла предоставляется автоматически в зависимости от "
"операционной\n"
"системы хоста, в соответствии с правилами libltdl (см. @pxref{Libltdl "
"interface,\n"
"lt_dlopenext, @code{lt_dlopenext}, libtool, Поддержка разделяемых библиотек "
"для\n"
"GNU})."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:92
msgid ""
"When @var{library} is omitted, a @dfn{global symbol handle} is returned.  "
"This\n"
"handle provides access to the symbols available to the program at run-time,\n"
"including those exported by the program itself and the shared libraries "
"already\n"
"loaded."
msgstr ""
"Когда @var{library} пропущено, возвращается хендл/дескриптор(ручка, а по "
"существу указатель)\n"
"глобальных символов@dfn{global symbol handle}.  Этот дескриптор обеспечивает "
"доступ к\n"
"символам, доступным программе во время выполнения, включая экспортированные "
"самой\n"
"программой и уже загруженные разделяемые библиотеки."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:98
msgid ""
"Note that on hosts that use dynamic-link libraries (DLLs), the global\n"
"symbol handle may not be able to provide access to symbols from\n"
"recursively-loaded DLLs.  Only exported symbols from those DLLs directly\n"
"loaded by the program may be available.\n"
"@end deffn"
msgstr ""
"Обратите внимание, что на машине(хосте) использующем динамически "
"загружаемые(компонуемые)\n"
"библиотеки(DLLs), дескриптор глобальных символов возможно не сможет "
"обеспечить доступк\n"
"к символам из рекурсивно загружаемых библиотек DLL.  Только экспортируемые "
"символы из этих\n"
"DLL, непосредственно загружаемых программой, могут быть доступны.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:104
msgid ""
"@deffn {Scheme Procedure} dynamic-object? obj\n"
"@deffnx {C Function} scm_dynamic_object_p (obj)\n"
"Return @code{#t} if @var{obj} is a dynamic library handle, or @code{#f}\n"
"otherwise.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} dynamic-object? obj\n"
"@deffnx {C Function} scm_dynamic_object_p (obj)\n"
"Возвращает @code{#t} если @var{obj} является дескриптором/хендлом "
"динамической библиотеки или @code{#f}\n"
"в противном случае.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:112
msgid ""
"@deffn {Scheme Procedure} dynamic-unlink dobj\n"
"@deffnx {C Function} scm_dynamic_unlink (dobj)\n"
"Unlink the indicated object file from the application.  The\n"
"argument @var{dobj} must have been obtained by a call to\n"
"@code{dynamic-link}.  After @code{dynamic-unlink} has been\n"
"called on @var{dobj}, its content is no longer accessible.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} dynamic-unlink dobj\n"
"@deffnx {C Function} scm_dynamic_unlink (dobj)\n"
"Unlink указывает файловый объект отключен от приложения. Аргумент\n"
"@var{dobj} должен быть получен путем вызова @code{dynamic-link}. \n"
"После вызова @code{dynamic-unlink} содержимое @var{dobj} \n"
"больше не доступно.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:121
msgid ""
"@smallexample\n"
"(define libgl-obj (dynamic-link \"libGL\"))\n"
"libgl-obj\n"
"@result{} #<dynamic-object \"libGL\">\n"
"(dynamic-unlink libGL-obj)\n"
"libGL-obj\n"
"@result{} #<dynamic-object \"libGL\" (unlinked)>\n"
"@end smallexample"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:127
msgid ""
"As you can see, after calling @code{dynamic-unlink} on a dynamically\n"
"linked library, it is marked as @samp{(unlinked)} and you are no longer\n"
"able to use it with @code{dynamic-call}, etc.  Whether the library is\n"
"really removed from you program is system-dependent and will generally\n"
"not happen when some other parts of your program still use it."
msgstr ""
"Как вы можете видеть, после вызова @code{dynamic-unlink} с динамически\n"
"связанной библиотекой, она помечается как отсоединенная(@samp{(unlinked)}) "
"и\n"
"вы больше не можете использовать ее с @code{dynamic-call}, и т.д. "
"Независимо\n"
"от того, действительно ли библиотека удалена из вашей программы в "
"зависимости\n"
"от системы и как правило ничего не произойдет, когда некоторые другие части "
"вашей\n"
"программы все еще используют ее."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:130
msgid ""
"When dynamic linking is disabled or not supported on your system,\n"
"the above functions throw errors, but they are still available."
msgstr ""
"Когда динамическое связывание не доступно или не поддерживается вашей "
"системой,\n"
"вышеуказанные функции выбрасывают ошибки(исключения), но они все еще "
"доступны."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:134
msgid ""
"@node Foreign Functions\n"
"@subsection Foreign Functions"
msgstr ""
"@node Foreign Functions\n"
"@subsection Внешние Функции"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:138
msgid ""
"The most natural thing to do with a dynamic library is to grovel around\n"
"in it for a function pointer: a @dfn{foreign function}.\n"
"@code{dynamic-func} exists for that purpose."
msgstr ""
"Самое естественное что можно сделать с динамической библиотекой это\n"
"найти в ней(взять из нее) указатель на функцию: внешнюю функцию(@dfn{foreign "
"function}).\n"
"Для этой цели служит функция @code{dynamic-func} ."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:144
msgid ""
"@deffn {Scheme Procedure} dynamic-func name dobj\n"
"@deffnx {C Function} scm_dynamic_func (name, dobj)\n"
"Return a ``handle'' for the func @var{name} in the shared object referred "
"to\n"
"by @var{dobj}. The handle can be passed to @code{dynamic-call} to\n"
"actually call the function."
msgstr ""
"@deffn {Scheme Procedure} dynamic-func name dobj\n"
"@deffnx {C Function} scm_dynamic_func (name, dobj)\n"
"Возвращает дескриптор(``handle'') для функции с именем @var{name} в "
"разделяемом объекте\n"
"на который ссылается @var{dobj}. Дескриптор может быть передан @code{dynamic-"
"call} для\n"
"фактического вызова функции."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:149
msgctxt "/home/bear/work/guile/doc/guile/en/api-foreign.texi:149"
msgid ""
"Regardless whether your C compiler prepends an underscore @samp{_} to the "
"global\n"
"names in a program, you should @strong{not} include this underscore in\n"
"@var{name} since it will be added automatically when necessary.\n"
"@end deffn"
msgstr ""
"Независимо от того, добавляет ли ваш Си компилятор символ подчеркивания "
"@samp{_} к глобальным\n"
"именам в программе, вы @strong{не} должны включать это подчеркивание в имя, "
"так как оно будет\n"
"автоматически добавлено в @var{name} при необходимости.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:152
msgid ""
"Guile has static support for calling functions with no arguments,\n"
"@code{dynamic-call}."
msgstr ""
"Guile имеет статическую поддержку для вызовов функций без аргументов,\n"
"@code{dynamic-call}."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:165
msgid ""
"@deffn {Scheme Procedure} dynamic-call func dobj\n"
"@deffnx {C Function} scm_dynamic_call (func, dobj)\n"
"Call the C function indicated by @var{func} and @var{dobj}.\n"
"The function is passed no arguments and its return value is\n"
"ignored.  When @var{function} is something returned by\n"
"@code{dynamic-func}, call that function and ignore @var{dobj}.\n"
"When @var{func} is a string , look it up in @var{dynobj}; this\n"
"is equivalent to\n"
"@smallexample\n"
"(dynamic-call (dynamic-func @var{func} @var{dobj}) #f)\n"
"@end smallexample\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} dynamic-call func dobj\n"
"@deffnx {C Function} scm_dynamic_call (func, dobj)\n"
"Вызывает Си функцию указанную @var{func} и @var{dobj}.\n"
"Функции не передаются аргументы и возвращаемое ей значение игнорируется.\n"
"Когда @var{function} возвращается как результат @code{dynamic-func}, "
"вызовите\n"
"эту функцию и игнорируйте @var{dobj}.\n"
"Когда @var{func} является строкой, она ищет дескриптор функции в "
"@var{dynobj}; этот вызов\n"
"эквивалентен коду\n"
"@smallexample\n"
"(dynamic-call (dynamic-func @var{func} @var{dobj}) #f)\n"
"@end smallexample\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:178
msgid ""
"@code{dynamic-call} is not very powerful. It is mostly intended to be\n"
"used for calling specially written initialization functions that will\n"
"then add new primitives to Guile. For example, we do not expect that you\n"
"will dynamically link @file{libX11} with @code{dynamic-link} and then\n"
"construct a beautiful graphical user interface just by using\n"
"@code{dynamic-call}. Instead, the usual way would be to write a special\n"
"Guile-to-X11 glue library that has intimate knowledge about both Guile\n"
"and X11 and does whatever is necessary to make them inter-operate\n"
"smoothly. This glue library could then be dynamically linked into a\n"
"vanilla Guile interpreter and activated by calling its initialization\n"
"function. That function would add all the new types and primitives to\n"
"the Guile interpreter that it has to offer."
msgstr ""
"@code{dynamic-call} не очень мощная функция. Она в основном предназначена\n"
"для использования специально написанных инициализирующих фунций, которые\n"
"затем добавят новые примитивы в Guile. Например, мы не ожидаем что вы\n"
"будете динамически связывать @file{libX11} используя @code{dynamic-link},\n"
"а затем строить красивый графический интерфейс пользователя, используя\n"
"@code{dynamic-call}. Вместо этого, обычным способом было бы написать\n"
"спициальную библиотеку склеивающую Guile-с-X11, имеющую глубокие знания\n"
"как о Guile, так и о X11 и делающую все, что необходимо для обеспечения их\n"
"взаимодействия.\n"
"Затем эту склеивающую библиотеку можно было бы динамически связать с чистым\n"
"интерпретатором Guile и активировать ее вызовом функции инициализации.\n"
"Эта функция добаит все новые типы и примитивы к интерпретатору Guile, всё\n"
"что она может предложить."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:182
msgid ""
"(There is actually another, better option: simply to create a\n"
"@file{libX11} wrapper in Scheme via the dynamic FFI. @xref{Dynamic FFI},\n"
"for more information.)"
msgstr ""
"(Здесь предлагается другой, лучший способ: просто создать обертку\n"
"@file{libX11} в Scheme используя динамический FFI. см. @xref{Dynamic FFI},\n"
"дополнительную информацию.)"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:187
msgid ""
"Given some set of C extensions to Guile, the next logical step is to\n"
"integrate these glue libraries into the module system of Guile so that\n"
"you can load new primitives into a running system just as you can load\n"
"new Scheme code."
msgstr ""
"Учитывая некоторый набор Си расширений для Guile, следующим логическим "
"шагом\n"
"является интеграция этих склеивающих библиотек в модульную систему Guile, "
"чтобы\n"
"вы могли загружать новые примитивы во время выполнения системы, также как "
"вы\n"
"можете загрузить новый код Scheme."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:193
msgid ""
"@deffn {Scheme Procedure} load-extension lib init\n"
"@deffnx {C Function} scm_load_extension (lib, init)\n"
"Load and initialize the extension designated by LIB and INIT.\n"
"When there is no pre-registered function for LIB/INIT, this is\n"
"equivalent to"
msgstr ""
"@deffn {Scheme Procedure} load-extension lib init\n"
"@deffnx {C Function} scm_load_extension (lib, init)\n"
"Загружает и инициализирует расширение указанное LIB и INIT.\n"
"Когда нет предварительно зарегистрированной функции для LIB/INIT, это\n"
"эквивалентно"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:197
msgid ""
"@lisp\n"
"(dynamic-call INIT (dynamic-link LIB))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:200
msgid ""
"When there is a pre-registered function, that function is called\n"
"instead."
msgstr ""
"Когда есть предварительно зарегистрированная функция, это функция вызывается "
"вместо\n"
"указанной(?)."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:206
msgid ""
"Normally, there is no pre-registered function.  This option exists\n"
"only for situations where dynamic linking is unavailable or unwanted.\n"
"In that case, you would statically link your program with the desired\n"
"library, and register its init function right after Guile has been\n"
"initialized."
msgstr ""
"Обычно, нет предварительно зарегистрированной функции. Этот вариант "
"существует\n"
"только для ситуаций где динамическая компоновка недоступна или "
"нежелательна.\n"
"В этом случае вы статически связываете свою программу с нужной библиотекой "
"и\n"
"зарегистрируете ее функуию инициализации(init) сразу после инициализации "
"Guile."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:214
msgid ""
"As for @code{dynamic-link}, @var{lib} should not contain any suffix such\n"
"as @code{.so} (@pxref{Foreign Libraries, dynamic-link}).  It\n"
"should also not contain any directory components.  Libraries that\n"
"implement Guile Extensions should be put into the normal locations for\n"
"shared libraries.  We recommend to use the naming convention\n"
"@file{libguile-bla-blum} for a extension related to a module @code{(bla\n"
"blum)}."
msgstr ""
"Что касается @code{dynamic-link}, @var{lib} не должен содержать никакого\n"
"суффикса, такого как @code{.so} (@pxref{Foreign Libraries, dynamic-link}).\n"
"Он также не должен содержать компонетов каталога. Библиотеки которые\n"
"реализуют Расширения Guile должны быть помещены в обычные места для "
"разделяемых\n"
"библиотек. Мы рекомендуем использовать соглашение об именах\n"
"@file{libguile-bla-blum} для расширения связанного с модулем @code{(bla\n"
"blum)}."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:219
msgid ""
"The normal way for a extension to be used is to write a small Scheme\n"
"file that defines a module, and to load the extension into this\n"
"module.  When the module is auto-loaded, the extension is loaded as\n"
"well.  For example,"
msgstr ""
"Обычным способом использования расширения является написание небольшого\n"
"файла Scheme который определяет модуль и загружает расширение в этот "
"модуль.\n"
"Когда модуль загружается автоматически, загружается и расширение. Например,"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:222
msgid ""
"@lisp\n"
"(define-module (bla blum))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:226
msgid ""
"(load-extension \"libguile-bla-blum\" \"bla_init_blum\")\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:229
msgid ""
"@node C Extensions\n"
"@subsection C Extensions"
msgstr ""
"@node C Extensions\n"
"@subsection Си Расширения"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:235
msgid ""
"The most interesting application of dynamically linked libraries is\n"
"probably to use them for providing @emph{compiled code modules} to\n"
"Scheme programs.  As much fun as programming in Scheme is, every now and\n"
"then comes the need to write some low-level C stuff to make Scheme even\n"
"more fun."
msgstr ""
"Наиболее интересным применением динамически связываемых библиотек вероятно\n"
"является их использование для предоставления скомпилированных модулей "
"кода(@emph{compiled code modules})\n"
"для программ Scheme.  Программирование на Scheme является очень веселым, но "
"время от времени\n"
"возникает потребоность написать некоторый низко уровневый Си код, чтобы "
"сделать программирование\n"
"на  Scheme еще веселей."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:240
msgid ""
"Not only can you put these new primitives into their own module (see the\n"
"previous section), you can even put them into a shared library that is\n"
"only then linked to your running Guile image when it is actually\n"
"needed."
msgstr ""
"Вы можете не только добавить эти новые примитивы в свой собственный модуль\n"
"(см. предыдущий раздел), вы можете даже поместить их в разделяемую "
"библиотеку, \n"
"которая подсоединяется к запущеному образу Guile только тогда, когда она\n"
"действительно необходима."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:248
msgid ""
"An example will hopefully make everything clear.  Suppose we want to\n"
"make the Bessel functions of the C library available to Scheme in the\n"
"module @samp{(math bessel)}.  First we need to write the appropriate\n"
"glue code to convert the arguments and return values of the functions\n"
"from Scheme to C and back.  Additionally, we need a function that will\n"
"add them to the set of Guile primitives.  Because this is just an\n"
"example, we will only implement this for the @code{j0} function."
msgstr ""
"Пример, надеюсь, все разяснит.  Предположим, мы хотим чтобы сделать "
"доступной\n"
"функцию Бесселя(Bessel) библиотеки Си для Scheme в модуле @samp{(math "
"bessel)}.\n"
"Первое что нам необходимо сделать это написать соответствющий код клея,\n"
"чтобы преобразовать аргументы и возвращаемые значения функций от\n"
"Scheme в Си и обратно.  Кроме того, нам нужна функция которая добавит\n"
"их к набору примитивов Guile.  Поскольку это всего лишь пример, мы будем\n"
"реализовывать его лишь для функции @code{j0}."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:252
msgid ""
"@smallexample\n"
"#include <math.h>\n"
"#include <libguile.h>"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:258
msgid ""
"SCM\n"
"j0_wrapper (SCM x)\n"
"@{\n"
"  return scm_from_double (j0 (scm_to_double (x, \"j0\")));\n"
"@}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:265
msgid ""
"void\n"
"init_math_bessel ()\n"
"@{\n"
"  scm_c_define_gsubr (\"j0\", 1, 0, 0, j0_wrapper);\n"
"@}\n"
"@end smallexample"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:271
msgid ""
"We can already try to bring this into action by manually calling the low\n"
"level functions for performing dynamic linking.  The C source file needs\n"
"to be compiled into a shared library.  Here is how to do it on\n"
"GNU/Linux, please refer to the @code{libtool} documentation for how to\n"
"create dynamically linkable libraries portably."
msgstr ""
"Мы уже можем попытаться привести это в действие, вручную вызвав функции\n"
"низкого уровня для выполнения динамического связвания. Исходный файл Си\n"
"должен быть скомпилирован в разделяемую библиотеку. Вот как это делается\n"
"в GNU/Linux, пожалуйста обратитесь к документации по @code{libtool} для "
"того\n"
"чтоыбы узнать как создавать переносимые динамически связываемые библиотеки."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:275
msgid ""
"@smallexample\n"
"gcc -shared -o libbessel.so -fPIC bessel.c\n"
"@end smallexample"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:277
msgid "Now fire up Guile:"
msgstr "Теперь запустите Guile:"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:284
msgid ""
"@lisp\n"
"(define bessel-lib (dynamic-link \"./libbessel.so\"))\n"
"(dynamic-call \"init_math_bessel\" bessel-lib)\n"
"(j0 2)\n"
"@result{} 0.223890779141236\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:292
msgid ""
"The filename @file{./libbessel.so} should be pointing to the shared\n"
"library produced with the @code{gcc} command above, of course.  The\n"
"second line of the Guile interaction will call the\n"
"@code{init_math_bessel} function which in turn will register the C\n"
"function @code{j0_wrapper} with the Guile interpreter under the name\n"
"@code{j0}.  This function becomes immediately available and we can call\n"
"it from Scheme."
msgstr ""
"Имя файла @file{./libbessel.so} должно указывать на разделяемую библиотеку\n"
"созданную с помощью команды @code{gcc} выше, конечно.  Вторая строка\n"
"взаимодействия с Guile вызовет функцию @code{init_math_bessel} которая в\n"
"свою очередь зарегистрирует Си функцию @code{j0_wrapper} в интерпретаторе "
"Guile\n"
"под именем @code{j0}.  Эта функция становиться сразу доступной и мы можем "
"вызвать\n"
"ее из Scheme."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:295
msgid ""
"Fun, isn't it?  But we are only half way there.  This is what\n"
"@code{apropos} has to say about @code{j0}:"
msgstr ""
"Всело, не так ли?  Но мы только на полпути. Это то, что,\n"
"@code{apropos} говорит о @code{j0}:"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:300
msgid ""
"@smallexample\n"
"(apropos \"j0\")\n"
"@print{} (guile-user): j0     #<primitive-procedure j0>\n"
"@end smallexample"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:305
msgid ""
"As you can see, @code{j0} is contained in the root module, where all\n"
"the other Guile primitives like @code{display}, etc live.  In general,\n"
"a primitive is put into whatever module is the @dfn{current module} at\n"
"the time @code{scm_c_define_gsubr} is called."
msgstr ""
"Как вы можете видеть, @code{j0} содержиться в корневом модуле, где и все\n"
"остальные примитивы Guile, такие как @code{display}, и т.д.  В общем,\n"
"примитив помещается в любой модуль являющийся текущим(@dfn{current module})\n"
"в момент вызова @code{scm_c_define_gsubr}."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:311
msgid ""
"A compiled module should have a specially named @dfn{module init\n"
"function}.  Guile knows about this special name and will call that\n"
"function automatically after having linked in the shared library.  For\n"
"our example, we replace @code{init_math_bessel} with the following code in\n"
"@file{bessel.c}:"
msgstr ""
"Скомпилированный модуль должен иметь специально именованную функцию "
"инициализации\n"
"(@dfn{module init function}.  Guile знает об этом специальном имени и "
"вызовет эту\n"
"функцию автоматически после связывания(linked) с разделяемой библиотекой.  В "
"нашем\n"
"примере, мы заменим @code{init_math_bessel} следующим кодом в\n"
"@file{bessel.c}:"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:319
msgid ""
"@smallexample\n"
"void\n"
"init_math_bessel (void *unused)\n"
"@{\n"
"  scm_c_define_gsubr (\"j0\", 1, 0, 0, j0_wrapper);\n"
"  scm_c_export (\"j0\", NULL);\n"
"@}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:326
msgid ""
"void\n"
"scm_init_math_bessel_module ()\n"
"@{\n"
"  scm_c_define_module (\"math bessel\", init_math_bessel, NULL);   \n"
"@}\n"
"@end smallexample"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:331
msgid ""
"The general pattern for the name of a module init function is:\n"
"@samp{scm_init_}, followed by the name of the module where the\n"
"individual hierarchical components are concatenated with underscores,\n"
"followed by @samp{_module}."
msgstr ""
"Общий шаблон для имени функции инициализации модуля является:\n"
"@samp{scm_init_}, затем имя модуля, в котором отдельные иерархические\n"
"компоненты объединяются символами подчеркивания,\n"
"а затем следует @samp{_module}."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:334
msgid ""
"After @file{libbessel.so} has been rebuilt, we need to place the shared\n"
"library into the right place."
msgstr ""
"После того как @file{libbessel.so} будет перестроен, нам нужно поместить "
"разделяемую\n"
"библиотеку в нужное место."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:337
msgid ""
"Once the module has been correctly installed, it should be possible to\n"
"use it like this:"
msgstr ""
"Как только модуль будет правильно установлен, его можно будет использовать "
"следующим\n"
"образом:"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:346
msgid ""
"@smallexample\n"
"guile> (load-extension \"./libbessel.so\" \"scm_init_math_bessel_module\")\n"
"guile> (use-modules (math bessel))\n"
"guile> (j0 2)\n"
"0.223890779141236\n"
"guile> (apropos \"j0\")\n"
"@print{} (math bessel): j0      #<primitive-procedure j0>\n"
"@end smallexample"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:348
msgid "That's it!"
msgstr "Это то что надо!"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:352
msgid ""
"@node Modules and Extensions\n"
"@subsection Modules and Extensions"
msgstr ""
"@node Modules and Extensions\n"
"@subsection Модули и Расширения"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:359
msgid ""
"The new primitives that you add to Guile with @code{scm_c_define_gsubr}\n"
"(@pxref{Primitive Procedures}) or with any of the other mechanisms are\n"
"placed into the module that is current when the\n"
"@code{scm_c_define_gsubr} is executed. Extensions loaded from the REPL,\n"
"for example, will be placed into the @code{(guile-user)} module, if the\n"
"REPL module was not changed."
msgstr ""
"Новые примитивы которые вы добавляете в Guile с помощью "
"@code{scm_c_define_gsubr}\n"
"(@pxref{Primitive Procedures}) или используя любые другие механизмы, "
"помещаются\n"
"в модуль, являющийся текущим на момент выполнения\n"
"@code{scm_c_define_gsubr}. Например, расширения, загруженные из REPL,\n"
"будут помещены в модуль @code{(guile-user)}, если модуль\n"
"REPL не был изменен."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:361
msgid "To define C primitives within a specific module, the simplest way is:"
msgstr ""
"Чтобы определить примитивы Си в определенном модуле, самый простой способ:"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:366
msgid ""
"@example\n"
"(define-module (foo bar))\n"
"(load-extension \"foobar-c-code\" \"foo_bar_init\")\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:374
msgid ""
"@cindex extensiondir\n"
"When loaded with @code{(use-modules (foo bar))}, the\n"
"@code{load-extension} call looks for the @file{foobar-c-code.so} (etc)\n"
"object file in Guile's @code{extensiondir}, which is usually a\n"
"subdirectory of the @code{libdir}. For example, if your libdir is\n"
"@file{/usr/lib}, the @code{extensiondir} for the Guile @value{EFFECTIVE-"
"VERSION}.@var{x}\n"
"series will be @file{/usr/lib/guile/@value{EFFECTIVE-VERSION}/}."
msgstr ""
"@cindex extensiondir\n"
"При загрузке с помощью @code{(use-modules (foo bar))}, вызов\n"
"@code{load-extension} ищет файл разделяемой библиотеки @file{foobar-c-code."
"so} (etc)\n"
"в директории расширений Guile @code{extensiondir}, который обычно является "
"подкаталогом\n"
"из @code{libdir}. Например, если ваш libdir это\n"
"@file{/usr/lib}, то директория для расширений @code{extensiondir} для  Guile "
"@value{EFFECTIVE-VERSION}.@var{x}\n"
"версии @file{/usr/lib/guile/@value{EFFECTIVE-VERSION}/}."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:379
msgid ""
"The extension path includes the major and minor version of Guile (the\n"
"``effective version''), because Guile guarantees compatibility within a\n"
"given effective version. This allows you to install different versions\n"
"of the same extension for different versions of Guile."
msgstr ""
"Путь к расширениям включает основную и второстепенную версии Guile (\n"
"т.е. эффективную версию/``effective version''), поскольку Guile гарантирует "
"совместимость\n"
"в рамках эффективной версии. Это дает вам возможность инсталировать "
"различные версии\n"
"одного и того же расширения для разных версий Guile."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:385
msgid ""
"If the extension is not found in the @code{extensiondir}, Guile will\n"
"also search the standard system locations, such as @file{/usr/lib} or\n"
"@file{/usr/local/lib}. It is preferable, however, to keep your extension\n"
"out of the system library path, to prevent unintended interference with\n"
"other dynamically-linked C libraries."
msgstr ""
"Если расширение не найдено в  @code{extensiondir}, Guile также будет\n"
"искать его в стандартных местах размещения библиотек, таких как @file{/usr/"
"lib}\n"
"или @file{/usr/local/lib}. Однако предпочтительно убрать ваше расширение от "
"туда,\n"
"чтобы предотвратить непреднамеренное вмешательство в другие динамически "
"связываемые\n"
"библиотеки Си."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:391
msgid ""
"If someone installs your module to a non-standard location then the\n"
"object file won't be found.  You can address this by inserting the\n"
"install location in the @file{foo/bar.scm} file.  This is convenient\n"
"for the user and also guarantees the intended object is read, even if\n"
"stray older or newer versions are in the loader's path."
msgstr ""
"Если кто-то устанавливает ваш модуль в нестандартное местоположение, тогда "
"ваш\n"
"объектный файл не будет найден. Вы можете решить эту проблему добавив место\n"
"установки в файл @file{foo/bar.scm}.  Это удобно для пользователя, а также "
"гарантирует,\n"
"что предполагаемый объект прочтется, даже если старые или более новые версии "
"находятся\n"
"в пути загрузки."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:399
msgid ""
"The usual way to specify an install location is with a @code{prefix}\n"
"at the configure stage, for instance @samp{./configure prefix=/opt}\n"
"results in library files as say @file{/opt/lib/foobar-c-code.so}.\n"
"When using Autoconf (@pxref{Top, , Introduction, autoconf, The GNU\n"
"Autoconf Manual}), the library location is in a @code{libdir}\n"
"variable.  Its value is intended to be expanded by @command{make}, and\n"
"can by substituted into a source file like @file{foo.scm.in}"
msgstr ""
"Обычный способ указать место установки с префиксом(@code{prefix})\n"
"на этапе конфигурации(configure), для команды @samp{./configure prefix=/"
"opt}\n"
"результирующие библиотечные файлы будут размещены: @file{/opt/lib/foobar-c-"
"code.so}.\n"
"При использовании Autoconf (@pxref{Top, , Introduction, autoconf, The GNU\n"
"Autoconf Manual}), расположение библиотеки находиться в переменной "
"@code{libdir}.\n"
"Его значение предполагается видно в команде @command{make}, и\n"
"может быть подставлено в исходный файл, например @file{foo.scm.in}"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:404
msgid ""
"@example\n"
"(define-module (foo bar))\n"
"(load-extension \"XXextensiondirXX/foobar-c-code\" \"foo_bar_init\")\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:408
msgid ""
"@noindent\n"
"with the following in a @file{Makefile}, using @command{sed}\n"
"(@pxref{Top, , Introduction, sed, SED, A Stream Editor}),"
msgstr ""
"@noindent\n"
"в следующем файле @file{Makefile}, используется команда @command{sed}\n"
"(@pxref{Top, , Introduction, sed, SED, A Stream Editor}),"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:413
msgid ""
"@example\n"
"foo.scm: foo.scm.in\n"
"        sed 's|XXextensiondirXX|$(libdir)/guile/@value{EFFECTIVE-VERSION}|' "
"<foo.scm.in >foo.scm\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:418
msgid ""
"The actual pattern @code{XXextensiondirXX} is arbitrary, it's only "
"something\n"
"which doesn't otherwise occur.  If several modules need the value, it\n"
"can be easier to create one @file{foo/config.scm} with a define of the\n"
"@code{extensiondir} location, and use that as required."
msgstr ""
"Фактический шаблон @code{XXextensiondirXX} выбран произвольно, лишь бы "
"небыло\n"
"совпадений с другими выражениями в файле. Если несколько модулей нуждаются "
"в\n"
"значении, его может быть проще создать в файле @file{foo/config.scm} "
"определяющием\n"
"местоположение @code{extensiondir} и используемым по мере необходимости."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:423
msgid ""
"@example\n"
"(define-module (foo config))\n"
"(define-public foo-config-extensiondir \"XXextensiondirXX\"\")\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:428
msgid ""
"Such a file might have other locations too, for instance a data\n"
"directory for auxiliary files, or @code{localedir} if the module has\n"
"its own @code{gettext} message catalogue\n"
"(@pxref{Internationalization})."
msgstr ""
"Такой файл может содержать и другие местоположения, например каталог\n"
"для вспомогательных файлов данных, или @code{localedir} если имеет свой\n"
"собственный каталог сообщений @code{gettext}, см "
"(@pxref{Internationalization})."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:435
msgid ""
"It will be noted all of the above requires that the Scheme code to be\n"
"found in @code{%load-path} (@pxref{Load Paths}).  Presently it's left up\n"
"to the system administrator or each user to augment that path when\n"
"installing Guile modules in non-default locations.  But having reached\n"
"the Scheme code, that code should take care of hitting any of its own\n"
"private files etc."
msgstr ""
"Следует отметить, что все вышеперечисленное требует, чтобы код Scheme был\n"
"найден в пути загрузки @code{%load-path} (@pxref{Load Paths}).  В настоящее\n"
"время он задается системным администратором или каждым пользователем "
"отдельно\n"
"когда модули Guile устанавливаются в нестандартные места.  Но достигнув "
"кода\n"
"Scheme, уже этот код должен заботитсья о том, чтобы найти любой из своих "
"файлов\n"
"и т.д."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:439
msgid ""
"@node Foreign Pointers\n"
"@subsection Foreign Pointers"
msgstr ""
"@node Foreign Pointers\n"
"@subsection Внешние Указатели"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:445
msgid ""
"The previous sections have shown how Guile can be extended at runtime by\n"
"loading compiled C extensions. This approach is all well and good, but\n"
"wouldn't it be nice if we didn't have to write any C at all? This\n"
"section takes up the problem of accessing C values from Scheme, and the\n"
"next discusses C functions."
msgstr ""
"В предыдущих разделах показано, как Guile может быть расширен во время\n"
"выполнения загрузкой скомпилированных Си расширений. Этот подход всегда\n"
"хорош, но было бы неплохо, если бы у нас небыло необходимости вообще писать\n"
"на Си? В этом разделе рассматривается проблема доступа к значениям Си из\n"
"Scheme, а в следующей обсуждаются Си функции."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:452
msgid ""
"@menu\n"
"* Foreign Types::                  Expressing C types in Scheme.\n"
"* Foreign Variables::              Pointers to C symbols.\n"
"* Void Pointers and Byte Access::  Pointers into the ether.\n"
"* Foreign Structs::                Packing and unpacking structs.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:455
msgid ""
"@node Foreign Types\n"
"@subsubsection Foreign Types"
msgstr ""
"@node Foreign Types\n"
"@subsubsection Внешние Типы"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:459
msgid ""
"The first impedance mismatch that one sees between C and Scheme is that\n"
"in C, the storage locations (variables) are typed, but in Scheme types\n"
"are associated with values, not variables. @xref{Values and Variables}."
msgstr ""
"Первое несоответствие, которое наблюдается между Си и Scheme заключается\n"
"в том, что в Си расположение хранилищ(переменные) является типизированным, "
"но\n"
"в Scheme типы связаны со значениями, а не переменными. @xref{Values and "
"Variables}."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:463
msgid ""
"So when describing a C function or a C structure so that it can be\n"
"accessed from Scheme, the data types of the parameters or fields must be\n"
"passed explicitly."
msgstr ""
"Таким образом, при описании функции Си или структуры Си, чтобы к ней можно "
"было\n"
"получить доступ из Scheme, типы данных параметров или полей должны "
"передаваться явно.\n"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:467
msgid ""
"These ``C type values'' may be constructed using the constants and\n"
"procedures from the @code{(system foreign)} module, which may be loaded\n"
"like this:"
msgstr ""
"Эти ``значения типов Си'' могут быть построены с использованием констант и \n"
"процедур из модуля @code{(system foreign)}, который может быть загружен\n"
"следующим образом:"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:471
msgid ""
"@example\n"
"(use-modules (system foreign))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:474
msgid ""
"@code{(system foreign)} exports a number of values expressing the basic\n"
"C types:"
msgstr ""
"@code{(system foreign)} экспортирует ряд значений, выражающих основные\n"
"Си типы:"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:488
msgid ""
"@defvr {Scheme Variable} int8\n"
"@defvrx {Scheme Variable} uint8\n"
"@defvrx {Scheme Variable} uint16\n"
"@defvrx {Scheme Variable} int16\n"
"@defvrx {Scheme Variable} uint32\n"
"@defvrx {Scheme Variable} int32\n"
"@defvrx {Scheme Variable} uint64\n"
"@defvrx {Scheme Variable} int64\n"
"@defvrx {Scheme Variable} float\n"
"@defvrx {Scheme Variable} double\n"
"These values represent the C numeric types of the specified sizes and\n"
"signednesses.\n"
"@end defvr"
msgstr ""
"@defvr {Scheme Variable} int8\n"
"@defvrx {Scheme Variable} uint8\n"
"@defvrx {Scheme Variable} uint16\n"
"@defvrx {Scheme Variable} int16\n"
"@defvrx {Scheme Variable} uint32\n"
"@defvrx {Scheme Variable} int32\n"
"@defvrx {Scheme Variable} uint64\n"
"@defvrx {Scheme Variable} int64\n"
"@defvrx {Scheme Variable} float\n"
"@defvrx {Scheme Variable} double\n"
"Эти значения представляют собой числовые типы Си указанных размеров и\n"
"типов.\n"
"@end defvr"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:491
msgid ""
"In addition there are some convenience bindings for indicating types of\n"
"platform-dependent size:"
msgstr ""
"Кроме того, есть некоторые удобные привязки для указания типов размер "
"которых зависит\n"
"от платформы:"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:507
msgid ""
"@defvr {Scheme Variable} int\n"
"@defvrx {Scheme Variable} unsigned-int\n"
"@defvrx {Scheme Variable} long\n"
"@defvrx {Scheme Variable} unsigned-long\n"
"@defvrx {Scheme Variable} short\n"
"@defvrx {Scheme Variable} unsigned-short\n"
"@defvrx {Scheme Variable} size_t\n"
"@defvrx {Scheme Variable} ssize_t\n"
"@defvrx {Scheme Variable} ptrdiff_t\n"
"@defvrx {Scheme Variable} intptr_t\n"
"@defvrx {Scheme Variable} uintptr_t\n"
"Values exported by the @code{(system foreign)} module, representing C\n"
"numeric types. For example, @code{long} may be @code{equal?} to\n"
"@code{int64} on a 64-bit platform.\n"
"@end defvr"
msgstr ""
"@defvr {Scheme Variable} int\n"
"@defvrx {Scheme Variable} unsigned-int\n"
"@defvrx {Scheme Variable} long\n"
"@defvrx {Scheme Variable} unsigned-long\n"
"@defvrx {Scheme Variable} short\n"
"@defvrx {Scheme Variable} unsigned-short\n"
"@defvrx {Scheme Variable} size_t\n"
"@defvrx {Scheme Variable} ssize_t\n"
"@defvrx {Scheme Variable} ptrdiff_t\n"
"@defvrx {Scheme Variable} intptr_t\n"
"@defvrx {Scheme Variable} uintptr_t\n"
"Значения, экспортируемые модулем @code{(system foreign)}, представляющие "
"числовые типы \n"
"Си. Например, @code{long} может быть @code{equal?}(равным)\n"
"@code{int64} на 64-битной платформе.\n"
"@end defvr"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:512
msgid ""
"@defvr {Scheme Variable} void\n"
"The @code{void} type.  It can be used as the first argument to\n"
"@code{pointer->procedure} to wrap a C function that returns nothing.\n"
"@end defvr"
msgstr ""
"@defvr {Scheme Variable} void\n"
"Тип @code{void}.  Его можно использовать в качестве первого аргумента для\n"
"@code{pointer->procedure} создающей обертку Си функции которая ничего не\n"
"возвращает.\n"
"@end defvr"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:516
msgid ""
"In addition, the symbol @code{*} is used by convention to denote pointer\n"
"types.  Procedures detailed in the following sections, such as\n"
"@code{pointer->procedure}, accept it as a type descriptor."
msgstr ""
"Кроме того, знак @code{*} используется как условное обозначение\n"
"разименовывающее указатель. Процедуры подробно описаны в следующих разделах, "
"такие\n"
"как @code{pointer->procedure}, принимают его как дескриптор(определитель) "
"типа."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:519
msgid ""
"@node Foreign Variables\n"
"@subsubsection Foreign Variables"
msgstr ""
"@node Foreign Variables\n"
"@subsubsection Внешние Переменные"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:522
msgid ""
"Pointers to variables in the current address space may be looked up\n"
"dynamically using @code{dynamic-pointer}."
msgstr ""
"Указатели на переменные в текущем адресном пространстве можно искать\n"
"динамически используя @code{dynamic-pointer}."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:528
msgid ""
"@deffn {Scheme Procedure} dynamic-pointer name dobj\n"
"@deffnx {C Function} scm_dynamic_pointer (name, dobj)\n"
"Return a ``wrapped pointer'' for the symbol @var{name} in the shared\n"
"object referred to by @var{dobj}.  The returned pointer points to a C\n"
"object."
msgstr ""
"@deffn {Scheme Procedure} dynamic-pointer name dobj\n"
"@deffnx {C Function} scm_dynamic_pointer (name, dobj)\n"
"Возвращает ``обернутый указатель(wrapped pointer)'' для символа @var{name} \n"
"в разделяемом объекте, на который ссылается @var{dobj}.  Возвращаемый "
"указатель\n"
"указывает на объект Си."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:533
msgctxt "/home/bear/work/guile/doc/guile/en/api-foreign.texi:533"
msgid ""
"Regardless whether your C compiler prepends an underscore @samp{_} to the "
"global\n"
"names in a program, you should @strong{not} include this underscore in\n"
"@var{name} since it will be added automatically when necessary.\n"
"@end deffn"
msgstr ""
"Независимо от того, добавляет ли ваш Си компилятор подчеркивание @samp{_} к "
"глобальным\n"
"именам в программе, вы @strong{НЕ} должны включать включать это "
"подчеркивание в \n"
"@var{name}, так как оно будет автоматически добавлено при необходимости.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:537
msgid ""
"For example, currently Guile has a variable, @code{scm_numptob}, as part\n"
"of its API. It is declared as a C @code{long}. So, to create a handle\n"
"pointing to that foreign value, we do:"
msgstr ""
"Например, в настоящее время Guile имеет переменную @code{scm_numptob} как "
"часть\n"
"своего API. Она объявлена в как Си @code{long}. Итак, чтобы создать "
"дескриптор,\n"
"указывающий на это внешнее значени, мы делаем следующее:"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:544
msgid ""
"@example\n"
"(use-modules (system foreign))\n"
"(define numptob (dynamic-pointer \"scm_numptob\" (dynamic-link)))\n"
"numptob\n"
"@result{} #<pointer 0x7fb35b1b4688>\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:546
msgid "(The next section discusses ways to dereference pointers.)"
msgstr ""
"(В следующем разделе рассматривается способ разыменовывания указателей(т.е "
"получения значений).)"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:549
msgid ""
"A value returned by @code{dynamic-pointer} is a Scheme wrapper for a C\n"
"pointer."
msgstr ""
"Значение возвращаемое @code{dynamic-pointer} представляет собой обертку\n"
"(оболочку) в Scheme для указателя Си."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:553
msgid ""
"@deffn {Scheme Procedure} pointer-address pointer\n"
"@deffnx {C Function} scm_pointer_address (pointer)\n"
"Return the numerical value of @var{pointer}."
msgstr ""
"@deffn {Scheme Procedure} pointer-address pointer\n"
"@deffnx {C Function} scm_pointer_address (pointer)\n"
"Возвращает числовое значение указателя @var{pointer}."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:559
msgid ""
"@example\n"
"(pointer-address numptob)\n"
"@result{} 139984413364296 ; YMMV\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:566
msgid ""
"@deffn {Scheme Procedure} make-pointer address [finalizer]\n"
"Return a foreign pointer object pointing to @var{address}.  If\n"
"@var{finalizer} is passed, it should be a pointer to a one-argument C\n"
"function that will be called when the pointer object becomes\n"
"unreachable.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} make-pointer address [finalizer]\n"
"Возвращает объект внешний указатель указывающий на адрес @var{address}.  \n"
"Если финализатор(@var{finalizer}) передан, он должен быть указателем на\n"
"Си функцию с одним аргументом, которая будет вызываться, когда объект\n"
"указатель становится недостижымым в Scheme(вызывается сборщиком мусора/GC).\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:570
msgid ""
"@deffn {Scheme Procedure} pointer? obj\n"
"Return @code{#t} if @var{obj} is a pointer object, @code{#f} otherwise.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} pointer? obj\n"
"Возвращает @code{#t} если @var{obj} является объектом-указателем, @code{#f} "
"в противном случае.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:574
msgid ""
"@defvr {Scheme Variable} %null-pointer\n"
"A foreign pointer whose value is 0.\n"
"@end defvr"
msgstr ""
"@defvr {Scheme Variable} %null-pointer\n"
"Внешний указатель значение которого равно 0.\n"
"@end defvr"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:578
msgid ""
"@deffn {Scheme Procedure} null-pointer? pointer\n"
"Return @code{#t} if @var{pointer} is the null pointer, @code{#f} otherwise.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} null-pointer? pointer\n"
"Возвращает @code{#t} если указатель @var{pointer} является нулевым "
"указателем, @code{#f} в противном случае.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:582
msgid ""
"For the purpose of passing SCM values directly to foreign functions, and\n"
"allowing them to return SCM values, Guile also supports some unsafe\n"
"casting operators."
msgstr ""
"С целью передачи значений SCM непосредственно во внешние функции и\n"
"разрешения им возвращать SCM значения, Guile также поддерживает\n"
"некоторые небезопасные операторы приведения(указания) типов."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:587
msgid ""
"@deffn {Scheme Procedure} scm->pointer scm\n"
"Return a foreign pointer object with the @code{object-address}\n"
"of @var{scm}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} scm->pointer scm\n"
"Возвращает объект внешний указатель с адресом объекта @code{object-address}\n"
"который имеет @var{scm}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:592
msgid ""
"@deffn {Scheme Procedure} pointer->scm pointer\n"
"Unsafely cast @var{pointer} to a Scheme object.\n"
"Cross your fingers!\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} pointer->scm pointer\n"
"Небезопасное преобразование указателя @var{pointer} в объект Scheme.\n"
"Скрестите пальцы!\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:598
msgid ""
"Sometimes you want to give C extensions access to the dynamic FFI.  At\n"
"that point, the names get confusing, because ``pointer'' can refer to a\n"
"@code{SCM} object that wraps a pointer, or to a @code{void*} value.  We\n"
"will try to use ``pointer object'' to refer to Scheme objects, and\n"
"``pointer value'' to refer to @code{void *} values."
msgstr ""
"Иногда ван надо предоставить Си расширениям доступ к динамическому FFI.\n"
"В этот момент имена путаются, поскольку указатель ``pointer'' может "
"ссылаться\n"
"на объект @code{SCM} который оборачивает указатель, или значение "
"@code{void*}.\n"
"Мы попытаемся использовать ``объект-указатель(pointer object)'' для "
"обозначения\n"
"объекта Scheme, и ``значение-указатель(pointer value)'' для обозначения\n"
"значений @code{void *}."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:601
msgid ""
"@deftypefn {C Function} SCM scm_from_pointer (void *ptr, void (*finalizer) "
"(void*))\n"
"Create a pointer object from a pointer value."
msgstr ""
"@deftypefn {C Function} SCM scm_from_pointer (void *ptr, void (*finalizer) "
"(void*))\n"
"Создает объект-указатель из значения указателя(pointer)."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:605
msgid ""
"If @var{finalizer} is non-null, Guile arranges to call it on the pointer\n"
"value at some point after the pointer object becomes collectable.\n"
"@end deftypefn"
msgstr ""
"Если финализатор(@var{finalizer}) не нулевой, Guile организует его вызов по "
"значению\n"
"указателя в некторой точке после того, как объект-указатель станет "
"собираемым(мусором).\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:609
msgid ""
"@deftypefn {C Function} void* scm_to_pointer (SCM obj)\n"
"Unpack the pointer value from a pointer object.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Function} void* scm_to_pointer (SCM obj)\n"
"Распаковывает значение указателя из объекта-указателя.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:612
msgid ""
"@node Void Pointers and Byte Access\n"
"@subsubsection Void Pointers and Byte Access"
msgstr ""
"@node Void Pointers and Byte Access\n"
"@subsubsection Указатели типа Void и Байтовый Доступ"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:619
msgid ""
"Wrapped pointers are untyped, so they are essentially equivalent to C\n"
"@code{void} pointers.  As in C, the memory region pointed to by a\n"
"pointer can be accessed at the byte level.  This is achieved using\n"
"@emph{bytevectors} (@pxref{Bytevectors}).  The @code{(rnrs bytevectors)}\n"
"module contains procedures that can be used to convert byte sequences to\n"
"Scheme objects such as strings, floating point numbers, or integers."
msgstr ""
"Обернутые указатели являются нетипизированными, поэтому они по сущетсву\n"
"эквивалентны Си укзателям на @code{void}. Как и в Си, в Scheme область "
"памяти\n"
"на которую указывает указатель, может быть доступна на уровне байта. Это\n"
"достигается использованием байтовых векторов @emph{bytevectors} "
"(@pxref{Bytevectors}).\n"
"Модуль @code{(rnrs bytevectors)} содержит процедуры, которые могут "
"использоваться для\n"
"преобразования последовательностей байтов в объекты Scheme, такие как "
"строки(string), \n"
"числа с плавающей запятой(floating point) или целые числа(integers)."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:624
msgid ""
"@deffn {Scheme Procedure} pointer->bytevector pointer len [offset "
"[uvec_type]]\n"
"@deffnx {C Function} scm_pointer_to_bytevector (pointer, len, offset, "
"uvec_type)\n"
"Return a bytevector aliasing the @var{len} bytes pointed to by\n"
"@var{pointer}."
msgstr ""
"@deffn {Scheme Procedure} pointer->bytevector pointer len [offset "
"[uvec_type]]\n"
"@deffnx {C Function} scm_pointer_to_bytevector (pointer, len, offset, "
"uvec_type)\n"
"Возвращает байт-вектор(bytevector) наложенный на некоторое число @var{len} "
"байтов\n"
"начинающееся с адреса указываемого @var{pointer}."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:629
msgid ""
"The user may specify an alternate default interpretation for the memory\n"
"by passing the @var{uvec_type} argument, to indicate that the memory is\n"
"an array of elements of that type.  @var{uvec_type} should be something\n"
"that @code{array-type} would return, like @code{f32} or @code{s16}."
msgstr ""
"Пользователь может указать альтернативную имеющейся по умолчанию "
"интерпретацию для\n"
"памяти путем передачи аргумента @var{uvec_type}, чтобы указать, что память "
"представляет\n"
"собой массив элементов этого типа.  @var{uvec_type} должен быть чем-то "
"вроде\n"
"@code{array-type}, например @code{f32} или @code{s16}."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:633
msgid ""
"When @var{offset} is passed, it specifies the offset in bytes relative\n"
"to @var{pointer} of the memory region aliased by the returned\n"
"bytevector."
msgstr ""
"Когда передается смещение( @var{offset} ) оно определяет смещение в байтах "
"относительно\n"
"указателя @var{pointer} на регион памяти возвращаемого констурктором "
"bytevector."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:637
msgid ""
"Mutating the returned bytevector mutates the memory pointed to by\n"
"@var{pointer}, so buckle your seatbelts.\n"
"@end deffn"
msgstr ""
"Изменение возвращаемого bytevector изменяет указываемую @var{pointer} "
"память, поэтому\n"
"пристегите ремни безопасности.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:643
msgid ""
"@deffn {Scheme Procedure} bytevector->pointer bv [offset]\n"
"@deffnx {C Function} scm_bytevector_to_pointer (bv, offset)\n"
"Return a pointer pointer aliasing the memory pointed to by @var{bv} or\n"
"@var{offset} bytes after @var{bv} when @var{offset} is passed.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} bytevector->pointer bv [offset]\n"
"@deffnx {C Function} scm_bytevector_to_pointer (bv, offset)\n"
"Возвращает указатель pointer налагающийся на память, на которую\n"
"указывает @var{bv} или смещение @var{offset} в байтах после @var{bv} \n"
"когда передается @var{offset}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:645
msgid "In addition to these primitives, convenience procedures are available:"
msgstr "В дополнении к этим примитивам, доступны удобные процедуры:"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:650
msgid ""
"@deffn {Scheme Procedure} dereference-pointer pointer\n"
"Assuming @var{pointer} points to a memory region that holds a pointer,\n"
"return this pointer.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} dereference-pointer pointer\n"
"Предполагая что указатель @var{pointer} указывает на область памяти, "
"которая\n"
"содержит указатель, возвращает этот указатель.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:655
msgid ""
"@deffn {Scheme Procedure} string->pointer string [encoding]\n"
"Return a foreign pointer to a nul-terminated copy of @var{string} in the\n"
"given @var{encoding}, defaulting to the current locale encoding.  The C\n"
"string is freed when the returned foreign pointer becomes unreachable."
msgstr ""
"@deffn {Scheme Procedure} string->pointer string [encoding]\n"
"Возвращает внешний указатель на копию строки заканчивающуюся нулем(си "
"строку)\n"
" @var{string} в данной кодировке @var{encoding}, по умолчанию это текущая\n"
"кодировка локали. Си строка освобождается, когда возвращаемый внешний\n"
"указатель становиться недоступным."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:658
msgid ""
"This is the Scheme equivalent of @code{scm_to_stringn}.\n"
"@end deffn"
msgstr ""
"Это Scheme  Это эквивалент вызова @code{scm_to_stringn}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:665
msgid ""
"@deffn {Scheme Procedure} pointer->string pointer [length] [encoding]\n"
"Return the string representing the C string pointed to by @var{pointer}.\n"
"If @var{length} is omitted or @code{-1}, the string is assumed to be\n"
"nul-terminated.  Otherwise @var{length} is the number of bytes in memory\n"
"pointed to by @var{pointer}.  The C string is assumed to be in the given\n"
"@var{encoding}, defaulting to the current locale encoding."
msgstr ""
"@deffn {Scheme Procedure} pointer->string pointer [length] [encoding]\n"
"Возвращает строку, представляющую Си строку, на которую указывает by "
"@var{pointer}.\n"
"Если @var{length} опущена или @code{-1}, предполагается что строка является\n"
"(nul-terminated), т.е оканчивается нулем.  В противном случае @var{length} "
"это количество\n"
"байтов памяти, на которые указывает указатель @var{pointer}.  "
"Предполагается, что Си\n"
"строка находиться в заданной кодировке @var{encoding}, по умолчанию это\n"
"текущая кодировка локали."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:668
msgid ""
"This is the Scheme equivalent of @code{scm_from_stringn}.\n"
"@end deffn"
msgstr ""
"Это Scheme эквивалент функции @code{scm_from_stringn}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:674
msgid ""
"@cindex wrapped pointer types\n"
"Most object-oriented C libraries use pointers to specific data\n"
"structures to identify objects.  It is useful in such cases to reify the\n"
"different pointer types as disjoint Scheme types.  The\n"
"@code{define-wrapped-pointer-type} macro simplifies this."
msgstr ""
"@cindex wrapped pointer types\n"
"Большинство объектно-ориентированных библиотек Си используют укзатели на "
"конкретные\n"
"структуры данных для идентификации объектов. В таких случаях полезно "
"использовать\n"
"различные  типы указателей как непересекающиеся типы Scheme.  Макрос\n"
"@code{define-wrapped-pointer-type} упрощает это."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:678
msgid ""
"@deffn {Scheme Syntax} define-wrapped-pointer-type type-name pred wrap "
"unwrap print\n"
"Define helper procedures to wrap pointer objects into Scheme objects\n"
"with a disjoint type.  Specifically, this macro defines:"
msgstr ""
"@deffn {Scheme Syntax} define-wrapped-pointer-type type-name pred wrap "
"unwrap print\n"
"Определяет вспомогательные процедуры для обертывания указываемых внешних "
"объектов в\n"
"объекты Scheme с помощью непересекающихся типов.  В частности этот макрос "
"определяет:"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:685
msgid ""
"@itemize\n"
"@item @var{pred}, a predicate for the new Scheme type;\n"
"@item @var{wrap}, a procedure that takes a pointer object and returns an\n"
"object that satisfies @var{pred};\n"
"@item @var{unwrap}, which does the reverse.\n"
"@end itemize"
msgstr ""
"@itemize\n"
"@item @var{pred}, предикат для нового типа Scheme;\n"
"@item @var{wrap}, процедуру которая принимает указатель на объект и "
"возвращает\n"
"объект который удовлетворяет @var{pred};\n"
"@item @var{unwrap}, процедуру которая делает обратное @var{wrap} "
"преобразование.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:689
msgid ""
"@var{wrap} preserves pointer identity, for two pointer objects @var{p1}\n"
"and @var{p2} that are @code{equal?}, @code{(eq? (@var{wrap} @var{p1})\n"
"(@var{wrap} @var{p2})) @result{} #t}."
msgstr ""
"@var{wrap} сохраняет идентификацию указателя, для двух объектов указателей "
"@var{p1}\n"
"и @var{p2} которые @code{equal?}, @code{(eq? (@var{wrap} @var{p1})\n"
"(@var{wrap} @var{p2})) @result{} #t}."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:693
msgid ""
"Finally, @var{print} should name a user-defined procedure to print such\n"
"objects.  The procedure is passed the wrapped object and a port to write\n"
"to."
msgstr ""
"Наконец, @var{print} должна именовать(указывать) пользовательскую процедуру "
"для печати\n"
"таких объектов. Процедуре передается обернутый объект и порт для записи."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:697
msgid ""
"For example, assume we are wrapping a C library that defines a type,\n"
"@code{bottle_t}, and functions that can be passed @code{bottle_t *}\n"
"pointers to manipulate them.  We could write:"
msgstr ""
"Например, предположим что мы создаем обертку для библиотеки Си, которая\n"
"определяет тип @code{bottle_t}, и функции которым могут быть переданы\n"
"указатели не этот тип @code{bottle_t *}, чтобы они могли манипулировать им.\n"
"Мы можем записать:"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:706
msgid ""
"@example\n"
"(define-wrapped-pointer-type bottle\n"
"  bottle?\n"
"  wrap-bottle unwrap-bottle\n"
"  (lambda (b p)\n"
"    (format p \"#<bottle of ~a ~x>\"\n"
"            (bottle-contents b)\n"
"            (pointer-address (unwrap-bottle b)))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:715
msgid ""
"(define grab-bottle\n"
"  ;; Wrapper for `bottle_t *grab (void)'.\n"
"  (let ((grab (pointer->procedure '*\n"
"                                  (dynamic-func \"grab_bottle\" libbottle)\n"
"                                  '())))\n"
"    (lambda ()\n"
"      \"Return a new bottle.\"\n"
"      (wrap-bottle (grab)))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:725
msgid ""
"(define bottle-contents\n"
"  ;; Wrapper for `const char *bottle_contents (bottle_t *)'.\n"
"  (let ((contents (pointer->procedure '*\n"
"                                      (dynamic-func \"bottle_contents\"\n"
"                                                     libbottle)\n"
"                                      '(*))))\n"
"    (lambda (b)\n"
"      \"Return the contents of B.\"\n"
"      (pointer->string (contents (unwrap-bottle b))))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:729
msgid ""
"(write (grab-bottle))\n"
"@result{} #<bottle of Ch@^ateau Haut-Brion 803d36>\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:735
msgid ""
"In this example, @code{grab-bottle} is guaranteed to return a genuine\n"
"@code{bottle} object satisfying @code{bottle?}.  Likewise,\n"
"@code{bottle-contents} errors out when its argument is not a genuine\n"
"@code{bottle} object.\n"
"@end deffn"
msgstr ""
"В этом примере, @code{grab-bottle} гарантированно возвращает подлинный\n"
"объект @code{bottle} удовлетворяющий предикату @code{bottle?}.  Аналогичным "
"образом,\n"
"@code{bottle-contents} возвращает ошибку когда ее аргумент не является "
"подлинным\n"
"объектом @code{bottle}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:738
msgid ""
"Going back to the @code{scm_numptob} example above, here is how we can\n"
"read its value as a C @code{long} integer:"
msgstr ""
"Возвращаясь к приведенному выше примеру с @code{scm_numptob}, мы можем "
"прочитать его значение как\n"
"Си длинное целое(@code{long} integer):"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:741
msgctxt "/home/bear/work/guile/doc/guile/en/api-foreign.texi:741"
msgid ""
"@example\n"
"(use-modules (rnrs bytevectors))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:747
msgid ""
"(bytevector-uint-ref (pointer->bytevector numptob (sizeof long))\n"
"                     0 (native-endianness)\n"
"                     (sizeof long))\n"
"@result{} 8\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:754
msgid ""
"If we wanted to corrupt Guile's internal state, we could set\n"
"@code{scm_numptob} to another value; but we shouldn't, because that\n"
"variable is not meant to be set.  Indeed this point applies more widely:\n"
"the C API is a dangerous place to be.  Not only might setting a value\n"
"crash your program, simply accessing the data pointed to by a dangling\n"
"pointer or similar can prove equally disastrous."
msgstr ""
"Если бы мы хотели повредить внутреннее состояние Guile, мы могли бы\n"
"установить @code{scm_numptob} в другое значение; но мы этого делать\n"
"недолжны, потому что эта переменная не предназначена для "
"установки(присваивания).\n"
"Действительно, этот момент применяется широко: Си API является опасным "
"местом.\n"
"Не только установка значения может вызвать крах вашей программы, простой "
"доступ\n"
"к данным, на которые указывает \"висячий\" указатель или аналогичное "
"действие может\n"
"оказаться стольже катастрофическим."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:757
msgid ""
"@node Foreign Structs\n"
"@subsubsection Foreign Structs"
msgstr ""
"@node Foreign Structs\n"
"@subsubsection Внешние Структуры"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:763
msgid ""
"Finally, one last note on foreign values before moving on to actually\n"
"calling foreign functions. Sometimes you need to deal with C structs,\n"
"which requires interpreting each element of the struct according to the\n"
"its type, offset, and alignment. Guile has some primitives to support\n"
"this."
msgstr ""
"Наконец, последнее замечание по внешним значениям, прежде чем перейти\n"
"к фактическим вызвовам внешних функций. Иногда вам приходиться иметь дело\n"
"с Си структурами, что требует итерпретатции каждого элемента структуры в\n"
"соответствии с его типом, смещением и выравниванием. У Guile есть несколько\n"
"примитивова для поддержки этого."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:767
msgid ""
"@deffn {Scheme Procedure} sizeof type\n"
"@deffnx {C Function} scm_sizeof (type)\n"
"Return the size of @var{type}, in bytes."
msgstr ""
"@deffn {Scheme Procedure} sizeof type\n"
"@deffnx {C Function} scm_sizeof (type)\n"
"Возвращает размер @var{type}, в байтах."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:774
msgid ""
"@var{type} should be a valid C type, like @code{int}.\n"
"Alternately @var{type} may be the symbol @code{*}, in which\n"
"case the size of a pointer is returned. @var{type} may\n"
"also be a list of types, in which case the size of a\n"
"@code{struct} with ABI-conventional packing is returned.\n"
"@end deffn"
msgstr ""
"@var{type} должен быть допустимым Си типом, например @code{int}.\n"
"Альтернативным @var{type} может быть символ @code{*}, в этом случае\n"
"возвращается размер указателя. @var{type} также может быть\n"
"списком типов, в этом случае возвращается размер структуры\n"
"@code{struct} с обычной для ABI упаковкой(размещением элементов).\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:778
msgid ""
"@deffn {Scheme Procedure} alignof type\n"
"@deffnx {C Function} scm_alignof (type)\n"
"Return the alignment of @var{type}, in bytes."
msgstr ""
"@deffn {Scheme Procedure} alignof type\n"
"@deffnx {C Function} scm_alignof (type)\n"
"Возвращается выравнивание @var{type}, в байтах."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:785
msgid ""
"@var{type} should be a valid C type, like @code{int}.\n"
"Alternately @var{type} may be the symbol @code{*}, in which\n"
"case the alignment of a pointer is returned. @var{type} may\n"
"also be a list of types, in which case the alignment of a\n"
"@code{struct} with ABI-conventional packing is returned.\n"
"@end deffn"
msgstr ""
"@var{type} должен быть допустимым Си типом, например @code{int}.\n"
"Альтернативным @var{type} может быть символ @code{*}, в этом случае\n"
"возвращается размер указателя. @var{type} также может быть\n"
"списком типов, в этом случае возвращается размер структуры\n"
"@code{struct} с обычной для ABI упаковкой(размещением элементов).\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:788
msgid ""
"Guile also provides some convenience methods to pack and unpack foreign\n"
"pointers wrapping C structs."
msgstr ""
"Guile также предоставляет некоторые удобные методы для упаковки и "
"распаковки\n"
"внешних указателей обертывающих Си структуры."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:792
msgid ""
"@deffn {Scheme Procedure} make-c-struct types vals\n"
"Create a foreign pointer to a C struct containing @var{vals} with types\n"
"@code{types}."
msgstr ""
"@deffn {Scheme Procedure} make-c-struct types vals\n"
"Создает внешний указатель на Си структуру содержащую значения @var{vals} с "
"типами\n"
"@code{types}."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:795
msgid ""
"@var{vals} and @code{types} should be lists of the same length.\n"
"@end deffn"
msgstr ""
"@var{vals} и @code{types} должны быть списками одинаковой длины.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:798
msgid ""
"@deffn {Scheme Procedure} parse-c-struct foreign types\n"
"Parse a foreign pointer to a C struct, returning a list of values."
msgstr ""
"@deffn {Scheme Procedure} parse-c-struct foreign types\n"
"Разбирает внешний указатель на Си структуру, возвращая список значений."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:801
msgid ""
"@code{types} should be a list of C types.\n"
"@end deffn"
msgstr ""
"@code{types} должен быть списком Си типов.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:804
msgid ""
"For example, to create and parse the equivalent of a @code{struct @{\n"
"int64_t a; uint8_t b; @}}:"
msgstr ""
"Например, создадим и разберем эквивалент структуры @code{struct @{\n"
"int64_t a; uint8_t b; @}}:"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:811
msgid ""
"@example\n"
"(parse-c-struct (make-c-struct (list int64 uint8)\n"
"                               (list 300 43))\n"
"                (list int64 uint8))\n"
"@result{} (300 43)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:817
msgid ""
"As yet, Guile only has convenience routines to support\n"
"conventionally-packed structs. But given the @code{bytevector->pointer}\n"
"and @code{pointer->bytevector} routines, one can create and parse\n"
"tightly packed structs and unions by hand. See the code for\n"
"@code{(system foreign)} for details."
msgstr ""
"Пока у Guile есть только удобные процедуры поддержки упакованных структур\n"
"поддерживающих соглашение. Но учитывая процедуры @code{bytevector->pointer}\n"
"и @code{pointer->bytevector}, можно создавать и разбирать плотно "
"упакованные\n"
"структуры и объединения(unions) в ручную. См. код для\n"
"@code{(system foreign)} для ознакомления с деталями."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:821
msgid ""
"@node Dynamic FFI\n"
"@subsection Dynamic FFI"
msgstr ""
"@node Dynamic FFI\n"
"@subsection Динамический FFI"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:824
msgid ""
"Of course, the land of C is not all nouns and no verbs: there are\n"
"functions too, and Guile allows you to call them."
msgstr ""
"Конечно, земля Си это не только существительные и не глаголы: есть также\n"
"функции, и Guile позволяет вам их вызывать."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:829
msgid ""
"@deffn {Scheme Procedure} pointer->procedure return_type func_ptr arg_types "
"@\n"
"                                             [#:return-errno?=#f]\n"
"@deffnx {C Function} scm_pointer_to_procedure (return_type, func_ptr, "
"arg_types)\n"
"@deffnx {C Function} scm_pointer_to_procedure_with_errno (return_type, "
"func_ptr, arg_types)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:831
msgid "Make a foreign function."
msgstr "Создает внешнюю функцию."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:836
msgid ""
"Given the foreign void pointer @var{func_ptr}, its argument and\n"
"return types @var{arg_types} and @var{return_type}, return a\n"
"procedure that will pass arguments to the foreign function\n"
"and return appropriate values."
msgstr ""
"Данный внешний свободный/неопределенный(void) указатель @var{func_ptr}, "
"является ее\n"
"аргументом, как и типы аргументов @var{arg_types} и возвращаемый тип "
"@var{return_type}, \n"
"она возвращает процедуру, которая будет передавать аргументы внешней функции "
"и возвращать\n"
"соответствующее значение."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:840
msgid ""
"@var{arg_types} should be a list of foreign types.\n"
"@code{return_type} should be a foreign type. @xref{Foreign Types}, for\n"
"more information on foreign types."
msgstr ""
"@var{arg_types} должен быть списком внешних типов.\n"
"@code{return_type} должно быть внешним типом. @xref{Foreign Types}, для\n"
"получения дополнительной информации о внешних типах."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:845
msgid ""
"If @var{return-errno?} is true, or when calling\n"
"@code{scm_pointer_to_procedure_with_errno}, the returned procedure will\n"
"return two values, with @code{errno} as the second value.\n"
"@end deffn"
msgstr ""
"Если @var{return-errno?} равно истине, или при вызове\n"
"@code{scm_pointer_to_procedure_with_errno}, возвращается процедура\n"
"возвращающая два значения, вторым значением является\n"
"кодом ошибки @code{errno}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:847
msgid "Here is a better definition of @code{(math bessel)}:"
msgstr "Вот лучшее определение @code{(math bessel)}:"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:852
msgid ""
"@example\n"
"(define-module (math bessel)\n"
"  #:use-module (system foreign)\n"
"  #:export (j0))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:854
msgid "(define libm (dynamic-link \"libm\"))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:860
msgid ""
"(define j0\n"
"  (pointer->procedure double\n"
"                      (dynamic-func \"j0\" libm)\n"
"                      (list double)))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:862
msgid "That's it! No C at all."
msgstr "Вот так! Никаких Си вызовов."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:867
msgid ""
"Numeric arguments and return values from foreign functions are\n"
"represented as Scheme values. For example, @code{j0} in the above\n"
"example takes a Scheme number as its argument, and returns a Scheme\n"
"number."
msgstr ""
"Числовые аргументы и возвращаемые значения из внешних функций представлены\n"
"в виде значений Scheme. Например, @code{j0} в приведенном выше примере "
"принимает\n"
"в качестве аргумента число Scheme в качестве аргумента, и возвращает число\n"
"Scheme."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:872
msgid ""
"Pointers may be passed to and returned from foreign functions as well.\n"
"In that case the type of the argument or return value should be the\n"
"symbol @code{*}, indicating a pointer. For example, the following\n"
"code makes @code{memcpy} available to Scheme:"
msgstr ""
"Указатели могут быть переданы и возвращены из внешних функций.\n"
"В этом случае тип аргумента или возвращаемого значения должен быть\n"
"символом @code{*}, обозначающим указатель. Например, следующий код\n"
"делает функцию @code{memcpy} доступным для Scheme:"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:880
msgid ""
"@example\n"
"(define memcpy\n"
"  (let ((this (dynamic-link)))\n"
"    (pointer->procedure '*\n"
"                        (dynamic-func \"memcpy\" this)\n"
"                        (list '* '* size_t))))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:882
msgid "To invoke @code{memcpy}, one must pass it foreign pointers:"
msgstr "Чтобы вызвать @code{memcpy}, нужно передать ей внешние указатели:"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:885
msgctxt "/home/bear/work/guile/doc/guile/en/api-foreign.texi:885"
msgid ""
"@example\n"
"(use-modules (rnrs bytevectors))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:892
msgid ""
"(define src-bits\n"
"  (u8-list->bytevector '(0 1 2 3 4 5 6 7)))\n"
"(define src\n"
"  (bytevector->pointer src-bits))\n"
"(define dest\n"
"  (bytevector->pointer (make-bytevector 16 0)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:894
msgid "(memcpy dest src (bytevector-length src-bits))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:898
msgid ""
"(bytevector->u8-list (pointer->bytevector dest 16))\n"
"@result{} (0 1 2 3 4 5 6 7 0 0 0 0 0 0 0 0)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:902
msgid ""
"One may also pass structs as values, passing structs as foreign\n"
"pointers. @xref{Foreign Structs}, for more information on how to express\n"
"struct types and struct values."
msgstr ""
"Можно также передавать структуры как значения, передавая структуры как\n"
"внешние указатели. @xref{Foreign Structs}, для получения дальнейшей "
"информации\n"
"о том как выразить структуру через типы и значения элементов структуры."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:905
msgid ""
"``Out'' arguments are passed as foreign pointers. The memory pointed to\n"
"by the foreign pointer is mutated in place."
msgstr ""
"Аргументы ``Out'' передаются как внешние указатели. Памеять на которую "
"указывают\n"
"внешние указатели изменяется на месте(просто изменяется внешней функцией)."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:912
msgid ""
"@example\n"
";; struct timeval @{\n"
";;      time_t      tv_sec;     /* seconds */\n"
";;      suseconds_t tv_usec;    /* microseconds */\n"
";; @};\n"
";; assuming fields are of type \"long\""
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:925
msgid ""
"(define gettimeofday\n"
"  (let ((f (pointer->procedure\n"
"            int\n"
"            (dynamic-func \"gettimeofday\" (dynamic-link))\n"
"            (list '* '*)))\n"
"        (tv-type (list long long)))\n"
"    (lambda ()\n"
"      (let* ((timeval (make-c-struct tv-type (list 0 0)))\n"
"             (ret (f timeval %null-pointer)))\n"
"        (if (zero? ret)\n"
"            (apply values (parse-c-struct timeval tv-type))\n"
"            (error \"gettimeofday returned an error\" ret))))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:930
msgid ""
"(gettimeofday)    \n"
"@result{} 1270587589\n"
"@result{} 499553\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:934
msgid ""
"As you can see, this interface to foreign functions is at a very low,\n"
"somewhat dangerous level@footnote{A contribution to Guile in the form of\n"
"a high-level FFI would be most welcome.}."
msgstr ""
"Как вы можете видеть, этот интерфейс для внешних функций работает но очень\n"
"низком уровне, очень опасном уровне@footnote{Весьма приветствуется вклад в "
"Guile \n"
"в на высоком уровне FFI.}."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:939
msgid ""
"@cindex callbacks\n"
"The FFI can also work in the opposite direction: making Scheme\n"
"procedures callable from C.  This makes it possible to use Scheme\n"
"procedures as ``callbacks'' expected by C function."
msgstr ""
"@cindex callbacks\n"
"FFI также может работать и в обратном направлении: создании процедур Scheme\n"
"вызываемых из Си.  Это позволяет использовать процедуры Scheme как\n"
"``обратные вызовы(callbacks)'', ожидаемые Си функцией."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:948
msgid ""
"@deffn {Scheme Procedure} procedure->pointer return-type proc arg-types\n"
"@deffnx {C Function} scm_procedure_to_pointer (return_type, proc, "
"arg_types)\n"
"Return a pointer to a C function of type @var{return-type}\n"
"taking arguments of types @var{arg-types} (a list) and\n"
"behaving as a proxy to procedure @var{proc}.  Thus\n"
"@var{proc}'s arity, supported argument types, and return\n"
"type should match @var{return-type} and @var{arg-types}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} procedure->pointer return-type proc arg-types\n"
"@deffnx {C Function} scm_procedure_to_pointer (return_type, proc, "
"arg_types)\n"
"Возвращает указатель на функцию Си возвращающую значение типа @var{return-"
"type}\n"
"и принимающую аргументы типов @var{arg-types} (это список) и ведет\n"
"себя как посредник к процедуре @var{proc}.  Таким образом "
"арность(размерность) \n"
"@var{proc} поддерживает типы аргументов @var{arg-types} и возвращает тип "
"который должен соответствовать\n"
"@var{return-type}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:952
msgid ""
"As an example, here's how the C library's @code{qsort} array sorting\n"
"function can be made accessible to Scheme (@pxref{Array Sort Function,\n"
"@code{qsort},, libc, The GNU C Library Reference Manual}):"
msgstr ""
"В качестве примера можно привести функцию сортировки массива @code{qsort} "
"библиотеки Си\n"
"доступной для Scheme (@pxref{Array Sort Function,\n"
"@code{qsort},, libc, The GNU C Library Reference Manual}):"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:973
msgid ""
"@example\n"
"(define qsort!\n"
"  (let ((qsort (pointer->procedure void\n"
"                                   (dynamic-func \"qsort\"\n"
"                                                 (dynamic-link))\n"
"                                   (list '* size_t size_t '*))))\n"
"    (lambda (bv compare)\n"
"      ;; Sort bytevector BV in-place according to comparison\n"
"      ;; procedure COMPARE.\n"
"      (let ((ptr (procedure->pointer int\n"
"                                     (lambda (x y)\n"
"                                       ;; X and Y are pointers so,\n"
"                                       ;; for convenience, dereference\n"
"                                       ;; them before calling COMPARE.\n"
"                                       (compare (dereference-uint8* x)\n"
"                                                (dereference-uint8* y)))\n"
"                                     (list '* '*))))\n"
"        (qsort (bytevector->pointer bv)\n"
"               (bytevector-length bv) 1 ;; we're sorting bytes\n"
"               ptr)))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:978
msgid ""
"(define (dereference-uint8* ptr)\n"
"  ;; Helper function: dereference the byte pointed to by PTR.\n"
"  (let ((b (pointer->bytevector ptr 1)))\n"
"    (bytevector-u8-ref b 0)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:982
msgid ""
"(define bv\n"
"  ;; An unsorted array of bytes.\n"
"  (u8-list->bytevector '(7 1 127 3 5 4 77 2 9 0)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:985
msgid ""
";; Sort BV.\n"
"(qsort! bv (lambda (x y) (- x y)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:990
msgid ""
";; Let's see what the sorted array looks like:\n"
"(bytevector->u8-list bv)\n"
"@result{} (0 1 2 3 4 5 7 9 77 127)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:992
msgid "And voil@`a!"
msgstr "И вуаля!"

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:998
msgid ""
"Note that @code{procedure->pointer} is not supported (and not defined)\n"
"on a few exotic architectures.  Thus, user code may need to check\n"
"@code{(defined? 'procedure->pointer)}.  Nevertheless, it is available on\n"
"many architectures, including (as of libffi 3.0.9) x86, ia64, SPARC,\n"
"PowerPC, ARM, and MIPS, to name a few."
msgstr ""
"Обратите внимание, что @code{procedure->pointer} не поддерживат(и не "
"определена)\n"
"на нескольких экзотических архитектурах. Таким образом, пользовательскому "
"коду\n"
"возможно потребуется проверять определенали эта процедура\n"
"@code{(defined? 'procedure->pointer)}.  Тем не менее, она доступна на "
"многих\n"
"архитектурах, включая (как libffi 3.0.9) x86, ia64, SPARC,\n"
"PowerPC, ARM, и MIPS."

#: /home/bear/work/guile/doc/guile/en/api-foreign.texi:1001
msgid ""
"@c Local Variables:\n"
"@c TeX-master: \"guile.texi\"\n"
"@c End:"
msgstr ""
