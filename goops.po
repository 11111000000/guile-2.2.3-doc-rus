#
# Gagin <mikhail-gagin@yandex.ru>, 2018.
#
#. extracted from /home/bear/work/guile/doc/guile/en/goops.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-04-26 11:56+0300\n"
"PO-Revision-Date: 2018-06-20 11:39+0300\n"
"Last-Translator: Gagin <mikhail-gagin@yandex.ru>\n"
"Language-Team: Russian <mikhail-gagin@yandex.ru>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: /home/bear/work/guile/doc/guile/en/goops.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C)  2008, 2009, 2011\n"
"@c   Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:10
msgid ""
"@macro goops\n"
"GOOPS\n"
"@end macro"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:14
msgid ""
"@macro guile\n"
"Guile\n"
"@end macro"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:17
msgid ""
"@node GOOPS\n"
"@chapter GOOPS"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:23
msgid ""
"@goops{} is the object oriented extension to @guile{}. Its\n"
"implementation is derived from @w{STk-3.99.3} by Erick Gallesio and\n"
"version 1.3 of Gregor Kiczales' @cite{Tiny-Clos}.  It is very close in\n"
"spirit to CLOS, the Common Lisp Object System, but is adapted for the\n"
"Scheme language."
msgstr ""
"@goops{} - это объектно-ориентированное расширение для @guile{}. Его\n"
"реализация проистекает из @w{STk-3.99.3} от Erick Gallesio и\n"
"версии 1.3 of Gregor Kiczales' @cite{Tiny-Clos}.  Оно очень близко\n"
"по духу к CLOS, Common Lisp Object System, но адаптировано для Scheme."

#: /home/bear/work/guile/doc/guile/en/goops.texi:30
msgid ""
"@goops{} is a full object oriented system, with classes, objects,\n"
"multiple inheritance, and generic functions with multi-method\n"
"dispatch.  Furthermore its implementation relies on a meta object\n"
"protocol --- which means that @goops{}'s core operations are themselves\n"
"defined as methods on relevant classes, and can be customised by\n"
"overriding or redefining those methods."
msgstr ""
"@goops{} - это полная объектно-ориентированная система с классами,\n"
"объектами, множественным наследованием и обобщенными функциями имеющими\n"
"несколько методов обработки. Кроме того, ее реализация основывается\n"
"на метаобъектном протоколе - это означает, что основные операции\n"
"@goops{} сами определены как методы соответствующих классов, и их\n"
"можно насторить путем переопределения классов или путем переопределения\n"
"этих методов."

#: /home/bear/work/guile/doc/guile/en/goops.texi:33
msgid ""
"To start using @goops{} you first need to import the @code{(oop goops)}\n"
"module.  You can do this at the Guile REPL by evaluating:"
msgstr ""
"Чтобы начать использовать @goops{}, вам сначала нужно импортировать модуль\n"
"@code{(oop goops)}. Вы можете сделать это в Guile REPL выполнив:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:38
msgid ""
"@lisp\n"
"(use-modules (oop goops))\n"
"@end lisp\n"
"@findex (oop goops)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:54
msgid ""
"@menu\n"
"* Copyright Notice::\n"
"* Class Definition::\n"
"* Instance Creation::  \n"
"* Slot Options::\n"
"* Slot Description Example::\n"
"* Methods and Generic Functions::           \n"
"* Inheritance::                 \n"
"* Introspection::\n"
"* GOOPS Error Handling::\n"
"* GOOPS Object Miscellany::\n"
"* The Metaobject Protocol::\n"
"* Redefining a Class::\n"
"* Changing the Class of an Instance::\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:57
msgid ""
"@node Copyright Notice\n"
"@section Copyright Notice"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:60
msgid ""
"The material in this chapter is partly derived from the STk Reference\n"
"Manual written by Erick Gallesio, whose copyright notice is as follows."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:70
msgid ""
"Copyright © 1993-1999 Erick Gallesio - I3S-CNRS/ESSI <eg@@unice.fr>\n"
"Permission to use, copy, modify, distribute,and license this\n"
"software and its documentation for any purpose is hereby granted,\n"
"provided that existing copyright notices are retained in all\n"
"copies and that this notice is included verbatim in any\n"
"distributions.  No written agreement, license, or royalty fee is\n"
"required for any of the authorized uses.\n"
"This software is provided ``AS IS'' without express or implied\n"
"warranty."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:73
msgid ""
"The material has been adapted for use in Guile, with the author's\n"
"permission."
msgstr ""
"Материал был адаптирован для использования в Guile с разрешения\n"
"автора."

#: /home/bear/work/guile/doc/guile/en/goops.texi:77
msgid ""
"@node Class Definition\n"
"@section Class Definition"
msgstr ""
"@node Class Definition\n"
"@section Определение Класса"

#: /home/bear/work/guile/doc/guile/en/goops.texi:79
msgid "A new class is defined with the @code{define-class} syntax:"
msgstr "Новый класс определяется синтаксиом @code{define-class}:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:87
msgid ""
"@findex define-class\n"
"@cindex class\n"
"@lisp\n"
"(define-class @var{class} (@var{superclass} @dots{})\n"
"   @var{slot-description} @dots{}\n"
"   @var{class-option} @dots{})\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:99
msgid ""
"@var{class} is the class being defined.  The list of @var{superclass}es\n"
"specifies which existing classes, if any, to inherit slots and\n"
"properties from.  @dfn{Slots} hold per-instance@footnote{Usually --- but\n"
"see also the @code{#:allocation} slot option.} data, for instances of\n"
"that class --- like ``fields'' or ``member variables'' in other object\n"
"oriented systems.  Each @var{slot-description} gives the name of a slot\n"
"and optionally some ``properties'' of this slot; for example its initial\n"
"value, the name of a function which will access its value, and so on.\n"
"Class options, slot descriptions and inheritance are discussed more\n"
"below.\n"
"@cindex slot"
msgstr ""
"@var{class} является именем определяемого класса.  Список суперклассов\n"
"@var{superclass} указывает, какие существующие классы, если таковые\n"
"имеются, наследуются для слотов и свойств.  @dfn{Slots} Слоты хранят\n"
"per-instance@footnote{Обычно --- но также смотрите опцию @code{#:"
"allocation}.} \n"
"данные, для экземпляров класса --- подобно ``полям(fields)'' или \n"
"``переменным членам(member variables)'' в других объектно ориентированных \n"
"системах.  Каждое @var{slot-description}  определение дает имя слота и, \n"
"возможно, некоторые ``свойства'' этого слота; например его начальное \n"
"значение, имя функции, которая получит доступ к его значению, и так \n"
"далее. Опции класса (Class options), описание слотов\n"
"(slot descriptions) и наследование(inheritance) обсуждаются ниже\n"
"@cindex slot"

#: /home/bear/work/guile/doc/guile/en/goops.texi:106
msgid ""
"@deffn syntax define-class name (super @dots{}) @\n"
"              slot-definition @dots{} class-option @dots{}\n"
"Define a class called @var{name} that inherits from @var{super}s, with\n"
"direct slots defined by @var{slot-definition}s and @var{class-option}s.\n"
"The newly created class is bound to the variable name @var{name} in the\n"
"current environment."
msgstr ""
"@deffn syntax define-class name (super @dots{}) @\n"
"              slot-definition @dots{} class-option @dots{}\n"
"Определяет класс с именем @var{name} который наследуется от классов "
"@var{super},\n"
"со слотами определенными в  определении слотов@var{slot-definition}s \n"
"и опциями класса @var{class-option}.\n"
"Созданный класс привязывается к переменной @var{name} в текущем окружении."

#: /home/bear/work/guile/doc/guile/en/goops.texi:109
msgid ""
"Each @var{slot-definition} is either a symbol that names the slot or a\n"
"list,"
msgstr ""
"Каждое определение слота @var{slot-definition} является либо символом,\n"
"который обозначает слот либо списком,"

#: /home/bear/work/guile/doc/guile/en/goops.texi:113
msgid ""
"@example\n"
"(@var{slot-name-symbol} . @var{slot-options})\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:118
msgid ""
"where @var{slot-name-symbol} is a symbol and @var{slot-options} is a\n"
"list with an even number of elements.  The even-numbered elements of\n"
"@var{slot-options} (counting from zero) are slot option keywords; the\n"
"odd-numbered elements are the corresponding values for those keywords."
msgstr ""
"где имя слота @var{slot-name-symbol} это символ, а опции слота\n"
"@var{slot-options} это список с четным числом элементов.  Элементы\n"
"с четными номерами слотов @var{slot-options}(считая от нуля) являются\n"
"ключевыми словами; элементы с нечетными номерами являются соотвествующими\n"
"значениями для этих ключевых слов."

#: /home/bear/work/guile/doc/guile/en/goops.texi:121
msgid ""
"Each @var{class-option} is an option keyword and corresponding value.\n"
"@end deffn"
msgstr ""
"Каждая опция класса @var{class-option} это ключевое слово и соотвествующее\n"
"значение.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:127
msgid ""
"As an example, let us define a type for representing a complex number\n"
"in terms of two real numbers.@footnote{Of course Guile already\n"
"provides complex numbers, and @code{<complex>} is in fact a predefined\n"
"class in GOOPS; but the definition here is still useful as an\n"
"example.}  This can be done with the following class definition:"
msgstr ""
"В качестве примера, давайте определим тип для представления\n"
"комплексного числа как двух вещественных чисел. @footnote{Конечно \n"
"Guile уже имеет определение комплексных чисел. А @code{<complex>} \n"
"на самом деле является предопределенным классом в  GOOPS; \n"
"но наше определение полезно здесь в качестве примера.}  \n"
"Это можно сделать с помощью следующего определения\n"
"класса:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:132
msgid ""
"@lisp\n"
"(define-class <my-complex> (<number>)\n"
"   r i)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:141
msgid ""
"This binds the variable @code{<my-complex>} to a new class whose\n"
"instances will contain two slots.  These slots are called @code{r} and\n"
"@code{i} and will hold the real and imaginary parts of a complex\n"
"number. Note that this class inherits from @code{<number>}, which is a\n"
"predefined class.@footnote{@code{<number>} is the direct superclass of\n"
"the predefined class @code{<complex>}; @code{<complex>} is the\n"
"superclass of @code{<real>}, and @code{<real>} is the superclass of\n"
"@code{<integer>}.}"
msgstr ""
"Это определение связывает переменную @code{<my-complex>} с новым классо\n"
"экземпляры которого будут содержать два слота.  Эти слоты называются\n"
"@code{r} и @code{i} и будут содержать действительную и мнимую части\n"
"комплексного числа. Обратите внимание, что этот класс наследует\n"
"от класса @code{<number>}, который является предопределенным классом.\n"
"@footnote{@code{<number>} это прямой суперкласс предопределенного\n"
"класса @code{<complex>}; @code{<complex>} является суперклассом для\n"
"@code{<real>}, и @code{<real>} является суперклассом для @code{<integer>}.}"

#: /home/bear/work/guile/doc/guile/en/goops.texi:144
msgid ""
"Slot options are described in the next section.  The possible class\n"
"options are as follows."
msgstr ""
"Параметры слотов описаны в следующем разделе. Возможны следующие\n"
"опции класса:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:150
msgid ""
"@deffn {class option} #:metaclass metaclass\n"
"The @code{#:metaclass} class option specifies the metaclass of the class\n"
"being defined.  @var{metaclass} must be a class that inherits from\n"
"@code{<class>}.  For the use of metaclasses, see @ref{Metaobjects and\n"
"the Metaobject Protocol} and @ref{Metaclasses}."
msgstr ""
"@deffn {class option} #:metaclass metaclass\n"
"Опция класса @code{#:metaclass} задает метакласс класса, который "
"определяется.\n"
"@var{metaclass} должен быть классом, который наследует от @code{<class>}.\n"
"Для использоания метаклассов, см @ref{Metaobjects and the Metaobject "
"Protocol}\n"
"и @ref{Metaclasses}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:155
msgid ""
"If the @code{#:metaclass} option is absent, GOOPS reuses or constructs a\n"
"metaclass for the new class by calling @code{ensure-metaclass}\n"
"(@pxref{Class Definition Protocol,, ensure-metaclass}).\n"
"@end deffn"
msgstr ""
"Если опция @code{#:metaclass} отсутствует, GOOPS повторно использует или\n"
"создает метакласс для нового класса, вызвав @code{ensure-metaclass}\n"
"(@pxref{Class Definition Protocol,, ensure-metaclass}).\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:160
msgid ""
"@deffn {class option} #:name name\n"
"The @code{#:name} class option specifies the new class's name.  This\n"
"name is used to identify the class whenever related objects - the class\n"
"itself, its instances and its subclasses - are printed."
msgstr ""
"@deffn {class option} #:name name\n"
"Опция класса @code{#:name} указывает имя нового класса. Это имя "
"используется\n"
"для идентификации класса, когда печатаются связанные объекты - сам класс, "
"его \n"
"экземпляры и его подклассы."

#: /home/bear/work/guile/doc/guile/en/goops.texi:164
msgid ""
"If the @code{#:name} option is absent, GOOPS uses the first argument to\n"
"@code{define-class} as the class name.\n"
"@end deffn"
msgstr ""
"Если параметр @code{#:name} отсутствует, GOOPS использует первый аргумент "
"для\n"
"@code{define-class} как имя класса.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:168
msgid ""
"@node Instance Creation\n"
"@section Instance Creation and Slot Access"
msgstr ""
"@node Instance Creation\n"
"@section Создание экземпляров и доступ к слотам"

#: /home/bear/work/guile/doc/guile/en/goops.texi:174
msgid ""
"An instance (or object) of a defined class can be created with\n"
"@code{make}.  @code{make} takes one mandatory parameter, which is the\n"
"class of the instance to create, and a list of optional arguments that\n"
"will be used to initialize the slots of the new instance.  For instance\n"
"the following form"
msgstr ""
"Экземпляр (или Объект) определенного класса может быть создан с помощью\n"
"@code{make}.  @code{make} принимает один обязательный параметр, который \n"
"является классом создаваемого экземпляра, и список необязательных "
"аргументов,\n"
"которые будут использоваться для инициализации слотов нового экземпляра.\n"
"Например, следующая форма:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:180
msgid ""
"@findex make\n"
"@cindex instance\n"
"@lisp\n"
"(define c (make <my-complex>))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:184
msgid ""
"@noindent\n"
"creates a new @code{<my-complex>} object and binds it to the Scheme\n"
"variable @code{c}."
msgstr ""
"@noindent\n"
"создает новый объект @code{<my-complex>} и связывает его с переменно\n"
"Scheme  @code{c}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:189
msgid ""
"@deffn generic make\n"
"@deffnx method make (class <class>) initarg @dots{}\n"
"Create and return a new instance of class @var{class}, initialized using\n"
"@var{initarg} @enddots{}."
msgstr ""
"@deffn generic make\n"
"@deffnx method make (class <class>) initarg @dots{}\n"
"Создает и инициализирует новый экземпляр класса @var{class}, \n"
"используя аргументы @var{initarg} \n"
"@enddots{}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:193
msgid ""
"In theory, @var{initarg} @dots{} can have any structure that is\n"
"understood by whatever methods get applied when the @code{initialize}\n"
"generic function is applied to the newly allocated instance."
msgstr ""
"Теоретически, @var{initarg} @dots{} может иметь любую структуру,\n"
"которая понимается методами get, когда вызывается обобщенная функция\n"
"@code{initialize} для вновь созданного объекта."

#: /home/bear/work/guile/doc/guile/en/goops.texi:200
msgid ""
"In practice, specialized @code{initialize} methods would normally call\n"
"@code{(next-method)}, and so eventually the standard GOOPS\n"
"@code{initialize} methods are applied.  These methods expect\n"
"@var{initargs} to be a list with an even number of elements, where\n"
"even-numbered elements (counting from zero) are keywords and\n"
"odd-numbered elements are the corresponding values."
msgstr ""
"На практике, специализированные методы @code{initialize} \n"
"обычно вызывают @code{(next-method)}, и поэтому в конечно\n"
"итоге применяются стандартные методы инициализации GOOPS\n"
"@code{initialize}.  Эти методы ожидают. что @var{initargs}\n"
"будет списком с четным числом аргументов, где четные элементы\n"
"(начиная с нуля)  это ключевые слова, а элементы с нечетным \n"
"номером - соответствующие значения."

#: /home/bear/work/guile/doc/guile/en/goops.texi:207
msgid ""
"GOOPS processes initialization argument keywords automatically for slots\n"
"whose definition includes the @code{#:init-keyword} option (@pxref{Slot\n"
"Options,, init-keyword}).  Other keyword value pairs can only be\n"
"processed by an @code{initialize} method that is specialized for the new\n"
"instance's class.  Any unprocessed keyword value pairs are ignored.\n"
"@end deffn"
msgstr ""
"Процесс инициализации GOOPS автоматически обрабатывает аргументы ключевые \n"
"слова для слотов, определение которых включает опцию @code{#:init-keyword}\n"
"(@pxref{Slot Options,, init-keyword}).  Другие пары значений ключевого\n"
"слова могут обрабатываться только методом инициализации  @code{initialize}\n"
"который специализируется на классе нового экземпляра. Любые пары \n"
"необработанных ключевых слов игнорируются.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:212
msgid ""
"@deffn generic make-instance\n"
"@deffnx method make-instance (class <class>) initarg @dots{}\n"
"@code{make-instance} is an alias for @code{make}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:216
msgid ""
"The slots of the new complex number can be accessed using\n"
"@code{slot-ref} and @code{slot-set!}.  @code{slot-set!}  sets the value\n"
"of an object slot and @code{slot-ref} retrieves it."
msgstr ""
"Доступ к слотам нового комплексного числа можно получить используя\n"
"@code{slot-ref} и @code{slot-set!}.  @code{slot-set!}  устанавливает\n"
"значение слота объекта и @code{slot-ref} извлекает его."

#: /home/bear/work/guile/doc/guile/en/goops.texi:227
msgid ""
"@findex slot-set!\n"
"@findex slot-ref\n"
"@lisp\n"
"@group\n"
"(slot-set! c 'r 10)\n"
"(slot-set! c 'i 3)\n"
"(slot-ref c 'r) @result{} 10\n"
"(slot-ref c 'i) @result{} 3\n"
"@end group\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:231
msgid ""
"The @code{(oop goops describe)} module provides a @code{describe}\n"
"function that is useful for seeing all the slots of an object; it prints\n"
"the slots and their values to standard output."
msgstr ""
"Модуль @code{(oop goops describe)} предоставляет функцию @code{describe},\n"
"которая полезна для просмотра всех слотов объекта; она печатает слоты\n"
"и их значения на стандартный вывод."

#: /home/bear/work/guile/doc/guile/en/goops.texi:240
msgid ""
"@lisp\n"
"(describe c)\n"
"@print{}\n"
"#<<my-complex> 401d8638> is an instance of class <my-complex>\n"
"Slots are: \n"
"     r = 10\n"
"     i = 3\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:244
msgid ""
"@node Slot Options\n"
"@section Slot Options"
msgstr ""
"@node Slot Options\n"
"@section Опции Слотов(Slot Options)"

#: /home/bear/work/guile/doc/guile/en/goops.texi:249
msgid ""
"When specifying a slot (in a @code{(define-class @dots{})} form),\n"
"various options can be specified in addition to the slot's name.  Each\n"
"option is specified by a keyword.  The list of possible keywords is\n"
"as follows."
msgstr ""
"При определении слота (в форме a @code{(define-class @dots{})} ),\n"
"могут быть указаны различные параметры в дополнение к названию\n"
"слота. Каждый параметр задается ключевым словом. Список возможных\n"
"ключевых слов следующий:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:257
msgid ""
"@deffn {slot option} #:init-value init-value\n"
"@deffnx {slot option} #:init-form init-form\n"
"@deffnx {slot option} #:init-thunk init-thunk\n"
"@deffnx {slot option} #:init-keyword init-keyword\n"
"These options provide various ways to specify how to initialize the\n"
"slot's value at instance creation time.\n"
"@cindex default slot value"
msgstr ""
"@deffn {slot option} #:init-value init-value\n"
"@deffnx {slot option} #:init-form init-form\n"
"@deffnx {slot option} #:init-thunk init-thunk\n"
"@deffnx {slot option} #:init-keyword init-keyword\n"
"Эти параметры предоставляют различные способы указать, как инициализировать\n"
"начальное значение слота во время создания нового экземпляра.\n"
"@cindex default slot value"

#: /home/bear/work/guile/doc/guile/en/goops.texi:260
msgid ""
"@var{init-value} specifies a fixed initial slot value (shared across all\n"
"new instances of the class)."
msgstr ""
"@var{init-value} задает фиксированное начальное значение слота (совместно "
"используемое\n"
"во всех новых экземплярах класса)."

#: /home/bear/work/guile/doc/guile/en/goops.texi:264
msgid ""
"@var{init-thunk} specifies a thunk that will provide a default value for\n"
"the slot.  The thunk is called when a new instance is created and should\n"
"return the desired initial slot value."
msgstr ""
"@var{init-thunk} указывает преобразователь(thunk) который предоставляет\n"
"значение по умолчанию для слота. Преобразователь вызывается когда\n"
"создается новый экземпляр класса и должен возвращать новое начальное\n"
"значение слота."

#: /home/bear/work/guile/doc/guile/en/goops.texi:269
msgid ""
"@var{init-form} specifies a form that, when evaluated, will return\n"
"an initial value for the slot.  The form is evaluated each time that\n"
"an instance of the class is created, in the lexical environment of the\n"
"containing @code{define-class} expression."
msgstr ""
"@var{init-form} указывает форму, которая при вызове возвращает\n"
"начальное значение для слота. Форма выполняется каждый раз, когда\n"
"создается экземпляр класса, в лексической среде содержащей выражение\n"
"@code{define-class}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:272
msgid ""
"@var{init-keyword} specifies a keyword that can be used to pass an\n"
"initial slot value to @code{make} when creating a new instance."
msgstr ""
"@var{init-keyword} указывает ключевое слово, которое может использоваться\n"
"для передачи начального значения слота через вызов  @code{make}, которая \n"
"создает новый экземпляр класса."

#: /home/bear/work/guile/doc/guile/en/goops.texi:279
msgid ""
"Note that, since an @code{init-value} value is shared across all\n"
"instances of a class, you should only use it when the initial value is\n"
"an immutable value, like a constant.  If you want to initialize a slot\n"
"with a fresh, independently mutable value, you should use\n"
"@code{init-thunk} or @code{init-form} instead.  Consider the following\n"
"example."
msgstr ""
"Обратите внимание: поскольку значение @code{init-value} является общим\n"
"для всех экземпляров класса, вы должны использовать его тогда, когда\n"
"начальное значение является неизменным, таким как константа. Если вы\n"
"хотите инициализировать слот новым, независимо изменяемым значением,\n"
"вы должны вместо этого использовать @code{init-thunk} или\n"
"@code{init-form}.  Рассмотрим пример."

#: /home/bear/work/guile/doc/guile/en/goops.texi:284
msgid ""
"@example\n"
"(define-class <chbouib> ()\n"
"  (hashtab #:init-value (make-hash-table)))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:290
msgid ""
"@noindent\n"
"Here only one hash table is created and all instances of\n"
"@code{<chbouib>} have their @code{hashtab} slot refer to it.  In order\n"
"to have each instance of @code{<chbouib>} refer to a new hash table, you\n"
"should instead write:"
msgstr ""
"@noindent\n"
"Здесь создается только одна хеш-таблица, и все экземпляры класса\n"
"@code{<chbouib>} имеют свой слот @code{hashtab}.  Чтобы каждый\n"
"экземпляр класса @code{<chbouib>} ссылался на новую хеш-таблицу,\n"
"вы должны написать:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:295
msgid ""
"@example\n"
"(define-class <chbouib> ()\n"
"  (hashtab #:init-thunk make-hash-table))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:298
msgid ""
"@noindent\n"
"or:"
msgstr ""
"@noindent\n"
"или:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:303
msgid ""
"@example\n"
"(define-class <chbouib> ()\n"
"  (hashtab #:init-form (make-hash-table)))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:306
msgid ""
"If more than one of these options is specified for the same slot, the\n"
"order of precedence, highest first is"
msgstr ""
"Если для одного из слотов указано больее одного из этих параметров,\n"
"порядок приоритета инициализации устанавливается вначале для:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:311
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{#:init-keyword}, if @var{init-keyword} is present in the options\n"
"passed to @code{make}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:315
msgid ""
"@item\n"
"@code{#:init-thunk}, @code{#:init-form} or @code{#:init-value}.\n"
"@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:319
msgid ""
"If the slot definition contains more than one initialization option of\n"
"the same precedence, the later ones are ignored.  If a slot is not\n"
"initialized at all, its value is unbound."
msgstr ""
"Если определение слота содержит более одного параметра инициализации того "
"же\n"
"приоритета, более поздние из них игнорируются. Если слот не инициализирован\n"
"вообще, его значение не устанавливается."

#: /home/bear/work/guile/doc/guile/en/goops.texi:325
msgid ""
"In general, slots that are shared between more than one instance are\n"
"only initialized at new instance creation time if the slot value is\n"
"unbound at that time.  However, if the new instance creation specifies\n"
"a valid init keyword and value for a shared slot, the slot is\n"
"re-initialized regardless of its previous value."
msgstr ""
"В общем случае слоты, которые разделяются между несколькими экземплярами,\n"
"инициализируются только в момент создания нового экземпляраа, если\n"
"значение слота еще не было связано. Однако, если при создание нового \n"
"экземпляра указывается ключевое слово init и значение для общего слота,\n"
"слот инициализируется не зависимо от его предыдущего значения."

#: /home/bear/work/guile/doc/guile/en/goops.texi:331
msgid ""
"Note, however, that the power of GOOPS' metaobject protocol means that\n"
"everything written here may be customized or overridden for particular\n"
"classes!  The slot initializations described here are performed by the "
"least\n"
"specialized method of the generic function @code{initialize}, whose\n"
"signature is"
msgstr ""
"Обратите внимание, однако, что мощь протокола метаобъектов GOOPS означает,\n"
"что все написанные здесь процедуры, могут быть настроены или перенастроены\n"
"для определенных классов!  Слот инициализации, описанный здесь, выполняется\n"
"наименее специализированным методом обобщенной функции @code{initialize}, "
"чья\n"
"сигнатура такова:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:335
msgid ""
"@example\n"
"(define-method (initialize (object <object>) initargs) ...)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:346
msgid ""
"The initialization of instances of any given class can be customized by\n"
"defining a @code{initialize} method that is specialized for that class,\n"
"and the author of the specialized method may decide to call\n"
"@code{next-method} - which will result in a call to the next less\n"
"specialized @code{initialize} method - at any point within the\n"
"specialized code, or maybe not at all.  In general, therefore, the\n"
"initialization mechanisms described here may be modified or overridden by\n"
"more specialized code, or may not be supported at all for particular\n"
"classes.\n"
"@end deffn"
msgstr ""
"Инициализация экземпляров любого данного класса может быть настроена\n"
"путем определения метода инициализации @code{initialize}, который \n"
"является специализированным для этого класса, и автор \n"
"специализированного метода может решить вызвать code{next-method} -\n"
"менее специализированный метод инициализации @code{initialize} - \n"
"и в любой точке специализированного кода это правила могут быть\n"
"переопределены и перестают работать.  В общем, поэтому механизмы \n"
"инициализации, описанные здесь, могут быть изменены или переопределены\n"
"более специализированным кодом или вообще могут не поддерживаться\n"
"для определенных классов.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:354
msgid ""
"@deffn {slot option} #:getter getter\n"
"@deffnx {slot option} #:setter setter\n"
"@deffnx {slot option} #:accessor accessor\n"
"Given an object @var{obj} with slots named @code{foo} and @code{bar}, it\n"
"is always possible to read and write those slots by calling\n"
"@code{slot-ref} and @code{slot-set!} with the relevant slot name; for\n"
"example:"
msgstr ""
"@deffn {slot option} #:getter getter\n"
"@deffnx {slot option} #:setter setter\n"
"@deffnx {slot option} #:accessor accessor\n"
"Доступный объект @var{obj} имеющий слоты с именами @code{foo} и @code{bar},\n"
"можно всегда читать и писать, вызывая методы @code{slot-ref} и @code{slot-"
"set!} \n"
"с соответствующим именем слота; например:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:359
msgid ""
"@example\n"
"(slot-ref @var{obj} 'foo)\n"
"(slot-set! @var{obj} 'bar 25)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:368
msgid ""
"The @code{#:getter}, @code{#:setter} and @code{#:accessor} options, if\n"
"present, tell GOOPS to create generic function and method definitions\n"
"that can be used to get and set the slot value more conveniently.\n"
"@var{getter} specifies a generic function to which GOOPS will add a\n"
"method for getting the slot value.  @var{setter} specifies a generic\n"
"function to which GOOPS will add a method for setting the slot value.\n"
"@var{accessor} specifies an accessor to which GOOPS will add methods for\n"
"both getting and setting the slot value."
msgstr ""
"Опции @code{#:getter}, @code{#:setter} и @code{#:accessor}, если\n"
"они присутствуют, сообщают GOOPS о создании обобщенной функции и "
"определении\n"
"методов, которые можно использовать для получения и установки значения\n"
"слота. @var{getter} указывает обобщенную функцию, к которой GOOPS добавит\n"
"метод получения значения слота.  @var{setter} указывает обобщенную функцию,\n"
"к которой GOOPS добавит метод установки значения слота.\n"
"@var{accessor} указывает обобщенную функцию accessor которой GOOPS добавит\n"
"методы для получения и установки значения слота."

#: /home/bear/work/guile/doc/guile/en/goops.texi:370
msgid "So if a class includes a slot definition like this:"
msgstr ""
"Поэтому, если класс включает определение слота,\n"
"например:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:374
msgid ""
"@example\n"
"(c #:getter get-count #:setter set-count #:accessor count)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:377
msgid ""
"GOOPS defines generic function methods such that the slot value can be\n"
"referenced using either the getter or the accessor -"
msgstr ""
"GOOPS определяет методы обобщенной функций, так что на значение слота \n"
"можно ссылаться исользуя либо getter либо accessor - "

#: /home/bear/work/guile/doc/guile/en/goops.texi:382
msgid ""
"@example\n"
"(let ((current-count (get-count obj))) @dots{})\n"
"(let ((current-count (count obj))) @dots{})\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:384
msgid "- and set using either the setter or the accessor -"
msgstr "- и устанавливать с помощью либо setter или accessorа"

#: /home/bear/work/guile/doc/guile/en/goops.texi:389
msgid ""
"@example\n"
"(set-count obj (+ 1 current-count))\n"
"(set! (count obj) (+ 1 current-count))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:391
msgid "Note that"
msgstr "Обратите внимание, что"

#: /home/bear/work/guile/doc/guile/en/goops.texi:396
msgid ""
"@itemize @bullet\n"
"@item\n"
"with an accessor, the slot value is set using the generalized\n"
"@code{set!} syntax"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"с accesor'ом значение слота устанавливается с использованием\n"
"обобщенного синтаксиса @code{set!}"

#: /home/bear/work/guile/doc/guile/en/goops.texi:403
msgid ""
"@item\n"
"in practice, it is unusual for a slot to use all three of these options:\n"
"read-only, write-only and read-write slots would typically use only\n"
"@code{#:getter}, @code{#:setter} and @code{#:accessor} options\n"
"respectively.\n"
"@end itemize"
msgstr ""
"@item\n"
"на практике для слота неиспользуют все три из этих опций:\n"
"только для чтения, только для записи и для чтения-записи\n"
"@code{#:getter}, @code{#:setter} и @code{#:accessor}\n"
"соответственно.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/goops.texi:411
msgid ""
"The binding of the specified names is done in the environment of the\n"
"@code{define-class} expression.  If the names are already bound (in that\n"
"environment) to values that cannot be upgraded to generic functions,\n"
"those values are overwritten when the @code{define-class} expression is\n"
"evaluated.  For more detail, see @ref{Generic Function Internals,,\n"
"ensure-generic}.\n"
"@end deffn"
msgstr ""
"Связывание указанных имен выполняется в среде определения класса\n"
"@code{define-class}.  Если имена уже связаны (в этой среде) значениями \n"
"которые не могут быть обновлены до  обобщеннх функций, эти значения будут\n"
"перезаписаны, если выполняется выражение the @code{define-class}.\n"
"Более подробно, См. @ref{Generic Function Internals,,ensure-generic}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:415
msgid ""
"@deffn {slot option} #:allocation allocation\n"
"The @code{#:allocation} option tells GOOPS how to allocate storage for\n"
"the slot.  Possible values for @var{allocation} are"
msgstr ""
"@deffn {slot option} #:allocation allocation\n"
"Опция @code{#:allocation} указывает GOOPS, как распределить памиять,\n"
"для слота. Возможные значения для @var{allocation}:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:418
msgid ""
"@itemize @bullet\n"
"@item @code{#:instance}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:423
msgid ""
"@findex #:instance\n"
"Indicates that GOOPS should create separate storage for this slot in\n"
"each new instance of the containing class (and its subclasses).  This is\n"
"the default."
msgstr ""
"@findex #:instance\n"
"Указывает, что GOOPS должен создавать отдельное хранилище для этого слота\n"
"в каждом новом экземпляре содержащего его класса (и его подклассов).  Это \n"
"значение устанавливается по умолчанию."

#: /home/bear/work/guile/doc/guile/en/goops.texi:425
msgid "@item @code{#:class}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:433
msgid ""
"@findex #:class\n"
"Indicates that GOOPS should create storage for this slot that is shared\n"
"by all instances of the containing class (and its subclasses).  In other\n"
"words, a slot in class @var{C} with allocation @code{#:class} is shared\n"
"by all @var{instance}s for which @code{(is-a? @var{instance} @var{c})}.\n"
"This permits defining a kind of global variable which can be accessed\n"
"only by (in)direct instances of the class which defines the slot."
msgstr ""
"@findex #:class\n"
"Указывает, что GOOPS должен создвать хранилище для слота, которое\n"
"будет использоваться всеми экземплярами содержащего его класса\n"
"(и его подклассов).  Другими словами, слот в классе @var{C} с\n"
"распределением типа @code{#:class} разделяется всеми экземплярами\n"
"@var{instance}s для которых выполнено @code{(is-a? @var{instance} "
"@var{c})}.\n"
"Это позволяет определенть некую глобальную переменную, к которой можно\n"
"получить доступ только из прямых наследников класса, который определяет\n"
"данный слот."

#: /home/bear/work/guile/doc/guile/en/goops.texi:435
msgid "@item @code{#:each-subclass}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:444
msgid ""
"@findex #:each-subclass\n"
"Indicates that GOOPS should create storage for this slot that is shared\n"
"by all @emph{direct} instances of the containing class, and that\n"
"whenever a subclass of the containing class is defined, GOOPS should\n"
"create a new storage for the slot that is shared by all @emph{direct}\n"
"instances of the subclass.  In other words, a slot with allocation\n"
"@code{#:each-subclass} is shared by all instances with the same\n"
"@code{class-of}."
msgstr ""
"@findex #:each-subclass\n"
"Указывает, что GOOPS должен создать хранилище для этого слота, который\n"
"будет использоваться всеми непосредственными @emph{direct} экземплярами\n"
"этого класса и что всякий раз, когда определяется подкласс данного класса,\n"
"GOOPS должен создать новое хранилище для слота, который будет разделяться\n"
"всеми непосредственными экземплярами данного подкласса.  Другими словами,\n"
"слот с @code{#:each-subclass} разделяется всеми экземплярами одного\n"
"класса @code{class-of}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:446
msgid "@item @code{#:virtual}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:455
msgid ""
"@findex #:slot-set!\n"
"@findex #:slot-ref\n"
"@findex #:virtual\n"
"Indicates that GOOPS should not allocate storage for this slot.  The\n"
"slot definition must also include the @code{#:slot-ref} and\n"
"@code{#:slot-set!} options to specify how to reference and set the value\n"
"for this slot.  See the example below.\n"
"@end itemize"
msgstr ""
"@findex #:slot-set!\n"
"@findex #:slot-ref\n"
"@findex #:virtual\n"
"Указывает, что GOOPS не должен выделять память для этого слота. Определение\n"
"слота также должны включать в себя опции @code{#:slot-ref} и\n"
"@code{#:slot-set!} для получения значения или его установки для данного "
"слота.\n"
"Смотри пример ниже.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/goops.texi:463
msgid ""
"Slot allocation options are processed when defining a new class by the\n"
"generic function @code{compute-get-n-set}, which is specialized by the\n"
"class's metaclass.  Hence new types of slot allocation can be\n"
"implemented by defining a new metaclass and a method for\n"
"@code{compute-get-n-set} that is specialized for the new metaclass.  For\n"
"an example of how to do this, see @ref{Customizing Class Definition}.\n"
"@end deffn"
msgstr ""
"Параметры рапределения слотов обрабатываются при определении нового\n"
"класса с помощью обобщенной функции @code{compute-get-n-set}, которая\n"
"определяется в метаклассе класса.  Следовательно, новые типы\n"
"распределения слотов могут быть реализованы путем определения\n"
"нового метакласса и метода для @code{compute-get-n-set} который\n"
"будет специализирован для нового метакласса.  Пример того, как\n"
"это делается, см. @ref{Customizing Class Definition}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:468
msgid ""
"@deffn {slot option} #:slot-ref getter\n"
"@deffnx {slot option} #:slot-set! setter\n"
"The @code{#:slot-ref} and @code{#:slot-set!} options must be specified\n"
"if the slot allocation is @code{#:virtual}, and are ignored otherwise."
msgstr ""
"@deffn {slot option} #:slot-ref getter\n"
"@deffnx {slot option} #:slot-set! setter\n"
"Опции @code{#:slot-ref} и @code{#:slot-set!} должны быть указаны, если\n"
"распределение слотов является  @code{#:virtual}, и игнорируются\n"
"иначе."

#: /home/bear/work/guile/doc/guile/en/goops.texi:474
msgid ""
"@var{getter} should be a closure taking a single @var{instance} parameter\n"
"that returns the current slot value.  @var{setter} should be a closure\n"
"taking two parameters - @var{instance} and @var{new-val} - that sets the\n"
"slot value to @var{new-val}.\n"
"@end deffn"
msgstr ""
"@var{getter} должен быть замыканием, принимающим один параметр "
"@var{instance},\n"
"которое возвращает текущее значение слота.  @var{setter} должен быть "
"замыканием\n"
"получающим два параметра - @var{instance} и @var{new-val} - которое "
"устанавливает\n"
"новое значение слота в  @var{new-val}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:477
msgid ""
"@node Slot Description Example\n"
"@section Illustrating Slot Description"
msgstr ""
"@node Slot Description Example\n"
"@section Илюстрирование Описание Слота"

#: /home/bear/work/guile/doc/guile/en/goops.texi:480
msgid ""
"To illustrate slot description, we can redefine the @code{<my-complex>}\n"
"class seen before. A definition could be:"
msgstr ""
"Чтобы проилюстрировать описание слота, мы можем переопределить класс "
"@code{<my-complex>}\n"
"рассмотренный ранее. Определение может быть:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:486
msgid ""
"@lisp\n"
"(define-class <my-complex> (<number>) \n"
"   (r #:init-value 0 #:getter get-r #:setter set-r! #:init-keyword #:r)\n"
"   (i #:init-value 0 #:getter get-i #:setter set-i! #:init-keyword #:i))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:493
msgid ""
"@noindent\n"
"With this definition, the @code{r} and @code{i} slots are set to 0 by\n"
"default, and can be initialised to other values by calling @code{make}\n"
"with the @code{#:r} and @code{#:i} keywords.  Also the generic functions\n"
"@code{get-r}, @code{set-r!}, @code{get-i} and @code{set-i!}  are\n"
"automatically defined to read and write the slots."
msgstr ""
"@noindent\n"
"При этом определении, слоты @code{r} и @code{i} по умолчанию "
"устанавливаются\n"
"в 0 и могут быть инициализированны другими значениями путем вызова "
"@code{make}\n"
"с ключевыми словами @code{#:r} и @code{#:i}.  Также обобщенные функции\n"
"@code{get-r}, @code{set-r!}, @code{get-i} и @code{set-i!} автоматически\n"
"определяются для чтения и записи слотов."

#: /home/bear/work/guile/doc/guile/en/goops.texi:503
msgid ""
"@lisp\n"
"(define c1 (make <my-complex> #:r 1 #:i 2))\n"
"(get-r c1) @result{} 1\n"
"(set-r! c1 12)\n"
"(get-r c1) @result{} 12\n"
"(define c2 (make <my-complex> #:r 2))\n"
"(get-r c2) @result{} 2\n"
"(get-i c2) @result{} 0\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:506
msgid ""
"Accessors can both read and write a slot.  So, another definition of the\n"
"@code{<my-complex>} class, using the @code{#:accessor} option, could be:"
msgstr ""
"Аксессоры могут читать и записывать слот.  Итак, другое определение класса\n"
"@code{<my-complex>}, использующее опцию @code{#:accessor}, может быть:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:513
msgid ""
"@findex set!\n"
"@lisp\n"
"(define-class <my-complex> (<number>) \n"
"   (r #:init-value 0 #:accessor real-part #:init-keyword #:r)\n"
"   (i #:init-value 0 #:accessor imag-part #:init-keyword #:i))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:524
msgid ""
"@noindent\n"
"With this definition, the @code{r} slot can be read with:\n"
"@lisp\n"
"(real-part c)\n"
"@end lisp\n"
"@noindent\n"
"and set with:\n"
"@lisp\n"
"(set! (real-part c) new-value)\n"
"@end lisp"
msgstr ""
"@noindent\n"
"с помощью этого определения слот @code{r} можно прочитать с помощью:\n"
"@lisp\n"
"(real-part c)\n"
"@end lisp\n"
"@noindent\n"
"и установить с помощью:\n"
"@lisp\n"
"(set! (real-part c) new-value)\n"
"@end lisp"

#: /home/bear/work/guile/doc/guile/en/goops.texi:530
msgid ""
"Suppose now that we want to manipulate complex numbers with both\n"
"rectangular and polar coordinates.  One solution could be to have a\n"
"definition of complex numbers which uses one particular representation\n"
"and some conversion functions to pass from one representation to the\n"
"other.  A better solution is to use virtual slots, like this:"
msgstr ""
"Предположим теперь, что мы хотим манипулировать комплексными числами\n"
"как прямоугольными, так и полярными координатами. Одним из решений может\n"
"быть определение комплексных чисел, которое использует одно конкретное\n"
"представление и некоторые функции преобразования для перехода из одного\n"
"представления в другое. Лучшее решение - использовать виртуальные слоты,\n"
"например:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:554
msgid ""
"@lisp\n"
"(define-class <my-complex> (<number>)\n"
"   ;; True slots use rectangular coordinates\n"
"   (r #:init-value 0 #:accessor real-part #:init-keyword #:r)\n"
"   (i #:init-value 0 #:accessor imag-part #:init-keyword #:i)\n"
"   ;; Virtual slots access do the conversion\n"
"   (m #:accessor magnitude #:init-keyword #:magn  \n"
"      #:allocation #:virtual\n"
"      #:slot-ref (lambda (o)\n"
"                  (let ((r (slot-ref o 'r)) (i (slot-ref o 'i)))\n"
"                    (sqrt (+ (* r r) (* i i)))))\n"
"      #:slot-set! (lambda (o m)\n"
"                    (let ((a (slot-ref o 'a)))\n"
"                      (slot-set! o 'r (* m (cos a)))\n"
"                      (slot-set! o 'i (* m (sin a))))))\n"
"   (a #:accessor angle #:init-keyword #:angle\n"
"      #:allocation #:virtual\n"
"      #:slot-ref (lambda (o)\n"
"                  (atan (slot-ref o 'i) (slot-ref o 'r)))\n"
"      #:slot-set! (lambda(o a)\n"
"                   (let ((m (slot-ref o 'm)))\n"
"                      (slot-set! o 'r (* m (cos a)))\n"
"                      (slot-set! o 'i (* m (sin a)))))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:556
msgid "@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:564
msgid ""
"In this class definition, the magnitude @code{m} and angle @code{a}\n"
"slots are virtual, and are calculated, when referenced, from the normal\n"
"(i.e.@: @code{#:allocation #:instance}) slots @code{r} and @code{i}, by\n"
"calling the function defined in the relevant @code{#:slot-ref} option.\n"
"Correspondingly, writing @code{m} or @code{a} leads to calling the\n"
"function defined in the @code{#:slot-set!} option.  Thus the\n"
"following expression"
msgstr ""
"В этом определении класса, слоты размах(magnitude) @code{m} и угол(angle)\n"
" @code{a} виртуальные, и вчисляются когда при ссылке, из значений "
"нормальных\n"
"слотов (т.е.@: @code{#:allocation #:instance})  @code{r} и @code{i}, путем\n"
"вызова функций, определенных в соответствующем параметре @code{#:slot-ref}.\n"
"Соответственно, запись @code{m} или @code{a} приводит к вызову функций\n"
"определенных в опции @code{#:slot-set!}.  Таким образом следующее\n"
"выражение"

#: /home/bear/work/guile/doc/guile/en/goops.texi:570
msgid ""
"@findex #:slot-set!\n"
"@findex #:slot-ref\n"
"@lisp\n"
"(slot-set! c 'a 3)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:573
msgid ""
"@noindent\n"
"permits to set the angle of the @code{c} complex number."
msgstr ""
"@noindent\n"
"позволяет установить угол комплексного числа @code{c}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:589
msgid ""
"@lisp\n"
"(define c (make <my-complex> #:r 12 #:i 20))\n"
"(real-part c) @result{} 12\n"
"(angle c) @result{} 1.03037682652431\n"
"(slot-set! c 'i 10)\n"
"(set! (real-part c) 1)\n"
"(describe c)\n"
"@print{}\n"
"#<<my-complex> 401e9b58> is an instance of class <my-complex>\n"
"Slots are: \n"
"     r = 1\n"
"     i = 10\n"
"     m = 10.0498756211209\n"
"     a = 1.47112767430373\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:593
msgid ""
"Since initialization keywords have been defined for the four slots, we\n"
"can now define the standard Scheme primitives @code{make-rectangular}\n"
"and @code{make-polar}."
msgstr ""
"Поскольку ключевые слова инициализации были определены для четырех слотов,\n"
"мы можем теперь определить стандартные примитивы Scheme @code{make-"
"rectangular}\n"
"и @code{make-polar}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:597
msgid ""
"@lisp\n"
"(define make-rectangular \n"
"   (lambda (x y) (make <my-complex> #:r x #:i y)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:601
msgid ""
"(define make-polar\n"
"   (lambda (x y) (make <my-complex> #:magn x #:angle y)))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:605
msgid ""
"@node Methods and Generic Functions\n"
"@section Methods and Generic Functions"
msgstr ""
"@node Methods and Generic Functions\n"
"@section Методы и Обобщенные Функции"

#: /home/bear/work/guile/doc/guile/en/goops.texi:609
msgid ""
"A GOOPS method is like a Scheme procedure except that it is specialized\n"
"for a particular set of argument classes, and will only be used when the\n"
"actual arguments in a call match the classes in the method definition."
msgstr ""
"Метод GOOPS похож на процедуру Scheme, за исключением того, что он "
"специализирован\n"
"для конкретного набора классов аргументов и будет использоваться только "
"тогда, когда\n"
"фактические аргументы в вызове совпадают с классами в определении метода."

#: /home/bear/work/guile/doc/guile/en/goops.texi:613
msgid ""
"@lisp\n"
"(define-method (+ (x <string>) (y <string>))\n"
"  (string-append x y))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:616
msgid ""
"(+ \"abc\" \"de\") @result{} \"abcde\"\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:625
msgid ""
"A method is not formally associated with any single class (as it is in\n"
"many other object oriented languages), because a method can be\n"
"specialized for a combination of several classes.  If you've studied\n"
"object orientation in non-Lispy languages, you may remember discussions\n"
"such as whether a method to stretch a graphical image around a surface\n"
"should be a method of the image class, with a surface as a parameter, or\n"
"a method of the surface class, with an image as a parameter.  In GOOPS\n"
"you'd just write"
msgstr ""
"Метод не формально связан с каким-либо одним классом (как и во многих\n"
"других объектно-ориентированных языках), поскольку метод может быть\n"
"специализирован для комбинации нескольких классов. Если вы изучали ООП\n"
"на примере не Лисп языков, вы можете помнить обсуждения, такие как метод\n"
"растягивания(stretch) графического изображения вокруг поверхности(surface)\n"
"должен быть методом класса изображения(image), с поверхностью(surface) в\n"
"качестве параметра, или методом класса поверхность(surface), с изображением\n"
"(image) в качестве параметра.  В GOOPS вы просто напишите:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:630
msgid ""
"@lisp\n"
"(define-method (stretch (im <image>) (sf <surface>))\n"
"  ...)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:634
msgid ""
"@noindent\n"
"and the question of which class the method is more associated with does\n"
"not need answering."
msgstr ""
"@noindent\n"
"и вопрос о том, к какому классу этот метод привязан, не нуждаеся в\n"
"ответе."

#: /home/bear/work/guile/doc/guile/en/goops.texi:637
msgid ""
"There can simultaneously be several methods with the same name but\n"
"different sets of specializing argument classes; for example:"
msgstr ""
"Одновременно может быть несколько методов с тем же именем, но разным\n"
"набором указанных аргументов классов; например:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:644
msgid ""
"@lisp\n"
"(define-method (+ (x <string>) (y <string)) ...)\n"
"(define-method (+ (x <matrix>) (y <matrix>)) ...)\n"
"(define-method (+ (f <fish>) (b <bicycle>)) ...)\n"
"(define-method (+ (a <foo>) (b <bar>) (c <baz>)) ...)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:648
msgid ""
"@noindent\n"
"A generic function is a container for the set of such methods that a\n"
"program intends to use."
msgstr ""
"@noindent\n"
"Обобщенная функция является контейнером для набора таких методов, которые\n"
"программа намерена использовать."

#: /home/bear/work/guile/doc/guile/en/goops.texi:658
msgid ""
"If you look at a program's source code, and see @code{(+ x y)} somewhere\n"
"in it, conceptually what is happening is that the program at that point\n"
"calls a generic function (in this case, the generic function bound to\n"
"the identifier @code{+}).  When that happens, Guile works out which of\n"
"the generic function's methods is the most appropriate for the arguments\n"
"that the function is being called with; then it evaluates the method's\n"
"code with the arguments as formal parameters.  This happens every time\n"
"that a generic function call is evaluated --- it isn't assumed that a\n"
"given source code call will end up invoking the same method every time."
msgstr ""
"Если вы посмотрите на исходный код программы и увидите где то в ней\n"
"@code{(+ x y)}, концептуально здесь происходит то, что программа в\n"
"этот момент вызывает обобщенную функцию (в этом случае, обобщенная функция\n"
"связана с идентификатором @code{+}).  Когда это происходит, Guile \n"
"разрбирается какой из методов обобщенной функции является наиболее "
"подходящим\n"
"для аргументов с которыми вызвана эта функция; после чего вычисляет этот\n"
"метод с аргументами как формальными параметрами метода.  Это происходит\n"
"каждый раз когда выполняется вызов обобщенной функции --- это не "
"предполагает,\n"
"что вызов данного исходного кода будет вызывать один и тот же метод\n"
"каждый раз."

#: /home/bear/work/guile/doc/guile/en/goops.texi:667
msgid ""
"Defining an identifier as a generic function is done with the\n"
"@code{define-generic} macro.  Definition of a new method is done with\n"
"the @code{define-method} macro.  Note that @code{define-method}\n"
"automatically does a @code{define-generic} if the identifier concerned\n"
"is not already a generic function, so often an explicit\n"
"@code{define-generic} call is not needed.\n"
"@findex define-generic\n"
"@findex define-method"
msgstr ""
"Определение идентификатора как обобщенной функции выполняется с помощью\n"
"макроса @code{define-generic}. Определение нового метода выполняется\n"
"с помощью макроса @code{define-method}.  Обратите внимание, что определение\n"
"метода @code{define-method} автоматически выполняет @code{define-generic},\n"
"если соответствующий идентификатор еще не является обобщенной функцией,\n"
"поэтому часто не требуется явно выраженного вызвова @code{define-generic}.\n"
"@findex define-generic\n"
"@findex define-method"

#: /home/bear/work/guile/doc/guile/en/goops.texi:676
msgid ""
"@deffn syntax define-generic symbol\n"
"Create a generic function with name @var{symbol} and bind it to the\n"
"variable @var{symbol}.  If @var{symbol} was previously bound to a Scheme\n"
"procedure (or procedure-with-setter), the old procedure (and setter) is\n"
"incorporated into the new generic function as its default procedure (and\n"
"setter).  Any other previous value, including an existing generic\n"
"function, is discarded and replaced by a new, empty generic function.\n"
"@end deffn"
msgstr ""
"@deffn syntax define-generic symbol\n"
"Создает обобщенную функцию с именем @var{symbol} и связывает ее с "
"переменной\n"
"@var{symbol}.  Если ранее @var{symbol} был связан с процедурой Scheme\n"
"procedure (или процедурой с устновщиком), старая процедура (и установщик) \n"
"включаются в новую обобщенную функцию как процедура по умолчанию(и "
"установщик).\n"
"Любое другое предыдущее значение, включая существующую обобщенную функцию,\n"
"отбрасывается и заменяется новой, пустой обобщенной функцией.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:680
msgid ""
"@deffn syntax define-method (generic parameter @dots{}) body @dots{}\n"
"Define a method for the generic function or accessor @var{generic} with\n"
"parameters @var{parameter}s and body @var{body} @enddots{}."
msgstr ""
"@deffn syntax define-method (generic parameter @dots{}) body @dots{}\n"
"Определяет метод для обобщенной функции или обобщенного аксессора "
"@var{generic} \n"
"параметрами @var{parameter} и телом @var{body} \n"
"@enddots{}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:688
msgid ""
"@var{generic} is a generic function.  If @var{generic} is a variable\n"
"which is not yet bound to a generic function object, the expansion of\n"
"@code{define-method} will include a call to @code{define-generic}.  If\n"
"@var{generic} is @code{(setter @var{generic-with-setter})}, where\n"
"@var{generic-with-setter} is a variable which is not yet bound to a\n"
"generic-with-setter object, the expansion will include a call to\n"
"@code{define-accessor}."
msgstr ""
"@var{generic} --- это Обобщенная функция.  Если @var{generic} это "
"переменная,\n"
"которая еще не связана с объектом обобщенной функции, расширение \n"
"@code{define-method} будет включать вызов @code{define-generic}.  Если\n"
"@var{generic} это @code{(setter @var{generic-with-setter})}, где\n"
"@var{generic-with-setter} это переменная еще не связанная с объктом\n"
"generic-with-setter, расширение будет включать вызов @code{define-accessor}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:695
msgid ""
"Each @var{parameter} must be either a symbol or a two-element list\n"
"@code{(@var{symbol} @var{class})}.  The symbols refer to variables in\n"
"the body forms that will be bound to the parameters supplied by the\n"
"caller when calling this method.  The @var{class}es, if present,\n"
"specify the possible combinations of parameters to which this method\n"
"can be applied."
msgstr ""
"Каждый @var{parameter} должен быть либо символом, либо двухэлементным\n"
"списком @code{(@var{symbol} @var{class})}.  Символы относятся к переменным\n"
"в теле форм, которые привязаны к параметрам предоставляемые вызывающим, при\n"
"вызове этого метода.  @var{class}, если он есть, указывают возможные\n"
"комбинации параметров, к которым может применяться этот метод"

#: /home/bear/work/guile/doc/guile/en/goops.texi:698
msgid ""
"@var{body} @dots{} are the bodies of the method definition.\n"
"@end deffn"
msgstr ""
"@var{body} @dots{} является телом определения метода.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:701
msgid ""
"@code{define-method} expressions look a little like Scheme procedure\n"
"definitions of the form"
msgstr ""
"@code{define-method} выражения немного напоминают форму определения\n"
"процедур Scheme"

#: /home/bear/work/guile/doc/guile/en/goops.texi:705
msgid ""
"@example\n"
"(define (name formals @dots{}) . body)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:715
msgid ""
"The important difference is that each formal parameter, apart from the\n"
"possible ``rest'' argument, can be qualified by a class name:\n"
"@code{@var{formal}} becomes @code{(@var{formal} @var{class})}.  The\n"
"meaning of this qualification is that the method being defined\n"
"will only be applicable in a particular generic function invocation if\n"
"the corresponding argument is an instance of @code{@var{class}} (or one of\n"
"its subclasses).  If more than one of the formal parameters is qualified\n"
"in this way, then the method will only be applicable if each of the\n"
"corresponding arguments is an instance of its respective qualifying class."
msgstr ""
"Важным отличием является то, что каждый формальный параметр, помимо\n"
"возможного аргумента ``rest'', может быть ограничен именем класса:\n"
"@code{@var{formal}} становиться @code{(@var{formal} @var{class})}.\n"
"Значение этого ограничения является то, что определяемый метод будет\n"
"применим только в конкретном вызове обобщенной функции, если "
"соответствующий\n"
"аргумент является экземпляром классса @code{@var{class}}(или одного из его\n"
"подклассов). Если более чем один из формальных параметров ограничен "
"подобным\n"
"образом, то метод будет применим только в том случае, если каждый из\n"
"соответствующих аргументов является экземпляром соответствующим указанному\n"
"классу."

#: /home/bear/work/guile/doc/guile/en/goops.texi:719
msgid ""
"Note that unqualified formal parameters act as though they are qualified\n"
"by the class @code{<top>}, which GOOPS uses to mean the superclass of\n"
"all valid Scheme types, including both primitive types and GOOPS classes."
msgstr ""
"Обратите внимание, что не ограниченные формальные параметры действуют\n"
"так, как если бы они были ограничены классом @code{<top>}, который GOOPS\n"
"использует для обозначения суперкласса всех допустимых типов Scheme,\n"
"включая примитивные типы и GOOPS классы."

#: /home/bear/work/guile/doc/guile/en/goops.texi:725
msgid ""
"For example, if a generic function method is defined with\n"
"@var{parameter}s @code{(s1 <square>)} and @code{(n <number>)}, that\n"
"method is only applicable to invocations of its generic function that\n"
"have two parameters where the first parameter is an instance of the\n"
"@code{<square>} class and the second parameter is a number."
msgstr ""
"Например, если метод обобщенной функции определен с "
"параметрами(@var{parameter})\n"
"@code{(s1 <square>)} и @code{(n <number>)}, этот метод применим только к\n"
"вызовам его обобщенной функции которые имеют два параметра, где первый "
"параметр\n"
"является экземпляром класса @code{<square>} и второй параметр\n"
"является числом."

#: /home/bear/work/guile/doc/guile/en/goops.texi:734
msgid ""
"@menu\n"
"* Accessors::\n"
"* Extending Primitives::\n"
"* Merging Generics::\n"
"* Next-method::                 \n"
"* Generic Function and Method Examples::                     \n"
"* Handling Invocation Errors::\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:738
msgid ""
"@node Accessors\n"
"@subsection Accessors"
msgstr ""
"@node Accessors\n"
"@subsection Аксессоры(методы доступа к значениям)"

#: /home/bear/work/guile/doc/guile/en/goops.texi:742
msgid ""
"An accessor is a generic function that can also be used with the\n"
"generalized @code{set!} syntax (@pxref{Procedures with Setters}).  Guile\n"
"will handle a call like"
msgstr ""
"Аксессор --- это обобщенная функция, которая может использоваться с "
"обобщенным\n"
"вызовом @code{set!} синтаксис (@pxref{Procedures with Setters}).  Guile\n"
"будет обрабатывать вызов как"

#: /home/bear/work/guile/doc/guile/en/goops.texi:746
msgid ""
"@example\n"
"(set! (@code{accessor} @code{args}@dots{}) @code{value})\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:751
msgid ""
"@noindent\n"
"by calling the most specialized method of @code{accessor} that matches\n"
"the classes of @code{args} and @code{value}.  @code{define-accessor} is\n"
"used to bind an identifier to an accessor."
msgstr ""
"@noindent\n"
"вызывая наиболее специализированный метод доступа(аксессор/@code{accessor})\n"
"соответствующий классам @code{args} и @code{value}.  @code{define-"
"accessor} \n"
"используется для привязки идентификатора к аксессору."

#: /home/bear/work/guile/doc/guile/en/goops.texi:761
msgid ""
"@deffn syntax define-accessor symbol\n"
"Create an accessor with name @var{symbol} and bind it to the variable\n"
"@var{symbol}.  If @var{symbol} was previously bound to a Scheme\n"
"procedure (or procedure-with-setter), the old procedure (and setter) is\n"
"incorporated into the new accessor as its default procedure (and\n"
"setter).  Any other previous value, including an existing generic\n"
"function or accessor, is discarded and replaced by a new, empty\n"
"accessor.\n"
"@end deffn"
msgstr ""
"@deffn syntax define-accessor symbol\n"
"Создает аксессор с именем @var{symbol} и связывает его с переменной\n"
"@var{symbol}.  Если @var{symbol} ранее был связан с процедурой Scheme\n"
"(илиr procedure-with-setter), старая процедура (и установщик) включается\n"
"в новый аксессор в качестве процедуры по умолчанию (и установщик).\n"
"Любое другое предыдущее значение, включая существующую обобщенную функцию\n"
"или акцессор заменяются новым, пустым аксессором.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:765
msgid ""
"@node Extending Primitives\n"
"@subsection Extending Primitives"
msgstr ""
"@node Extending Primitives\n"
"@subsection Расширение Примитивов"

#: /home/bear/work/guile/doc/guile/en/goops.texi:771
msgid ""
"Many of Guile's primitive procedures can be extended by giving them a\n"
"generic function definition that operates in conjunction with their\n"
"normal C-coded implementation.  When a primitive is extended in this\n"
"way, it behaves like a generic function with the C-coded implementation\n"
"as its default method."
msgstr ""
"Многие из примитивных процедур Guile можно расширить, предоставив им\n"
"обобщенную функцию которая работает в сочетании с их обычной Си-"
"кодированной\n"
"реализацией. Когда примитив расширяется таким образом, он ведет себя как\n"
"обобщенная функция с Си кодированным методом по умолчанию."

#: /home/bear/work/guile/doc/guile/en/goops.texi:776
msgid ""
"This extension happens automatically if a method is defined (by a\n"
"@code{define-method} call) for a variable whose current value is a\n"
"primitive.  But it can also be forced by calling\n"
"@code{enable-primitive-generic!}."
msgstr ""
"Это расширение происходит автоматически, если метод определен( вызовом\n"
"@code{define-method}) для переменной, текущее значение которой является\n"
"примитивным. Но его также можно выполнить принудительно вызвав\n"
"@code{enable-primitive-generic!}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:781
msgid ""
"@deffn {primitive procedure} enable-primitive-generic! primitive\n"
"Force the creation of a generic function definition for\n"
"@var{primitive}.\n"
"@end deffn"
msgstr ""
"@deffn {primitive procedure} enable-primitive-generic! primitive\n"
"Принудительное создание определения обобщенной функции для\n"
"@var{primitive}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:784
msgid ""
"Once the generic function definition for a primitive has been created,\n"
"it can be retrieved using @code{primitive-generic-generic}."
msgstr ""
"Как только было создано определение обобщенной функции для примитива,\n"
"оно может быть востановлено используя @code{primitive-generic-generic}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:787
msgid ""
"@deffn {primitive procedure} primitive-generic-generic primitive\n"
"Return the generic function definition of @var{primitive}."
msgstr ""
"@deffn {primitive procedure} primitive-generic-generic primitive\n"
"Возвращает обобщенной функции определение примитива @var{primitive}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:791
msgid ""
"@code{primitive-generic-generic} raises an error if @var{primitive}\n"
"is not a primitive with generic capability.\n"
"@end deffn"
msgstr ""
"@code{primitive-generic-generic} генерирует ошибку, если @var{primitive}\n"
"не является примитивом с обобщенным расширением.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:794
msgid ""
"@node Merging Generics\n"
"@subsection Merging Generics"
msgstr ""
"@node Merging Generics\n"
"@subsection Объединение Обобщенных функций"

#: /home/bear/work/guile/doc/guile/en/goops.texi:802
msgid ""
"GOOPS generic functions and accessors often have short, generic names.\n"
"For example, if a vector package provides an accessor for the X\n"
"coordinate of a vector, that accessor may just be called @code{x}.  It\n"
"doesn't need to be called, for example, @code{vector:x}, because\n"
"GOOPS will work out, when it sees code like @code{(x @var{obj})}, that\n"
"the vector-specific method of @code{x} should be called if @var{obj} is\n"
"a vector."
msgstr ""
"Обобщенные функции и аксессоры GOOPS часто имеют короткие, обобщенныые "
"имена.\n"
"Например, сли векторный пакет предоставляет аксессор для координаты X\n"
"вектора, этот аксессор может быть просто назван @code{x}.  Его не нужно\n"
"называть, например так, @code{vector:x}, потому что GOOPS будет работатт,\n"
"когда видит код, подобный @code{(x @var{obj})}, что должен быть ввызван\n"
"вектор-специфичный метод @code{x}, если @var{obj} это вектор."

#: /home/bear/work/guile/doc/guile/en/goops.texi:808
msgid ""
"That raises the question, though, of what happens when different\n"
"packages define a generic function with the same name.  Suppose we work\n"
"with a graphical package which needs to use two independent vector\n"
"packages for 2D and 3D vectors respectively.  If both packages export\n"
"@code{x}, what does the code using those packages end up with?"
msgstr ""
"Тем не менее возникает вопрос о том, что происходит когда разные\n"
"пакеты определяют обобщенную функцию с тем же именем. Предположим, мы\n"
"работаем с графическим пакетом, который должен использовать два \n"
"независимых векторных пакета для 2D и 3D векторов соответственно.\n"
"Если оба пакета экспортируют @code{x}, что делает код при\n"
"использовании этих пакетов?"

#: /home/bear/work/guile/doc/guile/en/goops.texi:814
msgid ""
"@ref{Creating Guile Modules,,duplicate binding handlers} explains how\n"
"this is resolved for conflicting bindings in general.  For generics,\n"
"there is a special duplicates handler, @code{merge-generics}, which\n"
"tells the module system to merge generic functions with the same name.\n"
"Here is an example:"
msgstr ""
"@ref{Creating Guile Modules,,duplicate binding handlers} объясняет,\n"
"как это разрешается для противоречивых привязок в общем. Для обобщенных,\n"
"существует специальный обработчик дубликатов, @code{merge-generics}, \n"
"который предписывает модульной системе объединить обобщенные функции с \n"
"одинаковыми именами.\n"
"Вот пример:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:819
msgid ""
"@lisp\n"
"(define-module (math 2D-vectors)\n"
"  #:use-module (oop goops)\n"
"  #:export (x y ...))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:823
msgid ""
"(define-module (math 3D-vectors)\n"
"  #:use-module (oop goops)\n"
"  #:export (x y z ...))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:830
msgid ""
"(define-module (my-module)\n"
"  #:use-module (oop goops)\n"
"  #:use-module (math 2D-vectors)\n"
"  #:use-module (math 3D-vectors)\n"
"  #:duplicates (merge-generics))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:833
msgid ""
"The generic function @code{x} in @code{(my-module)} will now incorporate\n"
"all of the methods of @code{x} from both imported modules."
msgstr ""
"Обобщенная функция @code{x}  в модуле @code{(my-module)} теперь будет "
"включать\n"
"все методы  @code{x} из обоих импортированных модулей."

#: /home/bear/work/guile/doc/guile/en/goops.texi:838
msgid ""
"To be precise, there will now be three distinct generic functions named\n"
"@code{x}: @code{x} in @code{(math 2D-vectors)}, @code{x} in @code{(math\n"
"3D-vectors)}, and @code{x} in @code{(my-module)}; and these functions\n"
"share their methods in an interesting and dynamic way."
msgstr ""
"Чтобы быть точным, теперь будут три различные обобщенные функции с именем\n"
"@code{x}: @code{x} в @code{(math 2D-vectors)}, @code{x} в @code{(math\n"
"3D-vectors)}, и @code{x} в @code{(my-module)}; и эти функции разделяют\n"
"их методы интересным и динамичным способом."

#: /home/bear/work/guile/doc/guile/en/goops.texi:846
msgid ""
"To explain, let's call the imported generic functions (in @code{(math\n"
"2D-vectors)} and @code{(math 3D-vectors)}) the @dfn{ancestors}, and the\n"
"merged generic function (in @code{(my-module)}), the @dfn{descendant}.\n"
"The general rule is that for any generic function G, the applicable\n"
"methods are selected from the union of the methods of G's descendant\n"
"functions, the methods of G itself and the methods of G's ancestor\n"
"functions."
msgstr ""
"Чтобы объяснить, давайте назовем импортированные обобщенные функции (в "
"@code{(math\n"
"2D-vectors)} и @code{(math 3D-vectors)}) предками(@dfn{ancestors}), и\n"
"объединенную обобщенную функцию (в @code{(my-module)}), "
"потомком(@dfn{descendant}).\n"
"Общее правило заключается в том, что для любой обобщенной функции G, "
"применимы\n"
"методы выбранные из объединения методов функций потомков G, сами методы G и\n"
"методы функций пердков G."

#: /home/bear/work/guile/doc/guile/en/goops.texi:855
msgid ""
"Thus ancestor functions effectively share methods with their\n"
"descendants, and vice versa.  In the example above, @code{x} in\n"
"@code{(math 2D-vectors)} will share the methods of @code{x} in\n"
"@code{(my-module)} and vice versa.@footnote{But note that @code{x} in\n"
"@code{(math 2D-vectors)} doesn't share methods with @code{x} in\n"
"@code{(math 3D-vectors)}, so modularity is still preserved.}  Sharing is\n"
"dynamic, so adding another new method to a descendant implies adding it\n"
"to that descendant's ancestors too."
msgstr ""
"Таким образом, функции предков эффективно делят методы с их потомками и\n"
"наоборот. В приведенном выше примере  @code{x} в\n"
"@code{(math 2D-vectors)} будет совместно использовать методы @code{x} в\n"
"@code{(my-module)} и наоборот. @footnote{Но обратите внимание, что @code{x}\n"
"в @code{(math 2D-vectors)} не разделяет методы с @code{x} в\n"
"@code{(math 3D-vectors)}, поэтому модульность сохраняется.}  Обмен "
"динамический,\n"
"поэтому добавление другого нового метода к потомству подразумевает "
"добавление\n"
"его к предкам потомка."

#: /home/bear/work/guile/doc/guile/en/goops.texi:858
msgid ""
"@node Next-method\n"
"@subsection Next-method"
msgstr ""
"@node Next-method\n"
"@subsection Next-method"

#: /home/bear/work/guile/doc/guile/en/goops.texi:865
msgid ""
"When you call a generic function, with a particular set of arguments,\n"
"GOOPS builds a list of all the methods that are applicable to those\n"
"arguments and orders them by how closely the method definitions match\n"
"the actual argument types.  It then calls the method at the top of this\n"
"list.  If the selected method's code wants to call on to the next method\n"
"in this list, it can do so by using @code{next-method}."
msgstr ""
"Когда вы вызываете обобщенную функцию с определенным набором аргументов,\n"
"GOOPS создает список всех методов, которые применимы к этим аргументам\n"
"и упорядочивает его, тем, насколько близко определение метода соответствует\n"
"фактическому типу аргументов. Затем он вызывает метод с верху этого списка.\n"
"Если код выбранного метода хочет вызвать следующий метод в этом списке,\n"
"он может это сделать используя @code{next-method}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:871
msgid ""
"@lisp\n"
"(define-method (Test (a <integer>)) (cons 'integer (next-method)))\n"
"(define-method (Test (a <number>))  (cons 'number  (next-method)))\n"
"(define-method (Test a)             (list 'top))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:873
msgid "With these definitions,"
msgstr "С этими определениями,"

#: /home/bear/work/guile/doc/guile/en/goops.texi:879
msgid ""
"@lisp\n"
"(Test 1)   @result{} (integer number top)\n"
"(Test 1.0) @result{} (number top)\n"
"(Test #t)  @result{} (top)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:883
msgid ""
"@code{next-method} is always called as just @code{(next-method)}.  The\n"
"arguments for the next method call are always implicit, and always the\n"
"same as for the original method call."
msgstr ""
"@code{next-method} всегда вызывается просто @code{(next-method)}.  "
"Аргументы\n"
"для вызова следующего метода всегда неявные и сегда те же, что и для вызова\n"
"исходного метода."

#: /home/bear/work/guile/doc/guile/en/goops.texi:888
msgid ""
"If you want to call on to a method with the same name but with a\n"
"different set of arguments (as you might with overloaded methods in C++,\n"
"for example), you do not use @code{next-method}, but instead simply\n"
"write the new call as usual:"
msgstr ""
"Если вы хотите вызвать метод с тем же именем, но с другим набором\n"
"аргументов( например, как вы можете  с перегруженными методами\n"
"Си++), не используйте  @code{next-method}, но в место этого просто\n"
"напишите новый вызов, как обычно:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:894
msgid ""
"@lisp\n"
"(define-method (Test (a <number>) min max)\n"
"  (if (and (>= a min) (<= a max))\n"
"      (display \"Number is in range\\n\"))\n"
"  (Test a))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:901
msgid ""
"(Test 2 1 10)\n"
"@print{}\n"
"Number is in range\n"
"@result{}\n"
"(integer number top)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:905
msgid ""
"(You should be careful in this case that the @code{Test} calls do not\n"
"lead to an infinite recursion, but this consideration is just the same\n"
"as in Scheme code in general.)"
msgstr ""
"(В этом случае вы должны быть осторожны, чтобы вызов @code{Test} не\n"
"привел к бесконечной рекурсии, но соображение такое же, как и в \n"
"любом коде Scheme.)"

#: /home/bear/work/guile/doc/guile/en/goops.texi:908
msgid ""
"@node Generic Function and Method Examples\n"
"@subsection Generic Function and Method Examples"
msgstr ""
"@node Generic Function and Method Examples\n"
"@subsection Примеры обобщенных функций и Методов"

#: /home/bear/work/guile/doc/guile/en/goops.texi:910
msgid "Consider the following definitions:"
msgstr "Рассмотрим следующие определения:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:917
msgid ""
"@lisp\n"
"(define-generic G)\n"
"(define-method (G (a <integer>) b) 'integer)\n"
"(define-method (G (a <real>) b) 'real)\n"
"(define-method (G a b) 'top)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:925
msgid ""
"The @code{define-generic} call defines @var{G} as a generic function.\n"
"The three next lines define methods for @var{G}.  Each method uses a\n"
"sequence of @dfn{parameter specializers} that specify when the given\n"
"method is applicable.  A specializer permits to indicate the class a\n"
"parameter must belong to (directly or indirectly) to be applicable.  If\n"
"no specializer is given, the system defaults it to @code{<top>}.  Thus,\n"
"the first method definition is equivalent to"
msgstr ""
"Вызов @code{define-generic} определяет  @var{G} как обобщенную функцию.\n"
"Три следующие строки определяют методы для @var{G}.  Каждый метод \n"
"использует последовательность специализированных параметров\n"
"(@dfn{parameter specializers}), которые определяют, когда данный\n"
"метод применим.  Специализатор позволяет указать класс применяемого\n"
"параметра, которому он должен принадлежать(напрямую или опосредованно).\n"
"Если специализатор не указан, система по умолчанию присваивает значение\n"
"@code{<top>}.  Таким образом, первое определение метода эквивалентно:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:930
msgid ""
"@cindex parameter specializers\n"
"@lisp\n"
"(define-method (G (a <integer>) (b <top>)) 'integer)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:932
msgid "Now, let's look at some possible calls to the generic function @var{G}:"
msgstr ""
"Теперь давайте рассмотрим некоторые возможные вызовы обобщенной\n"
"функции @var{G}:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:941
msgid ""
"@lisp\n"
"(G 2 3)    @result{} integer\n"
"(G 2 #t)   @result{} integer\n"
"(G 1.2 'a) @result{} real\n"
"@c (G #3 'a) @result{} real       @c was {\\sharpsign}\n"
"(G #t #f)  @result{} top\n"
"(G 1 2 3)  @result{} error (since no method exists for 3 parameters)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:945
msgid ""
"The methods above use only one specializer per parameter list.  But in\n"
"general, any or all of a method's parameters may be specialized.\n"
"Suppose we define now:"
msgstr ""
"Приведенные выше методы используют только один специализированный параметр\n"
"в списке параметров. Но в целом, любые или все параметры метода могут быть\n"
"специализированы. Предположим, что мы определим теперь:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:952
msgid ""
"@lisp\n"
"(define-method (G (a <integer>) (b <number>))  'integer-number)\n"
"(define-method (G (a <integer>) (b <real>))    'integer-real)\n"
"(define-method (G (a <integer>) (b <integer>)) 'integer-integer)\n"
"(define-method (G a (b <number>))              'top-number)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:954
msgid "@noindent With these definitions:"
msgstr "@noindent С этими определениями:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:961
msgid ""
"@lisp\n"
"(G 1 2)   @result{} integer-integer\n"
"(G 1 1.0) @result{} integer-real\n"
"(G 1 #t)  @result{} integer\n"
"(G 'a 1)  @result{} top-number\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:966
msgid ""
"As a further example we shall continue to define operations on the\n"
"@code{<my-complex>} class.  Suppose that we want to use it to implement\n"
"complex numbers completely.  For instance a definition for the addition\n"
"of two complex numbers could be"
msgstr ""
"В качестве дальнейшего примера мы продолжим определять операции над классом\n"
"@code{<my-complex>}.  Предположим, что мы хотим использовать его для полной\n"
"реализации комплексных чисел. Например, определение для сложения двух\n"
"комплексных чисел может быть"

#: /home/bear/work/guile/doc/guile/en/goops.texi:972
msgid ""
"@lisp\n"
"(define-method (new-+ (a <my-complex>) (b <my-complex>))\n"
"  (make-rectangular (+ (real-part a) (real-part b))\n"
"                    (+ (imag-part a) (imag-part b))))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:975
msgid ""
"To be sure that the @code{+} used in the method @code{new-+} is the\n"
"standard addition we can do:"
msgstr ""
"Чтобы убедиться, что метод @code{+} используемый в методе\n"
"@code{new-+} является стандартным суммированием мы можем\n"
"сделать:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:978
msgid ""
"@lisp\n"
"(define-generic new-+)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:984
msgid ""
"(let ((+ +))\n"
"  (define-method (new-+ (a <my-complex>) (b <my-complex>))\n"
"    (make-rectangular (+ (real-part a) (real-part b))\n"
"                      (+ (imag-part a) (imag-part b)))))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:990
msgid ""
"The @code{define-generic} ensures here that @code{new-+} will be defined\n"
"in the global environment. Once this is done, we can add methods to the\n"
"generic function @code{new-+} which make a closure on the @code{+}\n"
"symbol.  A complete writing of the @code{new-+} methods is shown in\n"
"@ref{fig:newplus}."
msgstr ""
"@code{define-generic} обеспечивает здесь, что @code{new-+} будет "
"определяться\n"
"в глобальном окружении. Как только это будет сделано, мы можем добавить\n"
"методы к обобщенной функции @code{new-+}, которые делают замыкание на символ "
"@code{+}.  \n"
"Полная запись метода @code{new-+} показана на @ref{fig:newplus}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:994
msgid ""
"@float Figure,fig:newplus\n"
"@lisp\n"
"(define-generic new-+)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:996
msgid "(let ((+ +))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:998
msgid "  (define-method (new-+ (a <real>) (b <real>)) (+ a b))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1001
msgid ""
"  (define-method (new-+ (a <real>) (b <my-complex>)) \n"
"    (make-rectangular (+ a (real-part b)) (imag-part b)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1004
msgid ""
"  (define-method (new-+ (a <my-complex>) (b <real>))\n"
"    (make-rectangular (+ (real-part a) b) (imag-part a)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1008
msgid ""
"  (define-method (new-+ (a <my-complex>) (b <my-complex>))\n"
"    (make-rectangular (+ (real-part a) (real-part b))\n"
"                      (+ (imag-part a) (imag-part b))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1010
msgid "  (define-method (new-+ (a <number>))  a)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1012
msgid "  (define-method (new-+) 0)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1016
msgid ""
"  (define-method (new-+ . args)\n"
"    (new-+ (car args) \n"
"      (apply new-+ (cdr args)))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1019
msgid ""
"(set! + new-+)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1022
msgid ""
"@caption{Extending @code{+} to handle complex numbers}\n"
"@end float"
msgstr ""
"@caption{Расширение @code{+} для обработки комплексных чисел}\n"
"@end float"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1036
msgid ""
"We take advantage here of the fact that generic function are not obliged\n"
"to have a fixed number of parameters.  The four first methods implement\n"
"dyadic addition.  The fifth method says that the addition of a single\n"
"element is this element itself.  The sixth method says that using the\n"
"addition with no parameter always return 0 (as is also true for the\n"
"primitive @code{+}).  The last method takes an arbitrary number of\n"
"parameters@footnote{The parameter list for a @code{define-method}\n"
"follows the conventions used for Scheme procedures. In particular it can\n"
"use the dot notation or a symbol to denote an arbitrary number of\n"
"parameters}.  This method acts as a kind of @code{reduce}: it calls the\n"
"dyadic addition on the @emph{car} of the list and on the result of\n"
"applying it on its rest.  To finish, the @code{set!} permits to redefine\n"
"the @code{+} symbol to our extended addition."
msgstr ""
"Мы используем тот факр, что обобщенная функция не обязана иметь "
"фиксированное\n"
"количество параметров. Четыре первых метода реализуют двухэлементное \n"
"суммирование. Пятый метод говорит что добавление одного элемента это сам\n"
"элемент. Шестой метод говорит, что использование добавления без параметра \n"
"всегда возвращает  0 (это верно и для примитива @code{+}). Последний метод\n"
"принимает произвольное количество параметров\n"
"parameters@footnote{The parameter list for a @code{define-method}\n"
"follows the conventions used for Scheme procedures. In particular it can\n"
"use the dot notation or a symbol to denote an arbitrary number of\n"
"parameters}.  Этот метод действует как @code{reduce}: он вызывает\n"
"двуэлементное суммирование для каждого элемента  @emph{car} из\n"
"списка и результата его последнего выполнения.  В завершении,\n"
"@code{set!} позволяет переопределить символ @code{+} нашему\n"
"расширенному дополнению."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1039
msgid ""
"To conclude our implementation (integration?) of complex numbers, we\n"
"could redefine standard Scheme predicates in the following manner:"
msgstr ""
"Чтобы завершить нашу реализацию  комплексных чисел, мы \n"
"могли бы переопределить стандартные предикаты Scheme следующим\n"
"образом:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1043
msgid ""
"@lisp\n"
"(define-method (complex? c <my-complex>) #t)\n"
"(define-method (complex? c)           #f)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1048
msgid ""
"(define-method (number? n <number>) #t)\n"
"(define-method (number? n)          #f)\n"
"@dots{}\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1051
msgid ""
"Standard primitives in which complex numbers are involved could also be\n"
"redefined in the same manner."
msgstr ""
"Стандартные примитивы, в которых задействованы комплексные числа, также "
"могут\n"
"быть переопределены в той же манере."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1055
msgid ""
"@node Handling Invocation Errors\n"
"@subsection Handling Invocation Errors"
msgstr ""
"@node Handling Invocation Errors\n"
"@subsection Обработка Ошибок Обращения"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1058
msgid ""
"If a generic function is invoked with a combination of parameters for\n"
"which there is no applicable method, GOOPS raises an error."
msgstr ""
"Если вызывается обобщенная функция с комбинацией параметров, для которых\n"
"нет применимого метода, GOOPS вызывает ошибку."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1066
msgid ""
"@deffn generic no-method\n"
"@deffnx method no-method (gf <generic>) args\n"
"When an application invokes a generic function, and no methods at all\n"
"have been defined for that generic function, GOOPS calls the\n"
"@code{no-method} generic function.  The default method calls\n"
"@code{goops-error} with an appropriate message.\n"
"@end deffn"
msgstr ""
"@deffn generic no-method\n"
"@deffnx method no-method (gf <generic>) args\n"
"Когда приложение вызывает обобщенную функцию, и никакие методы\n"
"не были определены для этой обобщенной функции, GOOPS вызывает\n"
"универсальную обобщенную функцию @code{no-method}.  По умолчанию\n"
"этот метод вызывает @code{goops-error} с сообщением об ошибке.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1074
msgid ""
"@deffn generic no-applicable-method\n"
"@deffnx method no-applicable-method (gf <generic>) args\n"
"When an application applies a generic function to a set of arguments,\n"
"and no methods have been defined for those argument types, GOOPS calls\n"
"the @code{no-applicable-method} generic function.  The default method\n"
"calls @code{goops-error} with an appropriate message.\n"
"@end deffn"
msgstr ""
"@deffn generic no-applicable-method\n"
"@deffnx method no-applicable-method (gf <generic>) args\n"
"Когда приложение применяет обобщенную функцию к набору аргументов и нет\n"
"метода который был бы определен для этих типов аргументов, GOOPS вызывает\n"
"обобщенную функцию @code{no-applicable-method}. Метод по умолчанию вызывает\n"
"@code{goops-error} с сообщением об ошибке.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1083
msgid ""
"@deffn generic no-next-method\n"
"@deffnx method no-next-method (gf <generic>) args\n"
"When a generic function method calls @code{(next-method)} to invoke the\n"
"next less specialized method for that generic function, and no less\n"
"specialized methods have been defined for the current generic function\n"
"arguments, GOOPS calls the @code{no-next-method} generic function.  The\n"
"default method calls @code{goops-error} with an appropriate message.\n"
"@end deffn"
msgstr ""
"@deffn generic no-next-method\n"
"@deffnx method no-next-method (gf <generic>) args\n"
"Когда метод обобщенной функции вызывает @code{(next-method)} для вызова\n"
"следующего менее специаизированного метода для этой обобщенной функции, и\n"
"нет менее специализированного метода определенного для данной обобщенной\n"
"функции для данного набора аргументов, GOOPS вызывает обобщенную функцию\n"
"@code{no-next-method}. Метод по умолчанию вызывает  @code{goops-error}\n"
"с соответствующим сообщением.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1087
msgid ""
"@node Inheritance\n"
"@section Inheritance"
msgstr ""
"@node Inheritance\n"
"@section Наследование"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1089
msgid "Here are some class definitions to help illustrate inheritance:"
msgstr ""
"Вот несколько определений классов, которые помогут проилюстрировать\n"
"наследование"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1098
msgid ""
"@lisp\n"
"(define-class A () a)\n"
"(define-class B () b)\n"
"(define-class C () c)\n"
"(define-class D (A B) d a)\n"
"(define-class E (A C) e c)\n"
"(define-class F (D E) f)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1109
msgid ""
"@code{A}, @code{B}, @code{C} have a null list of superclasses.  In this\n"
"case, the system will replace the null list by a list which only\n"
"contains @code{<object>}, the root of all the classes defined by\n"
"@code{define-class}.  @code{D}, @code{E}, @code{F} use multiple\n"
"inheritance: each class inherits from two previously defined classes.\n"
"Those class definitions define a hierarchy which is shown in\n"
"@ref{fig:hier}.  In this figure, the class @code{<top>} is also shown;\n"
"this class is the superclass of all Scheme objects.  In particular,\n"
"@code{<top>} is the superclass of all standard Scheme\n"
"types."
msgstr ""
"@code{A}, @code{B}, @code{C} имеют нулевой список суперклассов. В этом\n"
"случае, система заменит пустой список на список содержащий только\n"
"класс @code{<object>}, это корень всех классов определяемых вызовом\n"
"@code{define-class}.  @code{D}, @code{E}, @code{F} используют множественное\n"
"наследование: каждый класс наследуется от двух ранее определенных классов.\n"
"Т.е определения классов определяют иерархию, которая показана на \n"
"@ref{fig:hier}.  На этом рисунке так же показан класс @code{<top>};\n"
"этот класс является суперклассом всех объектов  Scheme.  В частности,\n"
"@code{<top>} является суперклассом для всех стандартных типов Scheme."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1117
msgid ""
"@float Figure,fig:hier\n"
"@iftex\n"
"@center @image{hierarchy,5in}\n"
"@end iftex\n"
"@ifnottex\n"
"@verbatiminclude hierarchy.txt\n"
"@end ifnottex"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1120
msgid ""
"@caption{A class hierarchy.}\n"
"@end float"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1126
msgid ""
"When a class has superclasses, its set of slots is calculated by taking\n"
"the union of its own slots and those of all its superclasses.  Thus each\n"
"instance of D will have three slots, @code{a}, @code{b} and\n"
"@code{d}). The slots of a class can be discovered using the\n"
"@code{class-slots} primitive.  For instance,"
msgstr ""
"Когда класс имеет суперклассы, его набор слотов вычисляется путем\n"
"объединения его собственных слотов и всех его суперклассов.\n"
"Таким образом, каждый экземпляр класса D будет иметь три слота,\n"
"@code{a}, @code{b} и @code{d}). Слоты класса могут быть просмотрены\n"
"с помощью примитива @code{class-slots}.  Для классов,"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1132
msgid ""
"@lisp\n"
"(class-slots A) @result{} ((a))\n"
"(class-slots E) @result{} ((a) (e) (c))\n"
"(class-slots F) @result{} ((e) (c) (b) (d) (a) (f))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1135
msgid ""
"@noindent\n"
"The ordering of the returned slots is not significant."
msgstr ""
"@noindent\n"
"Порядо вывода слотов не определен."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1140
msgid ""
"@menu\n"
"* Class Precedence List::\n"
"* Sorting Methods::\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1144
msgid ""
"@node Class Precedence List\n"
"@subsection Class Precedence List"
msgstr ""
"@node Class Precedence List\n"
"@subsection Список Старшинства(предшествования) Классов (Class Precedence "
"List)"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1152
msgid ""
"What happens when a class inherits from two or more superclasses that\n"
"have a slot with the same name but incompatible definitions --- for\n"
"example, different init values or slot allocations?  We need a rule for\n"
"deciding which slot definition the derived class ends up with, and this\n"
"rule is provided by the class's @dfn{Class Precedence\n"
"List}.@footnote{This section is an adaptation of material from Jeff\n"
"Dalton's (J.Dalton@@ed.ac.uk) @cite{Brief introduction to CLOS}}"
msgstr ""
"Что происходит, когда класс наследует от двух или более суперклассов,\n"
"имеющих слот с одним и темже именем, но с несовместимыми определениями\n"
"--- например, разными значениями инициализации или размещения слота?\n"
"Нам нужно правило для определения того, какое определение слота получит\n"
"производный класс, и это правило обеспечивается списком старшинства\n"
"классов. @dfn{Class Precedence List}.@footnote{Данная секция является\n"
"адаптацией материала Деффа Далтона (J.Dalton@@ed.ac.uk) \n"
"@cite{Brief introduction to CLOS}}"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1161
msgid ""
"Another problem arises when invoking a generic function, and there is\n"
"more than one method that could apply to the call arguments.  Here we\n"
"need a way of ordering the applicable methods, so that Guile knows which\n"
"method to use first, which to use next if that method calls\n"
"@code{next-method}, and so on.  One of the ingredients for this ordering\n"
"is determining, for each given call argument, which of the specializing\n"
"classes, from each applicable method's definition, is the most specific\n"
"for that argument; and here again the class precedence list helps."
msgstr ""
"Другая проблема возникает при вызове обобщенной функции, и есть более\n"
"одного метода, которые можно применить к аргументам вызова. Здесь нам\n"
"нужен способ упорядочения применения методов, так что бы Guile знал,\n"
"какой метод использовать первым, чтобы использовать следующий метод,\n"
"если этот метод вызывает @code{next-method}, и т.д. Одним из компонентов\n"
"определения этого порядка является определение для каждого заданного\n"
"аргумента вызова, котоыре из специализированных классов, из каждого\n"
"определения применимого метода являющегося наиболее специфичным для\n"
"этих аргументов, и здесь снова нам помогает список старшинства\n"
"классов."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1166
msgid ""
"If inheritance was restricted such that each class could only have one\n"
"superclass --- which is known as @dfn{single} inheritance --- class\n"
"ordering would be easy.  The rule would be simply that a subclass is\n"
"considered more specific than its superclass."
msgstr ""
"Если наследование было ограничено, так что каждый класс мог иметь только\n"
"один суперкласс --- также известное как одиночное @dfn{single} наследование\n"
"--- упорядочение классов было бы легким.  Правило было бы просто, что "
"подкласс\n"
"считается более конкретным, чем его суперкласс."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1169
msgid ""
"With multiple inheritance, ordering is less obvious, and we have to\n"
"impose an arbitrary rule to determine precedence. Suppose we have"
msgstr ""
"При множественном наследовании упорядочение менее очевидно, и мы\n"
"вынуждены определять правило для определения приоритета. Предопложим,\n"
"что мы имеем:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1173
msgid ""
"@lisp\n"
"(define-class X ()\n"
"   (x #:init-value 1))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1176
msgid ""
"(define-class Y ()\n"
"   (x #:init-value 2))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1180
msgid ""
"(define-class Z (X Y)\n"
"   (@dots{}))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1190
msgid ""
"@noindent\n"
"Clearly the @code{Z} class is more specific than @code{X} or @code{Y},\n"
"for instances of @code{Z}.  But which is more specific out of @code{X}\n"
"and @code{Y} --- and hence, for the definitions above, which\n"
"@code{#:init-value} will take effect when creating an instance of\n"
"@code{Z}?  The rule in @goops{} is that the superclasses listed earlier\n"
"are more specific than those listed later.  Hence @code{X} is more\n"
"specific than @code{Y}, and the @code{#:init-value} for slot @code{x} in\n"
"instances of @code{Z} will be 1."
msgstr ""
"@noindent\n"
"Очевидно, что @code{Z} класс является более конкретным(Старшим), чем\n"
"@code{X} или @code{Y}, для экземпляров @code{Z}. Но какой из классов\n"
"более конкретен(Старш) @code{X} или @code{Y} --- и, следовательно, для \n"
"определений выше, какое значение @code{#:init-value} вступит в силу\n"
"при создании экземпляра класса @code{Z}?  Правило @goops{} заключается\n"
"в том, что суперклассы перечисленные ранее, более конкретны(Старши), чем\n"
"перечисленные позднее. Следовательно @code{X} более конкретный(Старш) чем\n"
"@code{Y}, и значение @code{#:init-value} для слота @code{x} в\n"
"экземпляре @code{Z} будет равно 1."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1194
msgid ""
"Hence there is a linear ordering for a class and all its\n"
"superclasses, from most specific to least specific, and this ordering is\n"
"called the Class Precedence List of the class."
msgstr ""
"Следовательно, существует линейный порядок для класса и всех его "
"суперклассов,\n"
"от наименее конкретных к более конкретным, и этот порядок называется "
"Списком\n"
"Старшинства(Предшествования) Классов(Class Precedence List) класса."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1199
msgid ""
"In fact the rules above are not quite enough to always determine a\n"
"unique order, but they give an idea of how things work.  For example,\n"
"for the @code{F} class shown in @ref{fig:hier}, the class precedence\n"
"list is"
msgstr ""
"На самом деле вышеприведенных правил не достаточно, чтобы всегда определять\n"
"уникальный порядок, но они дают представление о том, как все работает.\n"
"Например, для класса @code{F} показанного на @ref{fig:hier}, список "
"старшинства\n"
"классов такой"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1203
msgid ""
"@example\n"
"(f d e a c b <object> <top>)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1209
msgid ""
"@noindent\n"
"In cases where there is any ambiguity (like this one), it is a bad idea\n"
"for programmers to rely on exactly what the order is.  If the order for\n"
"some superclasses is important, it can be expressed directly in the\n"
"class definition."
msgstr ""
"@noindent\n"
"В тех случаях, когда существует какая-либо двусмысленность(например, как "
"эта),\n"
"для программиста плохой идеей будет, полагаться именно на порядок. Если "
"порядок\n"
"для некоторых суперклассов важен , это может быть выражено непосредственно\n"
"в определении классов."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1213
msgid ""
"The precedence list of a class can be obtained by calling\n"
"@code{class-precedence-list}.  This function returns a ordered list\n"
"whose first element is the most specific class.  For instance:"
msgstr ""
"Список Старшинства Классов можно поличть, вызвав @code{class-precedence-"
"list}.\n"
"Эта функция возвращает упорядоченный список, первым элементом которого "
"является\n"
"наиболее Старший(конкретный) класс. Например:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1219
msgid ""
"@lisp\n"
"(class-precedence-list B) @result{} (#<<class> B 401b97c8> \n"
"                                     #<<class> <object> 401e4a10> \n"
"                                     #<<class> <top> 4026a9d8>)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1222
msgid ""
"@noindent\n"
"Or for a more immediately readable result:"
msgstr ""
"@noindent\n"
"или для более быстрого чтения:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1226
msgid ""
"@lisp\n"
"(map class-name (class-precedence-list B)) @result{} (B <object> <top>) \n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1230
msgid ""
"@node Sorting Methods\n"
"@subsection Sorting Methods"
msgstr ""
"@node Sorting Methods\n"
"@subsection Упорядочивание Методов"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1234
msgid ""
"Now, with the idea of the class precedence list, we can state precisely\n"
"how the possible methods are sorted when more than one of the methods of\n"
"a generic function are applicable to the call arguments."
msgstr ""
"Теперь, с идеей Списка Старшинста Классов, мы можем точно указать\n"
"как можно упорядочить методы, когда применимы более чем один из\n"
"методов обобщенной функции к аргументам вызова."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1241
msgid ""
"The rules are that\n"
"@itemize\n"
"@item\n"
"the applicable methods are sorted in order of specificity, and the most\n"
"specific method is used first, then the next if that method calls\n"
"@code{next-method}, and so on"
msgstr ""
"Правила таковы:\n"
"@itemize\n"
"@item\n"
"применяемые методы упорядочиваются по порядку конкретизации, а наиболее\n"
"конкретный метод используется вначале, а затем следующий, если этот метод\n"
"вызывает @code{next-method}, и т.д."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1247
msgid ""
"@item\n"
"a method M1 is more specific than another method M2 if the first\n"
"specializing class that differs, between the definitions of M1 and M2,\n"
"is more specific, in M1's definition, for the corresponding actual call\n"
"argument, than the specializing class in M2's definition"
msgstr ""
"@item\n"
"метод M1  более конкретен, чем другой метод М2, если первый "
"конкретизирующий\n"
"класс, который отличается, между определиниями M1 и M2,\n"
"более конкретен, в определении М1, для соответствующих фактических\n"
"аргументов вызова, чем конкретизирующий класс в определении M2"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1252
msgid ""
"@item\n"
"a class C1 is more specific than another class C2, for an object of\n"
"actual class C, if C1 comes before C2 in C's class precedence list.\n"
"@end itemize"
msgstr ""
"@item\n"
"Класс C1 более конкретен. чем другой класс C2, для объекта фактического\n"
"класса  C, если C1 предшествует(Старше) C2 в списке приоритетов класса C.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1256
msgid ""
"@node Introspection\n"
"@section Introspection"
msgstr ""
"@node Introspection\n"
"@section Интроспекция(Самонаблюдение у Классов- Introspection)"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1261
msgid ""
"@dfn{Introspection}, or @dfn{reflection}, means being able to obtain\n"
"information dynamically about GOOPS objects.  It is perhaps best\n"
"illustrated by considering an object oriented language that does not\n"
"provide any introspection, namely C++."
msgstr ""
"@dfn{Introspection}Интроспекция, или  @dfn{reflection}Рефлексия, означает\n"
"возможность динамического получения информации об объектах GOOPS.  Это\n"
"пожалуй лучше всего илюстрируется рассмотрением объектно-ориентированнго \n"
"языка который не обеспечивает никакой интроспекции, а именно Си++."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1264
msgid ""
"Nothing in C++ allows a running program to obtain answers to the following\n"
"types of question:"
msgstr ""
"Ничто в Си++ не позволяет программе получать ответы на следующие типы\n"
"вопросов:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1268
msgid ""
"@itemize @bullet\n"
"@item\n"
"What are the data members of this object or class?"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"Что представляют собой данные этого объекта или класса?"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1271
msgid ""
"@item\n"
"What classes does this class inherit from?"
msgstr ""
"@item\n"
"Какие классы наследует этот класс?"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1274
msgid ""
"@item\n"
"Is this method call virtual or non-virtual?"
msgstr ""
"@item\n"
"Этот метод метод является виртуальным или не виртуальным?"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1279
msgid ""
"@item\n"
"If I invoke @code{Employee::adjustHoliday()}, what class contains the\n"
"@code{adjustHoliday()} method that will be applied?\n"
"@end itemize"
msgstr ""
"@item\n"
"Если я вызываю @code{Employee::adjustHoliday()}, то какой класс\n"
"содержит метод @code{adjustHoliday()} который будет применяться?\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1284
msgid ""
"In C++, answers to such questions can only be determined by looking at\n"
"the source code, if you have access to it.  GOOPS, on the other hand,\n"
"includes procedures that allow answers to these questions --- or their\n"
"GOOPS equivalents --- to be obtained dynamically, at run time."
msgstr ""
"В Си++ ответы на эти вопросы могут быть даны только при просмотре\n"
"исходного кода, если у вас есть к нему доступ. С другой стороны, GOOPS\n"
"включает процедуры, позволяющие отвечать на эти вопросы - или их\n"
"эквиваленты GOOPS - динамическе, т.е во время работы."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1292
msgid ""
"@menu\n"
"* Classes::\n"
"* Instances::\n"
"* Slots::\n"
"* Generic Functions::\n"
"* Accessing Slots::\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1295
msgid ""
"@node Classes\n"
"@subsection Classes"
msgstr ""
"@node Classes\n"
"@subsection Классы"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1300
msgid ""
"A GOOPS class is itself an instance of the @code{<class>} class, or of a\n"
"subclass of @code{<class>}.  The definition of the @code{<class>} class\n"
"has slots that are used to describe the properties of a class, including\n"
"the following."
msgstr ""
"Класс GOOPS сам является экзепляром класса @code{<class>}, или подкласса\n"
"@code{<class>}.  Определение класса @code{<class>} имеет слоты, которые\n"
"используются для описания свойств класса, включая следующие."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1305
msgid ""
"@deffn {primitive procedure} class-name class\n"
"Return the name of class @var{class}.  This is the value of\n"
"@var{class}'s @code{name} slot.\n"
"@end deffn"
msgstr ""
"@deffn {primitive procedure} class-name class\n"
"Возвращает имя класса @var{class}.  Им является значение слота\n"
"@code{name} в @var{class}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1310
msgid ""
"@deffn {primitive procedure} class-direct-supers class\n"
"Return a list containing the direct superclasses of @var{class}.  This\n"
"is the value of @var{class}'s @code{direct-supers} slot.\n"
"@end deffn"
msgstr ""
"@deffn {primitive procedure} class-direct-supers class\n"
"Возвращет список, содержащий прямые суперклассы @var{class}. Это значение\n"
"слота @code{direct-supers} переменной @var{class}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1316
msgid ""
"@deffn {primitive procedure} class-direct-slots class\n"
"Return a list containing the slot definitions of the direct slots of\n"
"@var{class}.  This is the value of @var{class}'s @code{direct-slots}\n"
"slot.\n"
"@end deffn"
msgstr ""
"@deffn {primitive procedure} class-direct-slots class\n"
"Взвращает список, содержащий определения словтов непосредственно\n"
"заданных в @var{class}.  Это значение слота @code{direct-slots}\n"
"переменной @var{class}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1321
msgid ""
"@deffn {primitive procedure} class-direct-subclasses class\n"
"Return a list containing the direct subclasses of @var{class}.  This is\n"
"the value of @var{class}'s @code{direct-subclasses} slot.\n"
"@end deffn"
msgstr ""
"@deffn {primitive procedure} class-direct-subclasses class\n"
"возвращает список содержащий прямые подклассы класса @var{class}.  Это\n"
"значение слота @code{direct-subclasses} переменной @var{class}\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1327
msgid ""
"@deffn {primitive procedure} class-direct-methods class\n"
"Return a list of all the generic function methods that use @var{class}\n"
"as a formal parameter specializer.  This is the value of @var{class}'s\n"
"@code{direct-methods} slot.\n"
"@end deffn"
msgstr ""
"@deffn {primitive procedure} class-direct-methods class\n"
"возвращает список всех методов обобщенных функций, которые используют\n"
"класс @var{class} как формальный параметр конкретизации. Это значение\n"
"слота непосредственно определенных методов класса @code{direct-methods}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1332
msgid ""
"@deffn {primitive procedure} class-precedence-list class\n"
"Return the class precedence list for class @var{class} (@pxref{Class\n"
"Precedence List}).  This is the value of @var{class}'s @code{cpl} slot.\n"
"@end deffn"
msgstr ""
"@deffn {primitive procedure} class-precedence-list class\n"
"Возвращает список старшинства классов для класса @var{class} (@pxref{Class\n"
"Precedence List}).  Это значение слота @code{cpl} для @var{class}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1338
msgid ""
"@deffn {primitive procedure} class-slots class\n"
"Return a list containing the slot definitions for all @var{class}'s\n"
"slots, including any slots that are inherited from superclasses.  This\n"
"is the value of @var{class}'s @code{slots} slot.\n"
"@end deffn"
msgstr ""
"@deffn {primitive procedure} class-slots class\n"
"Возвращет список, содержащий определения слотов для всех слотов\n"
"класса, включая любые слоты, котрые наследуются от суперклассов. Это\n"
"значение слота @code{slots} в  @var{class}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1342
msgid ""
"@deffn procedure class-subclasses class\n"
"Return a list of all subclasses of @var{class}.\n"
"@end deffn"
msgstr ""
"@deffn procedure class-subclasses class\n"
"Возвращает список всех подклассов класса @var{class}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1347
msgid ""
"@deffn procedure class-methods class\n"
"Return a list of all methods that use @var{class} or a subclass of\n"
"@var{class} as one of its formal parameter specializers.\n"
"@end deffn"
msgstr ""
"@deffn procedure class-methods class\n"
"Возвращает список всех методов которые использует @var{class} или\n"
"подклассы @var{class}, как один из его формальных параметров\n"
"конкретизирующие параметры.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1351
msgid ""
"@node Instances\n"
"@subsection Instances"
msgstr ""
"@node Instances\n"
"@subsection Экземпляры(Instances)"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1355
msgid ""
"@deffn {primitive procedure} class-of value\n"
"Return the GOOPS class of any Scheme @var{value}.\n"
"@end deffn"
msgstr ""
"@deffn {primitive procedure} class-of value\n"
"Возвращает класс GOOPS для произвольного значения Scheme @var{value}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1360
msgid ""
"@deffn {primitive procedure} instance? object\n"
"Return @code{#t} if @var{object} is any GOOPS instance, otherwise\n"
"@code{#f}.\n"
"@end deffn"
msgstr ""
"@deffn {primitive procedure} instance? object\n"
"Возвращает @code{#t} если @var{object} является экземпляром\n"
"какого либо класса GOOPS, иначе @code{#f}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1365
msgid ""
"@deffn procedure is-a? object class\n"
"Return @code{#t} if @var{object} is an instance of @var{class} or one of\n"
"its subclasses.\n"
"@end deffn"
msgstr ""
"@deffn procedure is-a? object class\n"
"Взвращает @code{#t} если @var{object} является экземпляром класса\n"
"@var{class} или одного из его подклассов.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1372
msgid ""
"You can use the @code{is-a?} predicate to ask whether any given value\n"
"belongs to a given class, or @code{class-of} to discover the class of a\n"
"given value.  Note that when GOOPS is loaded (by code using the\n"
"@code{(oop goops)} module) built-in classes like @code{<string>},\n"
"@code{<list>} and @code{<number>} are automatically set up,\n"
"corresponding to all Guile Scheme types."
msgstr ""
"Вы можете использовать предикат @code{is-a?}, чтобы узнать, принадлежит\n"
"ли какое либо заданное значение данному классу, или @code{class-of} чтобы\n"
"узнать класс заданного значения. Обратите внимание, что при загрузке GOOPS\n"
"(код использующий модуль @code{(oop goops)}) встроенные классы, такие как\n"
"@code{<string>}, @code{<list>} и @code{<number>} автоматически "
"настраиваются,\n"
"соотвественно всем типам Guile Scheme."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1382
msgid ""
"@lisp\n"
"(is-a? 2.3 <number>) @result{} #t\n"
"(is-a? 2.3 <real>) @result{} #t\n"
"(is-a? 2.3 <string>) @result{} #f\n"
"(is-a? '(\"a\" \"b\") <string>) @result{} #f\n"
"(is-a? '(\"a\" \"b\") <list>) @result{} #t\n"
"(is-a? (car '(\"a\" \"b\")) <string>) @result{} #t\n"
"(is-a? <string> <class>) @result{} #t\n"
"(is-a? <class> <string>) @result{} #f"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1388
msgid ""
"(class-of 2.3) @result{} #<<class> <real> 908c708>\n"
"(class-of #(1 2 3)) @result{} #<<class> <vector> 908cd20>\n"
"(class-of <string>) @result{} #<<class> <class> 8bd3e10>\n"
"(class-of <class>) @result{} #<<class> <class> 8bd3e10>\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1392
msgid ""
"@node Slots\n"
"@subsection Slots"
msgstr ""
"@node Slots\n"
"@subsection Слоты(Slots)"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1397
msgid ""
"@deffn procedure class-slot-definition class slot-name\n"
"Return the slot definition for the slot named @var{slot-name} in class\n"
"@var{class}.  @var{slot-name} should be a symbol.\n"
"@end deffn"
msgstr ""
"@deffn procedure class-slot-definition class slot-name\n"
"Возвращает определение слота для слота с именем @var{slot-name} в классе\n"
"@var{class}.  @var{slot-name} должно быть символом.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1401
msgid ""
"@deffn procedure slot-definition-name slot-def\n"
"Extract and return the slot name from @var{slot-def}.\n"
"@end deffn"
msgstr ""
"@deffn procedure slot-definition-name slot-def\n"
"Извлекает и возвращает имя слота из @var{slot-def}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1405
msgid ""
"@deffn procedure slot-definition-options slot-def\n"
"Extract and return the slot options from @var{slot-def}.\n"
"@end deffn"
msgstr ""
"@deffn procedure slot-definition-options slot-def\n"
"Извлекает и возвращает параметры слота из @var{slot-def}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1412
msgid ""
"@deffn procedure slot-definition-allocation slot-def\n"
"Extract and return the slot allocation option from @var{slot-def}.  This\n"
"is the value of the @code{#:allocation} keyword (@pxref{Slot Options,,\n"
"allocation}), or @code{#:instance} if the @code{#:allocation} keyword is\n"
"absent.\n"
"@end deffn"
msgstr ""
"@deffn procedure slot-definition-allocation slot-def\n"
"Извлекает и возвращает параметры размещения из @var{slot-def}.  Это\n"
"значение ключевого слова @code{#:allocation} (@pxref{Slot Options,,\n"
"allocation}), или @code{#:instance} если ключевое слово @code{#:allocation}\n"
"отсутствует.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1418
msgid ""
"@deffn procedure slot-definition-getter slot-def\n"
"Extract and return the slot getter option from @var{slot-def}.  This is\n"
"the value of the @code{#:getter} keyword (@pxref{Slot Options,,\n"
"getter}), or @code{#f} if the @code{#:getter} keyword is absent.\n"
"@end deffn"
msgstr ""
"@deffn procedure slot-definition-getter slot-def\n"
"Извлекает и возвращает параметр getter из @var{slot-def}.  Это значение\n"
"ключевого слова @code{#:getter} (@pxref{Slot Options,,\n"
"getter}), или @code{#f} если ключевое слово @code{#:getter} не задано.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1424
msgid ""
"@deffn procedure slot-definition-setter slot-def\n"
"Extract and return the slot setter option from @var{slot-def}.  This is\n"
"the value of the @code{#:setter} keyword (@pxref{Slot Options,,\n"
"setter}), or @code{#f} if the @code{#:setter} keyword is absent.\n"
"@end deffn"
msgstr ""
"@deffn procedure slot-definition-setter slot-def\n"
"Извлекает и возвращает параметр слота setter из @var{slot-def}.  Это "
"значение\n"
"ключевого слова @code{#:setter} (@pxref{Slot Options,,\n"
"setter}), или @code{#f} если ключевое слово @code{#:setter} отсутствует.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1430
msgid ""
"@deffn procedure slot-definition-accessor slot-def\n"
"Extract and return the slot accessor option from @var{slot-def}.  This\n"
"is the value of the @code{#:accessor} keyword (@pxref{Slot Options,,\n"
"accessor}), or @code{#f} if the @code{#:accessor} keyword is absent.\n"
"@end deffn"
msgstr ""
"@deffn procedure slot-definition-accessor slot-def\n"
"Извлекает и возвращает параметр слота accessor из @var{slot-def}.  Это\n"
"значение ключевого слова @code{#:accessor} (@pxref{Slot Options,,\n"
"accessor}), или @code{#f} если ключевое слово @code{#:accessor} "
"отсутствует.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1437
msgid ""
"@deffn procedure slot-definition-init-value slot-def\n"
"Extract and return the slot init-value option from @var{slot-def}.  This\n"
"is the value of the @code{#:init-value} keyword (@pxref{Slot Options,,\n"
"init-value}), or the unbound value if the @code{#:init-value} keyword is\n"
"absent.\n"
"@end deffn"
msgstr ""
"@deffn procedure slot-definition-init-value slot-def\n"
"Извлекает и возвращает параметр слота начальное значение(init-value) из\n"
"@var{slot-def}.  Это значение ключевого слова @code{#:init-value}\n"
"(@pxref{Slot Options,,init-value}), или значение unbound если \n"
"ключевое слово @code{#:init-value} отсутствует.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1444
msgid ""
"@deffn procedure slot-definition-init-form slot-def\n"
"Extract and return the slot init-form option from @var{slot-def}.  This\n"
"is the value of the @code{#:init-form} keyword (@pxref{Slot Options,,\n"
"init-form}), or the unbound value if the @code{#:init-form} keyword is\n"
"absent.\n"
"@end deffn"
msgstr ""
"@deffn procedure slot-definition-init-form slot-def\n"
"Извлекает и возвращает опцию инициализации слота init-form из @var{slot-"
"def}.\n"
"Это значение ключевого слова @code{#:init-form} (@pxref{Slot Options,,\n"
"init-form}), или unbound если значение ключевого слова @code{#:init-form}\n"
"отсутствует.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1450
msgid ""
"@deffn procedure slot-definition-init-thunk slot-def\n"
"Extract and return the slot init-thunk option from @var{slot-def}.  This\n"
"is the value of the @code{#:init-thunk} keyword (@pxref{Slot Options,,\n"
"init-thunk}), or @code{#f} if the @code{#:init-thunk} keyword is absent.\n"
"@end deffn"
msgstr ""
"@deffn procedure slot-definition-init-thunk slot-def\n"
"Извлекает и возвращает опцию слота init-thunk из @var{slot-def}.  Это\n"
"значение ключевого слова @code{#:init-thunk} (@pxref{Slot Options,,\n"
"init-thunk}), или @code{#f} если ключевое слово @code{#:init-thunk}\n"
"отстутствует.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1457
msgid ""
"@deffn procedure slot-definition-init-keyword slot-def\n"
"Extract and return the slot init-keyword option from @var{slot-def}.\n"
"This is the value of the @code{#:init-keyword} keyword (@pxref{Slot\n"
"Options,, init-keyword}), or @code{#f} if the @code{#:init-keyword}\n"
"keyword is absent.\n"
"@end deffn"
msgstr ""
"@deffn procedure slot-definition-init-keyword slot-def\n"
"Извлекает и возвращает параметр слота init-keyword из @var{slot-def}.\n"
"Это значение ключевого слова @code{#:init-keyword} (@pxref{Slot\n"
"Options,, init-keyword}), или @code{#f} если ключевое слово @code{#:init-"
"keyword}\n"
"отсутствует.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1461
msgid ""
"@deffn procedure slot-init-function class slot-name\n"
"Return the initialization function for the slot named @var{slot-name} in\n"
"class @var{class}.  @var{slot-name} should be a symbol."
msgstr ""
"@deffn procedure slot-init-function class slot-name\n"
"Возвращает функцию инициализации для слота с именем @var{slot-name} в\n"
"классе @var{class}.  @var{slot-name} должно быть символом."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1470
msgid ""
"The returned initialization function incorporates the effects of the\n"
"standard @code{#:init-thunk}, @code{#:init-form} and @code{#:init-value}\n"
"slot options.  These initializations can be overridden by the\n"
"@code{#:init-keyword} slot option or by a specialized @code{initialize}\n"
"method, so, in general, the function returned by\n"
"@code{slot-init-function} may be irrelevant.  For a fuller discussion,\n"
"see @ref{Slot Options,, init-value}.\n"
"@end deffn"
msgstr ""
"Возвращенная функция инициализации включает эффекты стандартных\n"
"опциций слота @code{#:init-thunk}, @code{#:init-form} и @code{#:init-"
"value}.\n"
"Эти инициализации могут быть переопределены опцией слота @code{#:init-"
"keyword}\n"
"или специальным методом @code{initialize}, таким образом, в общем случае,\n"
"возвращаемая функцией @code{slot-init-function} может быть недостаточна.  \n"
"Более подробное обсуждение, см. @ref{Slot Options,, init-value}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1474
msgid ""
"@node Generic Functions\n"
"@subsection Generic Functions"
msgstr ""
"@node Generic Functions\n"
"@subsection обобщенные Функции(Generic Functions)"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1479
msgid ""
"A generic function is an instance of the @code{<generic>} class, or of a\n"
"subclass of @code{<generic>}.  The definition of the @code{<generic>}\n"
"class has slots that are used to describe the properties of a generic\n"
"function."
msgstr ""
"обобщенная функция является экземпляром класса @code{<generic>}, или "
"подкласса\n"
"@code{<generic>}.  Определение класса @code{<generic>} имеет слоты,\n"
"которые используются для описания свойств обобщенной функции."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1483
msgid ""
"@deffn {primitive procedure} generic-function-name gf\n"
"Return the name of generic function @var{gf}.\n"
"@end deffn"
msgstr ""
"@deffn {primitive procedure} generic-function-name gf\n"
"Возвращает имя обобщенной функции @var{gf}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1488
msgid ""
"@deffn {primitive procedure} generic-function-methods gf\n"
"Return a list of the methods of generic function @var{gf}.  This is the\n"
"value of @var{gf}'s @code{methods} slot.\n"
"@end deffn"
msgstr ""
"@deffn {primitive procedure} generic-function-methods gf\n"
"Возвращает список методов обобщенной функции @var{gf}.  Этот список\n"
"является значением слота @code{methods}  объекта @var{gf}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1492
msgid ""
"Similarly, a method is an instance of the @code{<method>} class, or of a\n"
"subclass of @code{<method>}; and the definition of the @code{<method>}\n"
"class has slots that are used to describe the properties of a method."
msgstr ""
"Аналогичным образом, метод является экземпляром класса @code{<method>}, или\n"
"подкласса @code{<method>}; и определение класса @code{<method>} имеет\n"
"слоты, которые используются для описания свойств метода."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1497
msgid ""
"@deffn {primitive procedure} method-generic-function method\n"
"Return the generic function that @var{method} belongs to.  This is the\n"
"value of @var{method}'s @code{generic-function} slot.\n"
"@end deffn"
msgstr ""
"@deffn {primitive procedure} method-generic-function method\n"
"Возвращает обобщенную функцию, к которой принадлежит метод(@var{method}). "
"Это\n"
"значение слота @var{method} обобщенной функции @code{generic-function}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1502
msgid ""
"@deffn {primitive procedure} method-specializers method\n"
"Return a list of @var{method}'s formal parameter specializers .  This is\n"
"the value of @var{method}'s @code{specializers} slot.\n"
"@end deffn"
msgstr ""
"@deffn {primitive procedure} method-specializers method\n"
"Возвращает список формальных параметров конкретизирующих метод "
"@var{method}. \n"
"Это значение слота @code{specializers} в  методе(@var{method}).\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1507
msgid ""
"@deffn {primitive procedure} method-procedure method\n"
"Return the procedure that implements @var{method}.  This is the value of\n"
"@var{method}'s @code{procedure} slot.\n"
"@end deffn"
msgstr ""
"@deffn {primitive procedure} method-procedure method\n"
"Возвращает процедуру, реализующую @var{method}.  Это значение слота "
"@code{procedure}\n"
"в методе(@var{method}).\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1512
msgid ""
"@deffn generic method-source\n"
"@deffnx method method-source (m <method>)\n"
"Return an expression that prints to show the definition of method\n"
"@var{m}."
msgstr ""
"@deffn generic method-source\n"
"@deffnx method method-source (m <method>)\n"
"Возвращает выражение для печати показывающее определение метода\n"
"@var{m}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1515
msgid ""
"@example\n"
"(define-generic cube)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1518
msgid ""
"(define-method (cube (n <number>))\n"
"  (* n n n))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1524
msgid ""
"(map method-source (generic-function-methods cube))\n"
"@result{}\n"
"((method ((n <number>)) (* n n n)))\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1528
msgid ""
"@node Accessing Slots\n"
"@subsection Accessing Slots"
msgstr ""
"@node Accessing Slots\n"
"@subsection Доступ к Слотам(Accessing Slots)"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1531
msgid ""
"Any slot, regardless of its allocation, can be queried, referenced and\n"
"set using the following four primitive procedures."
msgstr ""
"Любой слот, независимо от его размещения, может быть проверен, получен или\n"
"установлен с использованием следующих четырех процедур."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1536
msgid ""
"@deffn {primitive procedure} slot-exists? obj slot-name\n"
"Return @code{#t} if @var{obj} has a slot with name @var{slot-name},\n"
"otherwise @code{#f}.\n"
"@end deffn"
msgstr ""
"@deffn {primitive procedure} slot-exists? obj slot-name\n"
"Возвращает @code{#t} если объект @var{obj} имеет слот с именем @var{slot-"
"name},\n"
"иначе @code{#f}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1540
msgid ""
"@deffn {primitive procedure} slot-bound? obj slot-name\n"
"Return @code{#t} if the slot named @var{slot-name} in @var{obj} has a\n"
"value, otherwise @code{#f}."
msgstr ""
"@deffn {primitive procedure} slot-bound? obj slot-name\n"
"Возвращает @code{#t} если слот с именем @var{slot-name} в объекте @var{obj}\n"
"имеет значение, иначе @code{#f}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1545
msgid ""
"@code{slot-bound?} calls the generic function @code{slot-missing} if\n"
"@var{obj} does not have a slot called @var{slot-name} (@pxref{Accessing\n"
"Slots, slot-missing}).\n"
"@end deffn"
msgstr ""
"@code{slot-bound?} вызывает обобщенную функцию @code{slot-missing} если "
"объект\n"
"@var{obj} не имеет слота именуемого @var{slot-name} (@pxref{Accessing\n"
"Slots, slot-missing}).\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1548
msgid ""
"@deffn {primitive procedure} slot-ref obj slot-name\n"
"Return the value of the slot named @var{slot-name} in @var{obj}."
msgstr ""
"@deffn {primitive procedure} slot-ref obj slot-name\n"
"Возвращает значение слота с именем @var{slot-name} в объекте @var{obj}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1552
msgid ""
"@code{slot-ref} calls the generic function @code{slot-missing} if\n"
"@var{obj} does not have a slot called @var{slot-name} (@pxref{Accessing\n"
"Slots, slot-missing})."
msgstr ""
"@code{slot-ref} вызывает обобщенную функцию @code{slot-missing} если объект\n"
"@var{obj} не имеет слота называемого @var{slot-name} (@pxref{Accessing\n"
"Slots, slot-missing})."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1557
msgid ""
"@code{slot-ref} calls the generic function @code{slot-unbound} if the\n"
"named slot in @var{obj} does not have a value (@pxref{Accessing Slots,\n"
"slot-unbound}).\n"
"@end deffn"
msgstr ""
"@code{slot-ref} вызывает обобщенную функцию @code{slot-unbound} если "
"именуемый\n"
"слот объекта @var{obj} не имеет значения (@pxref{Accessing Slots,\n"
"slot-unbound}).\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1560
msgid ""
"@deffn {primitive procedure} slot-set! obj slot-name value\n"
"Set the value of the slot named @var{slot-name} in @var{obj} to @var{value}."
msgstr ""
"@deffn {primitive procedure} slot-set! obj slot-name value\n"
"Устанавливает значение слота с именем @var{slot-name} в объекте @var{obj} \n"
"значением @var{value}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1565
msgid ""
"@code{slot-set!} calls the generic function @code{slot-missing} if\n"
"@var{obj} does not have a slot called @var{slot-name} (@pxref{Accessing\n"
"Slots, slot-missing}).\n"
"@end deffn"
msgstr ""
"@code{slot-set!} вызывает обобщенную функцию @code{slot-missing} если "
"объект\n"
"@var{obj} не имеет слота именуемого @var{slot-name} (@pxref{Accessing\n"
"Slots, slot-missing}).\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1571
msgid ""
"GOOPS stores information about slots in classes.  Internally,\n"
"all of these procedures work by looking up the slot definition for the\n"
"slot named @var{slot-name} in the class @code{(class-of\n"
"@var{obj})}, and then using the slot definition's ``getter'' and\n"
"``setter'' closures to get and set the slot value."
msgstr ""
"GOOPS хранит информацию о слотах в классах. Внутренне все эти процедуры\n"
"работают проматривая определение слота для слота с именем @var{slot-name}\n"
"в классе @code{(class-of @var{obj})}, а затем используют определенные для\n"
"слотов функции доступа ``getter'' и ``setter'' чтобы получить или "
"установить\n"
"значение этих слотов."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1577
msgid ""
"The next four procedures differ from the previous ones in that they take\n"
"the class as an explicit argument, rather than assuming\n"
"@code{(class-of @var{obj})}.  Therefore they allow you to apply the\n"
"``getter'' and ``setter'' closures of a slot definition in one class to\n"
"an instance of a different class."
msgstr ""
"Следующие четыре процедуры отличаются от предыдущих, поскольку они\n"
"принимают класс как явный аргумент, а не предполагают @code{(class-of "
"@var{obj})}.  \n"
"Поэтому они позволяют применить замыкания ``getter'' и ``setter'' "
"определенные\n"
"слотами в одном классе к экземпляру другого класса."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1582
msgid ""
"@deffn {primitive procedure} slot-exists-using-class? class obj slot-name\n"
"Return @code{#t} if @var{class} has a slot definition for a slot with\n"
"name @var{slot-name}, otherwise @code{#f}.\n"
"@end deffn"
msgstr ""
"@deffn {primitive procedure} slot-exists-using-class? class obj slot-name\n"
"Возвращает @code{#t} если класс @var{class} имеет определение слота с "
"именем\n"
"@var{slot-name}, иначе @code{#f}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1587
msgid ""
"@deffn {primitive procedure} slot-bound-using-class? class obj slot-name\n"
"Return @code{#t} if applying @code{slot-ref-using-class} to the same\n"
"arguments would call the generic function @code{slot-unbound}, otherwise\n"
"@code{#f}."
msgstr ""
"@deffn {primitive procedure} slot-bound-using-class? class obj slot-name\n"
"Возвращет @code{#t} если применение функции @code{slot-ref-using-class} к\n"
"тем же аргументам вызовет обобщенную функцию @code{slot-unbound}, иначе\n"
"@code{#f}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1593
msgid ""
"@code{slot-bound-using-class?} calls the generic function\n"
"@code{slot-missing} if @var{class} does not have a slot definition for a\n"
"slot called @var{slot-name} (@pxref{Accessing Slots,\n"
"slot-missing}).\n"
"@end deffn"
msgstr ""
"@code{slot-bound-using-class?} вызывает обобщенную функцию\n"
"@code{slot-missing} если класс @var{class} не имеет определения слота для\n"
"слота с именем @var{slot-name} (@pxref{Accessing Slots,\n"
"slot-missing}).\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1597
msgid ""
"@deffn {primitive procedure} slot-ref-using-class class obj slot-name\n"
"Apply the ``getter'' closure for the slot named @var{slot-name} in\n"
"@var{class} to @var{obj}, and return its result."
msgstr ""
"@deffn {primitive procedure} slot-ref-using-class class obj slot-name\n"
"Применяет замыкание ``getter'' для слота с именем @var{slot-name} класса\n"
"@var{class} к объекту @var{obj}, и возвращает результат."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1602
msgid ""
"@code{slot-ref-using-class} calls the generic function\n"
"@code{slot-missing} if @var{class} does not have a slot definition for a\n"
"slot called @var{slot-name} (@pxref{Accessing Slots,\n"
"slot-missing})."
msgstr ""
"@code{slot-ref-using-class} вызывает обобщенную функцию @code{slot-missing}\n"
"если класс @var{class} не имеет определения определения слота с именем\n"
"@var{slot-name} (@pxref{Accessing Slots,\n"
"slot-missing})."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1608
msgid ""
"@code{slot-ref-using-class} calls the generic function\n"
"@code{slot-unbound} if the application of the ``getter'' closure to\n"
"@var{obj} returns an unbound value (@pxref{Accessing Slots,\n"
"slot-unbound}).\n"
"@end deffn"
msgstr ""
"@code{slot-ref-using-class} вызывает обобщенную функцию @code{slot-unbound}\n"
"если применение замыкания ``getter'' к объекту @var{obj} возвращает\n"
" значение unbound (@pxref{Accessing Slots,\n"
"slot-unbound}).\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1612
msgid ""
"@deffn {primitive procedure} slot-set-using-class! class obj slot-name "
"value\n"
"Apply the ``setter'' closure for the slot named @var{slot-name} in\n"
"@var{class} to @var{obj} and @var{value}."
msgstr ""
"@deffn {primitive procedure} slot-set-using-class! class obj slot-name "
"value\n"
"Применяет замыкание ``setter'' для слота с именем @var{slot-name} в классе\n"
"@var{class} объекта @var{obj} и новым значением @var{value}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1617
msgid ""
"@code{slot-set-using-class!} calls the generic function\n"
"@code{slot-missing} if @var{class} does not have a slot definition for a\n"
"slot called @var{slot-name} (@pxref{Accessing Slots, slot-missing}).\n"
"@end deffn"
msgstr ""
"@code{slot-set-using-class!} вызывает обобщенную функцию @code{slot-"
"missing}\n"
"если класс @var{class} не имеет определения слота с именем @var{slot-name}\n"
"(@pxref{Accessing Slots, slot-missing}).\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1620
msgid ""
"Slots whose allocation is per-class rather than per-instance can be\n"
"referenced and set without needing to specify any particular instance."
msgstr ""
"Слоты, чье размещение определено для класса, а не для каждого экземпляра,\n"
"можно ссылаться и устанавливать без необходимости указывать какой либо\n"
"конкретный экземпляр."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1625
msgid ""
"@deffn procedure class-slot-ref class slot-name\n"
"Return the value of the slot named @var{slot-name} in class @var{class}.\n"
"The named slot must have @code{#:class} or @code{#:each-subclass}\n"
"allocation (@pxref{Slot Options,, allocation})."
msgstr ""
"@deffn procedure class-slot-ref class slot-name\n"
"Возвращает значение слота с именем @var{slot-name} в классе @var{class}.\n"
"Именованный слот должен иметь распределение типа @code{#:class} или @code{#:"
"each-subclass}\n"
"(@pxref{Slot Options,, allocation})."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1632
msgid ""
"If there is no such slot with @code{#:class} or @code{#:each-subclass}\n"
"allocation, @code{class-slot-ref} calls the @code{slot-missing} generic\n"
"function with arguments @var{class} and @var{slot-name}.  Otherwise, if\n"
"the slot value is unbound, @code{class-slot-ref} calls the\n"
"@code{slot-unbound} generic function, with the same arguments.\n"
"@end deffn"
msgstr ""
"Если нет такого слота с кодом распределения @code{#:class} или @code{#:each-"
"subclass},\n"
"@code{class-slot-ref} вызывает обобщенную функцию @code{slot-missing} с "
"аргументами\n"
"@var{class} и @var{slot-name}.  Иначе, если значение слота не связано,\n"
"@code{class-slot-ref} вызывает обобщенную функцию @code{slot-unbound}, с "
"теми же\n"
"самыми аргументами.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1637
msgid ""
"@deffn procedure class-slot-set! class slot-name value\n"
"Set the value of the slot named @var{slot-name} in class @var{class} to\n"
"@var{value}.  The named slot must have @code{#:class} or\n"
"@code{#:each-subclass} allocation (@pxref{Slot Options,, allocation})."
msgstr ""
"@deffn procedure class-slot-set! class slot-name value\n"
"Задает значение слота с именем @var{slot-name} в классе @var{class} "
"значением\n"
"@var{value}.  Именованный слот должен иметь распределение типа @code{#:"
"class}\n"
"или @code{#:each-subclass} (@pxref{Slot Options,, allocation})."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1642
msgid ""
"If there is no such slot with @code{#:class} or @code{#:each-subclass}\n"
"allocation, @code{class-slot-ref} calls the @code{slot-missing} generic\n"
"function with arguments @var{class} and @var{slot-name}.\n"
"@end deffn"
msgstr ""
"Если он не имеет тип размещения @code{#:class} или @code{#:each-subclass},\n"
"@code{class-slot-ref} вызывает обобщенную функцию @code{slot-missing}\n"
"с аргументами @var{class} или @var{slot-name}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1646
msgid ""
"When a @code{slot-ref} or @code{slot-set!} call specifies a non-existent\n"
"slot name, or tries to reference a slot whose value is unbound, GOOPS\n"
"calls one of the following generic functions."
msgstr ""
"Когда вызов @code{slot-ref} или @code{slot-set!} указывает несуществующие\n"
"имя слота или пытается получить ссылку на слот, значение которого не \n"
"установлено, GOOPS вызывает одну из следующих обобщенных функций."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1654
msgid ""
"@deffn generic slot-missing\n"
"@deffnx method slot-missing (class <class>) slot-name\n"
"@deffnx method slot-missing (class <class>) (object <object>) slot-name\n"
"@deffnx method slot-missing (class <class>) (object <object>) slot-name "
"value\n"
"When an application attempts to reference or set a class or instance\n"
"slot by name, and the slot name is invalid for the specified @var{class}\n"
"or @var{object}, GOOPS calls the @code{slot-missing} generic function."
msgstr ""
"@deffn generic slot-missing\n"
"@deffnx method slot-missing (class <class>) slot-name\n"
"@deffnx method slot-missing (class <class>) (object <object>) slot-name\n"
"@deffnx method slot-missing (class <class>) (object <object>) slot-name "
"value\n"
"Когда приложение пытается ссылаться или устанавливать слот класса или "
"экземпляра\n"
"по имени и с недопустимым именем слота для данного класса @var{class} или "
"объекта\n"
"@var{object}, GOOPS вызывает обобщенную функцию @code{slot-missing}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1658
msgctxt "/home/bear/work/guile/doc/guile/en/goops.texi:1658"
msgid ""
"The default methods all call @code{goops-error} with an appropriate\n"
"message.\n"
"@end deffn"
msgstr ""
"По умолчанию все методы вызывают @code{goops-error} с соответствюущим \n"
"сообщением.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1666
msgid ""
"@deffn generic slot-unbound\n"
"@deffnx method slot-unbound (object <object>)\n"
"@deffnx method slot-unbound (class <class>) slot-name\n"
"@deffnx method slot-unbound (class <class>) (object <object>) slot-name\n"
"When an application attempts to reference a class or instance slot, and\n"
"the slot's value is unbound, GOOPS calls the @code{slot-unbound} generic\n"
"function."
msgstr ""
"@deffn generic slot-unbound\n"
"@deffnx method slot-unbound (object <object>)\n"
"@deffnx method slot-unbound (class <class>) slot-name\n"
"@deffnx method slot-unbound (class <class>) (object <object>) slot-name\n"
"Когда приложение пытается ссылатья на слот класса или экземпляра, а слот\n"
"не имеет связанного значения, GOOPS вызывает обобщенную функцию\n"
"@code{slot-unbound}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1670
msgctxt "/home/bear/work/guile/doc/guile/en/goops.texi:1670"
msgid ""
"The default methods all call @code{goops-error} with an appropriate\n"
"message.\n"
"@end deffn"
msgstr ""
"По умолчанию все методы вызывают @code{goops-error} с соответствующим "
"сообщением.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1674
msgid ""
"@node GOOPS Error Handling\n"
"@section Error Handling"
msgstr ""
"@node GOOPS Error Handling\n"
"@section Обработка Ошибок"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1677
msgid ""
"The procedure @code{goops-error} is called to raise an appropriate error\n"
"by the default methods of the following generic functions:"
msgstr ""
"Процедура @code{goops-error} вызывается методами по умолчанию для "
"генерации \n"
"соответствующей ошибки следующими обобщенными функциями:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1681
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{slot-missing} (@pxref{Accessing Slots,, slot-missing})"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1684
msgid ""
"@item\n"
"@code{slot-unbound} (@pxref{Accessing Slots,, slot-unbound})"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1687
msgid ""
"@item\n"
"@code{no-method} (@pxref{Handling Invocation Errors,, no-method})"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1691
msgid ""
"@item\n"
"@code{no-applicable-method} (@pxref{Handling Invocation Errors,,\n"
"no-applicable-method})"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1696
msgid ""
"@item\n"
"@code{no-next-method} (@pxref{Handling Invocation Errors,,\n"
"no-next-method})\n"
"@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1700
msgid ""
"If you customize these functions for particular classes or metaclasses,\n"
"you may still want to use @code{goops-error} to signal any error\n"
"conditions that you detect."
msgstr ""
"Если вы настраиваете эти функции для определенных классов или метаклассов, \n"
"вы все равно можете захотеть использовать @code{goops-error}, чтобы\n"
"сигнализировать о любых обнаруженных ошибках."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1706
msgid ""
"@deffn procedure goops-error format-string arg @dots{}\n"
"Raise an error with key @code{goops-error} and error message constructed\n"
"from @var{format-string} and @var{arg} @enddots{}.  Error message\n"
"formatting is as done by @code{scm-error}.\n"
"@end deffn"
msgstr ""
"@deffn procedure goops-error format-string arg @dots{}\n"
"Выбрасывает ошибку с ключем @code{goops-error} и сообщением об ошибке,\n"
"построенному из @var{format-string} и аргументов @var{arg} @enddots{}.  \n"
"Форматирование сообщений об ошибках выполняется с помощью @code{scm-error}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1710
msgid ""
"@node GOOPS Object Miscellany\n"
"@section GOOPS Object Miscellany"
msgstr ""
"@node GOOPS Object Miscellany\n"
"@section Некоторые функции работы с Объектами GOOPS"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1713
msgid ""
"Here we cover some points about GOOPS objects that aren't substantial\n"
"enough to merit sections on their own."
msgstr ""
"Здесь мы рассмотрим некоторые моменты, касающиеся объектов GOOPS, которые\n"
"не достаточно существенны, что бы им посвятить отдельные разделы."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1715
msgid "@subheading Object Equality"
msgstr "@subheading Равенство Объектов"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1720
msgid ""
"When GOOPS is loaded, @code{eqv?}, @code{equal?} and @code{=} become\n"
"generic functions, and you can define methods for them, specialized for\n"
"your own classes, so as to control what the various kinds of equality\n"
"mean for your classes."
msgstr ""
"Когда GOOPS загружается, @code{eqv?}, @code{equal?} и @code{=} становятся\n"
"обобщенными функциями, и вы можете определять методы для них, "
"специалзированные\n"
"для ваших классов, чтобы контролировать то, как работают различные виды\n"
"равенств для ваших классов."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1728
msgid ""
"For example, the @code{assoc} procedure, for looking up an entry in an\n"
"alist, is specified as using @code{equal?} to determine when the car of\n"
"an entry in the alist is the same as the key parameter that @code{assoc}\n"
"is called with.  Hence, if you had defined a new class, and wanted to\n"
"use instances of that class as the keys in an alist, you could define a\n"
"method for @code{equal?}, for your class, to control @code{assoc}'s\n"
"lookup precisely."
msgstr ""
"Например, процедура @code{assoc}, для поиска записи в ассоциированном\n"
"списке alist, настроена на использование @code{equal?} для определения\n"
"когда  начало списка alist(car) совпадет с ключевым параметром, с которым\n"
"вызван @code{assoc}. Следовательно, если вы определили новый класс, и\n"
"хотите испольовать экземпляры этого класса в качестве ключей alist, вы\n"
"можете определить метод @code{equal?}, для вашего класса, чтобы точно\n"
"контролировать соответствие при работе @code{assoc}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1730
msgid "@subheading Cloning Objects"
msgstr "@subheading Клонирование Объектов"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1738
msgid ""
"@deffn generic shallow-clone\n"
"@deffnx method shallow-clone (self <object>)\n"
"Return a ``shallow'' clone of @var{self}.  The default method makes a\n"
"shallow clone by allocating a new instance and copying slot values from\n"
"self to the new instance.  Each slot value is copied either as an\n"
"immediate value or by reference.\n"
"@end deffn"
msgstr ""
"@deffn generic shallow-clone\n"
"@deffnx method shallow-clone (self <object>)\n"
"Возвращает ``поверхностную'' копию объекта(@var{self}).  По умолчанию метод\n"
"создает поверхностную копию размещающаую новый экземплфр и копируюя "
"значения\n"
"слотов из себя в новый экземпляр. Каждое значение слота копируется как "
"немедленное\n"
"значение или как ссылка.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1748
msgid ""
"@deffn generic deep-clone\n"
"@deffnx method deep-clone (self <object>)\n"
"Return a ``deep'' clone of @var{self}.  The default method makes a deep\n"
"clone by allocating a new instance and copying or cloning slot values\n"
"from self to the new instance.  If a slot value is an instance\n"
"(satisfies @code{instance?}), it is cloned by calling @code{deep-clone}\n"
"on that value.  Other slot values are copied either as immediate values\n"
"or by reference.\n"
"@end deffn"
msgstr ""
"@deffn generic deep-clone\n"
"@deffnx method deep-clone (self <object>)\n"
"Возвращает ``глубокую'' копию объекта(@var{self}).  По умолчанию метод\n"
"делающий глубокую копию выделяет место для нового экземпляра и копирует\n"
"или клонирует значение слотов от себе в новый экземпляр. Если значение\n"
"слота является экземпляром (удовлетворяет @code{instance?}), оно "
"клонируется\n"
"вызовом @code{deep-clone} с этим значением. Другие слоты копируются либо\n"
"как непосредственные значения, либо по ссылке.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1750
msgid "@subheading Write and Display"
msgstr "@subheading Write and Display"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1755
msgid ""
"@deffn {primitive generic} write object port\n"
"@deffnx {primitive generic} display object port\n"
"When GOOPS is loaded, @code{write} and @code{display} become generic\n"
"functions with special methods for printing"
msgstr ""
"@deffn {primitive generic} write object port\n"
"@deffnx {primitive generic} display object port\n"
"Когда GOOPS загружается, @code{write} и @code{display} становятся "
"обобщенными\n"
"функциями со специальными методами для печати"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1759
msgid ""
"@itemize @bullet\n"
"@item\n"
"objects - instances of the class @code{<object>}"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"objects - экземпляр класса @code{<object>}"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1762
msgid ""
"@item\n"
"foreign objects - instances of the class @code{<foreign-object>}"
msgstr ""
"@item\n"
"foreign objects - экземпляр класса @code{<foreign-object>}"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1765
msgid ""
"@item\n"
"classes - instances of the class @code{<class>}"
msgstr ""
"@item\n"
"classes - экземпляр класса @code{<class>}"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1768
msgid ""
"@item\n"
"generic functions - instances of the class @code{<generic>}"
msgstr ""
"@item\n"
"generic functions - экземпляр класса @code{<generic>}"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1772
msgid ""
"@item\n"
"methods - instances of the class @code{<method>}.\n"
"@end itemize"
msgstr ""
"@item\n"
"methods - экземпляр класса @code{<method>}.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1776
msgid ""
"@code{write} and @code{display} print non-GOOPS values in the same way\n"
"as the Guile primitive @code{write} and @code{display} functions.\n"
"@end deffn"
msgstr ""
"@code{write} и @code{display} печатают не-GOOPS значения, также как\n"
"примитивные Guile  функции @code{write} и @code{display}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1780
msgid ""
"In addition to the cases mentioned, you can of course define\n"
"@code{write} and @code{display} methods for your own classes, to\n"
"customize how instances of those classes are printed."
msgstr ""
"В дополнение к упомянутым случаям вы можете конечно определить\n"
"методы @code{write} и @code{display} для ваших классов, чтобы настроить, \n"
"как будут печататься экземпляры этих классов."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1784
msgid ""
"@node The Metaobject Protocol\n"
"@section The Metaobject Protocol"
msgstr ""
"@node The Metaobject Protocol\n"
"@section Метаобъектный Протокол"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1792
msgid ""
"At this point, we've said about as much as can be said about GOOPS\n"
"without having to confront the idea of the metaobject protocol.  There\n"
"are a couple more topics that could be discussed in isolation first ---\n"
"class redefinition, and changing the class of existing instances --- but\n"
"in practice developers using them will be advanced enough to want to\n"
"understand the metaobject protocol too, and will probably be using the\n"
"protocol to customize exactly what happens during these events."
msgstr ""
"До сего момента, мы говорили только о GOOPS, без сопоставления его\n"
"с идеей протокола метаобъектов. Есть еще несколько тем, которые могут\n"
"обсуждаться отдельно, первая - это переопределение класса, и вторая "
"изменение\n"
"класса  с существующими экземплярами, но на практике разработчики "
"использующие\n"
"их, должны быть достаточно продвинутыми, чтобы понять также и протокол\n"
"метаобъектов, и, вероятно, точно будут использовать этот протокол для "
"настройки\n"
"того, что должно происходить во время этих событий."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1797
msgid ""
"So let's plunge in.  GOOPS is based on a ``metaobject protocol'' (aka\n"
"``MOP'') derived from the ones used in CLOS (the Common Lisp Object\n"
"System), tiny-clos (a small Scheme implementation of a subset of CLOS\n"
"functionality) and STKlos."
msgstr ""
"Итак давайте начнем.  GOOPS основан на ``метаобъектном протоколе'' (также\n"
"известный как ``МОП'') производном из использумых в CLOS (the Common Lisp \n"
"Object System), tiny-clos (небольшая реализация Scheme подмножества "
"функций \n"
"CLOS) и STKlos."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1805
msgid ""
"The MOP underlies many possible GOOPS customizations --- such as\n"
"defining an @code{initialize} method to customize the initialization of\n"
"instances of an application-defined class --- and an understanding of\n"
"the MOP makes it much easier to explain such customizations in a precise\n"
"way.  And at a deeper level, understanding the MOP is a key part of\n"
"understanding GOOPS, and of taking full advantage of GOOPS' power, by\n"
"customizing the behaviour of GOOPS itself."
msgstr ""
"МОП лежит в основе многих возможных настроек GOOPS --- таких как "
"определение\n"
"метода @code{initialize} для настройки инициализации экземпляров "
"определенного\n"
"класса приложений и понимание МОП делает гораздо более легким объяснение "
"таких\n"
"настроек в правильном порядке. И на более глубоком уровне понимание МОП "
"является\n"
"ключевой частью понимания GOOPS, и также полного использования мощи GOOPS, "
"настройки\n"
"поведения самого  GOOPS."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1818
msgid ""
"@menu\n"
"* Metaobjects and the Metaobject Protocol::\n"
"* Metaclasses::\n"
"* MOP Specification::\n"
"* Instance Creation Protocol::\n"
"* Class Definition Protocol::\n"
"* Customizing Class Definition::\n"
"* Method Definition::\n"
"* Method Definition Internals::\n"
"* Generic Function Internals::\n"
"* Generic Function Invocation::\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1821
msgid ""
"@node Metaobjects and the Metaobject Protocol\n"
"@subsection Metaobjects and the Metaobject Protocol"
msgstr ""
"@node Metaobjects and the Metaobject Protocol\n"
"@subsection Метаобъекты и Метаобъектный Протокол(МОП)"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1831
msgid ""
"The building blocks of GOOPS are classes, slot definitions, instances,\n"
"generic functions and methods.  A class is a grouping of inheritance\n"
"relations and slot definitions.  An instance is an object with slots\n"
"that are allocated following the rules implied by its class's\n"
"superclasses and slot definitions.  A generic function is a collection\n"
"of methods and rules for determining which of those methods to apply\n"
"when the generic function is invoked.  A method is a procedure and a set\n"
"of specializers that specify the type of arguments to which the\n"
"procedure is applicable."
msgstr ""
"Основными строительными блоками GOOPS являются классы, определения слотов,\n"
"экзепляров, обобщенных функций и методов. Класс - это группировка отношений\n"
"наследования и определения слотов. Экземпляр объекта со слотами, которые\n"
"размещаются следуя правилам, предусмотренными суперклассами этого класса\n"
"и определениями слотов. Обобщенная функция представляет собой набор методов\n"
"и правил определения какой из этих методов применяется при вызове "
"обобщенной\n"
"функции. Метод представляет собой процедуру и набор спецификаторов "
"определяющих\n"
"тип аргументов, к которым применима процедура."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1838
msgid ""
"Of these entities, GOOPS represents classes, generic functions and\n"
"methods as ``metaobjects''.  In other words, the values in a GOOPS\n"
"program that describe classes, generic functions and methods, are\n"
"themselves instances (or ``objects'') of special GOOPS classes that\n"
"encapsulate the behaviour, respectively, of classes, generic functions,\n"
"and methods."
msgstr ""
"Из этих объектов, GOOPS представляет классы, обобщенные функции и методы\n"
"как ``метаобъекты''.  Другими словами, значения в программе GOOPS\n"
"описывающие классы, обобщенные функции и методы, сами являются экземплярами\n"
"(или ``объектами'') специальных классов GOOPS которые инкапсулируют "
"поведение\n"
"соответственно, классов, обобщенных функций и методов."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1845
msgid ""
"(The other two entities are slot definitions and instances.  Slot\n"
"definitions are not strictly instances, but every slot definition is\n"
"associated with a GOOPS class that specifies the behaviour of the slot\n"
"as regards accessibility and protection from garbage collection.\n"
"Instances are of course objects in the usual sense, and there is no\n"
"benefit from thinking of them as metaobjects.)"
msgstr ""
"(Другими двумя объектами являются определение слотов и экземпляры. "
"Определения\n"
"слотов не являются строго экземплярами, но каждое определение слота связано\n"
"с классом GOOPS, который определяет поведение слота в отношении доступности\n"
"и защиты от сборки мусора. Экземпляры, конечно, объекты в обычном смысле, и\n"
"нет никакой пользы от мысли о них как о метаобъектах.)"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1849
msgid ""
"The ``metaobject protocol'' (or ``MOP'') is the specification of the\n"
"generic functions which determine the behaviour of these metaobjects and\n"
"the circumstances in which these generic functions are invoked."
msgstr ""
"``Метаобъектный протокол'' (или ``МОП'') это спецификация обобщенных "
"функций,\n"
"которые определяют поведение этих метаобъектов и обстоятельств при которых\n"
"эти обобщенные функции вызываются."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1858
msgid ""
"For a concrete example of what this means, consider how GOOPS calculates\n"
"the set of slots for a class that is being defined using\n"
"@code{define-class}.  The desired set of slots is the union of the new\n"
"class's direct slots and the slots of all its superclasses.  But\n"
"@code{define-class} itself does not perform this calculation.  Instead,\n"
"there is a method of the @code{initialize} generic function that is\n"
"specialized for instances of type @code{<class>}, and it is this method\n"
"that performs the slot calculation."
msgstr ""
"В качесте конкретного примера того, что это означает, рассмотрим как\n"
"GOOPS вычисляет набор слотов для класса, который определяется с "
"использованием\n"
"@code{define-class}.  Желательным набором слотов является объединение "
"прямых\n"
"слотов и слотов всех его суперклассов. Но @code{define-class} сам не "
"выполняет\n"
"этот расчет. Вмето этого существует метод @code{initialize} обобщенной "
"функции\n"
"который специализирован для экземпляров типа @code{<class>}, и именно этот\n"
"метод выполняет расчет слотов."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1863
msgid ""
"@code{initialize} is a generic function which GOOPS calls whenever a new\n"
"instance is created, immediately after allocating memory for a new\n"
"instance, in order to initialize the new instance's slots.  The sequence\n"
"of steps is as follows."
msgstr ""
"@code{initialize} это обобщенная функция, которую GOOPS вызывает всякий "
"раз,\n"
"когда создается новый экземпляр, сразу после выделения памяти для нового\n"
"экземпляра, чтобы инициализировать слоты нового экземпляра. "
"Последовательность\n"
"шагов следующая."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1870
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{define-class} uses @code{make} to make a new instance of the\n"
"@code{<class>} class, passing as initialization arguments the\n"
"superclasses, slot definitions and class options that were specified in\n"
"the @code{define-class} form."
msgstr ""
"@itemize @bullet\n"
"@item\n"
"@code{define-class} использует @code{make} для создания нового экземпляра\n"
"класса @code{<class>}, передающегося как аргумент инициализации "
"суперкласса,\n"
"определения слотов и параметров класса, которые были указаны в форме\n"
"@code{define-class}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1875
msgid ""
"@item\n"
"@code{make} allocates memory for the new instance, and invokes the\n"
"@code{initialize} generic function to initialize the new instance's\n"
"slots."
msgstr ""
"@item\n"
"@code{make} выделяет память для нового экземпляра и вызывает обобщенную\n"
"функцию @code{initialize} для инициализации слотов нового экземляра."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1881
msgid ""
"@item\n"
"The @code{initialize} generic function applies the method that is\n"
"specialized for instances of type @code{<class>}, and this method\n"
"performs the slot calculation.\n"
"@end itemize"
msgstr ""
"@item\n"
"Обобщенная функция @code{initialize} применяет метод, который "
"специализирован\n"
"для экземпляров типа @code{<class>}, и этот метод выполняет расчет слотов.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1885
msgid ""
"In other words, rather than being hardcoded in @code{define-class}, the\n"
"default behaviour of class definition is encapsulated by generic\n"
"function methods that are specialized for the class @code{<class>}."
msgstr ""
"Другими словами, вместо того чтобы быть жестко закодированным в @code{define-"
"class},\n"
"поведение определения класса по умолчанию инкапсулируется методами "
"обобщенной\n"
"функции, которые специализируются для класса @code{<class>}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1896
msgid ""
"It is possible to create a new class that inherits from @code{<class>},\n"
"which is called a ``metaclass'', and to write a new @code{initialize}\n"
"method that is specialized for instances of the new metaclass.  Then, if\n"
"the @code{define-class} form includes a @code{#:metaclass} class option\n"
"whose value is the new metaclass, the class that is defined by the\n"
"@code{define-class} form will be an instance of the new metaclass rather\n"
"than of the default @code{<class>}, and will be defined in accordance\n"
"with the new @code{initialize} method.  Thus the default slot\n"
"calculation, as well as any other aspect of the new class's relationship\n"
"with its superclasses, can be modified or overridden."
msgstr ""
"Можно создать новый класс, который наследует от @code{<class>},\n"
"который называется ``метаклассом'', и написать новый метод "
"@code{initialize},\n"
"который специализирован для экземпляров нового метакласса. Затем, если "
"форма\n"
"@code{define-class} включает опцию класса @code{#:metaclass}, чье значение "
"это\n"
"новый метакласс, класс который будет определен формой @code{define-class}\n"
"будет экземпляром нового метакласса, а не стандартного @code{<class>}, и "
"будет\n"
"определен в соответствии с новым методом инициализации @code{initialize}.\n"
"Таким образом, расчет слотов по умолчанию, а также любой другой аспект "
"отношения\n"
"нового класса с его суперклассами может быть изменен или переопределен."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1902
msgid ""
"In a similar way, the behaviour of generic functions can be modified or\n"
"overridden by creating a new class that inherits from the standard\n"
"generic function class @code{<generic>}, writing appropriate methods\n"
"that are specialized to the new class, and creating new generic\n"
"functions that are instances of the new class."
msgstr ""
"Аналогичным образом, поведение обобщенных функций может быть изменено или\n"
"переопределено созданием нового класса, который наследуется от стандартного\n"
"класса обобщенных функций @code{<generic>}, написанием соответствующих "
"методов,\n"
"которые конкретизируются в новом классе, и создают новые обобщенные "
"функции,\n"
"являющиеся экземплярами нового класса обобщенных функций."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1907
msgid ""
"The same is true for method metaobjects.  And the same basic mechanism\n"
"allows the application class author to write an @code{initialize} method\n"
"that is specialized to their application class, to initialize instances\n"
"of that class."
msgstr ""
"То же самое верно и для метаобъектов методов. И тот же самый базовый\n"
"механизм применяется автором класса для написания метода @code{initialize}\n"
"который конкретизирован для применения их класса, чтобы инициализировать\n"
"экземпляры этого класса."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1914
msgid ""
"Such is the power of the MOP.  Note that @code{initialize} is just one\n"
"of a large number of generic functions that can be customized to modify\n"
"the behaviour of application objects and classes and of GOOPS itself.\n"
"Each following section covers a particular area of GOOPS functionality,\n"
"and describes the generic functions that are relevant for customization\n"
"of that area."
msgstr ""
"Такова мощь МОП.  Обратите внимание, что @code{initialize} это просто\n"
"одна из большого числа обобщенных функций, которые могут быть настроены\n"
"для изменения поведения объектов приложения и классов и самого GOOPS.\n"
"Каждый следующий раздел охватывает конкретную область функциональности "
"GOOPS,\n"
"и описывает обобщенные функции, которые имеют отношение к настройке этой\n"
"области."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1917
msgid ""
"@node Metaclasses\n"
"@subsection Metaclasses"
msgstr ""
"@node Metaclasses\n"
"@subsection Метаклассы"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1920
msgid ""
"A @dfn{metaclass} is the class of an object which represents a GOOPS\n"
"class.  Put more succinctly, a metaclass is a class's class."
msgstr ""
"Метакласс(@dfn{metaclass}) это класс, объекты которого представляют классы\n"
"GOOPS. Или более лаконично, метакласс это класс классов."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1924
msgid ""
"Most GOOPS classes have the metaclass @code{<class>} and, by default,\n"
"any new class that is created using @code{define-class} has the\n"
"metaclass @code{<class>}."
msgstr ""
"Большинство классов GOOPS имеют в качестве метакласса класс @code{<class>}\n"
"и по умолчанию, любой новый класс создаваемый с использованием @code{define-"
"class}\n"
"имеет в качестве метакласса класс @code{<class>}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1927
msgid ""
"But what does this really mean?  To find out, let's look in more detail\n"
"at what happens when a new class is created using @code{define-class}:"
msgstr ""
"Но что это значит?  Чтобы узнать, давайте подробнее рассмотрим, что "
"происходит\n"
"когда создается новый класс с помощью @code{define-class}:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1931
msgid ""
"@example\n"
"(define-class <my-class> (<object>) . slots)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1934
msgid ""
"@noindent\n"
"Guile expands this to something like:"
msgstr ""
"@noindent\n"
"Guile расширяет это до чего-то вроде:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1938
msgid ""
"@example\n"
"(define <my-class> (class (<object>) . slots))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1941
msgid ""
"@noindent\n"
"which in turn expands to:"
msgstr ""
"@noindent\n"
"который в свою очередь расширяется до:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1946
msgid ""
"@example\n"
"(define <my-class>\n"
"  (make <class> #:dsupers (list <object>) #:slots slots))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1952
msgid ""
"As this expansion makes clear, the resulting value of @code{<my-class>}\n"
"is an instance of the class @code{<class>} with slot values specifying\n"
"the superclasses and slot definitions for the class @code{<my-class>}.\n"
"(@code{#:dsupers} and @code{#:slots} are initialization keywords for the\n"
"@code{dsupers} and @code{dslots} slots of the @code{<class>} class.)"
msgstr ""
"Как видно из этого расширения, результирующее значение @code{<my-class>}\n"
"явлется экземпляром класса @code{<class>} со значениями слотов "
"определяемыми\n"
"суперклассами и определением слотов для класса  @code{<my-class>}.\n"
"(@code{#:dsupers} и @code{#:slots} являются ключевыми словами иницализации\n"
"для слотов @code{dsupers} и @code{dslots} в классе @code{<class>}.)"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1955
msgid ""
"Now suppose that you want to define a new class with a metaclass other\n"
"than the default @code{<class>}.  This is done by writing:"
msgstr ""
"Предположим теперь, что вы хотите определить новый класс с метаклассом,\n"
"отличным от стандартного @code{<class>}.  Это делается путем написания:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1961
msgid ""
"@example\n"
"(define-class <my-class2> (<object>)\n"
"   slot @dots{}\n"
"   #:metaclass <my-metaclass>)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1964
msgid ""
"@noindent\n"
"and Guile expands @emph{this} to something like:"
msgstr ""
"@noindent\n"
"и Guile расширяет это(@emph{this}) определение до чегото вроде:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1969
msgid ""
"@example\n"
"(define <my-class2>\n"
"  (make <my-metaclass> #:dsupers (list <object>) #:slots slots))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1975
msgid ""
"In this case, the value of @code{<my-class2>} is an instance of the more\n"
"specialized class @code{<my-metaclass>}.  Note that\n"
"@code{<my-metaclass>} itself must previously have been defined as a\n"
"subclass of @code{<class>}.  For a full discussion of when and how it is\n"
"useful to define new metaclasses, see @ref{MOP Specification}."
msgstr ""
"В этом случае значение @code{<my-class2>} является экземпляром более\n"
"специализированного класса @code{<my-metaclass>}.  Обратите внимание,\n"
"что сам @code{<my-metaclass>} должен быть предварительно определен как\n"
"подкласс класса @code{<class>}.  Для более полного обсуждения того,\n"
"когда и как полезно определять новые метаклассы, см. @ref{MOP Specification}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1977
msgid "Now let's make an instance of @code{<my-class2>}:"
msgstr "Теперь давайте создадим экземпляр @code{<my-class2>}:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:1981
msgid ""
"@example\n"
"(define my-object (make <my-class2> ...))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:1985
msgid ""
"All of the following statements are correct expressions of the\n"
"relationships between @code{my-object}, @code{<my-class2>},\n"
"@code{<my-metaclass>} and @code{<class>}."
msgstr ""
"Все последующие утверждения являются правильными выражениями \n"
"отношений между  @code{my-object}, @code{<my-class2>},\n"
"@code{<my-metaclass>} и @code{<class>}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1989
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{my-object} is an instance of the class @code{<my-class2>}."
msgstr ""
"@itemize @bullet\n"
"@item\n"
"@code{my-object} это экземпляр класса @code{<my-class2>}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1992
msgid ""
"@item\n"
"@code{<my-class2>} is an instance of the class @code{<my-metaclass>}."
msgstr ""
"@item\n"
"@code{<my-class2>} это экземпляр класса @code{<my-metaclass>}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1995
msgid ""
"@item\n"
"@code{<my-metaclass>} is an instance of the class @code{<class>}."
msgstr ""
"@item\n"
"@code{<my-metaclass>} это экземпляр класса @code{<class>}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:1998
msgid ""
"@item\n"
"The class of @code{my-object} is @code{<my-class2>}."
msgstr ""
"@item\n"
"Класс объекта @code{my-object} это @code{<my-class2>}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2001
msgid ""
"@item\n"
"The class of @code{<my-class2>} is @code{<my-metaclass>}."
msgstr ""
"@item\n"
"Класс объекта @code{<my-class2>} это @code{<my-metaclass>}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2005
msgid ""
"@item\n"
"The class of @code{<my-metaclass>} is @code{<class>}.\n"
"@end itemize"
msgstr ""
"@item\n"
"Класс объекта @code{<my-metaclass>} это @code{<class>}.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2009
msgid ""
"@node MOP Specification\n"
"@subsection MOP Specification"
msgstr ""
"@node MOP Specification\n"
"@subsection Спецификация МОП"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2014
msgid ""
"The aim of the MOP specification in this chapter is to specify all the\n"
"customizable generic function invocations that can be made by the standard\n"
"GOOPS syntax, procedures and methods, and to explain the protocol for\n"
"customizing such invocations."
msgstr ""
"Цель спецификации МОП в этой главе --- указать все настраиваемые обобщенные\n"
"функции вызовы которых могут выполняться стандартным синтаксисом GOOPS, \n"
"процедурами и методами, и объяснить протокол для настройки таких вызовов."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2022
msgid ""
"A generic function invocation is customizable if the types of the\n"
"arguments to which it is applied are not completely determined by the\n"
"lexical context in which the invocation appears.  For example, the\n"
"@code{(initialize @var{instance} @var{initargs})} invocation in the\n"
"default @code{make-instance} method is customizable, because the type of\n"
"the @code{@var{instance}} argument is determined by the class that was\n"
"passed to @code{make-instance}."
msgstr ""
"Вызовы обобщенных функций настраиваются, если типы аргументов, к которым\n"
"она применяется не полностью определяются лексическим контекстом, в котором\n"
"этот вызов появляется. Например, вызов инициализации\n"
"@code{(initialize @var{instance} @var{initargs})} по умолчанию метод\n"
"@code{make-instance} настраивается, поскольку тип аргумента  "
"@code{@var{instance}}\n"
"определяемый классом, передается  @code{make-instance}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2026
msgid ""
"(Whereas --- to give a counter-example --- the @code{(make <generic>\n"
"#:name ',name)} invocation in @code{define-generic} is not customizable,\n"
"because all of its arguments have lexically determined types.)"
msgstr ""
"(Тогда как --- даем контр-пример --- @code{(make <generic> #:name ',name)} \n"
"вызов в @code{define-generic} не настраивается, потому что все его "
"аргументы\n"
"лексически  определенные типы.)"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2030
msgid ""
"When using this rule to decide whether a given generic function invocation\n"
"is customizable, we ignore arguments that are expected to be handled in\n"
"method definitions as a single ``rest'' list argument."
msgstr ""
"При использовании этого правила для определения того, настраивается ли "
"данный\n"
"вызов обобщенной функции, мы игнорируем аргументы, которые, как ожидается,\n"
"будут обрабатываться в определениях методов как один списковый аргумент "
"``rest''."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2033
msgid ""
"For each customizable generic function invocation, the @dfn{invocation\n"
"protocol} is explained by specifying"
msgstr ""
"Для каждого настраиваемого вызова обобщенной функции, протокол вызова\n"
"(@dfn{invocation protocol}) разъясняется указанием:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2037
msgid ""
"@itemize @bullet\n"
"@item\n"
"what, conceptually, the applied method is intended to do"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"что, Концептуально, для чего предназначен применяемый метод"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2041
msgid ""
"@item\n"
"what assumptions, if any, the caller makes about the applied method's side\n"
"effects"
msgstr ""
"@item\n"
"какие предположения, если таковые имеются, вызывающий делает о побочных "
"эффктах\n"
"применяемого метода."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2045
msgid ""
"@item\n"
"what the caller expects to get as the applied method's return value.\n"
"@end itemize"
msgstr ""
"@item\n"
"что вызывающий ожидает получить в качестве возвращаемого значения \n"
"применяемого метода.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2049
msgid ""
"@node Instance Creation Protocol\n"
"@subsection Instance Creation Protocol"
msgstr ""
"@node Instance Creation Protocol\n"
"@subsection Протокол Создания Экземпляров"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2051
msgid "@code{make <class> . @var{initargs}} (method)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2055
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{allocate-instance @var{class} @var{initargs}} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2058
msgid ""
"The applied @code{allocate-instance} method should allocate storage for\n"
"a new instance of class @var{class} and return the uninitialized instance."
msgstr ""
"Применяемый метод @code{allocate-instance} должен выделять хранилище для\n"
"нового экземпляра класса @var{class} и вернуть не инициализированный "
"экзепляр."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2061
msgid ""
"@item\n"
"@code{initialize @var{instance} @var{initargs}} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2067
msgid ""
"@var{instance} is the uninitialized instance returned by\n"
"@code{allocate-instance}.  The applied method should initialize the new\n"
"instance in whatever sense is appropriate for its class.  The method's\n"
"return value is ignored.\n"
"@end itemize"
msgstr ""
"@var{instance} это не иницализированный экземпляр, возвращаемый \n"
"@code{allocate-instance}.  Применяемый метод должен инициализировать\n"
"новый экземпляр в любом смысле, подходящем для его класса. Возвращаемое\n"
"методом значение игнорируется.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2072
msgid ""
"@code{make} itself is a generic function.  Hence the @code{make}\n"
"invocation itself can be customized in the case where the new instance's\n"
"metaclass is more specialized than the default @code{<class>}, by\n"
"defining a @code{make} method that is specialized to that metaclass."
msgstr ""
"@code{make} сама является обобщенной функцией.  Следовательно сам вызов\n"
"@code{make} может быть настроен в зависимости от метакласса нового "
"экземпляра,\n"
"который является более специализированным чем класс по умолчанию "
"@code{<class>},\n"
"определением метода @code{make} специлизированного для этого метакласса."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2075
msgid ""
"Normally, however, the method for classes with metaclass @code{<class>}\n"
"will be applied.  This method calls two generic functions:"
msgstr ""
"Обычно, однако, применяется метод для классов с метаклассом @code{<class>}.\n"
"Этот метод вызывает две обобщенные функции:\n"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2079
msgid ""
"@itemize @bullet\n"
"@item\n"
"(allocate-instance @var{class} . @var{initargs})"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2083
msgid ""
"@item\n"
"(initialize @var{instance} . @var{initargs})\n"
"@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2088
msgid ""
"@code{allocate-instance} allocates storage for and returns the new\n"
"instance, uninitialized.  You might customize @code{allocate-instance},\n"
"for example, if you wanted to provide a GOOPS wrapper around some other\n"
"object programming system."
msgstr ""
"@code{allocate-instance} распределяет память для нового экземпляра и\n"
"возвращает новый экземпляр, не инициализированным. Вы можете настроить\n"
"@code{allocate-instance}, например, если вы хотите предоставить\n"
"GOOPS обертку вокруг некоторой другой объектной системы программирования.\n"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2095
msgid ""
"To do this, you would create a specialized metaclass, which would act as\n"
"the metaclass for all classes and instances from the other system.  Then\n"
"define an @code{allocate-instance} method, specialized to that\n"
"metaclass, which calls a Guile primitive C function (or FFI code), which\n"
"in turn allocates the new instance using the interface of the other\n"
"object system."
msgstr ""
"Для этого вы создадите специализированный метакласс, который будет "
"дейстовать\n"
"как метакласс для всех классов и экземпляров из другой системы. Затем\n"
"определяйте метод @code{allocate-instance}, специализированный для этого\n"
"метакласса, который вызывает примитив Guile Си функцию (или  код FFI), "
"который в \n"
"свою очередь, выделит паамять для нового экземпляра с использованием\n"
"интерфейса другой объектной системы."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2100
msgid ""
"In this case, for a complete system, you would also need to customize a\n"
"number of other generic functions like @code{make} and\n"
"@code{initialize}, so that GOOPS knows how to make classes from the\n"
"other system, access instance slots, and so on."
msgstr ""
"В этом случае для полной системы вам также потребуется настроить несколько\n"
"других обобщенных функций, таких как @code{make} и @code{initialize}, так\n"
"что GOOPS знает как создавать классы из другой системы, получать доступ к\n"
"слотам объектов, и т.д."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2104
msgid ""
"@code{initialize} initializes the instance that is returned by\n"
"@code{allocate-instance}.  The standard GOOPS methods perform\n"
"initializations appropriate to the instance class."
msgstr ""
"@code{initialize} инициализирует экземпляр, возвращаемый \n"
"@code{allocate-instance}.  Стадартный метод GOOPS выполняет\n"
"инициализацию, соответствующую классу экземпляра."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2111
msgid ""
"@itemize @bullet\n"
"@item\n"
"At the least specialized level, the method for instances of type\n"
"@code{<object>} performs internal GOOPS instance initialization, and\n"
"initializes the instance's slots according to the slot definitions and\n"
"any slot initialization keywords that appear in @var{initargs}."
msgstr ""
"@itemize @bullet\n"
"@item\n"
"На наименее специализированном уровне выполняется метод для экземпляров\n"
"типа @code{<object>} внутренняя инициализация экземпляра GOOPS, и\n"
"инициализирует слоты экземпляра в соответствии с определениями слотов\n"
"и любых ключевых слов иницализации слота, которые появляются в "
"@var{initargs}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2116
msgid ""
"@item\n"
"The method for instances of type @code{<class>} calls\n"
"@code{(next-method)}, then performs the class initializations described\n"
"in @ref{Class Definition Protocol}."
msgstr ""
"@item\n"
"Метод для экземпляров типа @code{<class>} вызывает\n"
"@code{(next-method)}, затем выполняет инициализацию класса, описанную в\n"
"разделе @ref{Class Definition Protocol}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2120
msgid ""
"@item\n"
"and so on for generic functions, methods, operator classes @dots{}\n"
"@end itemize"
msgstr ""
"@item\n"
"и т.д. для обобщенных функций, методов, операторов классов @dots{}\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2124
msgid ""
"Similarly, you can customize the initialization of instances of any\n"
"application-defined class by defining an @code{initialize} method\n"
"specialized to that class."
msgstr ""
"Аналогичным образом вы можете настроить инициализацию экземпляров любых\n"
"определенных в приложении классов определяя метод @code{initialize} \n"
"специализированный для этого класса."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2131
msgid ""
"Imagine a class whose instances' slots need to be initialized at\n"
"instance creation time by querying a database.  Although it might be\n"
"possible to achieve this a combination of @code{#:init-thunk} keywords\n"
"and closures in the slot definitions, it may be neater to write an\n"
"@code{initialize} method for the class that queries the database once\n"
"and initializes all the dependent slot values according to the results."
msgstr ""
"Представьте себе класс, чьи экземпляры должны быть инициализированы во \n"
"время создания экземпляра путем запросов к базе данных. Хотя это может\n"
"быть возможно, это сочетание ключевых слов @code{#:init-thunk} и замыкания\n"
"в определениях слота, возможно более аккуратно написать метод "
"@code{initialize}\n"
"для класса, который опрашивает базу данных один раз и инициализирует\n"
"все зависимые значения слотов в соответствии с результатами запроса."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2135
msgid ""
"@node Class Definition Protocol\n"
"@subsection Class Definition Protocol"
msgstr ""
"@node Class Definition Protocol\n"
"@subsection Протокол Определения Класса"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2138
msgid ""
"Here is a summary diagram of the syntax, procedures and generic\n"
"functions that may be involved in class definition."
msgstr ""
"Ниже приведена сводная диаграмма синтаксиса, процедур и обобщенных\n"
"функций, которые могут учавствовать в определении класса."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2141
msgid ""
"@noindent\n"
"@code{define-class} (syntax)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2145
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{class} (syntax)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2149
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{make-class} (procedure)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2153
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{ensure-metaclass} (procedure)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2156
msgid ""
"@item\n"
"@code{make @var{metaclass} @dots{}} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2160
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{allocate-instance} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2163
msgid ""
"@item\n"
"@code{initialize} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2167
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{compute-cpl} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2172
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{compute-std-cpl} (procedure)\n"
"@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2175
msgid ""
"@item\n"
"@code{compute-slots} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2178
msgid ""
"@item\n"
"@code{compute-get-n-set} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2181
msgid ""
"@item\n"
"@code{compute-getter-method} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2188
msgid ""
"@item\n"
"@code{compute-setter-method} (generic)\n"
"@end itemize\n"
"@end itemize\n"
"@end itemize\n"
"@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2191
msgid ""
"@item\n"
"@code{class-redefinition} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2195
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{remove-class-accessors} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2198
msgid ""
"@item\n"
"@code{update-direct-method!} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2203
msgid ""
"@item\n"
"@code{update-direct-subclass!} (generic)\n"
"@end itemize\n"
"@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2211
msgid ""
"Wherever a step above is marked as ``generic'', it can be customized,\n"
"and the detail shown below it is only ``correct'' insofar as it\n"
"describes what the default method of that generic function does.  For\n"
"example, if you write an @code{initialize} method, for some metaclass,\n"
"that does not call @code{next-method} and does not call\n"
"@code{compute-cpl}, then @code{compute-cpl} will not be called when a\n"
"class is defined with that metaclass. "
msgstr ""
"Каждый вышеописанный шаг обозначенный как  ``обобщенный(generic)'', может\n"
"быть настроен и детально покажем ниже как это сделать  "
"``правильно(correct)''\n"
"поскольку он описывает какой метод по умолчанию используется обобщенной "
"функцией.\n"
"Например, если вы пишете метод @code{initialize}, для некоторого "
"метакласса,\n"
"который не вызывает @code{next-method} и не вызывает @code{compute-cpl}, \n"
"тогда @code{compute-cpl} не будет вызван когда класс определяется с этим\n"
"метаклассом."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2214
msgid ""
"A @code{(define-class ...)} form (@pxref{Class Definition}) expands to\n"
"an expression which"
msgstr ""
"Форма @code{(define-class ...)}  (@pxref{Class Definition}) расшираяется до\n"
"выражения, которое:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2218
msgid ""
"@itemize @bullet\n"
"@item\n"
"checks that it is being evaluated only at top level"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"проверяет, что оно вычисляется только на верхнем уровне"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2221
msgid ""
"@item\n"
"defines any accessors that are implied by the @var{slot-definition}s"
msgstr ""
"@item\n"
"определяет любые аксессоры, которые подразумеваются определениями слотов\n"
"@var{slot-definition}"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2224
msgid ""
"@item\n"
"uses @code{class} to create the new class"
msgstr ""
"@item\n"
"использует @code{class} для создания нового класса"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2230
msgid ""
"@item\n"
"checks for a previous class definition for @var{name} and, if found,\n"
"handles the redefinition by invoking @code{class-redefinition}\n"
"(@pxref{Redefining a Class}).\n"
"@end itemize"
msgstr ""
"@item\n"
"проверяет предыдущее определение для класса с именем @var{name} и, если\n"
"оно найдено, обрабатывает переопределение путем вызова  @code{class-"
"redefinition}\n"
"(@pxref{Redefining a Class}).\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2238
msgid ""
"@deffn syntax class name (super @dots{}) @\n"
"              slot-definition @dots{} class-option @dots{}\n"
"Return a newly created class that inherits from @var{super}s, with\n"
"direct slots defined by @var{slot-definition}s and @var{class-option}s.\n"
"For the format of @var{slot-definition}s and @var{class-option}s, see\n"
"@ref{Class Definition,, define-class}.\n"
"@end deffn"
msgstr ""
"@deffn syntax class name (super @dots{}) @\n"
"              slot-definition @dots{} class-option @dots{}\n"
"Возвращает вновь созданный класс, который наследуется от @var{super}, с\n"
"непосредственно определенными слотами, определенными @var{slot-definition}\n"
"и @var{class-option}. Формат @var{slot-definition} и @var{class-option}, "
"см.\n"
"@ref{Class Definition,, define-class}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2240
msgid "@noindent @code{class} expands to an expression which"
msgstr "@noindent @code{class} расширяется до выражения, которое"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2248
msgid ""
"@itemize @bullet\n"
"@item\n"
"processes the class and slot definition options to check that they are\n"
"well-formed, to convert the @code{#:init-form} option to an\n"
"@code{#:init-thunk} option, to supply a default environment parameter\n"
"(the current top-level environment) and to evaluate all the bits that\n"
"need to be evaluated"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"обрабатывает параметры определения класса и слота, чтобы проверить\n"
"правильно ли они сформированы, чтобы конвертировать параметр \n"
"@code{#:init-form} в параметр @code{#:init-thunk}, поставляющий параметр\n"
"среды по умолчанию, (текущая среда верхнего уровня) и вычисляет все биты\n"
" которые необходимо вычислить."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2253
msgid ""
"@item\n"
"calls @code{make-class} to create the class with the processed and\n"
"evaluated parameters.\n"
"@end itemize"
msgstr ""
"@item\n"
"вызывает @code{make-class} для создания класса с обработанными и\n"
"вычисленными параметрами.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2261
msgid ""
"@deffn procedure make-class supers slots class-option @dots{}\n"
"Return a newly created class that inherits from @var{supers}, with\n"
"direct slots defined by @var{slots} and @var{class-option}s.  For the\n"
"format of @var{slots} and @var{class-option}s, see @ref{Class\n"
"Definition,, define-class}, except note that for @code{make-class},\n"
"@var{slots} is a separate list of slot definitions.\n"
"@end deffn"
msgstr ""
"@deffn procedure make-class supers slots class-option @dots{}\n"
"Возвращает вновь созданный класс, который наследуется от @var{supers}, с\n"
"непосредственно определенными слотами @var{slots} и @var{class-option}.  "
"Формат\n"
"определения слотов @var{slots} и @var{class-option}s, см @ref{Class\n"
"Definition,, define-class}, за исключением того, что для @code{make-class},\n"
"@var{slots} представляет собой отдельный список определения слотов.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2263
msgid "@noindent @code{make-class}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2269
msgid ""
"@itemize @bullet\n"
"@item\n"
"adds @code{<object>} to the @var{supers} list if @var{supers} is empty\n"
"or if none of the classes in @var{supers} have @code{<object>} in their\n"
"class precedence list"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"добавляет @code{<object>} в список @var{supers} если @var{supers} пустой "
"или\n"
"если ни один из классов в @var{supers} не имеет @code{<object>} в своем \n"
"списке старшинства классов."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2275
msgid ""
"@item\n"
"defaults the @code{#:environment}, @code{#:name} and @code{#:metaclass}\n"
"options, if they are not specified by @var{options}, to the current\n"
"top-level environment, the unbound value, and @code{(ensure-metaclass\n"
"@var{supers})} respectively"
msgstr ""
"@item\n"
"по умолчанию заданы параметры @code{#:environment}, @code{#:name} и\n"
"@code{#:metaclass}, если они не являются определенными в @var{options}, \n"
"в текущей среде верхнего уровня несвязанное значени и @code{(ensure-"
"metaclass\n"
"@var{supers})} соответственно"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2279
msgid ""
"@item\n"
"checks for duplicate classes in @var{supers} and duplicate slot names in\n"
"@var{slots}, and signals an error if there are any duplicates"
msgstr ""
"@item\n"
"проверяет наличие повторяющихся классов в @var{supers} и дублиурующиеся\n"
"имена слотов в @var{slots}, и сигнализирует об ошибке если имеются\n"
"дубликаты."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2284
msgid ""
"@item\n"
"calls @code{make}, passing the metaclass as the first parameter and all\n"
"other parameters as option keywords with values.\n"
"@end itemize"
msgstr ""
"@item\n"
"вызывает @code{make}, передает метакласс как первый параметр и все "
"остальные\n"
"параметры как ключевые слова со значениями.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2289
msgid ""
"@deffn procedure ensure-metaclass supers env\n"
"Return a metaclass suitable for a class that inherits from the list of\n"
"classes in @var{supers}.  The returned metaclass is the union by\n"
"inheritance of the metaclasses of the classes in @var{supers}."
msgstr ""
"@deffn procedure ensure-metaclass supers env\n"
"Возвращает метакласс, подходящий для класса, который наследуется от\n"
"списка классов в @var{supers}.  Возвращенный метакласс это объединение\n"
"наследуемых метаклассов из классов в @var{supers}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2293
msgid ""
"In the simplest case, where all the @var{supers} are straightforward\n"
"classes with metaclass @code{<class>}, the returned metaclass is just\n"
"@code{<class>}."
msgstr ""
"В простейшем случае, все the @var{supers} являются простыми классами\n"
"с метаклассом @code{<class>} и возвращаемый метакласс это просто\n"
"класс @code{<class>}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2299
msgid ""
"For a more complex example, suppose that @var{supers} contained one\n"
"class with metaclass @code{<operator-class>} and one with metaclass\n"
"@code{<foreign-object-class>}.  Then the returned metaclass would be a\n"
"class that inherits from both @code{<operator-class>} and\n"
"@code{<foreign-object-class>}."
msgstr ""
"Для более сложного примера предположим, что @var{supers} содержит\n"
"один класс с метаклассом @code{<operator-class>} и один класс\n"
"с метаклассом @code{<foreign-object-class>}.  Тогда возвращенный\n"
"метакласс будет классом, который наследуется от обоих метаклассов\n"
"от @code{<operator-class>} и от @code{<foreign-object-class>}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2302
msgid ""
"If @var{supers} is the empty list, @code{ensure-metaclass} returns the\n"
"default GOOPS metaclass @code{<class>}."
msgstr ""
"Если @var{supers} это пустой список, @code{ensure-metaclass} возвращает\n"
"метакласс  GOOPS по умолчанию, т.е. метакласс @code{<class>}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2306
msgid ""
"GOOPS keeps a list of the metaclasses created by\n"
"@code{ensure-metaclass}, so that each required type of metaclass only\n"
"has to be created once."
msgstr ""
"GOOPS хранит список метаклассов, созданных @code{ensure-metaclass},\n"
"так что каждый требуемый тип метакласса создается только один раз.\n"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2309
msgid ""
"The @code{env} parameter is ignored.\n"
"@end deffn"
msgstr ""
"Параметр @code{env} игнорируется.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2316
msgid ""
"@deffn generic make metaclass initarg @dots{}\n"
"@var{metaclass} is the metaclass of the class being defined, either\n"
"taken from the @code{#:metaclass} class option or computed by\n"
"@code{ensure-metaclass}.  The applied method must create and return the\n"
"fully initialized class metaobject for the new class definition.\n"
"@end deffn"
msgstr ""
"@deffn generic make metaclass initarg @dots{}\n"
"@var{metaclass} это метакласс класса, который определяется, либо берется\n"
"из опции класса @code{#:metaclass}, либо вычисляется с помощью \n"
"@code{ensure-metaclass}.  Применяемый метод должен создать и вернуть \n"
"полностью инициализированный метаобъект класса для определения нового "
"класса.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2323
msgid ""
"The @code{(make @var{metaclass} @var{initarg} @dots{})} invocation is a\n"
"particular case of the instance creation protocol covered in the\n"
"previous section.  It will create an class metaobject with metaclass\n"
"@var{metaclass}.  By default, this metaobject will be initialized by the\n"
"@code{initialize} method that is specialized for instances of type\n"
"@code{<class>}."
msgstr ""
"Вызов @code{(make @var{metaclass} @var{initarg} @dots{})} является частным\n"
"случаем протокола создания экземпляра, рассмотренный в предыдущем разделе.\n"
"Он создаст метаобъект класса с метаклассом @var{metaclass}.  По умолчанию\n"
"этот метаобъект будет инициализирован методом @code{initialize} "
"специализированный\n"
"для экземпляров типа @code{<class>}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2326
msgid ""
"The @code{initialize} method for classes (signature @code{(initialize\n"
"<class> initargs)}) calls the following generic functions."
msgstr ""
"Метод @code{initialize} для классов (signature @code{(initialize\n"
"<class> initargs)}) вызывает следующие обобщенные функции."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2330
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{compute-cpl @var{class}} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2337
msgid ""
"The applied method should compute and return the class precedence list\n"
"for @var{class} as a list of class metaobjects.  When @code{compute-cpl}\n"
"is called, the following @var{class} metaobject slots have all been\n"
"initialized: @code{name}, @code{direct-supers}, @code{direct-slots},\n"
"@code{direct-subclasses} (empty), @code{direct-methods}.  The value\n"
"returned by @code{compute-cpl} will be stored in the @code{cpl} slot."
msgstr ""
"Применяемый метод должен вычислить и вернуть список старшинства классов\n"
"для класса @var{class} как список метаобъектов классов. Когда вызывается\n"
"@code{compute-cpl} следующие слоты метаобъекта @var{class} должны быть\n"
"инициализированы:\n"
"@code{name}, @code{direct-supers}, @code{direct-slots},\n"
"@code{direct-subclasses} (empty), @code{direct-methods}.  Значение\n"
"возвращаемое @code{compute-cpl} будет храниться в слоте @code{cpl}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2340
msgid ""
"@item\n"
"@code{compute-slots @var{class}} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2348
msgid ""
"The applied method should compute and return the slots (union of direct\n"
"and inherited) for @var{class} as a list of slot definitions.  When\n"
"@code{compute-slots} is called, all the @var{class} metaobject slots\n"
"mentioned for @code{compute-cpl} have been initialized, plus the\n"
"following: @code{cpl}, @code{redefined} (@code{#f}), @code{environment}.\n"
"The value returned by @code{compute-slots} will be stored in the\n"
"@code{slots} slot."
msgstr ""
"Применяемый метод должен вычислять и возвращать слоты (объединение\n"
"прямых и наследуемых) для класса @var{class} как список определений\n"
"слотов.  Когда вызывается @code{compute-slots} все слоты метаобъекта\n"
"@var{class} упомянутые для @code{compute-cpl} должны быть инициализированы,\n"
"плюс следующие слоты: following: @code{cpl}, @code{redefined} \n"
"(@code{#f}), @code{environment}.\n"
"Значение возвращаемое @code{compute-slots} будет храниться в слоте\n"
"@code{slots}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2351
msgid ""
"@item\n"
"@code{compute-get-n-set @var{class} @var{slot-def}} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2361
msgid ""
"@code{initialize} calls @code{compute-get-n-set} for each slot computed\n"
"by @code{compute-slots}.  The applied method should compute and return a\n"
"pair of closures that, respectively, get and set the value of the specified\n"
"slot.  The get closure should have arity 1 and expect a single argument\n"
"that is the instance whose slot value is to be retrieved.  The set closure\n"
"should have arity 2 and expect two arguments, where the first argument is\n"
"the instance whose slot value is to be set and the second argument is the\n"
"new value for that slot.  The closures should be returned in a two element\n"
"list: @code{(list @var{get} @var{set})}."
msgstr ""
"@code{initialize} вызывает @code{compute-get-n-set} для каждого слота \n"
"вычисленного @code{compute-slots}.  Применяемый метод должен вычислить и \n"
"вернуть пару замыканий, которые соответственно, получают и устанавливают\n"
"значение указанного слота. get замыкание должно иметь арность 1 и ожидать\n"
"единственный аргумент, который является экземпляром слота, значение "
"которого\n"
"должно быть извлечено.  set замыкание должно иметь арность 2 и принимать\n"
"два аргумента, где первым аргументом является экземпляр слота значение "
"которого\n"
"должно быть установлено, а второй аргумент - новое значение для этого "
"слота.\n"
"Замыкания должны быть возвращены в виде списка из двух элементов: \n"
"@code{(list @var{get} @var{set})}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2366
msgid ""
"The closures returned by @code{compute-get-n-set} are stored as part of\n"
"the value of the @var{class} metaobject's @code{getters-n-setters} slot.\n"
"Specifically, the value of this slot is a list with the same number of\n"
"elements as there are slots in the class, and each element looks either like"
msgstr ""
"Замыкания возвращаемые @code{compute-get-n-set} сохраняются как часть\n"
"значения слота @code{getters-n-setters} метаобъекта @var{class}.\n"
"В частности, значение этого слота представляет собой список с тем же\n"
"количеством элементов, что и слоты в классе, и каждый элемент выглядит\n"
"так:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2370
msgid ""
"@example\n"
"@code{(@var{slot-name-symbol} @var{init-function} . @var{index})}\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2372
msgid "or like"
msgstr "или так:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2376
msgid ""
"@example\n"
"@code{(@var{slot-name-symbol} @var{init-function} @var{get} @var{set})}\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2382
msgid ""
"Where the get and set closures are replaced by @var{index}, the slot is\n"
"an instance slot and @var{index} is the slot's index in the underlying\n"
"structure: GOOPS knows how to get and set the value of such slots and so\n"
"does not need specially constructed get and set closures.  Otherwise,\n"
"@var{get} and @var{set} are the closures returned by @code{compute-get-n-"
"set}."
msgstr ""
"Где замыкания get и set заменяются индексом @var{index}, слот является\n"
"экземпляром слота и индекса @var{index} - индекс слота в базовой структуре:\n"
"GOOPS знает как получить и установить значение такого слота, и "
"следовательно,\n"
"не требуется специально конструировать get и set замыкания для этого "
"случая.\n"
"В противном случае замыкания @var{get} и @var{set} возвращаемые\n"
"@code{compute-get-n-set}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2386
msgid ""
"The structure of the @code{getters-n-setters} slot value is important when\n"
"understanding the next customizable generic functions that "
"@code{initialize}\n"
"calls@dots{}"
msgstr ""
"Структура значения слотов @code{getters-n-setters} важна при понимании\n"
"следующих настраиваемых обобщенных функций которые вызывает "
"@code{initialize}\n"
"@dots{}"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2389
msgid ""
"@item\n"
"@code{compute-getter-method @var{class} @var{gns}} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2401
msgid ""
"@code{initialize} calls @code{compute-getter-method} for each of the\n"
"class's slots (as determined by @code{compute-slots}) that includes a\n"
"@code{#:getter} or @code{#:accessor} slot option.  @var{gns} is the\n"
"element of the @var{class} metaobject's @code{getters-n-setters} slot\n"
"that specifies how the slot in question is referenced and set, as\n"
"described above under @code{compute-get-n-set}.  The applied method\n"
"should create and return a method that is specialized for instances of\n"
"type @var{class} and uses the get closure to retrieve the slot's value.\n"
"@code{initialize} uses @code{add-method!} to add the returned method to\n"
"the generic function named by the slot definition's @code{#:getter} or\n"
"@code{#:accessor} option."
msgstr ""
"@code{initialize} вызывает @code{compute-getter-method} для каждого\n"
"из слотов класса(определенных @code{compute-slots}), который включает\n"
"в себя опцию слота @code{#:getter} или @code{#:accessor}.  @var{gns} это\n"
"элемент метаобъекта класса @var{class} слот @code{getters-n-setters} "
"который\n"
"определяется как слот с запросами сслыки и установки, как описано выше, в\n"
"@code{compute-get-n-set}.  Применяемый метод должен создавать и возвращать\n"
"метод, который специализирован для экземпляров типа @var{class} и "
"использовать\n"
"get замыкание для получения значения слота.\n"
"@code{initialize} использует @code{add-method!} для добавления "
"возвращаемого\n"
"метода к обобщенной функции именуемой определением опции слота @code{#:"
"getter} или\n"
"@code{#:accessor}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2404
msgid ""
"@item\n"
"@code{compute-setter-method @var{class} @var{gns}} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2414
msgid ""
"@code{compute-setter-method} is invoked with the same arguments as\n"
"@code{compute-getter-method}, for each of the class's slots that includes\n"
"a @code{#:setter} or @code{#:accessor} slot option.  The applied method\n"
"should create and return a method that is specialized for instances of\n"
"type @var{class} and uses the set closure to set the slot's value.\n"
"@code{initialize} then uses @code{add-method!} to add the returned method\n"
"to the generic function named by the slot definition's @code{#:setter}\n"
"or @code{#:accessor} option.\n"
"@end itemize"
msgstr ""
"@code{compute-setter-method} вызывается с теми же аргументами, что и\n"
"@code{compute-getter-method}, для каждого слота класса, который включает\n"
"в себе опцию @code{#:setter} или @code{#:accessor}.  Применяемый метод\n"
"должен создать и вернуть метод, который специализирован для экземпляра\n"
"типа @var{class} и использовать замыкание set для установки значения слота.\n"
"@code{initialize} использует @code{add-method!} для добавления "
"возвращаемого\n"
"метода к обобщенной функции именуемой определением опции слота @code{#:"
"setter}\n"
"или @code{#:accessor}.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2417
msgid ""
"@node Customizing Class Definition\n"
"@subsection Customizing Class Definition"
msgstr ""
"@node Customizing Class Definition\n"
"@subsection Настройка Определения Класса"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2424
msgid ""
"If the metaclass of the new class is something more specialized than the\n"
"default @code{<class>}, then the type of @var{class} in the calls above\n"
"is more specialized than @code{<class>}, and hence it becomes possible\n"
"to define generic function methods, specialized for the new class's\n"
"metaclass, that can modify or override the default behaviour of\n"
"@code{initialize}, @code{compute-cpl} or @code{compute-get-n-set}."
msgstr ""
"Если метакласс нового класса является чем-то более специализированным,\n"
"чем стандартный класс @code{<class>}, то тип @var{class} в "
"вышеперечисленных\n"
"вызовах более специализирован чем @code{<class>}, и следовательно, он\n"
"может определить методы обобщенных функций, специализированные для \n"
"метакласса нового класса, которые могут изменить или отменять поведение\n"
"по умолчанию для @code{initialize}, @code{compute-cpl} или\n"
"@code{compute-get-n-set}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2433
msgid ""
"@code{compute-cpl} computes the class precedence list (``CPL'') for the\n"
"new class (@pxref{Class Precedence List}), and returns it as a list of\n"
"class objects.  The CPL is important because it defines a superclass\n"
"ordering that is used, when a generic function is invoked upon an\n"
"instance of the class, to decide which of the available generic function\n"
"methods is the most specific.  Hence @code{compute-cpl} could be\n"
"customized in order to modify the CPL ordering algorithm for all classes\n"
"with a special metaclass."
msgstr ""
"@code{compute-cpl} вычисляет список старшинства классов (``CPL'') для\n"
"нового класса (@pxref{Class Precedence List}), и возвращает его как\n"
"список объектов класса.  CPL важен, поскольку он определеят упорядочение\n"
"суперклассов, которые используются, когда обобщенная функция вызывается\n"
"для экземпляра класса, чтобы решить, какой из доступных методов обобщенной\n"
"функции является наиболее конкретным(подходящим).  Следовательно, \n"
"@code{compute-cpl} можно настроить в порядке изменения для изменения\n"
"алгоритма упорядочения CPL для всех классов со специальным метаклассом."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2436
msgid ""
"The default CPL algorithm is encapsulated by the @code{compute-std-cpl}\n"
"procedure, which is called by the default @code{compute-cpl} method."
msgstr ""
"Алгоритм CPL по умолчанию инкапсулируется процедурой @code{compute-std-"
"cpl},\n"
"которая вызывается методом по умолчанию @code{compute-cpl}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2441
msgid ""
"@deffn procedure compute-std-cpl class\n"
"Compute and return the class precedence list for @var{class} according\n"
"to the algorithm described in @ref{Class Precedence List}.\n"
"@end deffn"
msgstr ""
"@deffn procedure compute-std-cpl class\n"
"Вычисляет и возвращает список старшинства классов для класса @var{class} в "
"соответствии\n"
"с алгоритмом описанном в  @ref{Class Precedence List}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2451
msgid ""
"@code{compute-slots} computes and returns a list of all slot definitions\n"
"for the new class.  By default, this list includes the direct slot\n"
"definitions from the @code{define-class} form, plus the slot definitions\n"
"that are inherited from the new class's superclasses.  The default\n"
"@code{compute-slots} method uses the CPL computed by @code{compute-cpl}\n"
"to calculate this union of slot definitions, with the rule that slots\n"
"inherited from superclasses are shadowed by direct slots with the same\n"
"name.  One possible reason for customizing @code{compute-slots} would be\n"
"to implement an alternative resolution strategy for slot name conflicts."
msgstr ""
"@code{compute-slots} вычисляет и возвращает список всех определений\n"
"слотов для нового класса. По умолчанию, этот список включает в себя\n"
"непосредственно определенные в классе слоты из формы определения \n"
"@code{define-class}, плюс определения которые определения слотов, которые\n"
"унаследованы от суперклассов. По умолчанию  метод @code{compute-slots}\n"
"использует CPL вычисленный @code{compute-cpl} для вычисления этого \n"
"объединения слотов, с правилом, что слоты унаследованные от суперклассов,\n"
"заменяются непосредственными слотами с тем же именем. Одной из возможных\n"
"причин для настройки @code{compute-slots} будет реализация альтернативной\n"
"стратегии разрешения конфликтов имен слотов."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2455
msgid ""
"@code{compute-get-n-set} computes the low-level closures that will be\n"
"used to get and set the value of a particular slot, and returns them in\n"
"a list with two elements."
msgstr ""
"@code{compute-get-n-set} вычисляет низкоуровневые замыкания, которые будут\n"
"использоваться для получения и установки значений определенных слотов, и\n"
"возвращет их в списке с двумя элементами."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2462
msgid ""
"The closures returned depend on how storage for that slot is allocated.\n"
"The standard @code{compute-get-n-set} method, specialized for classes of\n"
"type @code{<class>}, handles the standard GOOPS values for the\n"
"@code{#:allocation} slot option (@pxref{Slot Options,, allocation}).  By\n"
"defining a new @code{compute-get-n-set} method for a more specialized\n"
"metaclass, it is possible to support new types of slot allocation."
msgstr ""
"Возвращемые замыкания зависят от того как распределяется хранилище для\n"
"данного слота. Стандартный метод @code{compute-get-n-set} "
"специализированный\n"
"для классов типа @code{<class>}, обрабатывает стандартные значения GOOPS\n"
"для опций слота @code{#:allocation} (@pxref{Slot Options,, allocation}).\n"
"Определяя новый метод @code{compute-get-n-set} для более "
"специализированного\n"
"метакласса, возможна поддержка нового типа распределения слотов."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2468
msgid ""
"Suppose you wanted to create a large number of instances of some class\n"
"with a slot that should be shared between some but not all instances of\n"
"that class - say every 10 instances should share the same slot storage.\n"
"The following example shows how to implement and use a new type of slot\n"
"allocation to do this."
msgstr ""
"Предположим, вы хотите создать большое количество экзепляров некоторого\n"
"класса со слотом, который должен быть разделен между некоторыми, но\n"
"не всеми экземплярами этого класса, скажем каждый 10 экземпляров должны\n"
"испльзовать одно и тоже хранилище. В следующем примере показано, как \n"
"реализовать и использовать для этого новый тип расределения слотов."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2471
msgid ""
"@example\n"
"(define-class <batched-allocation-metaclass> (<class>))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2492
msgid ""
"(let ((batch-allocation-count 0)\n"
"      (batch-get-n-set #f))\n"
"  (define-method (compute-get-n-set\n"
"                     (class <batched-allocation-metaclass>) s)\n"
"    (case (slot-definition-allocation s)\n"
"      ((#:batched)\n"
"       ;; If we've already used the same slot storage for 10 instances,\n"
"       ;; reset variables.\n"
"       (if (= batch-allocation-count 10)\n"
"           (begin\n"
"             (set! batch-allocation-count 0)\n"
"             (set! batch-get-n-set #f)))\n"
"       ;; If we don't have a current pair of get and set closures,\n"
"       ;; create one.  make-closure-variable returns a pair of closures\n"
"       ;; around a single Scheme variable - see goops.scm for details.\n"
"       (or batch-get-n-set\n"
"           (set! batch-get-n-set (make-closure-variable)))\n"
"       ;; Increment the batch allocation count.\n"
"       (set! batch-allocation-count (+ batch-allocation-count 1))\n"
"       batch-get-n-set)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2495
msgid ""
"      ;; Call next-method to handle standard allocation types.\n"
"      (else (next-method)))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2502
msgid ""
"(define-class <class-using-batched-slot> ()\n"
"  ...\n"
"  (c #:allocation #:batched)\n"
"  ...\n"
"  #:metaclass <batched-allocation-metaclass>)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2505
msgid ""
"The usage of @code{compute-getter-method} and @code{compute-setter-method}\n"
"is described in @ref{Class Definition Protocol}."
msgstr ""
"Использование методов @code{compute-getter-method} и @code{compute-setter-"
"method}\n"
"описано в @ref{Class Definition Protocol}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2514
msgid ""
"@code{compute-cpl} and @code{compute-get-n-set} are called by the\n"
"standard @code{initialize} method for classes whose metaclass is\n"
"@code{<class>}.  But @code{initialize} itself can also be modified, by\n"
"defining an @code{initialize} method specialized to the new class's\n"
"metaclass.  Such a method could complete override the standard\n"
"behaviour, by not calling @code{(next-method)} at all, but more\n"
"typically it would perform additional class initialization steps before\n"
"and/or after calling @code{(next-method)} for the standard behaviour."
msgstr ""
"@code{compute-cpl} и @code{compute-get-n-set} вызываются стандартным\n"
"методом @code{initialize} для классов, метаклассом которых является класс\n"
"@code{<class>}.  Но сам @code{initialize} можно также модифицировать, \n"
"определяя метод @code{initialize} специализированный для нового класса\n"
"метакласса. Такой метод может полностью переопределить стандартное "
"поведение,\n"
"не вызывая методов @code{(next-method)} вообще, но более типично он "
"выполнял\n"
"бы дополнительные шаги инициализации класса до или/и после вызова \n"
"@code{(next-method)} для стандартного поведения."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2518
msgid ""
"@node Method Definition\n"
"@subsection Method Definition"
msgstr ""
"@node Method Definition\n"
"@subsection Определение Методов"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2520
msgid "@code{define-method} (syntax)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2525
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{add-method! @var{target} @var{method}} (generic)\n"
"@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2530
msgid ""
"@noindent\n"
"@code{define-method} invokes the @code{add-method!} generic function to\n"
"handle adding the new method to a variety of possible targets.  GOOPS\n"
"includes methods to handle @var{target} as"
msgstr ""
"@noindent\n"
"@code{define-method} вызывает обобщенную функцию @code{add-method!} для\n"
"обработки добавления нового метода к множеству возможных целей. GOOPS\n"
"включает методы обработки @var{target} такие как:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2534
msgid ""
"@itemize @bullet\n"
"@item\n"
"a generic function (the most common case)"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"обобщенная функция (the most common case)"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2537
msgid ""
"@item\n"
"a procedure"
msgstr ""
"@item\n"
"процедура"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2541
msgid ""
"@item\n"
"a primitive generic (@pxref{Extending Primitives})\n"
"@end itemize"
msgstr ""
"@item\n"
"обобщенный примитив (@pxref{Extending Primitives})\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2544
msgid ""
"By defining further methods for @code{add-method!}, you can\n"
"theoretically handle adding methods to further types of target."
msgstr ""
"Определив дальнейшие методы для for @code{add-method!}, вы теоретически\n"
"можете обрабатывать добавление методов к другим типам целей."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2548
msgid ""
"@node Method Definition Internals\n"
"@subsection Method Definition Internals"
msgstr ""
"@node Method Definition Internals\n"
"@subsection Определение Методов Изнутри"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2550
msgid "@code{define-method}:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2555
msgid ""
"@itemize @bullet\n"
"@item\n"
"checks the form of the first parameter, and applies the following steps\n"
"to the accessor's setter if it has the @code{(setter @dots{})} form"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"проверяет форму первого параметра и применяет следующие шаги к аксессору\n"
"установщика если он имеет форму  @code{(setter @dots{})}"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2559
msgid ""
"@item\n"
"interpolates a call to @code{define-generic} or @code{define-accessor}\n"
"if a generic function is not already defined with the supplied name"
msgstr ""
"@item\n"
"интерполирует вызов @code{define-generic} или @code{define-accessor}\n"
"если обобщенная функция не является уже определенной с указанным именем.\n"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2563
msgid ""
"@item\n"
"calls @code{method} with the @var{parameter}s and @var{body}, to make a\n"
"new method instance"
msgstr ""
"@item\n"
"вызывает @code{method} с параметром @var{parameter}s и телом @var{body}, "
"чтобы\n"
"создать экзепляр нового метода."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2568
msgid ""
"@item\n"
"calls @code{add-method!} to add this method to the relevant generic\n"
"function.\n"
"@end itemize"
msgstr ""
"@item\n"
"вызывает @code{add-method!} чтобы добавить этот метод к соответствующей\n"
"обобщенной функции.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2573
msgid ""
"@deffn syntax method (parameter @dots{}) body @dots{}\n"
"Make a method whose specializers are defined by the classes in\n"
"@var{parameter}s and whose procedure definition is constructed from the\n"
"@var{parameter} symbols and @var{body} forms."
msgstr ""
"@deffn syntax method (parameter @dots{}) body @dots{}\n"
"Создает метод, специализаторы которого определяются классами в параметрах\n"
"@var{parameter} и чьё определение процедуры строиться из символов "
"@var{parameter}\n"
"и формы @var{body}.\n"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2578
msgid ""
"The @var{parameter} and @var{body} parameters should be as for\n"
"@code{define-method} (@pxref{Methods and Generic Functions,,\n"
"define-method}).\n"
"@end deffn"
msgstr ""
"Параметры @var{parameter} и @var{body} должны быть такими же, как\n"
"и для @code{define-method} (@pxref{Methods and Generic Functions,,\n"
"define-method}).\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2581
msgid ""
"@noindent\n"
"@code{method}:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2586
msgid ""
"@itemize @bullet\n"
"@item\n"
"extracts formals and specializing classes from the @var{parameter}s,\n"
"defaulting the class for unspecialized parameters to @code{<top>}"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"извлекает формальные и специализированные классы из @var{parameter},\n"
"по умолчанию класс не указанных параметров @code{<top>}"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2589
msgid ""
"@item\n"
"creates a closure using the formals and the @var{body} forms"
msgstr ""
"@item\n"
"создает замыкание, используя формальные параметры и форму @var{body}"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2595
msgid ""
"@item\n"
"calls @code{make} with metaclass @code{<method>} and the specializers\n"
"and closure using the @code{#:specializers} and @code{#:procedure}\n"
"keywords.\n"
"@end itemize"
msgstr ""
"@item\n"
"вызывает @code{make} с метаклассом @code{<method>} и специализаторами и\n"
"замыканием используя ключевые слова @code{#:specializers} и @code{#:"
"procedure}.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2598
msgid ""
"@deffn procedure make-method specializers procedure\n"
"Make a method using @var{specializers} and @var{procedure}."
msgstr ""
"@deffn procedure make-method specializers procedure\n"
"Создает метод используя @var{specializers} и @var{procedure}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2601
msgid ""
"@var{specializers} should be a list of classes that specifies the\n"
"parameter combinations to which this method will be applicable."
msgstr ""
"@var{specializers} должен быть списком классов, который задает\n"
"комбинацию параметров к которым этот метод применим."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2605
msgid ""
"@var{procedure} should be the closure that will applied to the generic\n"
"function parameters when this method is invoked.\n"
"@end deffn"
msgstr ""
"@var{procedure} должна быть замыканием, которое будет применяться к "
"параметрам\n"
"обобщенной функции когда этот метод вызывается.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2609
msgid ""
"@noindent\n"
"@code{make-method} is a simple wrapper around @code{make} with metaclass\n"
"@code{<method>}."
msgstr ""
"@noindent\n"
"@code{make-method} это простая обертка вокруг @code{make} с метаклассом\n"
"@code{<method>}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2613
msgid ""
"@deffn generic add-method! target method\n"
"Generic function for adding method @var{method} to @var{target}.\n"
"@end deffn"
msgstr ""
"@deffn generic add-method! target method\n"
"Обобщенная функция для добавления метода @var{method} к @var{target}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2617
msgid ""
"@deffn method add-method! (generic <generic>) (method <method>)\n"
"Add method @var{method} to the generic function @var{generic}.\n"
"@end deffn"
msgstr ""
"@deffn method add-method! (generic <generic>) (method <method>)\n"
"Добавляет метод @var{method} к обобщенной функции @var{generic}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2623
msgid ""
"@deffn method add-method! (proc <procedure>) (method <method>)\n"
"If @var{proc} is a procedure with generic capability (@pxref{Extending\n"
"Primitives,, generic-capability?}), upgrade it to a primitive generic\n"
"and add @var{method} to its generic function definition.\n"
"@end deffn"
msgstr ""
"@deffn method add-method! (proc <procedure>) (method <method>)\n"
"Если @var{proc} это процедура с возможностью обобщения (@pxref{Extending\n"
"Primitives,, generic-capability?}), обновляет ее до обобщенного примитива\n"
"и добавляет метод @var{method} к его определению обобщенной функции.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2626
msgid ""
"@deffn method add-method! (pg <primitive-generic>) (method <method>)\n"
"Add method @var{method} to the generic function definition of @var{pg}."
msgstr ""
"@deffn method add-method! (pg <primitive-generic>) (method <method>)\n"
"Добавляет метод @var{method} к определению обобщенной функции @var{pg}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2629
msgid ""
"Implementation: @code{(add-method! (primitive-generic-generic pg) method)}.\n"
"@end deffn"
msgstr ""
"Реализация: @code{(add-method! (primitive-generic-generic pg) method)}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2634
msgid ""
"@deffn method add-method! (whatever <top>) (method <method>)\n"
"Raise an error indicating that @var{whatever} is not a valid generic\n"
"function.\n"
"@end deffn"
msgstr ""
"@deffn method add-method! (whatever <top>) (method <method>)\n"
"Выбрасывает ошибку укзывающую, что @var{whatever} не является допустимой\n"
"обобщенной функцией.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2637
msgid ""
"@node Generic Function Internals\n"
"@subsection Generic Function Internals"
msgstr ""
"@node Generic Function Internals\n"
"@subsection Обобщенные Функции изнутри"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2641
msgid ""
"@code{define-generic} calls @code{ensure-generic} to upgrade a\n"
"pre-existing procedure value, or @code{make} with metaclass\n"
"@code{<generic>} to create a new generic function."
msgstr ""
"@code{define-generic} вызов @code{ensure-generic} обновляет ранее\n"
"существующее значение процедуры, или  @code{make} с укзанием в качестве\n"
"метакласса @code{<generic>} создает новую обобщенную функцию."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2645
msgid ""
"@code{define-accessor} calls @code{ensure-accessor} to upgrade a\n"
"pre-existing procedure value, or @code{make-accessor} to create a new\n"
"accessor."
msgstr ""
"@code{define-accessor} вызов @code{ensure-accessor} обновляет ранее\n"
"существовавшее значение процедуры, или @code{make-accessor} создает\n"
"новый аксессор."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2650
msgid ""
"@deffn procedure ensure-generic old-definition [name]\n"
"Return a generic function with name @var{name}, if possible by using or\n"
"upgrading @var{old-definition}.  If unspecified, @var{name} defaults to\n"
"@code{#f}."
msgstr ""
"@deffn procedure ensure-generic old-definition [name]\n"
"Возвращает обобщенную функцию с именем @var{name}, если это возможно, \n"
"используя или обновляя старое определение(@var{old-definition}). \n"
"Если не указано @var{name} по умолчанию равно @code{#f}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2653
msgid ""
"If @var{old-definition} is already a generic function, it is returned\n"
"unchanged."
msgstr ""
"Если старое определение(@var{old-definition}) уже является обобщенной "
"функцией,\n"
"вызов возвращает unchanged."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2657
msgid ""
"If @var{old-definition} is a Scheme procedure or procedure-with-setter,\n"
"@code{ensure-generic} returns a new generic function that uses\n"
"@var{old-definition} for its default procedure and setter."
msgstr ""
"Если старое определение(@var{old-definition}) это процедура Scheme или\n"
"процедура с установщиком(procedure-with-setter),\n"
"@code{ensure-generic} возвращает новую обобщенную функцию, которая "
"использует\n"
"старое определние(@var{old-definition}) для процедуры по умолчанию и для \n"
"установщика."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2661
msgid ""
"Otherwise @code{ensure-generic} returns a new generic function with no\n"
"defaults and no methods.\n"
"@end deffn"
msgstr ""
"В противном случае @code{ensure-generic} возвращает новую обобщенную "
"процедуру\n"
"без значения по умолчанию и без методов.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2666
msgid ""
"@deffn procedure make-generic [name]\n"
"Return a new generic function with name @code{(car @var{name})}.  If\n"
"unspecified, @var{name} defaults to @code{#f}.\n"
"@end deffn"
msgstr ""
"@deffn procedure make-generic [name]\n"
"Возвращает новую обобщенную функцию с именем @code{(car @var{name})}.  Если\n"
"неуказано имя @var{name} по умолчанию @code{#f}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2670
msgid ""
"@code{ensure-generic} calls @code{make} with metaclasses\n"
"@code{<generic>} and @code{<generic-with-setter>}, depending on the\n"
"previous value of the variable that it is trying to upgrade."
msgstr ""
"@code{ensure-generic} вызывает @code{make} с метаклассом @code{<generic>}\n"
"и @code{<generic-with-setter>}, в зависимости от предыдущего значения\n"
"переменной, которую он пытается обновить."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2673
msgid ""
"@code{make-generic} is a simple wrapper for @code{make} with metaclass\n"
"@code{<generic>}."
msgstr ""
"@code{make-generic} это просто оболочка для @code{make} с метаклассом\n"
"@code{<generic>}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2677
msgid ""
"@deffn procedure ensure-accessor proc [name]\n"
"Return an accessor with name @var{name}, if possible by using or\n"
"upgrading @var{proc}.  If unspecified, @var{name} defaults to @code{#f}."
msgstr ""
"@deffn procedure ensure-accessor proc [name]\n"
"Возвращает аксессор с именем @var{name}, если возможно используя или\n"
"обновляя @var{proc}.  Если не задано имя @var{name} по умолчанию @code{#f}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2679
msgid "If @var{proc} is already an accessor, it is returned unchanged."
msgstr "Если @var{proc} уже является аксессором, он возвращает unchanged."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2683
msgid ""
"If @var{proc} is a Scheme procedure, procedure-with-setter or generic\n"
"function, @code{ensure-accessor} returns an accessor that reuses the\n"
"reusable elements of @var{proc}."
msgstr ""
"Если @var{proc} это процедура Scheme, процедура с установщиком\n"
"(procedure-with-setter) или обобщенная процедура, @code{ensure-accessor}\n"
"возвращает аксессор который повторно использует элементы @var{proc}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2687
msgid ""
"Otherwise @code{ensure-accessor} returns a new accessor with no defaults\n"
"and no methods.\n"
"@end deffn"
msgstr ""
"В противном случае @code{ensure-accessor} возвращает новый аксессор без\n"
"умолчания и без методов.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2692
msgid ""
"@deffn procedure make-accessor [name]\n"
"Return a new accessor with name @code{(car @var{name})}.  If\n"
"unspecified, @var{name} defaults to @code{#f}.\n"
"@end deffn"
msgstr ""
"@deffn procedure make-accessor [name]\n"
"Возвращает новый аксессор с именем @code{(car @var{name})}.  Если\n"
"не указано имя @var{name} по умолчанию @code{#f}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2697
msgid ""
"@code{ensure-accessor} calls @code{make} with\n"
"metaclass @code{<generic-with-setter>}, as well as calls to\n"
"@code{ensure-generic}, @code{make-accessor} and (tail recursively)\n"
"@code{ensure-accessor}."
msgstr ""
"@code{ensure-accessor} вызывает @code{make} с метаклассом  @code{<generic-"
"with-setter>},\n"
"а также вызывает @code{ensure-generic}, @code{make-accessor} и (хвостовой "
"рекурсией)\n"
"@code{ensure-accessor}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2703
msgid ""
"@code{make-accessor} calls @code{make} twice, first\n"
"with metaclass @code{<generic>} to create a generic function for the\n"
"setter, then with metaclass @code{<generic-with-setter>} to create the\n"
"accessor, passing the setter generic function as the value of the\n"
"@code{#:setter} keyword."
msgstr ""
"@code{make-accessor} вызывает @code{make} дважды, первый раз с метаклассом\n"
"@code{<generic>} чтобы создать обобщенную функцию установщика, затем\n"
"с метаклассом @code{<generic-with-setter>} для создания аксессора, "
"передавая\n"
"обобщенную функцию установщик как значение ключевого слова @code{#:setter}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2706
msgid ""
"@node Generic Function Invocation\n"
"@subsection Generic Function Invocation"
msgstr ""
"@node Generic Function Invocation\n"
"@subsection Вызовы Обобщенной Функции"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2712
msgid ""
"There is a detailed and customizable protocol involved in the process of\n"
"invoking a generic function --- i.e., in the process of deciding which\n"
"of the generic function's methods are applicable to the current\n"
"arguments, and which one of those to apply.  Here is a summary diagram\n"
"of the generic functions involved."
msgstr ""
"Существует подробный и настраиваемый протокол, использующийся в процессе\n"
"вызова обобщенной функции --- т.е., в процессе определения того какие из\n"
"методов обобщенной функции применимы к текущим аргументам и какие из них\n"
"применять.  Вот краткая диаграмма запутанного протокола применения \n"
"обобщенной функции."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2715
msgid ""
"@noindent\n"
"@code{apply-generic} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2719
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{no-method} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2722
msgid ""
"@item\n"
"@code{compute-applicable-methods} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2725
msgid ""
"@item\n"
"@code{sort-applicable-methods} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2730
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{method-more-specific?} (generic)\n"
"@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2733
msgid ""
"@item\n"
"@code{apply-methods} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2737
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{apply-method} (generic)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2741
msgid ""
"@item\n"
"@code{no-next-method} (generic)\n"
"@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2745
msgid ""
"@item\n"
"@code{no-applicable-method}\n"
"@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2748
msgid ""
"We do not yet have full documentation for these.  Please refer to the\n"
"code (@file{oop/goops.scm}) for details."
msgstr ""
"У нас нет пока полной документации. См. Код для полной информации (@file{oop/"
"goops.scm})."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2752
msgid ""
"@node Redefining a Class\n"
"@section Redefining a Class"
msgstr ""
"@node Redefining a Class\n"
"@section Переопределение класса(Redefining a Class)"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2759
msgid ""
"Suppose that a class @code{<my-class>} is defined using @code{define-class}\n"
"(@pxref{Class Definition,, define-class}), with slots that have\n"
"accessor functions, and that an application has created several instances\n"
"of @code{<my-class>} using @code{make} (@pxref{Instance Creation,,\n"
"make}).  What then happens if @code{<my-class>} is redefined by calling\n"
"@code{define-class} again?"
msgstr ""
"Предположим, что класс @code{<my-class>} определяется с помощью @code{define-"
"class}\n"
"(@pxref{Class Definition,, define-class}), со слотами, которые имеют "
"функции\n"
"доступа, и что приложение создало несколько экземпляров @code{<my-class>} "
"используя\n"
"@code{make} (@pxref{Instance Creation,,make}).  Что происходит, если "
"@code{<my-class>}\n"
"переопределяется вызовом @code{define-class}?"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2764
msgid ""
"@menu\n"
"* Default Class Redefinition Behaviour::\n"
"* Customizing Class Redefinition::\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2767
msgid ""
"@node Default Class Redefinition Behaviour\n"
"@subsection Default Class Redefinition Behaviour"
msgstr ""
"@node Default Class Redefinition Behaviour\n"
"@subsection Поведение по умолчанию при пероопределении класса(Default Class "
"Redefinition Behaviour)"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2769
msgid "GOOPS' default answer to this question is as follows."
msgstr "Ответ GOOPS по умолчанию на этот вопрос выглядит следующим образом:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2777
msgid ""
"@itemize @bullet\n"
"@item\n"
"All existing direct instances of @code{<my-class>} are converted to be\n"
"instances of the new class.  This is achieved by preserving the values\n"
"of slots that exist in both the old and new definitions, and\n"
"initializing the values of new slots in the usual way (@pxref{Instance\n"
"Creation,, make})."
msgstr ""
"@itemize @bullet\n"
"@item\n"
"Все существующие прямые экземпляры @code{<my-class>} преобразуются в\n"
"экземпляры нового класса. Это достигается за счет сохранения значений\n"
"слотов, которые существуют как в старом, так и в новом определении\n"
"класса и инициализируя значение новых слотов обычным способом.\n"
"(@pxref{Instance Creation,, make})."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2784
msgid ""
"@item\n"
"All existing subclasses of @code{<my-class>} are redefined, as though\n"
"the @code{define-class} expressions that defined them were re-evaluated\n"
"following the redefinition of @code{<my-class>}, and the class\n"
"redefinition process described here is applied recursively to the\n"
"redefined subclasses."
msgstr ""
"@item\n"
"Все существующие подклассы @code{<my-class>} переопределяются, как будто\n"
"выражения  @code{define-class} которые их определили, были выполнены\n"
"после переопределения @code{<my-class>}, и описанный здесь процесс\n"
"переопределения класса применяется рекурсивно к переопределяемым\n"
"подклассам."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2790
msgid ""
"@item\n"
"Once all of its instances and subclasses have been updated, the class\n"
"metaobject previously bound to the variable @code{<my-class>} is no\n"
"longer needed and so can be allowed to be garbage collected.\n"
"@end itemize"
msgstr ""
"@item\n"
"Как только все его экземпляры и подклассы обновлены, метообъект\n"
"класса ранее связанный с переменной @code{<my-class>} больше не\n"
"нужен и поэтому можно отправить его в мусор(он будет уничтожен\n"
"сборщиком мусора).\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2793
msgid ""
"To keep things tidy, GOOPS also needs to do a little housekeeping on\n"
"methods that are associated with the redefined class."
msgstr ""
"Чтобы все было в порядке, GOOPS также необходимо немного поработать над\n"
"методами, которые связаны с переопредленным классом."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2799
msgid ""
"@itemize @bullet\n"
"@item\n"
"Slot accessor methods for slots in the old definition should be removed\n"
"from their generic functions.  They will be replaced by accessor methods\n"
"for the slots of the new class definition."
msgstr ""
"@itemize @bullet\n"
"@item\n"
"Слоты методов доступа для слотов из старого определения должны быть\n"
"удалены из обобщенной функции. Они будут заменены методами доступа для\n"
"слотов нового определения класса."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2809
msgid ""
"@item\n"
"Any generic function method that uses the old @code{<my-class>} metaobject\n"
"as one of its formal parameter specializers must be updated to refer to\n"
"the new @code{<my-class>} metaobject.  (Whenever a new generic function\n"
"method is defined, @code{define-method} adds the method to a list stored\n"
"in the class metaobject for each class used as a formal parameter\n"
"specializer, so it is easy to identify all the methods that must be\n"
"updated when a class is redefined.)\n"
"@end itemize"
msgstr ""
"@item\n"
"Любой метод обобщенной функции, который использует старый мета-объект \n"
"@code{<my-class>} как один из его формальных параметров должен быть\n"
"обновлен, чтобы ссылаться на новый метаобъект @code{<my-class>}.  \n"
"(Всякий раз, когда определяется новый метод обобщенной функции, \n"
"@code{define-method} добавляет метод к списку, хранящемуся в \n"
"метаобъекте класса для каждого класса, используемого в качестве\n"
"указанного формального параметра., поэтому легко найти все методы, \n"
"которые необходимо обновить, когда переопределяется класс.)\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2814
msgid ""
"If this class redefinition strategy strikes you as rather counter-"
"intuitive,\n"
"bear in mind that it is derived from similar behaviour in other object\n"
"systems such as CLOS, and that experience in those systems has shown it to "
"be\n"
"very useful in practice."
msgstr ""
"Если эта стратегия переопределения класса поражает вас как довольно\n"
"противоречащая интуиции, имейте в виду что она получена из аналогичного\n"
"поведения в других объектных системах, таких как  CLOS, и что опыт\n"
"в этих системах показал, что она очень полезна на практике."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2817
msgid ""
"Also bear in mind that, like most of GOOPS' default behaviour, it can\n"
"be customized@dots{}"
msgstr ""
"Так же имейте в виду, что как и большинство действий по умолчанию GOOPS,\n"
"это поведение можно настроить @dots{}"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2820
msgid ""
"@node Customizing Class Redefinition\n"
"@subsection Customizing Class Redefinition"
msgstr ""
"@node Customizing Class Redefinition\n"
"@subsection Настройка переопределения класса(Customizing Class Redefinition)"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2828
msgid ""
"When @code{define-class} notices that a class is being redefined, it\n"
"constructs the new class metaobject as usual, then invokes the\n"
"@code{class-redefinition} generic function with the old and new classes\n"
"as arguments.  Therefore, if the old or new classes have metaclasses\n"
"other than the default @code{<class>}, class redefinition behaviour can\n"
"be customized by defining a @code{class-redefinition} method that is\n"
"specialized for the relevant metaclasses."
msgstr ""
"Когда @code{define-class} замечает, что класс переопределяется,\n"
"он создает новый метаобъект класса, как обычно, затем вызывает \n"
"обобщенную функцию @code{class-redefinition} со старым и новым классом\n"
"в качестве аргументов. Поэтому, если у старых или новых классов есть\n"
"метаклассы отличные от класса по умолчанию @code{<class>}, поведение\n"
"переопределения класса можно настроить определив метод  \n"
"@code{class-redefinition}, который специализирован для соответствующих\n"
"метаклассов."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2834
msgid ""
"@deffn generic class-redefinition\n"
"Handle the class redefinition from @var{old-class} to @var{new-class},\n"
"and return the new class metaobject that should be bound to the\n"
"variable specified by @code{define-class}'s first argument.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2840
msgid ""
"@deffn method class-redefinition (old-class <class>) (new-class <class>)\n"
"Implements GOOPS' default class redefinition behaviour, as described in\n"
"@ref{Default Class Redefinition Behaviour}.  Returns the metaobject\n"
"for the new class definition.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2844
msgid ""
"The default @code{class-redefinition} method, for classes with the\n"
"default metaclass @code{<class>}, calls the following generic functions,\n"
"which could of course be individually customized."
msgstr ""
"Метод по умолчанию @code{class-redefinition}, для классов с \n"
"метаклассом по умолчанию @code{<class>}, вызывает следующие\n"
"обобщенные функции, которые, конечно могут быть индивидуально\n"
"настроены."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2849
msgid ""
"@deffn generic remove-class-accessors! old\n"
"The default @code{remove-class-accessors!} method removes the accessor\n"
"methods of the old class from all classes which they specialize.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2854
msgid ""
"@deffn generic update-direct-method! method old new\n"
"The default @code{update-direct-method!} method substitutes the new\n"
"class for the old in all methods specialized to the old class.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2860
msgid ""
"@deffn generic update-direct-subclass! subclass old new\n"
"The default @code{update-direct-subclass!} method invokes\n"
"@code{class-redefinition} recursively to handle the redefinition of\n"
"subclasses.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2867
msgid ""
"An alternative class redefinition strategy could be to leave all\n"
"existing instances as instances of the old class, but accepting that the\n"
"old class is now ``nameless'', since its name has been taken over by the\n"
"new definition.  In this strategy, any existing subclasses could also\n"
"be left as they are, on the understanding that they inherit from a nameless\n"
"superclass."
msgstr ""
"Альтернативная стратегия переопределения класса может заключатся в том,\n"
"чтобы объявить все существующие экземпляры экземплярами старого класса,\n"
"но признавая что старый класс теперь ``безымянный(nameless)'', поскольку\n"
"его имя было получено новым определением. В этойо стратегии любые \n"
"существующие подклассы могли бы также остаться такими, как они есть,\n"
"при том понимании, чо они наследутся от безымянного класса."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2872
msgid ""
"This strategy is easily implemented in GOOPS, by defining a new metaclass,\n"
"that will be used as the metaclass for all classes to which the strategy\n"
"should apply, and then defining a @code{class-redefinition} method that\n"
"is specialized for this metaclass:"
msgstr ""
"Эта стратегия легко реализуется в GOOPS, определением нового метакласса,\n"
"который будет использоваться для всех классов, к которым должна применяться\n"
"эта стратегия, а затем определяется метод переопределения класса \n"
"@code{class-redefinition} который специализирован для этого метакласса:"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2875
msgid ""
"@example\n"
"(define-class <can-be-nameless> (<class>))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2880
msgid ""
"(define-method (class-redefinition (old <can-be-nameless>)\n"
"                                   (new <class>))\n"
"  new)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2883
msgid ""
"When customization can be as easy as this, aren't you glad that GOOPS\n"
"implements the far more difficult strategy as its default!"
msgstr ""
"Когда настройка может быть такой же простой, разве вы не рады, что\n"
"GOOPS реализует гораздо более сложную стратегию по умолчанию!?"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2887
msgid ""
"@node Changing the Class of an Instance\n"
"@section Changing the Class of an Instance"
msgstr ""
"@node Changing the Class of an Instance\n"
"@section Изменение Класса и Экземпляра"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2892
msgid ""
"When a class is redefined, any existing instance of the redefined class\n"
"will be modified for the new class definition before the next time that\n"
"any of the instance's slots is referenced or set.  GOOPS modifies each\n"
"instance by calling the generic function @code{change-class}."
msgstr ""
"Когда класс переопределяется, любой существующий экземпляр "
"переопределенного\n"
"класса будет изменен под определение новое определение класса до того "
"момента,\n"
"когда на любой из слотов экземпляра будут ссылаться или пытаться его "
"установить.\n"
"GOOPS изменяет каждый экземпляр, вызывая обобщенную функцию @code{change-"
"class}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2896
msgid ""
"More generally, you can change the class of an existing instance at any\n"
"time by invoking the generic function @code{change-class} with two\n"
"arguments: the instance and the new class."
msgstr ""
"В более общем плане вы можете изменить класс существующего экземпляра\n"
"в любое время, вызвав обобщенную функцию @code{change-class} с двумя "
"аргументами:\n"
"экземпляр(instance) и новый класс(new class)."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2905
msgid ""
"The default method for @code{change-class} decides how to implement the\n"
"change of class by looking at the slot definitions for the instance's\n"
"existing class and for the new class.  If the new class has slots with\n"
"the same name as slots in the existing class, the values for those slots\n"
"are preserved.  Slots that are present only in the existing class are\n"
"discarded.  Slots that are present only in the new class are initialized\n"
"using the corresponding slot definition's init function (@pxref{Classes,,\n"
"slot-init-function})."
msgstr ""
"По умолчанию метод @code{change-class} рашает, как реализовать изменение\n"
"класса глядя на определения слотов для существующего экземпляра класса\n"
"и нового класса.  Если новый класс имеет слоты с тем же именем, что и \n"
"слоты в существующем классе, значения для этих слотов сохранаются.\n"
"Слоты которые присутствуют только в существующем классе, отбрасываются.\n"
"Слоты которые присутствуют только в новом классе, инициализируются\n"
"с использованием соответствующего определения функции иницализации слота.\n"
"(@pxref{Classes,,slot-init-function})."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2908
msgid ""
"@deffn generic change-class instance new-class\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/goops.texi:2911
msgid ""
"@deffn {method} change-class (obj <object>) (new <class>)\n"
"Modify instance @var{obj} to make it an instance of class @var{new}."
msgstr ""
"@deffn {method} change-class (obj <object>) (new <class>)\n"
"Изменить экземпляр @var{obj} что бы сделать его экземпляром класса @var{new}."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2914
msgid ""
"The value of each of @var{obj}'s slots is preserved only if a similarly "
"named\n"
"slot exists in @var{new}; any other slot values are discarded."
msgstr ""
"Значение каждого из слотов @var{obj} сохраняется только в том случае, если "
"аналогичный\n"
"слот существует в новом @var{new} классе; любые другие значения слотов "
"отбрасываются."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2919
msgid ""
"The slots in @var{new} that do not correspond to any of @var{obj}'s\n"
"pre-existing slots are initialized according to @var{new}'s slot "
"definitions'\n"
"init functions.\n"
"@end deffn"
msgstr ""
"Стоты нового класса@var{new}, которым нет соответстветствия ни однго из "
"ранее\n"
"существовавших слотов в @var{obj}, инициализируются в соответствии с "
"функциями\n"
"инициализации определенных для них в определении слотов класса @var{new}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2927
msgid ""
"The default @code{change-class} method also invokes another generic\n"
"function, @code{update-instance-for-different-class}, as the last thing\n"
"that it does before returning.  The applied\n"
"@code{update-instance-for-different-class} method can make any further\n"
"adjustments to @var{new-instance} that are required to complete or\n"
"modify the change of class.  The return value from the applied method is\n"
"ignored."
msgstr ""
"По умолчанию метод @code{change-class} также вызывает другую обобщенную "
"функцию,\n"
"@code{update-instance-for-different-class}, в конце своей работы, пред\n"
"возвратом.  Примененный метод @code{update-instance-for-different-class}\n"
"может в дальнейшем корректировать  новые экземпляры @var{new-instance} что\n"
"необходимо для завершения изменения класса или изменять класс.  \n"
"Возвращаемое значение применяемого метода\n"
"игнорируется."

#: /home/bear/work/guile/doc/guile/en/goops.texi:2933
msgid ""
"@deffn generic update-instance-for-different-class old-instance new-"
"instance\n"
"A generic function that can be customized to put finishing touches to an\n"
"instance whose class has just been changed.  The default\n"
"@code{update-instance-for-different-class} method does nothing.\n"
"@end deffn"
msgstr ""
"@deffn generic update-instance-for-different-class old-instance new-"
"instance\n"
"обобщенная функция. которая может быть настроена для того, чтобы поместить "
"завершающие\n"
"штрихи в экземпляры чей класс был изменен. По умолчанию метод\n"
"@code{update-instance-for-different-class} ничего не делает.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/goops.texi:2936
msgid ""
"Customized change of class behaviour can be implemented by defining\n"
"@code{change-class} methods that are specialized either by the class\n"
"of the instances to be modified or by the metaclass of the new class."
msgstr ""
"Индивидуальное изменение поведения класса может быть реализовано\n"
"путем определения метода @code{change-class}, который специализируется\n"
"либо по экземпляру класса, подлежащему модификации, либо по метаклассу\n"
"нового класса."
