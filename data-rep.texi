@c -*-texinfo-*-
@c This is part of the GNU Guile Reference Manual.
@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2010, 2015
@c   Free Software Foundation, Inc.
@c See the file guile.texi for copying conditions.

@node Data Representation
@section Представление данных

Scheme - это язык со скрытой типизацией; это означает, что система
не может определить тип данных во время компиляции. Типы данных
становяться известными во время выполнения программы. Переменные не
имеют фиксированных типов; Переменная может содержать пару(pair) в 
одном месте программы, целое число в следующем и тысячаэлемнтный 
вектор позже. Вместо переменных, значения имеют фиксированный
тип.

Для реализации стандартных функций Scheme, таких как @code{pair?} и
@code{string?} и обеспечения сборки мусора, представление каждого значения
должно содержать достаточно информации для точного определения его типа
во время выполнения. Часто системы Scheme также используют эту информацию,
чтобы определить, пыталась ли программа применить операцию к неуместному
типу значения(например применить @code{car} к строке(string)).

Поскольку переменные, пары и векторы могут содержать значения любого
типа, реализация Scheme использует единое представление для значений
--- один тип, достаточно большой, чтобы содержать либо полное значение
либо указатель на полное значение, а также необходимую информацию о
типе.

В следующих разделах будет представлена простая система типов, а затем
сделаны некоторые уточнения для устранения основных ее недостатков. Затем
мы завершаем обсуждение, конкретным выбором, который выбран для Guile в
отношении сборки мусора и представления данных.

@menu
* A Simple Representation::     
* Faster Integers::             
* Cheaper Pairs::               
* Conservative GC::          
* The SCM Type in Guile::
@end menu

@node A Simple Representation
@subsection Простейшее представление

Простейший способ представления значений Scheme в Си представить каждое
значение как указатель на структуру, содержащую индикатор типа, за
которым следует объединение, несущее реальное значение. Предполагая, что
@code{SCM} это имя нашего универсального типа, мы можем написать:

@example
enum type @{ integer, pair, string, vector, ... @};

typedef struct value *SCM;

struct value @{
  enum type type;
  union @{
    int integer;
    struct @{ SCM car, cdr; @} pair;
    struct @{ int length; char *elts; @} string;
    struct @{ int length; SCM  *elts; @} vector;
    ...
  @} value;
@};
@end example
с точками заменяющими код для остальных типо Scheme.

Это представление достаточно для реализации всей семантики Scheme. Если @var{x} 
является значением @code{SCM}:
@itemize @bullet
@item
  Для проверки что @var{x} является целым(integer), мы можем написать @code{@var{x}->type == integer}.
@item
  Чтобы найти его значение, мы можем написать @code{@var{x}->value.integer}.
@item
  Для проверки что @var{x} это вектор(vector), мы можем наисать @code{@var{x}->type == vector}.
@item
  Если мы знаем что @var{x} это вектор, мы можем написать
  @code{@var{x}->value.vector.elts[0]} чтобы сослаться на первый элемент.
@item
  Если мы знаем что @var{x} это пара, мы можем написать
  @code{@var{x}->value.pair.car} чтобы извлечь начало пары(car).
@end itemize

@node Faster Integers
@subsection Быстрые Целые числа

К сожалению, вышеупомянутое представление имеет серьезный недостаток.
Чтобы вернуть  целое(integer), выражение должно выделить память под
структуру значения @code{struct value}, инициализировать его, чтобы
представить это целое число и вернуть указатель на него. Кроме того,
для получения значения целого числа требуется ссылка на память,
которая намного медленне, чем ссылка на регистры для большинства
процессоров. Поскольку целые числа чрезвычайно распространены,
это представление является слишком дорогостоящим, как по времени,
так и по памяти. Целые должны быть очень дешевыми, для создания и
манипулирования ими.

Одним из возможных решений кроется в наблюдении, что на многих
архитектурах, выделеное в куче(heap) место для данных (т.е то, что
вы получаете при вызове @code{malloc}) должно быть выровнено по
воьмибайтовой границе. (Независимо от того, действительно ли
машина требует этого, мы можем написать собственный распределитель
(allocator) для объектов структур значений@code{struct value} который
будет гарантировать что это так) В этом случае нижние три бита
адреса структуры, как известно, равны нулю.

Это дает нам место, которое поможет обеспечить улучшенное представление
целых чисел. Мы создадим последовательность правил:
@itemize @bullet
@item
Если нижние три бита значения @code{SCM} равны нулю, SCM значение
является указателем на структуру значения @code{struct value}, и все
работает как и раньше.
@item
В противном случае, значение @code{SCM} представляет собой целое
число, значение которого отображается в его верхних битах.
@end itemize

Вот код Си, реализующий это соглашение:
@example
enum type @{ pair, string, vector, ... @};

typedef struct value *SCM;

struct value @{
  enum type type;
  union @{
    struct @{ SCM car, cdr; @} pair;
    struct @{ int length; char *elts; @} string;
    struct @{ int length; SCM  *elts; @} vector;
    ...
  @} value;
@};

#define POINTER_P(x) (((int) (x) & 7) == 0)
#define INTEGER_P(x) (! POINTER_P (x))

#define GET_INTEGER(x)  ((int) (x) >> 3)
#define MAKE_INTEGER(x) ((SCM) (((x) << 3) | 1))
@end example

Обратите внимание, что целое(@code{integer}) больше не отображается как
элемент типа перечисления@code{enum type}, и объединение теряет 
целочисленный член.  Вместо этого мы используем макросы @code{POINTER_P} 
и @code{INTEGER_P} для создания грубого разделения значений на целые
и не целые числа, а также тестирования типов прежде использования.

Здесь мы ответим на поставленные выше вопросы(опять же предположим что
@var{x} это значение @code{SCM}):
@itemize @bullet
@item
  Чтобы проверить, является ли @var{x} целым числом, мы можем написать
 @code{INTEGER_P (@var{x})}.
@item
  Чтобы найти его значение, мы можем написать @code{GET_INTEGER (@var{x})}.
@item
  Чтобы проверить, является ли @var{x} вектором, мы можем написать:
@example
  @code{POINTER_P (@var{x}) && @var{x}->type == vector}
@end example
  Учитывая новое представление, мы должны убедиться, что @var{x} действительно
  является указателем перед разыменовыванием, чтобы определить его полный тип.
@item
  Если мы знаем что @var{x} это вектор, мы можем записать
  @code{@var{x}->value.vector.elts[0]}, чтобы ссылаться на его первый элемент,
  как и раньше
@item
  Если мы знаем что @var{x} это пара, мы можем записать
  @code{@var{x}->value.pair.car} чтобы извлечь первый элемент пары(car), также как
  и раньше.
@end itemize

Это представление позволяет более эффективно работать с целыми числами,
чем первое.  Например если известно что @var{x} и @var{y} целые числа,
мы можем вычислить их сумму следующим образом:
@example
MAKE_INTEGER (GET_INTEGER (@var{x}) + GET_INTEGER (@var{y}))
@end example
Теперь, целочисленная математика не требует выделения памяти или ссылок.
Реальные системы Scheme реализуют сложение и другие операции, используя
еще более эффективный алгоритм, но это эссе не о bit-twiddling. 
(Подсказка: как вы решаете, когда переполниться большое число? Как вы
это сделаете на ассемблере?)

@node Cheaper Pairs
@subsection Дешевые Пары

Однако, есть еще одна проблема, с которой можно столкнуться. Значительная
часть кучи(heap) Scheme содержат пары, их большее чем других типов объектов; 
Как то Jonathan Rees обратил внимание на то, что пары занимаеют  45% 
кучи в его реализации  Scheme (Scheme 48). Однако наше представление, выше,
тратит три слова @code{SCM} на пару - одно для типа и два для @sc{car} и 
@sc{cdr}. Есть ли способ представить пары, используя только два слова?

Давайте уточним соглашение, которое мы установили ранее для представления
целых integer.  Допустим, что:
that:
@itemize @bullet
@item
  Если нижние три бита значения @code{SCM} равны @code{#b000}, то это
  указатель, как и раньше.
@item
  Если нижние три бита равны @code{#b001}, то верхние биты являются
  целым числом. Это немного более строгое ограничение чем раньше.
@item
  Если нижние три бита равны @code{#b010}, тогда значение с нижними
  тремя битами отбрасывается, а верхние являются адресом пары.
@end itemize

Здесь представлен новый Си код:
@example
enum type @{ string, vector, ... @};

typedef struct value *SCM;

struct value @{
  enum type type;
  union @{
    struct @{ int length; char *elts; @} string;
    struct @{ int length; SCM  *elts; @} vector;
    ...
  @} value;
@};

struct pair @{
  SCM car, cdr;
@};

#define POINTER_P(x) (((int) (x) & 7) == 0)

#define INTEGER_P(x)  (((int) (x) & 7) == 1)
#define GET_INTEGER(x)  ((int) (x) >> 3)
#define MAKE_INTEGER(x) ((SCM) (((x) << 3) | 1))

#define PAIR_P(x) (((int) (x) & 7) == 2)
#define GET_PAIR(x) ((struct pair *) ((int) (x) & ~7))
@end example

Обратите внимание, что перечисление(@code{enum type}) и структура значения
(@code{struct value}) теперь содержат только положения для векторов и строк;
как целые числа, так и пары стали особыми случаями. Выше приведеный код
также предполагает что @code{int} достаточно велик, чтобы содержать указатель,
что обычно не так.

Ниже приведен список наших примеров:
@itemize @bullet
@item
  Чтобы проверить, является ли @var{x} целым числом, мы можем
  написать @code{INTEGER_P (@var{x})}; как и раньше.
@item
  Чтобы получить значение, мы можем написать @code{GET_INTEGER (@var{x})},
  как и раньше.
@item
  Чтобы проверить является ли @var{x} вектором, мы можем записать:
@example
  @code{POINTER_P (@var{x}) && @var{x}->type == vector}
@end example
  Мы все равно должны убедиться, что @var{x} является указателем
  перед разыменовыванием @code{struct value} в соответстви с типом.
@item
  Если мы знаем, что тип @var{x} это вектор, мы можем записать
  @code{@var{x}->value.vector.elts[0]}, чтобы ссылаться на на его 
  первый элемент, как и раньше.
@item
  Мы можем написать @code{PAIR_P (@var{x})} чтобы определить является
  ли  @var{x} парой, а затем записать @code{GET_PAIR (@var{x})->car}
  чтобы получить ссылку на ее первый элемент car.
@end itemize

Это изменение представления уменьшает размер нашей кучи на 15%.  
Это также делает его более быстрым при решении является ли
значение парой или нет, поскольку ссылки на память для этого не нужны; 
достаточно проверить нижние два бита значения @code{SCM}. Это может быть
значительным при просмотре списков, являющемся основной деятельностью
системы Scheme.

Опять же, большинство реальных систем Scheme используют немного другую
реализацию; например, если GET_PAIR вычитает младшие биты @code{x},
а не маскирует их, оптимизатор может сочетать это вычитание с добавлением
смещения члена структуры, на который мы ссылаемся, делая измененный указатель
столь же быстрым в использовании, как и немодифицированный указатель.

@node Conservative GC
@subsection Консервативная сборка мусора

Помимо скрытой типизации, основным источником ограничений на реализацию
в Scheme представлений данных накладывает сбощик мусора. Сборщик должен
иметь возможность, чтобы определить какой объект живой в куче, а какой
не живой и следовательно, должен быть собран. 

Существует много способов реализовать его. Сборщик мусора Guile
построен на библиотеке консервативного сборщика мусора Boehm-Demers-Weiser
(BDW-GC). BDW-GC ``просто работает'', по большей части. Но поскольку
интересно знать, как он работает, мы включаем здесь описание на
высоком уровне, что делает BDW-GC.

Сбор мусор имеет две логические фазы% фазу @dfn{пометки(mark)}, в которой
устанавливается набор живых объектов, и фазу @dfn{чистки(sweep)}, в которой
объекты не прошедшие пометку убираются. Корректное функционирование
сборщика зависит от возможности пройти весь набор живых объектов.

В фазе пометки коллекционер сканирует глобальные переменные системы
и локальные переменные в стеке, чтобы определить какие объекты
сразу(непосредственно) доступны Си-коду. Тогда он сканирует эти
объпкты, чтобы айти объекты, на которые они указывают и так далее.
Сборщик логически устанавливает @dfn{бит метки(mark bit)} для
каждого найденного объекта, поэтому каждый объект проходиться только
один раз.

Когда сборщик мусора не может найти никаких немаркированных объектов, 
на которые указывают отмеченные объекты, предполагается, что любые
объекты, которые все еще не отмечены, никогда не будут использоваться
программой (т.к. нет разметки из любой глобальной или локальной 
переменной, которая достигает их) и освобождает их.

В приведенных выше пунктах мы не указали, как сборщик мусора находит
глобальные и локальные перменные; как обычно существует много разных
подходов. Часто программист должен содержать список указателей на 
все глобальные переменные, относящиеся к куче, и другой список
(корректирующийся при входе и выходе из каждой функции) локальных
переменных, для работы сборщика.

Список глобальных переменных обычно не так сложно поддерживать, поскольку
глобальные переменные относительно редки. Тем не менее, явно поддерживаемый
список локальных переменных(по личному опыту) - это кошмар для поддержания.
Таким образом, BDW-GC использует технику так называемой @dfn{консервативной сборки
мусора}, чтобы сделать список локальных переменных не нужным.

Трюк консервативной сборки мусора заключается в том, чтобы рассматривать
стек как обычный диапазон памяти, и предполагать, что каждое слово в
стеке является указателем на кучу. Таким образом, сборщик отмечает все
объекты, адреса которых отображаются в любом месте стека, не зная наверняка
как это слово правильно толковать.

Помимо стека, BDW-GC также сканирует разделы статических данных. Это означает
что глобальные переменные также сканируются при поиске живых объектов Scheme.

Очевидно, что такая система будет иногда сохранять объекты, которые
на самом деле являются мусором, и должны быть освобождены. На практике
это не является проблемой. Альтернатива, с явно поддерживаемым списком
адресов локальных переменных, значительно менее надежна, из-за ошибок
программиста. Заинтересованные читатели должны посмотреть веб страницу
BDW-GC по адресу @uref{http://www.hboehm.info/gc/}, чтобы получить больше
информации.

@node The SCM Type in Guile
@subsection Тип SCM в Guile

Guile разделяет объекты Scheme на два вида: те которые полностью 
соответствуют  @code{SCM}, и те которые требуют храненения в куче.

Первый класс называется @dfn{непосредственным(immediates)}.  Класс непосредственных
включает в себя малые целые числа, символы, знаковые символы, логические значения,
пустой список, таинственный объект конца файла и некоторые другие.

Оставшиеся типы называются, что неудивительно, @dfn{опосредованными
(non-immediates)}.
Они включают в себя пары, процедуры, строки, вектор и все другие
типы данных в  Guile. Для опосредованных, слово @code{SCM} содержит
указатель на данные в куче, с дополнительной информацией об объекте
в вопросе что храниться в этих данных.

В этом разделе описывается, как тип @code{SCM} фактически представлен и
исползуется на уровне Си. Заинтересованные читатели должны посмотреть
файл @code{libguile/tags.h} для представления того как Guile хранит
инофрмацию о типах.

Фактически, для представления объектов в Guile существуют два базовых
типа данных Си: @code{SCM} и @code{scm_t_bits}.

@menu
* Relationship between SCM and scm_t_bits::
* Immediate objects::
* Non-immediate objects::
* Allocating Cells::
* Heap Cell Type Information::
* Accessing Cell Entries::
@end menu

@node Relationship between SCM and scm_t_bits
@subsubsection Связь между @code{SCM} и @code{scm_t_bits}

Переменная типа @code{SCM} гарантированно содержит действительный
объект Scheme. С другой стороны, переменная типа @code{scm_t_bits},
может содержать представление значения @code{SCM} как интегрального
значения Си типа, но также может содержать любое значение Си, даже
если оно не соответствует действительному объекту Scheme.

Для переменной @var{x} типа @code{SCM}, информация о типе объекта
Scheme храниться в форме, которая не может быть использована
непосредственно. Чтобы иметь возможность рабоать с типом кодирующим
значение scheme, переменная @code{SCM} должна быть преобразована в
соответствующее представление,  такое как @code{scm_t_bits} переменной
@var{y}, используя макрос @code{SCM_UNPACK}.  Как только это будет
сделано, тип объекта scheme  @var{x} может быть получен из содержимого
битов значения @code{scm_t_bits} @var{y}, способом проилюстрированным
ранее в этой главе (@pxref{Cheaper Pairs}).  И наоборот, действительное
битовое кодирование значения переменной @code{scm_t_bits} может быть
преобразовано в соответствующее значение @code{SCM} используя макрос
@code{SCM_PACK}.

@node Immediate objects
@subsubsection Непосредственные Объекты

Объект Scheme может быть либо непосредственным, т.е.: содержать всю необходимую
информацию в себе, или он может содержать ссылку на @dfn{ячейку(cell)} с
дополнительной инфомрацией в куче. Хотя в общем случае для кода пользователя
не должно быть никакого значения, является ли объект непосредственным или нет,
в собственном коде Guile различие иногда имеет значение. Работа обеспечивается
следующими предоставляемыми низкоуровневыми макросами:

@deftypefn Macro int SCM_IMP (SCM @var{x})
Объект Scheme является непосредственным, если для него выполняется
предикат @code{SCM_IMP}, в противном случае он содержит закодированную
ссылку на ячейку в куче. Результат предиката предоставляется Си как
булево значение. Коду пользователя и коду, который расширяет Guile,
обычно не требуется использовать этот макрос.
@end deftypefn

@noindent
Резюмируем:
@itemize @bullet
@item
Если задан Scheme объект @var{x} неизвестного типа, сначала проверьте с
помощью @code{SCM_IMP (@var{x})} не непосредственный ли это объект.
@item
Если это так, всю информацию о типе и значении можно определить из
значения @code{scm_t_bits}, которое предоставляется макросом 
@code{SCM_UNPACK(@var{x})}.
@end itemize

В Scheme имеется ряд специальных значений, большинство из которых 
задокументировано в других местах этого руководства. Это не совсем подходящее
место для их размещения, но пока вот список Си имен, присвоенных некоторым
из этих значений:

@deftypefn Macro SCM SCM_EOL
Объект пустого списка Scheme или объект ``End Of List'', обычно записываемый
в Scheme как @code{'()}.
@end deftypefn

@deftypefn Macro SCM SCM_EOF_VAL
Значение - конец файла(end-of-file) в Scheme.  Оне не имеет стандартного 
представления, по очевидным причинам.
@end deftypefn

@deftypefn Macro SCM SCM_UNSPECIFIED
Значение, возвращаемое некоторыми(но не всеми) выражениями, указанными
в стандарте Scheme возвращающими ``неопределенное(unspecified)'' значение.

Это своего рода своего рода буквальный способ использования стандарта,
цикл read-eval-print не печатает ничего, когда выражение возвращает
это значение. Поэтому неплохо вернуть это значение, когда вы не можете
придумать ничего полезного.
@end deftypefn

@deftypefn Macro SCM SCM_UNDEFINED
``Неопределенное'' значение.  Его наиболее важным свойством является то, что
он не равен действительным значениям Scheme. Это связано с различными
внутренними потребностями используемого Си кода, взаимодействующего с Guile.

Например, когда вы пишите функцию Си, вызываемую из Scheme и
которая принимает необязательные аргументы, интерпретатор 
передает @code{SCM_UNDEFINED} для любых аргументов которые
вы не получили.

Мы также используем это для обозначения несвязанных переменных.
@end deftypefn

@deftypefn Macro int SCM_UNBNDP (SCM @var{x})
Возвращает true, если @var{x} равна @code{SCM_UNDEFINED}.  Обратите внимание,
что это не проверка является ли @var{x} - @code{SCM_UNBOUND}(является ли х связанным).
История не простит такое название нам.
@end deftypefn

@node Non-immediate objects
@subsubsection Опосредованные(Non-immediate) Объекты

Объект Scheme типа @code{SCM}, для которого не выполнен предикат 
@code{SCM_IMP}, содержит закодированную ссылку на ячеку из кучи.
Эта ссылка может быть декодирована в Си указатель на ячеку кучи,
использованием макроса @code{SCM2PTR}.  Кодирование указателя
на ячейку кучи в значение @code{SCM} выполняется с использоанием
макроса @code{PTR2SCM}.

@c (FIXME:: this name should be changed)
@deftypefn Macro {scm_t_cell *} SCM2PTR (SCM @var{x})
Извлечь и вернуть указатель ячеки кучи из опосредствованого объекта
@code{SCM} @var{x}.
@end deftypefn

@c (FIXME:: this name should be changed)
@deftypefn Macro SCM PTR2SCM (scm_t_cell * @var{x})
Возвращает значение @code{SCM}, которое кодирует ссылку на указатель
@var{x} кучи.
@end deftypefn

Обратите внимание, что также возможно преобразовать опосредствованное
значение @code{SCM} используя @code{SCM_UNPACK} в переменную @code{scm_t_bits}.
Однако, результат @code{SCM_UNPACK} не может быть использован как указатель
на @code{scm_t_cell}: только @code{SCM2PTR} гарантированно преобразует объект
@code{SCM} в действительный указатель на ячейку кучи. Кроме того, не
разрешается применять @code{PTR2SCM} ко всему, что не является
действительным указателем на ячейки кучи.

@noindent
Резюме:  
@itemize @bullet
@item
Используйте @code{SCM2PTR} только для значений @code{SCM}, для которых @code{SCM_IMP}
является ложным!
@item
Не используйте @code{(scm_t_cell *) SCM_UNPACK (@var{x})}!  Вместо этог используйте
{SCM2PTR (@var{x})}!
@item
Не ипользуйте @code{PTR2SCM} для чего либо, кроме как указателя на ячейку из кучи!
@end itemize

@node Allocating Cells
@subsubsection Выделение Ячеек

Guile предоставляет как обычные ячейки с двумя слотами, так и двойные
ячейки с четырьмя слотами.  Следующие функции являются наибольее 
примитивным способом выделения ячеек.

Если вызывающий намерен использовать его в качестве заголовка для
какого-либо другого типа, он должен передать соответствующее
магическое значение в  @var{word_0}, чтобы пометить его
как член этого типа и передать все значение как @var{word_1}, и т.д.,
которое необходимо данному типу. Обычно вам не нужны эти функции,
если вы не внедряете новый тип данных лезете глубоко в код
 @code{<libguile/tags.h>}.

Если вы просто хотите выделить пару, используйте @code{scm_cons}.

@deftypefn Function SCM scm_cell (scm_t_bits word_0, scm_t_bits word_1)
Выделяет новую ячейку, инициализирует два слота значениями @var{word_0} и
@var{word_1}, и возвращает ее.

Обратите внимание, что слова @var{word_0} и @var{word_1} имеют тип @code{scm_t_bits}.
Если вы хотите передать объект @code{SCM} вам необдимо использовать
@code{SCM_UNPACK}.
@end deftypefn

@deftypefn Function SCM scm_double_cell (scm_t_bits word_0, scm_t_bits word_1, scm_t_bits word_2, scm_t_bits word_3)
Подобно @code{scm_cell}, но выделяет двойную ячейку с четыремя слотами.
@end deftypefn

@node Heap Cell Type Information
@subsubsection Ячейка Кучи Информация о типе

Ячейки кучи содержат несколько записей, каждая из которых является либо
объектом scheme типа @code{SCM} или наобработанным значением Си типа
@code{scm_t_bits}. Какая из записей ячейки содержит объекты Scheme
и какая содержит необработанные значения Си, определяется первой записью
ячейки, которая содержит ячейку типа информации.

@deftypefn Macro scm_t_bits SCM_CELL_TYPE (SCM @var{x})
Для опосредованного объекта Scheme  @var{x}, достает содержимое первой
записи ячейки кучи, на которую ссылается @var{x}.  Это значение
содержит информацию о типе ячейки.
@end deftypefn

@deftypefn Macro void SCM_SET_CELL_TYPE (SCM @var{x}, scm_t_bits @var{t})
Для опосредованного объекта Scheme @var{x}, записывает значение @var{t} в
первую запись ячеейки кучи на которую ссылается @var{x}.  Значение @var{t} 
должно содержать действительный тип ячекйки.
@end deftypefn

@node Accessing Cell Entries
@subsubsection Доступ к содержимому Ячеек

Для опосредованного объекта Scheme @var{x}, тип объекта можно определить
прочитав ячейку типа используя макрос @code{SCM_CELL_TYPE}.  Для каждого
типа ячкейки известно какие записи содержат ячейки объектов Scheme и
и какие записи содержат ячейки необработанных Си данных. Для доступа
к различным записям ячеек соответственно, предоставляются следующие
макросы.

@deftypefn Macro scm_t_bits SCM_CELL_WORD (SCM @var{x}, unsigned int @var{n})
Достать запись ячейки @var{n}, на которую ссылается опосредованный объект
Scheme @var{x} как необработанные данные.  Это незаконно, для доступа
к ячейкам, в которых объекты Scheme используют эти макросы. Для удобства
предусмотрены следующие макросы:@itemize @bullet
@item
SCM_CELL_WORD_0 (@var{x}) @result{} SCM_CELL_WORD (@var{x}, 0)
@item
SCM_CELL_WORD_1 (@var{x}) @result{} SCM_CELL_WORD (@var{x}, 1)
@item
@dots{}
@item
SCM_CELL_WORD_@var{n} (@var{x}) @result{} SCM_CELL_WORD (@var{x}, @var{n})
@end itemize
@end deftypefn

@deftypefn Macro SCM SCM_CELL_OBJECT (SCM @var{x}, unsigned int @var{n})
Достать запись @var{n} ячейки из кучи, на которую ссылается опосредованный
объект Scheme @var{x} как объект Scheme.  Это незаконно, для доступа к 
записям ячеек которые не хранят объекты Scheme с помощью использования
данных макросов. для удобства, предусмотрены следующие макросы.
@itemize @bullet
@item
SCM_CELL_OBJECT_0 (@var{x}) @result{} SCM_CELL_OBJECT (@var{x}, 0)
@item
SCM_CELL_OBJECT_1 (@var{x}) @result{} SCM_CELL_OBJECT (@var{x}, 1)
@item
@dots{}
@item
SCM_CELL_OBJECT_@var{n} (@var{x}) @result{} SCM_CELL_OBJECT (@var{x},
@var{n})
@end itemize
@end deftypefn

@deftypefn Macro void SCM_SET_CELL_WORD (SCM @var{x}, unsigned int @var{n}, scm_t_bits @var{w})
Записать необработанное значение Си @var{w} в запись с номером @var{n} 
ячейки кучи опосредованного значения Scheme @var{x}.  Значения, которые
записываются в ячейки таким образом, могут считываться из ячеек с 
использованием макросов @code{SCM_CELL_WORD} или, в случае, если это нулевая
запись ячейки макросом @code{SCM_CELL_TYPE}.  Для частного случая нулевой
записи ячейки надо убедиться что @var{w} содержит информацию  о типе ячейки,
которая не описывает объект Scheme.  Для удобства, предусмотрены следующие
макросы.
@itemize @bullet
@item
SCM_SET_CELL_WORD_0 (@var{x}, @var{w}) @result{} SCM_SET_CELL_WORD
(@var{x}, 0, @var{w})
@item
SCM_SET_CELL_WORD_1 (@var{x}, @var{w}) @result{} SCM_SET_CELL_WORD
(@var{x}, 1, @var{w})
@item
@dots{}
@item
SCM_SET_CELL_WORD_@var{n} (@var{x}, @var{w}) @result{} SCM_SET_CELL_WORD
(@var{x}, @var{n}, @var{w})
@end itemize
@end deftypefn

@deftypefn Macro void SCM_SET_CELL_OBJECT (SCM @var{x}, unsigned int @var{n}, SCM @var{o})

Записать объект Scheme @var{o} в запись с номером @var{n} 
ячейки кучи опосредованного значения Scheme @var{x}.  Значения, которые
записываются в ячейки таким образом, могут считываться из ячеек с 
использованием макросов @code{SCM_CELL_OBJECT} или, в случае, если это нулевая
запись ячейки макросом @code{SCM_CELL_TYPE}.  Для частного случая нулевой
запись объекта Scheme в эту ячейку разрешена только в том случае, если
ячейка формирует пару.  Для удобства, предусмотрены следующие
макросы.@itemize @bullet
@item
SCM_SET_CELL_OBJECT_0 (@var{x}, @var{o}) @result{} SCM_SET_CELL_OBJECT
(@var{x}, 0, @var{o})
@item
SCM_SET_CELL_OBJECT_1 (@var{x}, @var{o}) @result{} SCM_SET_CELL_OBJECT
(@var{x}, 1, @var{o})
@item
@dots{}
@item
SCM_SET_CELL_OBJECT_@var{n} (@var{x}, @var{o}) @result{}
SCM_SET_CELL_OBJECT (@var{x}, @var{n}, @var{o})
@end itemize
@end deftypefn

@noindent
Резюме:
@itemize @bullet
@item
Для опосредованного объекта Scheme @var{x} неизвестного типа, получить тип
можно используя макрос @code{SCM_CELL_TYPE (@var{x})}.
@item
Как только информация о типе ячейки будет доступна, используйте только
соответствующие методы доступа для чтения и записи данных в разные
записи ячейки.
@end itemize

@c Local Variables:
@c TeX-master: "guile.texi"
@c End: