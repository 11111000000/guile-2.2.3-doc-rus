#
# NuINu <don't@send.my>, 2018.
#
#. extracted from /home/bear/work/guile/doc/guile/en/api-init.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-07 12:36+0300\n"
"PO-Revision-Date: 2018-12-24 08:11+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: /home/bear/work/guile/doc/guile/en/api-init.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2007\n"
"@c   Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-init.texi:11
msgid ""
"@node Initialization\n"
"@section Initializing Guile\n"
"@cindex Initializing Guile"
msgstr ""
"@node Initialization\n"
"@section Инициализация Guile\n"
"@cindex Initializing Guile"

#: /home/bear/work/guile/doc/guile/en/api-init.texi:16
msgid ""
"Each thread that wants to use functions from the Guile API needs to\n"
"put itself into guile mode with either @code{scm_with_guile} or\n"
"@code{scm_init_guile}.  The global state of Guile is initialized\n"
"automatically when the first thread enters guile mode."
msgstr ""
"Каждый поток, который хочет использовать функции из API Guile, должен\n"
"поместить себя в guile режим  с помощью вызова функции @code{scm_with_guile} "
"или\n"
"@code{scm_init_guile}.  Глобальное состояние Guile инициализируется "
"автоматически,\n"
"когда первый поток входит в режим guile."

#: /home/bear/work/guile/doc/guile/en/api-init.texi:20
msgid ""
"When a thread wants to block outside of a Guile API function, it\n"
"should leave guile mode temporarily with @code{scm_without_guile},\n"
"@xref{Blocking}."
msgstr ""
"Когда поток хочет заблокировать все функции API Guile, он должен\n"
"выйти временно из режима guile вызвав @code{scm_without_guile},\n"
"@xref{Blocking}."

#: /home/bear/work/guile/doc/guile/en/api-init.texi:24
msgid ""
"Threads that are created by @code{call-with-new-thread} or\n"
"@code{scm_spawn_thread} start out in guile mode so you don't need to\n"
"initialize them."
msgstr ""
"Потоки созданные с помощью @code{call-with-new-thread} или\n"
"@code{scm_spawn_thread} начинаются в режиме guile, поэтому вам не нужно\n"
"его инициализировать."

#: /home/bear/work/guile/doc/guile/en/api-init.texi:29
msgid ""
"@deftypefn {C Function} {void *} scm_with_guile (void *(*func)(void *), void "
"*data)\n"
"Call @var{func}, passing it @var{data} and return what @var{func}\n"
"returns.  While @var{func} is running, the current thread is in guile\n"
"mode and can thus use the Guile API."
msgstr ""
"@deftypefn {C Function} {void *} scm_with_guile (void *(*func)(void *), void "
"*data)\n"
"Вызывает @var{func}, передавая ей данные @var{data} и возвращая то что "
"возвращает \n"
"функция @var{func}.  Пока @var{func} выполняется, текущий поток находиться в "
"режиме\n"
"guilee и может использовать Guile API."

#: /home/bear/work/guile/doc/guile/en/api-init.texi:32
msgid ""
"When @code{scm_with_guile} is called from guile mode, the thread remains\n"
"in guile mode when @code{scm_with_guile} returns."
msgstr ""
"Когда @code{scm_with_guile} вызывается из режима guile, поток остается в\n"
"режиме guile, когда @code{scm_with_guile} возвращается(завершается)."

#: /home/bear/work/guile/doc/guile/en/api-init.texi:39
msgid ""
"Otherwise, it puts the current thread into guile mode and, if needed,\n"
"gives it a Scheme representation that is contained in the list returned\n"
"by @code{all-threads}, for example.  This Scheme representation is not\n"
"removed when @code{scm_with_guile} returns so that a given thread is\n"
"always represented by the same Scheme value during its lifetime, if at\n"
"all."
msgstr ""
"В противном случае, он переводит текущий поток в режим guile и, если "
"необходимо,\n"
"выдает ему представление Scheme котораое содержит в списке возврат функции,\n"
"например, @code{all-threads}.  Это представление Scheme не удаляется, когда\n"
"происходит возврат из @code{scm_with_guile}, так что данный поток вседа "
"представлен\n"
"одним и тем же значением Scheme в течении всего времени жизни(, если вообще)."

#: /home/bear/work/guile/doc/guile/en/api-init.texi:42
msgid ""
"When this is the first thread that enters guile mode, the global state\n"
"of Guile is initialized before calling @code{func}."
msgstr ""
"Когда этот первый поток входит в режим guile, глобальное состояние Guile\n"
"инициализируется перед вызовом @code{func}."

#: /home/bear/work/guile/doc/guile/en/api-init.texi:46
msgid ""
"The function @var{func} is called via\n"
"@code{scm_with_continuation_barrier}; thus, @code{scm_with_guile}\n"
"returns exactly once."
msgstr ""
"Функция @var{func} вызывается через\n"
"@code{scm_with_continuation_barrier}; таким образом, @code{scm_with_guile}\n"
"возвращается ровно один раз."

#: /home/bear/work/guile/doc/guile/en/api-init.texi:53
msgid ""
"When @code{scm_with_guile} returns, the thread is no longer in guile\n"
"mode (except when @code{scm_with_guile} was called from guile mode, see\n"
"above).  Thus, only @code{func} can store @code{SCM} variables on the\n"
"stack and be sure that they are protected from the garbage collector.\n"
"See @code{scm_init_guile} for another approach at initializing Guile\n"
"that does not have this restriction."
msgstr ""
"Когда @code{scm_with_guile} возвращается, поток больше не находиться в "
"режиме guile\n"
"(кроме случаев, когда @code{scm_with_guile} был вызван из режима guile, см "
"выше).\n"
"Таким образом, только @code{func} может хранить @code{SCM} переменные в "
"стеке и\n"
"быть уверенным что они защищены от сборщика мусора.\n"
"См. @code{scm_init_guile} для другого подхода к инициализации Guile,\n"
"который не имеет данных ограничений."

#: /home/bear/work/guile/doc/guile/en/api-init.texi:58
msgid ""
"It is OK to call @code{scm_with_guile} while a thread has temporarily\n"
"left guile mode via @code{scm_without_guile}.  It will then simply\n"
"temporarily enter guile mode again.\n"
"@end deftypefn"
msgstr ""
"Это хорошо вызвать @code{scm_with_guile}, когда поток временно вышел из \n"
"режима guile использовав @code{scm_without_guile}.  Затем он просто опять \n"
"временно войдет в режим guile.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-init.texi:65
msgid ""
"@deftypefn {C Function} void scm_init_guile ()\n"
"Arrange things so that all of the code in the current thread executes as\n"
"if from within a call to @code{scm_with_guile}.  That is, all functions\n"
"called by the current thread can assume that @code{SCM} values on their\n"
"stack frames are protected from the garbage collector (except when the\n"
"thread has explicitly left guile mode, of course)."
msgstr ""
"@deftypefn {C Function} void scm_init_guile ()\n"
"Организует вещи так, чтобы весь код в текущем потоке выполнялся как будто \n"
"внутри вызова @code{scm_with_guile}.  То есть все функции вызываемые "
"текущим\n"
"потоком, могут полагать что значения @code{SCM} в их кадрах стека защищены\n"
"от сборщика мусора (за исключением случаев, когда поток явно вышел из "
"режима\n"
"guile, коченчно)."

#: /home/bear/work/guile/doc/guile/en/api-init.texi:72
msgid ""
"When @code{scm_init_guile} is called from a thread that already has been\n"
"in guile mode once, nothing happens.  This behavior matters when you\n"
"call @code{scm_init_guile} while the thread has only temporarily left\n"
"guile mode: in that case the thread will not be in guile mode after\n"
"@code{scm_init_guile} returns.  Thus, you should not use\n"
"@code{scm_init_guile} in such a scenario."
msgstr ""
"Когда @code{scm_init_guile} вызывается из потока, который уже находиться в\n"
"одном режиме guile, ничего не происходит.  Такое поведение имеет значение,\n"
"когда вы вызываете  @code{scm_init_guile} в то время когда поток только\n"
"временно вышел из режима guile: в этом случае поток не будет в режиме guile\n"
"после возврата @code{scm_init_guile}.  Таким образом, вы не должны "
"использовать\n"
"@code{scm_init_guile} по такому сценарию."

#: /home/bear/work/guile/doc/guile/en/api-init.texi:77
msgid ""
"When a uncaught throw happens in a thread that has been put into guile\n"
"mode via @code{scm_init_guile}, a short message is printed to the\n"
"current error port and the thread is exited via @code{scm_pthread_exit\n"
"(NULL)}.  No restrictions are placed on continuations."
msgstr ""
"Когда в потоке, переведенном в режим guile @code{scm_init_guile}, "
"происходит\n"
"непрехваченное исключение, печатается короткое сообщение в текущий порт "
"ошибки и\n"
"поток завершается с помощью @code{scm_pthread_exit\n"
"(NULL)}.  На продолжения не накладывается никаких ограничений."

#: /home/bear/work/guile/doc/guile/en/api-init.texi:84
msgid ""
"The function @code{scm_init_guile} might not be available on all\n"
"platforms since it requires some stack-bounds-finding magic that might\n"
"not have been ported to all platforms that Guile runs on.  Thus, if you\n"
"can, it is better to use @code{scm_with_guile} or its variation\n"
"@code{scm_boot_guile} instead of this function.\n"
"@end deftypefn"
msgstr ""
"Функция @code{scm_init_guile} может быть недоступной на всех платформах, так "
"как\n"
"это требует некоторой магии поиска границ стека, которая могла бы быть "
"перенесена\n"
"на все платформы, на которых работает Guile.  Таким образом, если вы можете, "
"лучше\n"
"использовать @code{scm_with_guile} или его вариант @code{scm_boot_guile} "
"вместо\n"
"этой функции.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-init.texi:92
msgid ""
"@deftypefn {C Function} void scm_boot_guile (int @var{argc}, char "
"**@var{argv}, void (*@var{main_func}) (void *@var{data}, int @var{argc}, "
"char **@var{argv}), void *@var{data})\n"
"Enter guile mode as with @code{scm_with_guile} and call @var{main_func},\n"
"passing it @var{data}, @var{argc}, and @var{argv} as indicated.  When\n"
"@var{main_func} returns, @code{scm_boot_guile} calls @code{exit (0)};\n"
"@code{scm_boot_guile} never returns.  If you want some other exit value,\n"
"have @var{main_func} call @code{exit} itself.  If you don't want to exit\n"
"at all, use @code{scm_with_guile} instead of @code{scm_boot_guile}."
msgstr ""
"@deftypefn {C Function} void scm_boot_guile (int @var{argc}, char "
"**@var{argv}, void (*@var{main_func}) (void *@var{data}, int @var{argc}, "
"char **@var{argv}), void *@var{data})\n"
"Входит в режим guile как с @code{scm_with_guile} и вызывает "
"@var{main_func},\n"
"передавая ей @var{data}, @var{argc}, и @var{argv} как указано.  Когда\n"
"@var{main_func} возвращается, @code{scm_boot_guile} вызывает @code{exit "
"(0)};\n"
"@code{scm_boot_guile} никогда не возвращается.  Если вам нужно другое "
"значение\n"
"выхода, используйте в @var{main_func} вызов @code{exit} сами.  Если вы не "
"хотите выходить\n"
"вообще, используйте @code{scm_with_guile} вместо @code{scm_boot_guile}."

#: /home/bear/work/guile/doc/guile/en/api-init.texi:100
msgid ""
"The function @code{scm_boot_guile} arranges for the Scheme\n"
"@code{command-line} function to return the strings given by @var{argc}\n"
"and @var{argv}.  If @var{main_func} modifies @var{argc} or @var{argv},\n"
"it should call @code{scm_set_program_arguments} with the final list, so\n"
"Scheme code will know which arguments have been processed\n"
"(@pxref{Runtime Environment}).\n"
"@end deftypefn"
msgstr ""
"Функция @code{scm_boot_guile} организует для функции @code{command-line} "
"Scheme\n"
"возврат строк переданных с помощью @var{argc} и @var{argv}.  Если "
"@var{main_func}\n"
"изменяет @var{argc} или @var{argv}, она должна вызвать "
"@code{scm_set_program_arguments} \n"
"с окончательным списком, чтобы код Scheme узнал, какие аргументы необходимо "
"обработать.\n"
"(@pxref{Runtime Environment}).\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-init.texi:107
msgid ""
"@deftypefn {C Function} void scm_shell (int @var{argc}, char **@var{argv})\n"
"Process command-line arguments in the manner of the @code{guile}\n"
"executable.  This includes loading the normal Guile initialization\n"
"files, interacting with the user or running any scripts or expressions\n"
"specified by @code{-s} or @code{-e} options, and then exiting.\n"
"@xref{Invoking Guile}, for more details."
msgstr ""
"@deftypefn {C Function} void scm_shell (int @var{argc}, char **@var{argv})\n"
"Обрабатывает аргументы командной строки в манере исполняемого файла "
"@code{guile}.\n"
"Это включет загрузку обычных файлов инициализации Guile, взаимодействие с \n"
"пользователем или запуск любых сценариев или выражений, заданных "
"параметрами\n"
"@code{-s} или @code{-e}, и затем выход.\n"
"@xref{Invoking Guile}, для более подробной информации."

#: /home/bear/work/guile/doc/guile/en/api-init.texi:110
msgid ""
"Since this function does not return, you must do all\n"
"application-specific initialization before calling this function.\n"
"@end deftypefn"
msgstr ""
"Поскольку эта фунция не возвращается, вы должны выполнить всю инициализацию\n"
"для конкретного приложения перед вызовом этой функции.\n"
"@end deftypefn"
