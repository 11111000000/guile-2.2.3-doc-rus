#
# Gagin <mikhail-gagin@yandex.ru>, 2018.
#
#. extracted from /home/bear/work/guile/doc/guile/en/compiler.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-07 12:37+0300\n"
"PO-Revision-Date: 2018-06-21 09:25+0300\n"
"Last-Translator: Gagin <mikhail-gagin@yandex.ru>\n"
"Language-Team: Russian <mikhail-gagin@yandex.ru>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C)  2008-2016\n"
"@c   Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:9
msgid ""
"@node Compiling to the Virtual Machine\n"
"@section Compiling to the Virtual Machine"
msgstr ""
"@node Compiling to the Virtual Machine\n"
"@section Компиляция в код Виртуальной Машины"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:15
msgid ""
"Compilers!  The word itself inspires excitement and awe, even among\n"
"experienced practitioners.  But a compiler is just a program: an\n"
"eminently hackable thing.  This section aims to to describe Guile's\n"
"compiler in such a way that interested Scheme hackers can feel\n"
"comfortable reading and extending it."
msgstr ""
"Компиляторы!  Само слово вызывает волнение и срах даже среди опытных\n"
"практиков. Но компилятор - это просто программа: черезвычайно хакерская\n"
"вещь. Эта секция направлена на то, чтобы описать компилятор Guile\n"
"таким образом, чтобы заинтересованные Scheme хакеры могли чувствовать\n"
"себя удобно при чтении и расширении его."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:18
msgid ""
"@xref{Read/Load/Eval/Compile}, if you're lost and you just wanted to\n"
"know how to compile your @code{.scm} file."
msgstr ""
"@xref{Read/Load/Eval/Compile}, если вы потерялись, и вы просто хотите\n"
"знать, как скомпилировать ваш @code{.scm} файл."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:28
msgid ""
"@menu\n"
"* Compiler Tower::                   \n"
"* The Scheme Compiler::                   \n"
"* Tree-IL::                 \n"
"* Continuation-Passing Style::                 \n"
"* Bytecode::                \n"
"* Writing New High-Level Languages::\n"
"* Extending the Compiler::\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:31
msgid ""
"@node Compiler Tower\n"
"@subsection Compiler Tower"
msgstr ""
"@node Compiler Tower\n"
"@subsection Башня Компилятора"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:36
msgid ""
"Guile's compiler is quite simple -- its @emph{compilers}, to put it more\n"
"accurately.  Guile defines a tower of languages, starting at Scheme and\n"
"progressively simplifying down to languages that resemble the VM\n"
"instruction set (@pxref{Instruction Set})."
msgstr ""
"Guile компилятор довольно прост -- это компиляторы @emph{compilers}, если \n"
"выражаться более точно. Guile определяет башню языков, начиная со Scheme и\n"
"постепенно упрощая до языков которые напоминают набор инструкций ВМ\n"
"(@pxref{Instruction Set})."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:41
msgid ""
"Each language knows how to compile to the next, so each step is simple\n"
"and understandable.  Furthermore, this set of languages is not hardcoded\n"
"into Guile, so it is possible for the user to add new high-level\n"
"languages, new passes, or even different compilation targets."
msgstr ""
"Каждый язык знает, как скомпилировать до следующего, поэтому каждый\n"
"шаг прост и понятен.  Кроме того, этот набор языков не жестко закодирован\n"
"в Guile, поэтому можно пользователю добавлять новые языки высокого уровня,\n"
"новые проходы, или даже раличные цели компиляции."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:43
msgid "Languages are registered in the module, @code{(system base language)}:"
msgstr "Языки зарегистрированы в модуле, @code{(system base language)}:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:47
msgid ""
"@example\n"
"(use-modules (system base language))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:49
msgid "They are registered with the @code{define-language} form."
msgstr "Они зарегистрированы в форме @code{define-language}."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:57
msgid ""
"@deffn {Scheme Syntax} define-language @\n"
"                       [#:name] [#:title] [#:reader] [#:printer] @\n"
"                       [#:parser=#f] [#:compilers='()] @\n"
"                       [#:decompilers='()] [#:evaluator=#f] @\n"
"                       [#:joiner=#f] [#:for-humans?=#t] @\n"
"                       [#:make-default-environment=make-fresh-user-module]\n"
"Define a language."
msgstr ""
"@deffn {Scheme Syntax} define-language @\n"
"                       [#:name] [#:title] [#:reader] [#:printer] @\n"
"                       [#:parser=#f] [#:compilers='()] @\n"
"                       [#:decompilers='()] [#:evaluator=#f] @\n"
"                       [#:joiner=#f] [#:for-humans?=#t] @\n"
"                       [#:make-default-environment=make-fresh-user-module]\n"
"Определяет язык."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:62
msgid ""
"This syntax defines a @code{<language>} object, bound to @var{name} in\n"
"the current environment.  In addition, the language will be added to the\n"
"global language set.  For example, this is the language definition for\n"
"Scheme:"
msgstr ""
"Этот синтаксис определяет объект @code{<language>}, связаный с именем "
"@var{name}\n"
"в текущй среде. Кроме того, язык будет добавлен в глобальный набор языков. \n"
"Например, это определения языка для Scheme:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:74
msgid ""
"@example\n"
"(define-language scheme\n"
"  #:title\t\"Scheme\"\n"
"  #:reader      (lambda (port env) ...)\n"
"  #:compilers   `((tree-il . ,compile-tree-il))\n"
"  #:decompilers `((tree-il . ,decompile-tree-il))\n"
"  #:evaluator\t(lambda (x module) (primitive-eval x))\n"
"  #:printer\twrite\n"
"  #:make-default-environment (lambda () ...))\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:78
msgid ""
"The interesting thing about having languages defined this way is that\n"
"they present a uniform interface to the read-eval-print loop.  This\n"
"allows the user to change the current language of the REPL:"
msgstr ""
"Интересная вещь заключается в том, что языки определены таким образом,\n"
"что они представляют единый интерфейс к циклу read-eval-print loop.  \n"
"Это позволяет пользователю изменять текущий язык REPL:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:86
msgid ""
"@example\n"
"scheme@@(guile-user)> ,language tree-il\n"
"Happy hacking with Tree Intermediate Language!  To switch back, type `,L "
"scheme'.\n"
"tree-il@@(guile-user)> ,L scheme\n"
"Happy hacking with Scheme!  To switch back, type `,L tree-il'.\n"
"scheme@@(guile-user)> \n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:88
msgid "Languages can be looked up by name, as they were above."
msgstr "Язык можно найти по имени, так как показано выше."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:91
msgid ""
"@deffn {Scheme Procedure} lookup-language name\n"
"Looks up a language named @var{name}, autoloading it if necessary."
msgstr ""
"@deffn {Scheme Procedure} lookup-language name\n"
"Ищет язык по имени @var{name}, автоматически загружая его, если необходимо."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:94
msgid ""
"Languages are autoloaded by looking for a variable named @var{name} in\n"
"a module named @code{(language @var{name} spec)}."
msgstr ""
"Язык автоматически загружается путем поиска пермеменной с именем\n"
"@var{name} в модуле с именем @code{(language @var{name} spec)}."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:98
msgid ""
"The language object will be returned, or @code{#f} if there does not\n"
"exist a language with that name.\n"
"@end deffn"
msgstr ""
"Объект языка будет возвращен, или @code{#f} если не существует языка\n"
"с таким именем.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:101
msgid ""
"Defining languages this way allows us to programmatically determine\n"
"the necessary steps for compiling code from one language to another."
msgstr ""
"Определение языков таким образом позволяет нам программно определять\n"
"необходимые шаги для компиляции кода с одного языка на другой."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:106
msgid ""
"@deffn {Scheme Procedure} lookup-compilation-order from to\n"
"Recursively traverses the set of languages to which @var{from} can\n"
"compile, depth-first, and return the first path that can transform\n"
"@var{from} to @var{to}. Returns @code{#f} if no path is found."
msgstr ""
"@deffn {Scheme Procedure} lookup-compilation-order from to\n"
"Рекурсивно пересекает множество языков, с которыми можно компилировать\n"
"ища в глубину, и возвращает первый путь, который может преобразовывать\n"
"@var{from} в @var{to}. Возвращает @code{#f} если путь не найден."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:111
msgid ""
"This function memoizes its results in a cache that is invalidated by\n"
"subsequent calls to @code{define-language}, so it should be quite\n"
"fast.\n"
"@end deffn"
msgstr ""
"Эта функция запоминает свои результаты в кеше, который становиться\n"
"недействительным последующими вызовами @code{define-language}, поэтому\n"
"он должен быть доволно быстрым.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:118
msgid ""
"There is a notion of a ``current language'', which is maintained in the\n"
"@code{current-language} parameter, defined in the core @code{(guile)}\n"
"module.  This language is normally Scheme, and may be rebound by the\n"
"user.  The run-time compilation interfaces\n"
"(@pxref{Read/Load/Eval/Compile}) also allow you to choose other source\n"
"and target languages."
msgstr ""
"Существует понятие ``текущего языка(current language)'', который\n"
"содержиться в параметре @code{current-language}, определенном \n"
"в ядре модуля @code{(guile)}. Этот язык обычно представляет собой\n"
"Scheme, и может быть переустановлен пользователем. Интерфейс\n"
"компиляции во время выполнения (@pxref{Read/Load/Eval/Compile}) \n"
"так же позволяет выбирать другие языки источника и цели.\n"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:120
msgid "The normal tower of languages when compiling Scheme goes like this:"
msgstr "Обычная башня языков при компиляции Scheme выглядит следующим образом:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:127
msgid ""
"@itemize\n"
"@item Scheme\n"
"@item Tree Intermediate Language (Tree-IL)\n"
"@item Continuation-Passing Style (CPS)\n"
"@item Bytecode\n"
"@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:133
msgid ""
"As discussed before (@pxref{Object File Format}), bytecode is in ELF\n"
"format, ready to be serialized to disk.  But when compiling Scheme at\n"
"run time, you want a Scheme value: for example, a compiled procedure.\n"
"For this reason, so as not to break the abstraction, Guile defines a\n"
"fake language at the bottom of the tower:"
msgstr ""
"Как обсуждалось ранее (@pxref{Object File Format}), байт-код(bytecode)\n"
"находиться в формате ELF, готовый к сериализации(последовательной записи)\n"
"на диск.  Но при компиляции Scheme во время выполнения, вам требуется\n"
"значение Scheme: например, при компиляции процедуры. По этой причине, \n"
"чтобы не сломать абстракцию, Guile определяет фальшивый язык в \n"
"нижней части башни языков:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:137
msgid ""
"@itemize\n"
"@item Value\n"
"@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:140
msgid ""
"Compiling to @code{value} loads the bytecode into a procedure, turning\n"
"cold bytes into warm code."
msgstr ""
"Компиляция в язык @code{value} загружает байткод в процедуру, превращает\n"
"холодные байты в горячий код."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:146
msgid ""
"Perhaps this strangeness can be explained by example:\n"
"@code{compile-file} defaults to compiling to bytecode, because it\n"
"produces object code that has to live in the barren world outside the\n"
"Guile runtime; but @code{compile} defaults to compiling to @code{value},\n"
"as its product re-enters the Guile world."
msgstr ""
"Возможно, эту странность можно объяснить примером: \n"
"@code{compile-file} по умолчанию компилирует в байт-код(bytecode), потому\n"
"что он создает объектный код который должен жить в бесплодном мире\n"
"вне времени выполнения Guile; но фукция @code{compile} по умолчанию\n"
"компилирут в @code{value}, послкольку этот результат возвращается в мир\n"
"Guile."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:149
msgid ""
"@c FIXME: This doesn't work anymore :(  Should we add some kind of\n"
"@c special GC pass, or disclaim this kind of code, or what?"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:152
msgid ""
"Indeed, the process of compilation can circulate through these\n"
"different worlds indefinitely, as shown by the following quine:"
msgstr ""
"Действительно, процесс компиляции ожет распространяться через эти\n"
"разные миры на неопределенный срок, как показано в следующем\n"
"quine(прогр. выдающая на выход точную копию своего исходного текста):"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:156
msgid ""
"@example\n"
"((lambda (x) ((compile x) x)) '(lambda (x) ((compile x) x)))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:159
msgid ""
"@node The Scheme Compiler\n"
"@subsection The Scheme Compiler"
msgstr ""
"@node The Scheme Compiler\n"
"@subsection Компилятор Scheme"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:166
msgid ""
"The job of the Scheme compiler is to expand all macros and all of Scheme\n"
"to its most primitive expressions.  The definition of ``primitive\n"
"expression'' is given by the inventory of constructs provided by\n"
"Tree-IL, the target language of the Scheme compiler: procedure calls,\n"
"conditionals, lexical references, and so on.  This is described more\n"
"fully in the next section."
msgstr ""
"Задача компилятора Scheme состоит в том, чтобы развернуть все макросы\n"
"и все конструкции Scheme до самых примитивных выражений. Определение\n"
"``примитивного выражения'' дается инвентаризацией конструкций, \n"
"предоставлеямых Tree-IL, целевом языке компилятора Scheme: вызовы процедур,\n"
"условные выражения, лексические ссылки и т.д. Они описаны более подробно\n"
"в следующем разделе."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:172
msgid ""
"The tricky and amusing thing about the Scheme-to-Tree-IL compiler is\n"
"that it is completely implemented by the macro expander.  Since the\n"
"macro expander has to run over all of the source code already in order\n"
"to expand macros, it might as well do the analysis at the same time,\n"
"producing Tree-IL expressions directly."
msgstr ""
"Сложная и интересная вещь о компиляторе Scheme-to-Tree-IL заключается\n"
"в том, что он полностью реализует расширение(развертку) макросов.\n"
"Поскольку расширитель макросов должен пробегать по всему исходному\n"
"коду для расширения макросов, он мог бы также провести анализ в это же\n"
"время, непосредственно формируя выражения Tree-IL."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:175
msgid ""
"Because this compiler is actually the macro expander, it is extensible.\n"
"Any macro which the user writes becomes part of the compiler."
msgstr ""
"Поскольку этот компилятор фактически является расширителем макросов,\n"
"он расширяем! Любой макрос, который записывает пользователь, становиться\n"
"частью компилятора."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:178
msgid ""
"The Scheme-to-Tree-IL expander may be invoked using the generic\n"
"@code{compile} procedure:"
msgstr ""
"Макрорасширитель Scheme-to-Tree-IL может быть вызван с ипользованием\n"
"общей процедуры компиляции @code{compile}:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:184
msgid ""
"@lisp\n"
"(compile '(+ 1 2) #:from 'scheme #:to 'tree-il)\n"
"@result{}\n"
"#<tree-il (call (toplevel +) (const 1) (const 2))>\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:192
msgid ""
"@code{(compile @var{foo} #:from 'scheme #:to 'tree-il)} is entirely\n"
"equivalent to calling the macro expander as @code{(macroexpand @var{foo}\n"
"'c '(compile load eval))}.  @xref{Macro Expansion}.\n"
"@code{compile-tree-il}, the procedure dispatched by @code{compile} to\n"
"@code{'tree-il}, is a small wrapper around @code{macroexpand}, to make\n"
"it conform to the general form of compiler procedures in Guile's\n"
"language tower."
msgstr ""
"@code{(compile @var{foo} #:from 'scheme #:to 'tree-il)} полностью "
"эквивалентен\n"
"вызову макрорасширителя  @code{(macroexpand @var{foo}\n"
"'c '(compile load eval))}.  @xref{Macro Expansion}.\n"
"@code{compile-tree-il}, это процедура используемая в @code{compile} для \n"
"получения @code{'tree-il}, представляет собой обертку вокруг "
"@code{macroexpand},\n"
"чтобы его вызов соответствовал общей форме процедур компилятора в языковой\n"
"башне Guile."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:200
msgid ""
"Compiler procedures take three arguments: an expression, an\n"
"environment, and a keyword list of options. They return three values:\n"
"the compiled expression, the corresponding environment for the target\n"
"language, and a ``continuation environment''. The compiled expression\n"
"and environment will serve as input to the next language's compiler.\n"
"The ``continuation environment'' can be used to compile another\n"
"expression from the same source language within the same module."
msgstr ""
"Процедуры компиляции принимают три аргумента: выражение, среду(окружение) и\n"
"как опцию список ключевых слов. Они возвращают три значения: "
"скомпилированное\n"
"выражение, соответствующее среде целевого языка, и ``среда продолжения \n"
"(continuation environment)''. Скомпилированное выражение и среда будут\n"
"служить в качестве входных данных для компилятора языка следущего уровня.\n"
"``Среда продолжения'' может быть использована для компиляции другого\n"
"выражения из того же языка источника внутри одного модуля."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:208
msgid ""
"For example, you might compile the expression, @code{(define-module\n"
"(foo))}. This will result in a Tree-IL expression and environment. But\n"
"if you compiled a second expression, you would want to take into\n"
"account the compile-time effect of compiling the previous expression,\n"
"which puts the user in the @code{(foo)} module. That is purpose of the\n"
"``continuation environment''; you would pass it as the environment\n"
"when compiling the subsequent expression."
msgstr ""
"Например, вы можете скомпилировать выражение, @code{(define-module\n"
"(foo))}. Это приведет построению вражения и среды на языке Tree-IL.\n"
"Но если вы компилируете второе(и последующие) выражения, вы хотели \n"
"бы получить  эффект от компиляции предыдущего выражения учитываемый \n"
"во время компиляции, результат которой пользователь помещает в модуль \n"
"@code{(foo)}. \n"
"Это и есть назначение ``среды продолжения(continuation environment)''; вы "
"должны \n"
"передать ее в качестве среды при компиляции последующих выражений."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:213
msgid ""
"For Scheme, an environment is a module. By default, the @code{compile}\n"
"and @code{compile-file} procedures compile in a fresh module, such\n"
"that bindings and macros introduced by the expression being compiled\n"
"are isolated:"
msgstr ""
"Для Scheme, среда представляет собой модуль. По умолчанию, процедуры\n"
"@code{compile} и @code{compile-file} компилирутся в новом модуле,\n"
"так что связанные переменные и макросы введенные в выражении\n"
"компилируются отдельно:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:217
msgid ""
"@example\n"
"(eq? (current-module) (compile '(current-module)))\n"
"@result{} #f"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:221
msgid ""
"(compile '(define hello 'world))\n"
"(defined? 'hello)\n"
"@result{} #f"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:226
msgid ""
"(define / *)\n"
"(eq? (compile '/) /)\n"
"@result{} #f\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:229
msgid ""
"Similarly, changes to the @code{current-reader} fluid (@pxref{Loading,\n"
"@code{current-reader}}) are isolated:"
msgstr ""
"Аналогично, измения @code{current-reader} fluid (@pxref{Loading,\n"
"@code{current-reader}}) изолированы:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:235
msgid ""
"@example\n"
"(compile '(fluid-set! current-reader (lambda args 'fail)))\n"
"(fluid-ref current-reader)\n"
"@result{} #f\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:239
msgid ""
"Nevertheless, having the compiler and @dfn{compilee} share the same name\n"
"space can be achieved by explicitly passing @code{(current-module)} as\n"
"the compilation environment:"
msgstr ""
"Тем не менее, имея компилятор и @dfn{compilee}, общее\n"
"пространство имен может быть достигнуто явной передачей @code{(current-"
"module)}\n"
"в качестве среды компиляции:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:245
msgid ""
"@example\n"
"(define hello 'world)\n"
"(compile 'hello #:env (current-module))\n"
"@result{} world\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:248
msgid ""
"@node Tree-IL\n"
"@subsection Tree-IL"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:252
msgid ""
"Tree Intermediate Language (Tree-IL) is a structured intermediate\n"
"language that is close in expressive power to Scheme. It is an\n"
"expanded, pre-analyzed Scheme."
msgstr ""
"Tree Intermediate Language (Tree-IL) это структурированный промежуточный\n"
"язык, который близок к выразительной способности  Scheme. Это развернутая,\n"
"предварительно проанализированная Scheme."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:262
msgid ""
"Tree-IL is ``structured'' in the sense that its representation is\n"
"based on records, not S-expressions. This gives a rigidity to the\n"
"language that ensures that compiling to a lower-level language only\n"
"requires a limited set of transformations. For example, the Tree-IL\n"
"type @code{<const>} is a record type with two fields, @code{src} and\n"
"@code{exp}. Instances of this type are created via @code{make-const}.\n"
"Fields of this type are accessed via the @code{const-src} and\n"
"@code{const-exp} procedures. There is also a predicate, @code{const?}.\n"
"@xref{Records}, for more information on records."
msgstr ""
"Tree-IL является ``структурированным(structured)'' в том смысле, что\n"
"его представление основано на записях,  а не S-выражениях.\n"
"Это дает жесткость языку, которые обеспечивает компиляцию на язык\n"
"нижнего уровня, требуя ограниченного набора преобразований. Например,\n"
"тип Tree-IL @code{<const>} это запись с двумя полями @code{src} и\n"
"@code{exp}. Экземпляры этого типа созданы с помощью @code{make-const}.\n"
"Поля этого типа доступны через процедуры @code{const-src} и\n"
"@code{const-exp}. Существует также предикат, @code{const?}.\n"
"@xref{Records}, для дальнейшей информации о записях."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:264
msgid "@c alpha renaming"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:271
msgid ""
"All Tree-IL types have a @code{src} slot, which holds source location\n"
"information for the expression. This information, if present, will be\n"
"residualized into the compiled object code, allowing backtraces to\n"
"show source information. The format of @code{src} is the same as that\n"
"returned by Guile's @code{source-properties} function. @xref{Source\n"
"Properties}, for more information."
msgstr ""
"Все типы Tree-IL имеют слот @code{src}, который содержит информацию\n"
"о местоположении источника для выражения. Эта информаия, если она \n"
"присутствует, будет оставлена в скомпилированом объектном коде,\n"
"позволяя трассировщику вызовов показывать информацию об исходном \n"
"коде процедур. Формат @code{src} такой же, как и возвращаемый\n"
"функцией Guile @code{source-properties}. @xref{Source\n"
"Properties}, для получения дополнительной информации."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:276
msgid ""
"Although Tree-IL objects are represented internally using records,\n"
"there is also an equivalent S-expression external representation for\n"
"each kind of Tree-IL. For example, the S-expression representation\n"
"of @code{#<const src: #f exp: 3>} expression would be:"
msgstr ""
"Хотя объекты Tree-IL представлены внутренне с использованием записей,\n"
"сущетствует также эквивалент S-выражений внешнего представления для\n"
"каждого типа Tree-IL. Например, S-выражение представления выражения\n"
"@code{#<const src: #f exp: 3>} был бы:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:280
msgid ""
"@example\n"
"(const 3)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:282
msgid "Users may program with this format directly at the REPL:"
msgstr ""
"Пользоватеи могут запрограммировать этот формат непосредственно\n"
"на REPL:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:289
msgid ""
"@example\n"
"scheme@@(guile-user)> ,language tree-il\n"
"Happy hacking with Tree Intermediate Language!  To switch back, type `,L "
"scheme'.\n"
"tree-il@@(guile-user)> (call (primitive +) (const 32) (const 10))\n"
"@result{} 42\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:291
msgid "The @code{src} fields are left out of the external representation."
msgstr "Поля @code{src} остаются вне внешнего представления."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:299
msgid ""
"One may create Tree-IL objects from their external representations via\n"
"calling @code{parse-tree-il}, the reader for Tree-IL. If any source\n"
"information is attached to the input S-expression, it will be\n"
"propagated to the resulting Tree-IL expressions. This is probably the\n"
"easiest way to compile to Tree-IL: just make the appropriate external\n"
"representations in S-expression format, and let @code{parse-tree-il}\n"
"take care of the rest."
msgstr ""
"Можно создавать объекты Tree-IL из своих внешних представлений посредством\n"
"вызова @code{parse-tree-il}, читателя для  Tree-IL. Если подключить\n"
"какую либо исходную информацию  вводимого S-выражения, она будет "
"распространена\n"
"на результирующее выражение Tree-IL. Это вероятно, самый простой способ\n"
"скомпилировать выражение в Tree-IL: просто сделайте соответствующее внешнее\n"
"представление в формате S-выражения, и пусть @code{parse-tree-il}\n"
"позаботиться об остальном."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:305
msgid ""
"@deftp {Scheme Variable} <void> src\n"
"@deftpx {External Representation} (void)\n"
"An empty expression.  In practice, equivalent to Scheme's @code{(if #f\n"
"#f)}.\n"
"@end deftp"
msgstr ""
"@deftp {Scheme Variable} <void> src\n"
"@deftpx {External Representation} (void)\n"
"Пустое выражение.  На практике, оно эквивалентно выражению Scheme @code{(if "
"#f\n"
"#f)}.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:310
msgid ""
"@deftp {Scheme Variable} <const> src exp\n"
"@deftpx {External Representation} (const @var{exp})\n"
"A constant.\n"
"@end deftp"
msgstr ""
"@deftp {Scheme Variable} <const> src exp\n"
"@deftpx {External Representation} (const @var{exp})\n"
"Константа.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:317
msgid ""
"@deftp {Scheme Variable} <primitive-ref> src name\n"
"@deftpx {External Representation} (primitive @var{name})\n"
"A reference to a ``primitive''.  A primitive is a procedure that, when\n"
"compiled, may be open-coded.  For example, @code{cons} is usually\n"
"recognized as a primitive, so that it compiles down to a single\n"
"instruction."
msgstr ""
"@deftp {Scheme Variable} <primitive-ref> src name\n"
"@deftpx {External Representation} (primitive @var{name})\n"
"Ссылка на ``примитив(primitive)''.  Примитив - это процедура, которая\n"
"при компиляции превращается в код операции(open-coded).  Например, \n"
"выражения @code{cons} обычно распознаются как примитивные, так что \n"
"скомпилируются до одной инструкции."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:324
msgid ""
"Compilation of Tree-IL usually begins with a pass that resolves some\n"
"@code{<module-ref>} and @code{<toplevel-ref>} expressions to\n"
"@code{<primitive-ref>} expressions.  The actual compilation pass has\n"
"special cases for calls to certain primitives, like @code{apply} or\n"
"@code{cons}.\n"
"@end deftp"
msgstr ""
"Компиляция Tree-IL обычно начинается с прохода, кторый разрешает некоторые\n"
"выражения @code{<module-ref>} и @code{<toplevel-ref>} в выражения\n"
"@code{<primitive-ref>}.  Фактический проход компиляции имеет особые случаи\n"
"для интерпретации некотоырых вызов  в определенные примитивы, например\n"
"подобные @code{apply} или @code{cons}.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:331
msgid ""
"@deftp {Scheme Variable} <lexical-ref> src name gensym\n"
"@deftpx {External Representation} (lexical @var{name} @var{gensym})\n"
"A reference to a lexically-bound variable.  The @var{name} is the\n"
"original name of the variable in the source program. @var{gensym} is a\n"
"unique identifier for this variable.\n"
"@end deftp"
msgstr ""
"@deftp {Scheme Variable} <lexical-ref> src name gensym\n"
"@deftpx {External Representation} (lexical @var{name} @var{gensym})\n"
"Ссылка на лексически связанную переменную. Имя(@var{name}) это оригинальное\n"
"имя переменной в исходной программе. @var{gensym} это уникальный "
"идентификатор\n"
"для этой переменной.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:336
msgid ""
"@deftp {Scheme Variable} <lexical-set> src name gensym exp\n"
"@deftpx {External Representation} (set! (lexical @var{name} @var{gensym}) "
"@var{exp})\n"
"Sets a lexically-bound variable.\n"
"@end deftp"
msgstr ""
"@deftp {Scheme Variable} <lexical-set> src name gensym exp\n"
"@deftpx {External Representation} (set! (lexical @var{name} @var{gensym}) "
"@var{exp})\n"
"Выполняет лексическое связывание переменной.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:342
msgid ""
"@deftp {Scheme Variable} <module-ref> src mod name public?\n"
"@deftpx {External Representation} (@@ @var{mod} @var{name})\n"
"@deftpx {External Representation} (@@@@ @var{mod} @var{name})\n"
"A reference to a variable in a specific module. @var{mod} should be\n"
"the name of the module, e.g.@: @code{(guile-user)}."
msgstr ""
"@deftp {Scheme Variable} <module-ref> src mod name public?\n"
"@deftpx {External Representation} (@@ @var{mod} @var{name})\n"
"@deftpx {External Representation} (@@@@ @var{mod} @var{name})\n"
"Ссылка на переменную в определенном(указанном) модуле. @var{mod} \n"
"должна быть именем модуля, например: @code{(guile-user)}."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:348
msgid ""
"If @var{public?} is true, the variable named @var{name} will be looked\n"
"up in @var{mod}'s public interface, and serialized with @code{@@};\n"
"otherwise it will be looked up among the module's private bindings,\n"
"and is serialized with @code{@@@@}.\n"
"@end deftp"
msgstr ""
"Если @var{public?} истинно, переменная с именем @var{name} будет\n"
"видна в открытом(внешнем) интерфейся модуля @var{mod}, и сериализована\n"
"с помощью @code{@@}; иначеона будет рассматриваться как внутренняя\n"
"связанная переменная и сериализироваться с помощью @code{@@@@}.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:354
msgid ""
"@deftp {Scheme Variable} <module-set> src mod name public? exp\n"
"@deftpx {External Representation} (set! (@@ @var{mod} @var{name}) "
"@var{exp})\n"
"@deftpx {External Representation} (set! (@@@@ @var{mod} @var{name}) "
"@var{exp})\n"
"Sets a variable in a specific module.\n"
"@end deftp"
msgstr ""
"@deftp {Scheme Variable} <module-set> src mod name public? exp\n"
"@deftpx {External Representation} (set! (@@ @var{mod} @var{name}) "
"@var{exp})\n"
"@deftpx {External Representation} (set! (@@@@ @var{mod} @var{name}) "
"@var{exp})\n"
"Установка переменной в указанном модуле.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:359
msgid ""
"@deftp {Scheme Variable} <toplevel-ref> src name\n"
"@deftpx {External Representation} (toplevel @var{name})\n"
"References a variable from the current procedure's module.\n"
"@end deftp"
msgstr ""
"@deftp {Scheme Variable} <toplevel-ref> src name\n"
"@deftpx {External Representation} (toplevel @var{name})\n"
"Ссылка на переменную(верхнего уровня) из текущей процедуры модуля.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:364
msgid ""
"@deftp {Scheme Variable} <toplevel-set> src name exp\n"
"@deftpx {External Representation} (set! (toplevel @var{name}) @var{exp})\n"
"Sets a variable in the current procedure's module.\n"
"@end deftp"
msgstr ""
"@deftp {Scheme Variable} <toplevel-set> src name exp\n"
"@deftpx {External Representation} (set! (toplevel @var{name}) @var{exp})\n"
"Устанавливает(связывает с выржением выдающим значение) переменную(верхнего\n"
" уровня) в текущей процедуре модуля.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:369
msgid ""
"@deftp {Scheme Variable} <toplevel-define> src name exp\n"
"@deftpx {External Representation} (define @var{name} @var{exp})\n"
"Defines a new top-level variable in the current procedure's module.\n"
"@end deftp"
msgstr ""
"@deftp {Scheme Variable} <toplevel-define> src name exp\n"
"@deftpx {External Representation} (define @var{name} @var{exp})\n"
"Определяет новую переменную верхнего уровня в текущей процедуре\n"
"модуля.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:374
msgid ""
"@deftp {Scheme Variable} <conditional> src test then else\n"
"@deftpx {External Representation} (if @var{test} @var{then} @var{else})\n"
"A conditional. Note that @var{else} is not optional.\n"
"@end deftp"
msgstr ""
"@deftp {Scheme Variable} <conditional> src test then else\n"
"@deftpx {External Representation} (if @var{test} @var{then} @var{else})\n"
"Условие. Обратите внимание что @var{else} является обязательным.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:379
msgid ""
"@deftp {Scheme Variable} <call> src proc args\n"
"@deftpx {External Representation} (call @var{proc} . @var{args})\n"
"A procedure call.\n"
"@end deftp"
msgstr ""
"@deftp {Scheme Variable} <call> src proc args\n"
"@deftpx {External Representation} (call @var{proc} . @var{args})\n"
"Вызов процедуры.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:385
msgid ""
"@deftp {Scheme Variable} <primcall> src name args\n"
"@deftpx {External Representation} (primcall @var{name} . @var{args})\n"
"A call to a primitive.  Equivalent to @code{(call (primitive @var{name})\n"
". @var{args})}.  This construct is often more convenient to generate and\n"
"analyze than @code{<call>}."
msgstr ""
"@deftp {Scheme Variable} <primcall> src name args\n"
"@deftpx {External Representation} (primcall @var{name} . @var{args})\n"
"Вызов примитива  Эквивалент  @code{(call (primitive @var{name})\n"
". @var{args})}.  Эту конструкцию более удобно создавать и анализировать,\n"
"чем @code{<call>}."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:389
msgid ""
"As part of the compilation process, instances of @code{(call (primitive\n"
"@var{name}) . @var{args})} are transformed into primcalls.\n"
"@end deftp"
msgstr ""
"В рамках процесса компиляции экземпляры @code{(call (primitive\n"
"@var{name}) . @var{args})} преобразуются в  primcalls.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:396
msgid ""
"@deftp {Scheme Variable} <seq> src head tail\n"
"@deftpx {External Representation} (seq @var{head} @var{tail})\n"
"A sequence.  The semantics is that @var{head} is evaluated first, and\n"
"any resulting values are ignored.  Then @var{tail} is evaluated, in tail\n"
"position.\n"
"@end deftp"
msgstr ""
"@deftp {Scheme Variable} <seq> src head tail\n"
"@deftpx {External Representation} (seq @var{head} @var{tail})\n"
"Последовательность. Семантика заключается в том, что сначала вычисляется\n"
"@var{head}(голова) и любые результирующие значения игнорируются. Затем\n"
"вычисляется @var{tail}(хвост), указанный в позиции tail.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:405
msgid ""
"@deftp {Scheme Variable} <lambda> src meta body\n"
"@deftpx {External Representation} (lambda @var{meta} @var{body})\n"
"A closure.  @var{meta} is an association list of properties for the\n"
"procedure.  @var{body} is a single Tree-IL expression of type\n"
"@code{<lambda-case>}.  As the @code{<lambda-case>} clause can chain to\n"
"an alternate clause, this makes Tree-IL's @code{<lambda>} have the\n"
"expressiveness of Scheme's @code{case-lambda}.\n"
"@end deftp"
msgstr ""
"@deftp {Scheme Variable} <lambda> src meta body\n"
"@deftpx {External Representation} (lambda @var{meta} @var{body})\n"
"Замыкание.  @var{meta} это ассоциированный список свойств(значения с "
"именами)\n"
"для процедуры.  @var{body} это одиночное выражение Tree-IL типа "
"@code{<lambda-case>}.\n"
"Поскольку предложение @code{<lambda-case>} может быть альтернативной "
"цепочкой \n"
"предложений, это означает, что у Tree-IL's @code{<lambda>} есть "
"выразительность\n"
"языка Scheme  @code{case-lambda}.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:413
msgid ""
"@deftp {Scheme Variable} <lambda-case> req opt rest kw inits gensyms body "
"alternate\n"
"@deftpx {External Representation} @\n"
"  (lambda-case ((@var{req} @var{opt} @var{rest} @var{kw} @var{inits} "
"@var{gensyms})@\n"
"                @var{body})@\n"
"               [@var{alternate}])\n"
"One clause of a @code{case-lambda}.  A @code{lambda} expression in\n"
"Scheme is treated as a @code{case-lambda} with one clause."
msgstr ""
"@deftp {Scheme Variable} <lambda-case> req opt rest kw inits gensyms body "
"alternate\n"
"@deftpx {External Representation} @\n"
"  (lambda-case ((@var{req} @var{opt} @var{rest} @var{kw} @var{inits} "
"@var{gensyms})@\n"
"                @var{body})@\n"
"               [@var{alternate}])\n"
"Единичное предложение @code{case-lambda}.  Лямбда(@code{lambda}) выражение "
"на\n"
"Scheme рассматривается как @code{case-lambda} с одним предложением."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:418
msgid ""
"@var{req} is a list of the procedure's required arguments, as symbols.\n"
"@var{opt} is a list of the optional arguments, or @code{#f} if there\n"
"are no optional arguments. @var{rest} is the name of the rest\n"
"argument, or @code{#f}."
msgstr ""
"@var{req} - это список необходимых процедуре аргуменов, как символов\n"
"@var{opt} - это список необязательных аргументовis, или @code{#f} если нет\n"
"необязательных аргументов. @var{rest} это имя остальных аргументов, или\n"
"@code{#f}."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:427
msgid ""
"@var{kw} is a list of the form, @code{(@var{allow-other-keys?}\n"
"(@var{keyword} @var{name} @var{var}) ...)}, where @var{keyword} is the\n"
"keyword corresponding to the argument named @var{name}, and whose\n"
"corresponding gensym is @var{var}.  @var{inits} are tree-il expressions\n"
"corresponding to all of the optional and keyword arguments, evaluated to\n"
"bind variables whose value is not supplied by the procedure caller.\n"
"Each @var{init} expression is evaluated in the lexical context of\n"
"previously bound variables, from left to right."
msgstr ""
"@var{kw} это список формы, @code{(@var{allow-other-keys?}\n"
"(@var{keyword} @var{name} @var{var}) ...)}, где @var{keyword} это ключевое\n"
"слово соответствующее аргументу с именем  @var{name}, и соответствующим\n"
"gensym значением @var{var}.  @var{inits} это выражения tree-il  "
"соответствующие\n"
"всем необязательным или ключевым аргументам, вычисляемых для связи "
"переменных\n"
"со значениями которые не предоставляются вызывающей процедурой.\n"
"Каждое выражение @var{init} вычисляется в лексическом контексте ранее \n"
"связанных переменных, с лева на право."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:431
msgid ""
"@var{gensyms} is a list of gensyms corresponding to all arguments:\n"
"first all of the required arguments, then the optional arguments if\n"
"any, then the rest argument if any, then all of the keyword arguments."
msgstr ""
"@var{gensyms} список gensyms соответствующий всем аргументам:\n"
"сначала все необходимые аргументы, затем необязательные, если они есть\n"
"затем все аргументы ключевые слова."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:439
msgid ""
"@var{body} is the body of the clause.  If the procedure is called with\n"
"an appropriate number of arguments, @var{body} is evaluated in tail\n"
"position.  Otherwise, if there is an @var{alternate}, it should be a\n"
"@code{<lambda-case>} expression, representing the next clause to try.\n"
"If there is no @var{alternate}, a wrong-number-of-arguments error is\n"
"signaled.\n"
"@end deftp"
msgstr ""
"@var{body} это тело предложения.  Если процедура вызывается с\n"
"соответствующим числом аргументов, тело( @var{body}) вычисляется в \n"
"хвостовой позиции. В противном случае , если есть  @var{alternate},\n"
"оно должно быть выражением @code{<lambda-case>}, представляющим\n"
"следующее предложение которое надо попробовать вычислить.\n"
"Если нет @var{alternate}, вызывается сигнал ошибки\n"
" wrong-number-of-arguments.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:447
msgid ""
"@deftp {Scheme Variable} <let> src names gensyms vals exp\n"
"@deftpx {External Representation} (let @var{names} @var{gensyms} @var{vals} "
"@var{exp})\n"
"Lexical binding, like Scheme's @code{let}.  @var{names} are the original\n"
"binding names, @var{gensyms} are gensyms corresponding to the\n"
"@var{names}, and @var{vals} are Tree-IL expressions for the values.\n"
"@var{exp} is a single Tree-IL expression.\n"
"@end deftp"
msgstr ""
"@deftp {Scheme Variable} <let> src names gensyms vals exp\n"
"@deftpx {External Representation} (let @var{names} @var{gensyms} @var{vals} "
"@var{exp})\n"
"Лексическое связывание, как и в Scheme @code{let}.  @var{names} это "
"оригинальные\n"
"именя привязываемых имен, @var{gensyms} это gensyms соответствующие именам "
"@var{names},\n"
"и @var{vals} это выражения Tree-IL для получения значений.\n"
"@var{exp} это единичное выражение Tree-IL.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:454
msgid ""
"@deftp {Scheme Variable} <letrec> in-order? src names gensyms vals exp\n"
"@deftpx {External Representation} (letrec @var{names} @var{gensyms} "
"@var{vals} @var{exp})\n"
"@deftpx {External Representation} (letrec* @var{names} @var{gensyms} "
"@var{vals} @var{exp})\n"
"A version of @code{<let>} that creates recursive bindings, like\n"
"Scheme's @code{letrec}, or @code{letrec*} if @var{in-order?} is true.\n"
"@end deftp"
msgstr ""
"@deftp {Scheme Variable} <letrec> in-order? src names gensyms vals exp\n"
"@deftpx {External Representation} (letrec @var{names} @var{gensyms} "
"@var{vals} @var{exp})\n"
"@deftpx {External Representation} (letrec* @var{names} @var{gensyms} "
"@var{vals} @var{exp})\n"
"Версия @code{<let>} которая создает рекурсивные связи, подобые\n"
"Scheme @code{letrec}, или @code{letrec*} если @var{in-order?} истинно.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:468
msgid ""
"@deftp {Scheme Variable} <prompt> escape-only? tag body handler\n"
"@deftpx {External Representation} (prompt @var{escape-only?} @var{tag} "
"@var{body} @var{handler})\n"
"A dynamic prompt.  Instates a prompt named @var{tag}, an expression,\n"
"during the dynamic extent of the execution of @var{body}, also an\n"
"expression.  If an abort occurs to this prompt, control will be passed\n"
"to @var{handler}, also an expression, which should be a procedure.  The\n"
"first argument to the handler procedure will be the captured\n"
"continuation, followed by all of the values passed to the abort.  If\n"
"@var{escape-only?} is true, the handler should be a @code{<lambda>} with\n"
"a single @code{<lambda-case>} body expression with no optional or\n"
"keyword arguments, and no alternate, and whose first argument is\n"
"unreferenced.  @xref{Prompts}, for more information.\n"
"@end deftp"
msgstr ""
"@deftp {Scheme Variable} <prompt> escape-only? tag body handler\n"
"@deftpx {External Representation} (prompt @var{escape-only?} @var{tag} "
"@var{body} @var{handler})\n"
"Динамический запрос.  Вставляет подсказку именуемую @var{tag}(являющуюся "
"выражением),\n"
"продолжающуюся выполнением @var{body}(также выражение).\n"
"Если в этом запросе произойдет внезапное прерывание, управление передается\n"
"процедуре @var{handler}(также выражение, которое должно быть процедурой). \n"
"Первым аргументом процедуры handler будут захваченные продолжения, "
"последующие\n"
"все значения переданные в abort.  Если @var{escape-only?} истинно, обработчк "
"handler\n"
"должен быть @code{<lambda>} с единственным выражением тела @code{<lambda-"
"case>}\n"
"без необязательных аргументов или аргументов ключевых слов, и не "
"альтернативой,\n"
"и чей первый аргумент не указан.  @xref{Prompts}, для получения "
"дополнительной\n"
"информацией.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:478
msgid ""
"@deftp {Scheme Variable} <abort> tag args tail\n"
"@deftpx {External Representation} (abort @var{tag} @var{args} @var{tail})\n"
"An abort to the nearest prompt with the name @var{tag}, an expression.\n"
"@var{args} should be a list of expressions to pass to the prompt's\n"
"handler, and @var{tail} should be an expression that will evaluate to\n"
"a list of additional arguments.  An abort will save the partial\n"
"continuation, which may later be reinstated, resulting in the\n"
"@code{<abort>} expression evaluating to some number of values.\n"
"@end deftp"
msgstr ""
"@deftp {Scheme Variable} <abort> tag args tail\n"
"@deftpx {External Representation} (abort @var{tag} @var{args} @var{tail})\n"
"Отмена до ближайшего prompt с именем @var{tag}(являющеимся выражением).\n"
"@var{args} должен быть списком выражений для передачи обработчику handler\n"
"указанному в prompt, и @var{tail} должен быть выражением которое будет\n"
"вычислять(обрабатывать) список дополнительных аргументов.  abort сохраняет\n"
"части продолжения, которые позже могут быть востановлены, что приведет\n"
"к вычислению в выражении @code{<abort>} нeкоторого количества значений.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:485
msgid ""
"There are two Tree-IL constructs that are not normally produced by\n"
"higher-level compilers, but instead are generated during the\n"
"source-to-source optimization and analysis passes that the Tree-IL\n"
"compiler does.  Users should not generate these expressions directly,\n"
"unless they feel very clever, as the default analysis pass will generate\n"
"them as necessary."
msgstr ""
"Существуют две конструкции Tree-IL, которые обычно не генерируются\n"
"высоко-уровневым компилятором, но вместо этого генерирутся во время\n"
"оптимизации source-to-source и прохождения анализа, что и делает\n"
"компилятор Tree-IL.  Пользователи не должны генерировать эти \n"
"выражения напрямую, если только не чувствуют себя очень умными, \n"
"поскольку прохождение анализа по умолчанию будет генерировать их\n"
"по мере необходимости."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:491
msgid ""
"@deftp {Scheme Variable} <let-values> src names gensyms exp body\n"
"@deftpx {External Representation} (let-values @var{names} @var{gensyms} "
"@var{exp} @var{body})\n"
"Like Scheme's @code{receive} -- binds the values returned by\n"
"evaluating @code{exp} to the @code{lambda}-like bindings described by\n"
"@var{gensyms}.  That is to say, @var{gensyms} may be an improper list."
msgstr ""
"@deftp {Scheme Variable} <let-values> src names gensyms exp body\n"
"@deftpx {External Representation} (let-values @var{names} @var{gensyms} "
"@var{exp} @var{body})\n"
"Подобно Scheme's @code{receive} -- привязывает значения возвращаемые путем\n"
"вычисления @code{exp} @code{lambda}-подобной связи описанной в "
"@var{gensyms}.\n"
"То есть, @var{gensyms} может быть неправильным списком."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:495
msgid ""
"@code{<let-values>} is an optimization of a @code{<call>} to the\n"
"primitive, @code{call-with-values}.\n"
"@end deftp"
msgstr ""
"@code{<let-values>} - это оптимизация вызова @code{<call>} для примитива,\n"
"@code{call-with-values}.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:500
msgid ""
"@deftp {Scheme Variable} <fix> src names gensyms vals body\n"
"@deftpx {External Representation} (fix @var{names} @var{gensyms} @var{vals} "
"@var{body})\n"
"Like @code{<letrec>}, but only for @var{vals} that are unset\n"
"@code{lambda} expressions."
msgstr ""
"@deftp {Scheme Variable} <fix> src names gensyms vals body\n"
"@deftpx {External Representation} (fix @var{names} @var{gensyms} @var{vals} "
"@var{body})\n"
"Как и @code{<letrec>}, но только для @var{vals}, котрые не заданы "
"@code{lambda} выражениями."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:503
msgid ""
"@code{fix} is an optimization of @code{letrec} (and @code{let}).\n"
"@end deftp"
msgstr ""
"@code{fix} это оптимизация of @code{letrec} (and @code{let}).\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:508
msgid ""
"Tree-IL is a convenient compilation target from source languages.  It\n"
"can be convenient as a medium for optimization, though CPS is usually\n"
"better.  The strength of Tree-IL is that it does not fix order of\n"
"evaluation, so it makes some code motion a bit easier."
msgstr ""
"Tree-IL - это удобная цель компиляции из исходных языков. Это может\n"
"быть удобно как средство оптимизации, хотя CPS обычно лучше. Сила\n"
"Tree-IL что он не фиксирует порядок вычислений, поэтому немного\n"
"облегчает движение кода."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:510
msgid "Optimization passes performed on Tree-IL currently include:"
msgstr "Выполнение оптимизационного прохода в Tree-IL включает:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:517
msgid ""
"@itemize\n"
"@item Open-coding (turning toplevel-refs into primitive-refs,\n"
"and calls to primitives to primcalls)\n"
"@item Partial evaluation (comprising inlining, copy propagation, and\n"
"constant folding)\n"
"@end itemize"
msgstr ""
"@itemize\n"
"@item Open-coding (превращение toplevel-refs в primitive-refs,\n"
"и вызов примитивов primcalls)\n"
"@item Частичное вычислениеn (включая вложения, copy propagation, и\n"
"constant folding)\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:520
msgid ""
"@node Continuation-Passing Style\n"
"@subsection Continuation-Passing Style"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:528
msgid ""
"@cindex CPS\n"
"Continuation-passing style (CPS) is Guile's principal intermediate\n"
"language, bridging the gap between languages for people and languages\n"
"for machines.  CPS gives a name to every part of a program: every\n"
"control point, and every intermediate value.  This makes it an excellent\n"
"medium for reasoning about programs, which is the principal job of a\n"
"compiler."
msgstr ""
"@cindex CPS\n"
"Continuation-passing style (CPS) в Guile является основным промежуточным\n"
"языком, преодолевающим разрыв между языками для людей и языками для машин.\n"
"CPS дает имя каждой части программы: каждой контрольной точке и каждому\n"
"промежуточному значению. Это создает отличную среду  для рассуждения о\n"
"программах, которая является основной задачей компилятора."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:536
msgid ""
"@menu\n"
"* An Introduction to CPS::\n"
"* CPS in Guile::\n"
"* Building CPS::\n"
"* CPS Soup::\n"
"* Compiling CPS::\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:539
msgid ""
"@node An Introduction to CPS\n"
"@subsubsection An Introduction to CPS"
msgstr ""
"@node An Introduction to CPS\n"
"@subsubsection Введение в CPS"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:541
msgid "Consider the following Scheme expression:"
msgstr "Рассмотрим следующее выражение Scheme:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:548
msgid ""
"@lisp\n"
"(begin\n"
"  (display \"The sum of 32 and 10 is: \")\n"
"  (display 42)\n"
"  (newline))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:551
msgid ""
"Let us identify all of the sub-expressions in this expression,\n"
"annotating them with unique labels:"
msgstr ""
"Выделим все подвыражения в этом выражении, анотируя их уникальнми\n"
"метками."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:564
msgid ""
"@lisp\n"
"(begin\n"
"  (display \"The sum of 32 and 10 is: \")\n"
"  |k1      k2\n"
"  k0\n"
"  (display 42)\n"
"  |k4      k5\n"
"  k3\n"
"  (newline))\n"
"  |k7\n"
"  k6\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:570
msgid ""
"Each of these labels identifies a point in a program.  One label may be\n"
"the continuation of another label.  For example, the continuation of\n"
"@code{k7} is @code{k6}.  This is because after evaluating the value of\n"
"@code{newline}, performed by the expression labelled @code{k7}, we\n"
"continue to apply it in @code{k6}."
msgstr ""
"Каждая из этих меток идентифицирует точку в программе. Одна метка\n"
"может быть продолжением другой метки. Например, продолжение @code{k7}\n"
"это @code{k6}.  Это связано с тем, что после вычисления значения\n"
"@code{newline}, выполняемое выражением помеченным @code{k7}, мы\n"
"продолжим применять его в @code{k6}."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:577
msgid ""
"Which expression has @code{k0} as its continuation?  It is either the\n"
"expression labelled @code{k1} or the expression labelled @code{k2}.\n"
"Scheme does not have a fixed order of evaluation of arguments, though it\n"
"does guarantee that they are evaluated in some order.  Unlike general\n"
"Scheme, continuation-passing style makes evaluation order explicit.  In\n"
"Guile, this choice is made by the higher-level language compilers."
msgstr ""
"Какое выражение имеет @code{k0} в качестве продолжения?  Это либо\n"
"выражение помеченное как @code{k1} либо выражение помеченное как @code{k2}.\n"
"Scheme не имеет фиксированного порядка вычисления аргументов. Хотя она\n"
"гарантирует, что они будут вычисляться в определенном порядке. В отличи\n"
"от общей Scheme, continuation-passing style(стиль продолжене-передача) \n"
"делает порядок вычисления явным. В Guile, этот выбор делают компиляторы\n"
"языков более высокого-уровня."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:581
msgid ""
"Let us assume a left-to-right evaluation order.  In that case the\n"
"continuation of @code{k1} is @code{k2}, and the continuation of\n"
"@code{k2} is @code{k0}."
msgstr ""
"Предположим, что порядок вычисления слева направо. В этом случае\n"
"продолжением @code{k1} будет @code{k2}, и продолжением @code{k2}\n"
"будет @code{k0}."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:584
msgid ""
"With this example established, we are ready to give an example of CPS in\n"
"Scheme:"
msgstr ""
"Для выбранного примера, мы готовы привести пример CPS в\n"
"Scheme:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:605
msgid ""
"@smalllisp\n"
"(lambda (ktail)\n"
"  (let ((k1 (lambda ()\n"
"              (let ((k2 (lambda (proc)\n"
"                          (let ((k0 (lambda (arg0)\n"
"                                      (proc k4 arg0))))\n"
"                            (k0 \"The sum of 32 and 10 is: \")))))\n"
"                (k2 display))))\n"
"        (k4 (lambda _\n"
"              (let ((k5 (lambda (proc)\n"
"                          (let ((k3 (lambda (arg0)\n"
"                                      (proc k7 arg0))))\n"
"                            (k3 42)))))\n"
"                (k5 display))))\n"
"        (k7 (lambda _\n"
"              (let ((k6 (lambda (proc)\n"
"                          (proc ktail))))\n"
"                (k6 newline)))))\n"
"    (k1))\n"
"@end smalllisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:610
msgid ""
"Holy code explosion, Batman!  What's with all the lambdas?  Indeed, CPS\n"
"is by nature much more verbose than ``direct-style'' intermediate\n"
"languages like Tree-IL.  At the same time, CPS is simpler than full\n"
"Scheme, because it makes things more explicit."
msgstr ""
"Взрыв Священного кода, Бэтман!  Что со всеми лямбдами?  Действительно, CPS\n"
"по своей природе гораздо более подробный, чем промежуточные языки \n"
"``прямого-стиля'' подобные Tree-IL.  В тоже время, CPS проще, чем\n"
"полная Scheme, потому что он делает вещи более явными."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:620
msgid ""
"In the original program, the expression labelled @code{k0} is in effect\n"
"context.  Any values it returns are ignored.  In Scheme, this fact is\n"
"implicit.  In CPS, we can see it explicitly by noting that its\n"
"continuation, @code{k4}, takes any number of values and ignores them.\n"
"Compare this to @code{k2}, which takes a single value; in this way we\n"
"can say that @code{k1} is in a ``value'' context.  Likewise @code{k6} is\n"
"in tail context with respect to the expression as a whole, because its\n"
"continuation is the tail continuation, @code{ktail}.  CPS makes these\n"
"details manifest, and gives them names."
msgstr ""
"В исходной программе, выражение помеченное@code{k0} является фактически\n"
"контекстом. Любые возвращаемые значения игнорируются. В Scheme, этот\n"
"факт не выражен явно. В CPS, мы видим это явно, отмечая что продолжение\n"
"@code{k4}, принимает любое количество значений и игнорирует их.\n"
"Сравнивая его с @code{k2}, которое принимает одно значение, мы можем\n"
"сказать что @code{k1} является ``значением'' контекста.  Аналогично\n"
"@code{k6} находится в хвостовом(конечном) контексте относительно всего\n"
"представленного выражения, поскольку его продолжение это хвостовое\n"
"продолжение, @code{ktail}.  CPS делает эти детали очевидными и дает\n"
"им имена."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:623
msgid ""
"@node CPS in Guile\n"
"@subsubsection CPS in Guile"
msgstr ""
"@node CPS in Guile\n"
"@subsubsection CPS в Guile"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:630
msgid ""
"@cindex continuation, CPS\n"
"Guile's CPS language is composed of @dfn{continuations}.  A continuation\n"
"is a labelled program point.  If you are used to traditional compilers,\n"
"think of a continuation as a trivial basic block.  A program is a\n"
"``soup'' of continuations, represented as a map from labels to\n"
"continuations."
msgstr ""
"@cindex continuation, CPS\n"
"Язык CPS Guile  состоит из  продолжений(@dfn{continuations}). Продолжение\n"
"это снабженная меткой точка программы. Если вы привыкли к традиционным \n"
"компиляторам, думайте о продолжении как о тривиальном базовом блоке.\n"
"Программм представляет собой ``суп'' из продолжений, представляемый в виде\n"
"карты меток к продолжениям."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:641
msgid ""
"@cindex term, CPS\n"
"@cindex expression, CPS\n"
"Like basic blocks, each continuation belongs to only one function.  Some\n"
"continuations are special, like the continuation corresponding to a\n"
"function's entry point, or the continuation that represents the tail of\n"
"a function.  Others contain a @dfn{term}.  A term contains an\n"
"@dfn{expression}, which evaluates to zero or more values.  The term also\n"
"records the continuation to which it will pass its values.  Some terms,\n"
"like conditional branches, may continue to one of a number of\n"
"continuations."
msgstr ""
"@cindex term, CPS\n"
"@cindex expression, CPS\n"
"Подобно базовым блокам, каждое продолжение осущетсвляет только одну "
"функцию.\n"
"Некоторые продолжения являются специальными, такие как продолжения \n"
"соответствующие точке входа в функцию, или продолжения представляющие\n"
"хвост функции.  Другие содержат термы(@dfn{term}).  Терм содержит выражение\n"
"(@dfn{expression}), которое вычисляет ноль или больше значений. Терм\n"
"также описывает продолжение, которому он будет передавать свои значения.\n"
"Некоторые термы, такие как условные ветви, могут продожиться в одно\n"
"из некоторого числа продолжений."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:646
msgid ""
"Continuation labels are small integers.  This makes it easy to sort them\n"
"and to group them into sets.  Whenever a term refers to a continuation,\n"
"it does so by name, simply recording the label of the continuation.\n"
"Continuation labels are unique among the set of labels in a program."
msgstr ""
"Метки продолжений представляют собой малые целые числа.  Это упрощает "
"сортировку\n"
"и группировку их в множества. Всякий раз, когда терм ссылается на "
"продолжение, он\n"
"делает это по имения, просто записывая метку продолжения. Метки продолжений\n"
"уникальны среди множества меток в программе."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:649
msgid ""
"Variables are also named by small integers.  Variable names are unique\n"
"among the set of variables in a program."
msgstr ""
"Переменные также именуются малыми целыми числами.  Имена переменных "
"уникальны\n"
"среди множетсва переменных в программе."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:653
msgid ""
"For example, a simple continuation that receives two values and adds\n"
"them together can be matched like this, using the @code{match} form from\n"
"@code{(ice-9 match)}:"
msgstr ""
"Например, простое продолжение, которое получает два значения и\n"
"объединяет их, такое как это, использует форму @code{match} из\n"
"модуля @code{(ice-9 match)}:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:661
msgid ""
"@smallexample\n"
"(match cont\n"
"  (($ $kargs (x-name y-name) (x-var y-var)\n"
"      ($ $continue k src ($ $primcall '+ (x-var y-var))))\n"
"   (format #t \"Add ~a and ~a and pass the result to label ~a\"\n"
"           x-var y-var k)))\n"
"@end smallexample"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:664
msgid ""
"Here we see the most common kind of continuation, @code{$kargs}, which\n"
"binds some number of values to variables and then evaluates a term."
msgstr ""
"Здесь мы видим наиболее распространенный вид продолжения,@code{$kargs}, \n"
"который привязывает некоторое число значений к переменным, а завем\n"
"вычисляет терм."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:669
msgid ""
"@deftp {CPS Continuation} $kargs names vars term\n"
"Bind the incoming values to the variables @var{vars}, with original\n"
"names @var{names}, and then evaluate @var{term}.\n"
"@end deftp"
msgstr ""
"@deftp {CPS Continuation} $kargs names vars term\n"
"Связь входных значений с переменными @var{vars}, с оригинальными\n"
"именами @var{names}, и вычисление  @var{term}.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:672
msgid ""
"The @var{names} of a @code{$kargs} are just for debugging, and will end\n"
"up residualized in the object file for use by the debugger."
msgstr ""
"Имена(@var{names}) @code{$kargs} предназначены только для отладки и\n"
"в конечном итоге будут оставлены в объектном файле для использования\n"
"отладчиком."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:675
msgid ""
"The @var{term} in a @code{$kargs} is always a @code{$continue}, which\n"
"evaluates an expression and continues to a continuation."
msgstr ""
"Выражение @var{term} в @code{$kargs} всегда продолжение(@code{$continue}), "
"которое\n"
"вычисляется как выражение и продолжает продолжение."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:683
msgid ""
"@deftp {CPS Term} $continue k src exp\n"
"Evaluate the expression @var{exp} and pass the resulting values (if any)\n"
"to the continuation labelled @var{k}.  The source information associated\n"
"with the expression may be found in @var{src}, which is either an alist\n"
"as in @code{source-properties} or is @code{#f} if there is no associated\n"
"source.\n"
"@end deftp"
msgstr ""
"@deftp {CPS Term} $continue k src exp\n"
"Вычисление выражения @var{exp} и передача полученных значений (если они\n"
"есть) в продолжение с меткой @var{k}.  Исходная информация связанная с\n"
"выражением, может быть найдена в @var{src}, который является ассоциативным\n"
"списком(alist), как в @code{source-properties} или быть @code{#f} если\n"
"нет связанного источника.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:686
msgid ""
"There are a number of expression kinds.  Above you see an example of\n"
"@code{$primcall}."
msgstr ""
"Существует несколько видов выражений. Выше вы видите пример\n"
"@code{$primcall}."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:694
msgid ""
"@deftp {CPS Expression} $primcall name args\n"
"Perform the primitive operation identified by @code{name}, a well-known\n"
"symbol, passing it the arguments @var{args}, and pass all resulting\n"
"values to the continuation.  The set of available primitives includes\n"
"all primitives known to Tree-IL and then some more; see the source code\n"
"for details.\n"
"@end deftp"
msgstr ""
"@deftp {CPS Expression} $primcall name args\n"
"Perform the primitive operation identified by @code{name}, a well-known\n"
"symbol, passing it the arguments @var{args}, and pass all resulting\n"
"values to the continuation.  The set of available primitives includes\n"
"all primitives known to Tree-IL and then some more; see the source code\n"
"for details.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:706
msgid ""
"@cindex dominate, CPS\n"
"The variables that are used by @code{$primcall}, or indeed by any\n"
"expression, must be defined before the expression is evaluated.  An\n"
"equivalent way of saying this is that predecessor @code{$kargs}\n"
"continuation(s) that bind the variables(s) used by the expression must\n"
"@dfn{dominate} the continuation that uses the expression: definitions\n"
"dominate uses.  This condition is trivially satisfied in our example\n"
"above, but in general to determine the set of variables that are in\n"
"``scope'' for a given term, you need to do a flow analysis to see what\n"
"continuations dominate a term.  The variables that are in scope are\n"
"those variables defined by the continuations that dominate a term."
msgstr ""
"@cindex dominate, CPS\n"
"Переменные, которые использует @code{$primcall}, или любое другое\n"
"выражение, должны быть определены перед вычислением выражения. \n"
"Эквивалентным способом сказать это является то, что предшествующее\n"
"@code{$kargs} продолжение, которое связывает переменные используемые\n"
"выражением должны доминировать@dfn{dominate} над продолжением, которое\n"
"использует выражение: определения преобладают в использовании.\n"
"Это условие тривиально удовлетворены в примере выше, но в целом для\n"
"определения набора переменных, которые находятся в ``области'' для\n"
"доступа данного термина, вам нужно провести анализ потока, чтобы увидеть,\n"
"какие продолжения доминируют термин. Переменные, которые входят в область\n"
"охвата, - это те переменные, которые определены в продолжениях, которые\n"
"доминируют над термином."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:711
msgid ""
"Here is an inventory of the kinds of expressions in Guile's CPS\n"
"language, besides @code{$primcall} which has already been described.\n"
"Recall that all expressions are wrapped in a @code{$continue} term which\n"
"specifies their continuation."
msgstr ""
"Вот список видов выражений в языке CPS Guile, кроме того @code{$primcall}\n"
"который уже описан.\n"
"Напомним, что все выражения завернуты в @code{$continue}, который указывает\n"
"их продолжение."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:715
msgid ""
"@deftp {CPS Expression} $const val\n"
"Continue with the constant value @var{val}.\n"
"@end deftp"
msgstr ""
"@deftp {CPS Expression} $const val\n"
"Продолжение с постоянным значением @var{val}.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:720
msgid ""
"@deftp {CPS Expression} $prim name\n"
"Continue with the procedure that implements the primitive operation\n"
"named by @var{name}.\n"
"@end deftp"
msgstr ""
"@deftp {CPS Expression} $prim name\n"
"Продолжение процедуры, которая реализует примитивную операцию\n"
"названную @var{name}.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:727
msgid ""
"@deftp {CPS Expression} $call proc args\n"
"Call @var{proc} with the arguments @var{args}, and pass all values to\n"
"the continuation.  @var{proc} and the elements of the @var{args} list\n"
"should all be variable names.  The continuation identified by the term's\n"
"@var{k} should be a @code{$kreceive} or a @code{$ktail} instance.\n"
"@end deftp"
msgstr ""
"@deftp {CPS Expression} $call proc args\n"
"Вызвать @var{proc} с аргументами @var{args}, и передать все значения в\n"
"продолжение.  @var{proc} и элементы списка @var{args} должны быть именами\n"
"переменных.  Продолжение идентифицируемое термином @var{k} должно быть\n"
"@code{$kreceive} или экземпляром @code{$ktail}.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:731
msgid ""
"@deftp {CPS Expression} $values args\n"
"Pass the values named by the list @var{args} to the continuation.\n"
"@end deftp"
msgstr ""
"@deftp {CPS Expression} $values args\n"
"Передача значений, указанных в списке @var{args} в продолжение.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:736
msgid ""
"@deftp {CPS Expression} $branch kt exp\n"
"Evaluate the branching expression @var{exp}, and continue to @var{kt}\n"
"with zero values if the test evaluates to true.  Otherwise continue to\n"
"the continuation named in the outer @code{$continue} term."
msgstr ""
"@deftp {CPS Expression} $branch kt exp\n"
"Вычисление выражения ветвления @var{exp}, и продолжение @var{kt}\n"
"с нулевым значением если тест возвращает истину.  В противном случае\n"
"продолжается продолжение с именем @code{$continue} во внешнем терме."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:747
msgid ""
"Only certain expressions are valid in a @var{$branch}.  Compiling a\n"
"@code{$branch} avoids allocating space for the test variable, so the\n"
"expression should be evaluatable without temporary values.  In practice\n"
"this condition is true for @code{$primcall}s to @code{null?}, @code{=},\n"
"and similar primitives that have corresponding @code{br-if-@var{foo}} VM\n"
"operations; see the source code for full details.  When in doubt, bind\n"
"the test expression to a variable, and branch on a @code{$values}\n"
"expression that references that variable.  The optimizer should inline\n"
"the reference if possible.\n"
"@end deftp"
msgstr ""
"Только определенные выражения действительны в @var{$branch}.  Компиляция\n"
"@code{$branch} исключает выделение пространства для тестовой переменной,\n"
"поэтому выражение должно быть вычислено без временного значения.  На "
"практике\n"
"это условие верно для @code{$primcall} для @code{null?}, @code{=},\n"
"и аналогичных примитивов, которые имеют соответствующие операции \n"
"ВМ @code{br-if-@var{foo}}; см исходный код для полной информации. Если есть\n"
"сомнения, привяжите тестовое выражение к переменной и ветвь в выражение\n"
"@code{$values}, ссылающееся на эту переменную. Оптимизатор должен вставить\n"
"ссылку, если это возможно.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:756
msgid ""
"@deftp {CPS Expression} $prompt escape? tag handler\n"
"Push a prompt on the stack identified by the variable name @var{tag},\n"
"which may be escape-only if @var{escape?} is true, and continue with\n"
"zero values.  If the body aborts to this prompt, control will proceed at\n"
"the continuation labelled @var{handler}, which should be a\n"
"@code{$kreceive} continuation.  Prompts are later popped by\n"
"@code{pop-prompt} primcalls.\n"
"@end deftp"
msgstr ""
"@deftp {CPS Expression} $prompt escape? tag handler\n"
"Помещает приглашение в стек идентифицируемое именем переменной @var{tag},\n"
"выйти из которого можно только если @var{escape?} равно истине, и "
"продлжиться\n"
"с нулевым значением. Если тело выполниния программы прервано этим запросом,\n"
"управление продолжиться в обработчике с меткой @var{handler}, который "
"должен\n"
"быть продолжением @code{$kreceive}.  Само приглашение выдается позже\n"
"вызовом primcalls @code{pop-prompt}.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:769
msgid ""
"@cindex higher-order CPS\n"
"@cindex CPS, higher-order\n"
"@cindex first-order CPS\n"
"@cindex CPS, first-order\n"
"There are two sub-languages of CPS, @dfn{higher-order CPS} and\n"
"@dfn{first-order CPS}.  The difference is that in higher-order CPS,\n"
"there are @code{$fun} and @code{$rec} expressions that bind functions or\n"
"mutually-recursive functions in the implicit scope of their use sites.\n"
"Guile transforms higher-order CPS into first-order CPS by @dfn{closure\n"
"conversion}, which chooses representations for all closures and which\n"
"arranges to access free variables through the implicit closure parameter\n"
"that is passed to every function call."
msgstr ""
"@cindex higher-order CPS\n"
"@cindex CPS, higher-order\n"
"@cindex first-order CPS\n"
"@cindex CPS, first-order\n"
"Существуют два подязыка CPS, высокоуровневый @dfn{higher-order CPS} и\n"
"первого порядка @dfn{first-order CPS}.  Различие их в том, что в \n"
"высокоуровневом CPS существуют выражения @code{$fun} и @code{$rec},\n"
"которые связывают функции или взаимно-рекурсивные функции в неявной\n"
"области их использования. Трансформация Guile высокоуровневого CPS в\n"
"CPS первого порядка путем @dfn{closure conversion}, которое выбирает\n"
"представление для всех замыканий и которое организует доступ к свободным\n"
"переменным через неявный закрытый параметр, который передается каждому\n"
"вызову функции."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:776
msgid ""
"@deftp {CPS Expression} $fun body\n"
"Continue with a procedure.  @var{body} names the entry point of the\n"
"function, which should be a @code{$kfun}.  This expression kind is only\n"
"valid in higher-order CPS, which is the CPS language before closure\n"
"conversion.\n"
"@end deftp"
msgstr ""
"@deftp {CPS Expression} $fun body\n"
"Продолжение с процедурой.  Имя @var{body} это точка входа функции, которая\n"
"должна быть @code{$kfun}.  Этот вид выражения действителен только в \n"
"высокоуровневом CPS, которым является язык CPS до вызова closure\n"
"conversion.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:784
msgid ""
"@deftp {CPS Expression} $rec names vars funs\n"
"Continue with a set of mutually recursive procedures denoted by\n"
"@var{names}, @var{vars}, and @var{funs}.  @var{names} is a list of\n"
"symbols, @var{vars} is a list of variable names (unique integers), and\n"
"@var{funs} is a list of @code{$fun} values.  Note that the @code{$kargs}\n"
"continuation should also define @var{names}/@var{vars} bindings.\n"
"@end deftp"
msgstr ""
"@deftp {CPS Expression} $rec names vars funs\n"
"Продолжение с набором взаимно-рекурсивных процедур, обозначеных именами\n"
"@var{names}, @var{vars}, и @var{funs}.  @var{names} это список символов,\n"
"@var{vars} это список имен переменных (уникальные целые числа), и\n"
"@var{funs} это список значений @code{$fun}.  Заметим, что продолжение\n"
"@code{$kargs} также должно определять связки @var{names}/@var{vars}.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:790
msgid ""
"The contification pass will attempt to transform the functions declared\n"
"in a @code{$rec} into local continuations.  Any remaining @code{$fun}\n"
"instances are later removed by the closure conversion pass.  By default,\n"
"a closure is represented as an object built by a @code{$closure}\n"
"expression."
msgstr ""
"Проход contification попытается преобразовать функции, объявленные в \n"
"@code{$rec} в локальные продолжения.  Любые оставшиеся экземпляры\n"
"@code{$fun} позже удаляются проходом closure conversion.  По умолчанию,\n"
"замыкание представлено как объект построенный выражением @code{$closure}."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:797
msgid ""
"@deftp {CPS Expression} $closure label nfree\n"
"Build a closure that joins the code at the continuation named\n"
"@var{label} with space for @var{nfree} free variables.  The variables\n"
"will be initialized later via @code{free-set!} primcalls.  This\n"
"expression kind is part of first-order CPS.\n"
"@end deftp"
msgstr ""
"@deftp {CPS Expression} $closure label nfree\n"
"Создает замыкание, которое присоединятся к коду в продолжении\n"
"с именем @var{label} с пространством имен свободных переменных @var{nfree}.\n"
"Переменные будут инициализированные позже через вызов primcalls @code{free-"
"set!}.\n"
"Этот вид выражения является частью CPS первого порядка.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:802
msgid ""
"If the closure can be proven to never escape its scope then other\n"
"lighter-weight representations can be chosen.  Additionally, if all call\n"
"sites are known, closure conversion will hard-wire the calls by lowering\n"
"@code{$call} to @code{$callk}."
msgstr ""
"Если для замыкания можно доказать что оно никогда не выходит за пределы\n"
"своей области, тогда может быть выбрано другое более легковесное\n"
"представление. Кроме того, если известны все точки вызова, closure "
"conversion\n"
"принудительно преобразует вызовы в низкоуровневые, опустив @code{$call} до\n"
"@code{$callk}."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:810
msgid ""
"@deftp {CPS Expression} $callk label proc args\n"
"Like @code{$call}, but for the case where the call target is known to be\n"
"in the same compilation unit.  @var{label} should denote some\n"
"@code{$kfun} continuation in the program.  In this case the @var{proc}\n"
"is simply an additional argument, since it is not used to determine the\n"
"call target at run-time.\n"
"@end deftp"
msgstr ""
"@deftp {CPS Expression} $callk label proc args\n"
"Как и @code{$call}, но для случая, когда цель вызова, известно\n"
"находитьсяв томже компилируемом модуле. @var{label} должно означать \n"
"продолжение @code{$kfun} в программе.  В этом случае @var{proc}\n"
"является просто дополнительным аргуменом, поскольку он не используется\n"
"для определения цели вызова во время выполнения.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:824
msgid ""
"At this point we have described terms, expressions, and the most common\n"
"kind of continuation, @code{$kargs}.  @code{$kargs} is used when the\n"
"predecessors of the continuation can be instructed to pass the values\n"
"where the continuation wants them.  For example, if a @code{$kargs}\n"
"continuation @var{k} binds a variable @var{v}, and the compiler decides\n"
"to allocate @var{v} to slot 6, all predecessors of @var{k} should put\n"
"the value for @var{v} in slot 6 before jumping to @var{k}.  One\n"
"situation in which this isn't possible is receiving values from function\n"
"calls.  Guile has a calling convention for functions which currently\n"
"places return values on the stack.  A continuation of a call must check\n"
"that the number of values returned from a function matches the expected\n"
"number of values, and then must shuffle or collect those values to named\n"
"variables.  @code{$kreceive} denotes this kind of continuation."
msgstr ""
"На этом этапе мы описали термины, выражения и наиболее распространенные\n"
"виды продолжений, @code{$kargs}.  @code{$kargs} используется, когда \n"
"предшествующие продолжения могут передать значения, в которых требуется\n"
"их продолжение. Например, если @code{$kargs} продолжение @var{k} \n"
"связывает переменную @var{v}, и компилятор решает выделить @var{v} \n"
"слот 6, все предшественники @var{k} должны помещать значение для @var{v} \n"
"в слот 6 перед переходом к @var{k}.  Одна ситуация, в которой это не "
"возможно\n"
"это получение значения из вызова функции.  Guile имеет соглашение о вызовах\n"
"функций, которое в настоящее время помещает возвращаемые значения в стек.\n"
"Продолжение вызова должно проверить, что количество значений возвращаемых \n"
"функцией, соответствует ожидаемому числу значений и затем необходимо "
"перетасовать\n"
"или собрать эти значения для именованных переменных.  @code{$kreceive} "
"обозначает\n"
"этот вид продолжения."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:831
msgid ""
"@deftp {CPS Continuation} $kreceive arity k\n"
"Receive values on the stack.  Parse them according to @var{arity}, and\n"
"then proceed with the parsed values to the @code{$kargs} continuation\n"
"labelled @var{k}.  As a limitation specific to @code{$kreceive},\n"
"@var{arity} may only contain required and rest arguments.\n"
"@end deftp"
msgstr ""
"@deftp {CPS Continuation} $kreceive arity k\n"
"Получает значения в стеке. Разбирает их в соответствии с "
"арностью(@var{arity}),\n"
"а затем приступает к разбору значений @code{$kargs} продолжения помеченного\n"
"@var{k}.  В качестве ограничения, характерного для @code{$kreceive},\n"
"арность(@var{arity}) может содержать только необходимые и остальные\n"
"аргументы.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:834
msgid ""
"@code{$arity} is a helper data structure used by @code{$kreceive} and\n"
"also by @code{$kclause}, described below."
msgstr ""
"@code{$arity} это вспомогательная структура данных, используемая "
"@code{$kreceive},\n"
"а также @code{$kclause}, описанная ниже."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:843
msgid ""
"@deftp {CPS Data} $arity req opt rest kw allow-other-keys?\n"
"A data type declaring an arity.  @var{req} and @var{opt} are lists of\n"
"source names of required and optional arguments, respectively.\n"
"@var{rest} is either the source name of the rest variable, or @code{#f}\n"
"if this arity does not accept additional values.  @var{kw} is a list of\n"
"the form @code{((@var{keyword} @var{name} @var{var}) ...)}, describing\n"
"the keyword arguments.  @var{allow-other-keys?} is true if other keyword\n"
"arguments are allowed and false otherwise."
msgstr ""
"@deftp {CPS Data} $arity req opt rest kw allow-other-keys?\n"
"Тип данных, обявляющий арность(arity).  @var{req} и @var{opt} - списки\n"
"имен источников требуемых и необязательных аргументов, соответственно.\n"
"@var{rest} являетс либо либо исходным именем переменной rest, либо "
"@code{#f},\n"
"если эта арность(arity) не принимает дополнительные значения. @var{kw} - "
"это\n"
"список форм вида @code{((@var{keyword} @var{name} @var{var}) ...)}, "
"описывающий\n"
"аргументы ключевого слова.  @var{allow-other-keys?} установлено в истину "
"если\n"
"другие ключевые слова разрешены, иначе ложь."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:847
msgid ""
"Note that all of these names with the exception of the @var{var}s in the\n"
"@var{kw} list are source names, not unique variable names.\n"
"@end deftp"
msgstr ""
"Обратите внимание, что все эти имена, за исключением @var{var} в списке\n"
"@var{kw}, являются исходными именами, а не уникальными именами переменных.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:850
msgid ""
"Additionally, there are three specific kinds of continuations that are\n"
"only used in function entries."
msgstr ""
"Кроме того, сущетсвтуют три вида продолжений, которые используются только\n"
"в внутри функций."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:861
msgid ""
"@deftp {CPS Continuation} $kfun src meta self tail clauses\n"
"Declare a function entry.  @var{src} is the source information for the\n"
"procedure declaration, and @var{meta} is the metadata alist as described\n"
"above in Tree-IL's @code{<lambda>}.  @var{self} is a variable bound to\n"
"the procedure being called, and which may be used for self-references.\n"
"@var{tail} is the label of the @code{$ktail} for this function,\n"
"corresponding to the function's tail continuation.  @var{clause} is the\n"
"label of the first @code{$kclause} for the first @code{case-lambda}\n"
"clause in the function, or otherwise @code{#f}.\n"
"@end deftp"
msgstr ""
"@deftp {CPS Continuation} $kfun src meta self tail clauses\n"
"Объявляет точку входа в функцию.  @var{src} является исходной\n"
"информацией для объявления процедуры, а @var{meta} это ассоциативный\n"
"список(alist) метаданных, как описано выше в Tree-IL's @code{<lambda>}.\n"
"@var{self} это переменная связанная с названной процедурой и которая\n"
"может испольоваться для ссылки на саму себя. @var{tail} это метка\n"
"@code{$ktail} для данной функции, соответствующая продолжению реализующему\n"
"хвост.  @var{clause} это метка первого @code{$kclause} для первого\n"
"предложения @code{case-lambda} в функции или иначе @code{#f}.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:865
msgid ""
"@deftp {CPS Continuation} $ktail\n"
"A tail continuation.\n"
"@end deftp"
msgstr ""
"@deftp {CPS Continuation} $ktail\n"
"Хвост(окончание) продолжения.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:874
msgid ""
"@deftp {CPS Continuation} $kclause arity cont alternate\n"
"A clause of a function with a given arity.  Applications of a function\n"
"with a compatible set of actual arguments will continue to the\n"
"continuation labelled @var{cont}, a @code{$kargs} instance representing\n"
"the clause body.  If the arguments are incompatible, control proceeds to\n"
"@var{alternate}, which is a @code{$kclause} for the next clause, or\n"
"@code{#f} if there is no next clause.\n"
"@end deftp"
msgstr ""
"@deftp {CPS Continuation} $kclause arity cont alternate\n"
"Предложение функции с заданной арностью(arity). Применение функции с \n"
"совместимым набором фактичеких аргументов будет продолжаться до\n"
"продолжения с меткой @var{cont}, а экземпляр @code{$kargs} пердставляет\n"
"тело предложения.  Если аргументы не совместимы, переходит к альтернативе\n"
"(@var{alternate}), которая представляет собой @code{$kclause}  для "
"следующего\n"
"предложения, или @code{#f}, если нет следующего предложения.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:877
msgid ""
"@node Building CPS\n"
"@subsubsection Building CPS"
msgstr ""
"@node Building CPS\n"
"@subsubsection Построение CPS"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:881
msgid ""
"Unlike Tree-IL, the CPS language is built to be constructed and\n"
"deconstructed with abstract macros instead of via procedural\n"
"constructors or accessors, or instead of S-expression matching."
msgstr ""
"В отличии от Tree-IL, язык CPS построен, чтобы быть сконструированным\n"
"и деконструированным с абстратными макросами, а не через процедурные\n"
"конструкторы или аксессоры, или вместо вычисления S-выражений."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:886
msgid ""
"Deconstruction and matching is handled adequately by the @code{match}\n"
"form from @code{(ice-9 match)}.  @xref{Pattern Matching}.  Construction\n"
"is handled by a set of mutually builder macros:\n"
"@code{build-term}, @code{build-cont}, and @code{build-exp}."
msgstr ""
"Деконструкция и сопоставление обрабатываются надлежащим образом формой\n"
"@code{match} из модуля @code{(ice-9 match)}.  @xref{Pattern Matching}.\n"
"Конструкция обрабатывается набором взаимосвязанных макросов:\n"
"@code{build-term}, @code{build-cont}, и @code{build-exp}."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:893
msgid ""
"In the following interface definitions, consider @code{term} and\n"
"@code{exp} to be built by @code{build-term} or @code{build-exp},\n"
"respectively.  Consider any other name to be evaluated as a Scheme\n"
"expression.  Many of these forms recognize @code{unquote} in some\n"
"contexts, to splice in a previously-built value; see the specifications\n"
"below for full details."
msgstr ""
"В следующих определениях интерфейсов рассматриваются термы(@code{term})\n"
"и выражения(@code{exp}), которые будут построены @code{build-term} или\n"
"@code{build-exp}, соответственно.  Рассмотрим любое другое имя, которое\n"
"будет вычисленно как выражение Scheme.  Многие из этих форм распознают\n"
"@code{unquote} в некоторых контекстах, чтобы объединять с ранее построенным\n"
"значением; см. спецификации ниже для получения полной информации."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:921
msgid ""
"@deffn {Scheme Syntax} build-term ,val\n"
"@deffnx {Scheme Syntax} build-term ($continue k src exp)\n"
"@deffnx {Scheme Syntax} build-exp ,val\n"
"@deffnx {Scheme Syntax} build-exp ($const val)\n"
"@deffnx {Scheme Syntax} build-exp ($prim name)\n"
"@deffnx {Scheme Syntax} build-exp ($branch kt exp)\n"
"@deffnx {Scheme Syntax} build-exp ($fun kentry)\n"
"@deffnx {Scheme Syntax} build-exp ($rec names syms funs)\n"
"@deffnx {Scheme Syntax} build-exp ($closure k nfree)\n"
"@deffnx {Scheme Syntax} build-exp ($call proc (arg ...))\n"
"@deffnx {Scheme Syntax} build-exp ($call proc args)\n"
"@deffnx {Scheme Syntax} build-exp ($callk k proc (arg ...))\n"
"@deffnx {Scheme Syntax} build-exp ($callk k proc args)\n"
"@deffnx {Scheme Syntax} build-exp ($primcall name (arg ...))\n"
"@deffnx {Scheme Syntax} build-exp ($primcall name args)\n"
"@deffnx {Scheme Syntax} build-exp ($values (arg ...))\n"
"@deffnx {Scheme Syntax} build-exp ($values args)\n"
"@deffnx {Scheme Syntax} build-exp ($prompt escape? tag handler)\n"
"@deffnx {Scheme Syntax} build-cont ,val\n"
"@deffnx {Scheme Syntax} build-cont ($kargs (name ...) (sym ...) term)\n"
"@deffnx {Scheme Syntax} build-cont ($kargs names syms term)\n"
"@deffnx {Scheme Syntax} build-cont ($kreceive req rest kargs)\n"
"@deffnx {Scheme Syntax} build-cont ($kfun src meta self ktail kclause)\n"
"@deffnx {Scheme Syntax} build-cont ($kclause ,arity kbody kalt)\n"
"@deffnx {Scheme Syntax} build-cont ($kclause (req opt rest kw aok?) kbody)\n"
"Construct a CPS term, expression, or continuation.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Syntax} build-term ,val\n"
"@deffnx {Scheme Syntax} build-term ($continue k src exp)\n"
"@deffnx {Scheme Syntax} build-exp ,val\n"
"@deffnx {Scheme Syntax} build-exp ($const val)\n"
"@deffnx {Scheme Syntax} build-exp ($prim name)\n"
"@deffnx {Scheme Syntax} build-exp ($branch kt exp)\n"
"@deffnx {Scheme Syntax} build-exp ($fun kentry)\n"
"@deffnx {Scheme Syntax} build-exp ($rec names syms funs)\n"
"@deffnx {Scheme Syntax} build-exp ($closure k nfree)\n"
"@deffnx {Scheme Syntax} build-exp ($call proc (arg ...))\n"
"@deffnx {Scheme Syntax} build-exp ($call proc args)\n"
"@deffnx {Scheme Syntax} build-exp ($callk k proc (arg ...))\n"
"@deffnx {Scheme Syntax} build-exp ($callk k proc args)\n"
"@deffnx {Scheme Syntax} build-exp ($primcall name (arg ...))\n"
"@deffnx {Scheme Syntax} build-exp ($primcall name args)\n"
"@deffnx {Scheme Syntax} build-exp ($values (arg ...))\n"
"@deffnx {Scheme Syntax} build-exp ($values args)\n"
"@deffnx {Scheme Syntax} build-exp ($prompt escape? tag handler)\n"
"@deffnx {Scheme Syntax} build-cont ,val\n"
"@deffnx {Scheme Syntax} build-cont ($kargs (name ...) (sym ...) term)\n"
"@deffnx {Scheme Syntax} build-cont ($kargs names syms term)\n"
"@deffnx {Scheme Syntax} build-cont ($kreceive req rest kargs)\n"
"@deffnx {Scheme Syntax} build-cont ($kfun src meta self ktail kclause)\n"
"@deffnx {Scheme Syntax} build-cont ($kclause ,arity kbody kalt)\n"
"@deffnx {Scheme Syntax} build-cont ($kclause (req opt rest kw aok?) kbody)\n"
"Создают CPS термы(term), выражения, или продолжения(continuation).\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:923
msgid "There are a few more miscellaneous interfaces as well."
msgstr "Есть еще несколько различных интерфейсов"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:927
msgid ""
"@deffn {Scheme Procedure} make-arity req opt rest kw allow-other-keywords?\n"
"A procedural constructor for @code{$arity} objects.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} make-arity req opt rest kw allow-other-keywords?\n"
"Процедурный конструктор для арных(@code{$arity}) объектов.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:936
msgid ""
"@deffn {Scheme Syntax} rewrite-term val (pat term) ...\n"
"@deffnx {Scheme Syntax} rewrite-exp val (pat exp) ...\n"
"@deffnx {Scheme Syntax} rewrite-cont val (pat cont) ...\n"
"Match @var{val} against the series of patterns @var{pat...}, using\n"
"@code{match}.  The body of the matching clause should be a template in\n"
"the syntax of @code{build-term}, @code{build-exp}, or @code{build-cont},\n"
"respectively.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Syntax} rewrite-term val (pat term) ...\n"
"@deffnx {Scheme Syntax} rewrite-exp val (pat exp) ...\n"
"@deffnx {Scheme Syntax} rewrite-cont val (pat cont) ...\n"
"Сопоставляет @var{val} с серией шаблонов @var{pat...}, используя\n"
"@code{match}.  Тело соответствия должно быть шаблоном в синтаксисе\n"
"@code{build-term}, @code{build-exp}, или @code{build-cont},\n"
"соответственно.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:939
msgid ""
"@node CPS Soup\n"
"@subsubsection CPS Soup"
msgstr ""
"@node CPS Soup\n"
"@subsubsection Суп CPS"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:946
msgid ""
"We describe programs in Guile's CPS language as being a kind of ``soup''\n"
"because all continuations in the program are mixed into the same\n"
"``pot'', so to speak, without explicit markers as to what function or\n"
"scope a continuation is in.  A program in CPS is a map from continuation\n"
"labels to continuation values.  As discussed in the introduction, a\n"
"continuation label is an integer.  No label may be negative."
msgstr ""
"Мы описываем программы на языке CPS Guile как своего рода ``суп''\n"
"потому что все продолжения в программе смешиваются в один и тот же\n"
"``банк'', так сказать, без явных указаний относительно того, какая\n"
"есть функции или области действия. Программа в CPS это карта из\n"
"помеченных продолжений к значениям продолжений.  Как обсуждалось\n"
"во введении, метка продолжения это целое число. Никакая метка не\n"
"может быть отритцательной."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:960
msgid ""
"As a matter of convention, label 0 should map to the @code{$kfun}\n"
"continuation of the entry to the program, which should be a function of\n"
"no arguments.  The body of a function consists of the labelled\n"
"continuations that are reachable from the function entry.  A program can\n"
"refer to other functions, either via @code{$fun} and @code{$rec} in\n"
"higher-order CPS, or via @code{$closure} and @code{$callk} in\n"
"first-order CPS.  The program logically contains all continuations of\n"
"all functions reachable from the entry function.  A compiler pass may\n"
"leave unreachable continuations in a program; subsequent compiler passes\n"
"should ensure that their transformations and analyses only take\n"
"reachable continuations into account.  It's OK though if transformation\n"
"runs over all continuations if including the unreachable continuations\n"
"has no effect on the transformations on the live continuations."
msgstr ""
"В качестве условного обозначения, метка 0 должна отображать продолжение\n"
"@code{$kfun} на точку входа в программу, которая должна быть функцией\n"
"без аргументов. Тело функции состоит из помеченных продолжений, доступных\n"
"из точки входа в функцию. Программа может ссылаться на другие функции,\n"
"либо через @code{$fun} и @code{$rec} в CPS высокого порядка, либо через\n"
"@code{$closure} и @code{$callk} CPS первого порядка.  Программа логически\n"
"содержит все продолжения всех функций достижимых из входной функции.  \n"
"Проход компилятора может оставить недостижимые продолжения в программе;\n"
"последующие проходы компилятора должны гарантировать, что их преобразвания\n"
"и анализ учитывают только достижимые продолжения.  Это нормально, хотя\n"
"если трансформация пробегает все продолжения, если включение недостижимых\n"
"продолжений не влияет на преобразования живых продолжений."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:967
msgid ""
"@cindex intmap\n"
"The ``soup'' itself is implemented as an @dfn{intmap}, a functional\n"
"array-mapped trie specialized for integer keys.  Intmaps associate\n"
"integers with values of any kind.  Currently intmaps are a private data\n"
"structure only used by the CPS phase of the compiler.  To work with\n"
"intmaps, load the @code{(language cps intmap)} module:"
msgstr ""
"@cindex intmap\n"
"Сам ``суп'' реализован как @dfn{intmap}, функциональный массив, "
"специализированный\n"
"для сопоставления целых ключей.  Intmaps связывает целые со значениями\n"
"любого типа.  В настоящее время intmaps частная структура данных, "
"используемая\n"
"только фазой компилятора  CPS.  Чтобы работать с intmaps, загрузиет модуль\n"
"@code{(language cps intmap)}:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:971
msgid ""
"@example\n"
"(use-modules (language cps intmap))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:974
msgid ""
"Intmaps are functional data structures, so there is no constructor as\n"
"such: one can simply start with the empty intmap and add entries to it."
msgstr ""
"Intmaps это функциональная структура данных, поэтому у нее нет конструктора\n"
"как такового: можно просто начать с пустой intmap и добавлять в нее\n"
"записи."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:984
msgid ""
"@example\n"
"(intmap? empty-intmap) @result{} #t\n"
"(define x (intmap-add empty-intmap 42 \"hi\"))\n"
"(intmap? x) @result{} #t\n"
"(intmap-ref x 42) @result{} \"hi\"\n"
"(intmap-ref x 43) @result{} @i{error: 43 not present}\n"
"(intmap-ref x 43 (lambda (k) \"yo!\")) @result{} \"yo\"\n"
"(intmap-add x 42 \"hej\") @result{} @i{error: 42 already present}\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:989
msgid ""
"@code{intmap-ref} and @code{intmap-add} are the core of the intmap\n"
"interface.  There is also @code{intmap-replace}, which replaces the\n"
"value associated with a given key, requiring that the key was present\n"
"already, and @code{intmap-remove}, which removes a key from an intmap."
msgstr ""
"@code{intmap-ref} и @code{intmap-add} являются ядром интерфейса intmap.\n"
"Есть также @code{intmap-replace}, которая заменяет значение связанное с\n"
"данным ключом, требует что бы ключ уже присутствовал в intmap, и \n"
"@code{intmap-remove}, который удаляет ключ из intmap."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:997
msgid ""
"Intmaps have a tree-like structure that is well-suited to set operations\n"
"such as union and intersection, so there is are also the binary\n"
"@code{intmap-union} and @code{intmap-intersect} procedures.  If the\n"
"result is equivalent to either argument, that argument is returned\n"
"as-is; in that way, one can detect whether the set operation produced a\n"
"new result simply by checking with @code{eq?}.  This makes intmaps\n"
"useful when computing fixed points."
msgstr ""
"Intmaps имеет древовидную структуру, которая хорошо подходит для операций\n"
"с множествами такими как объединение и пересечение, поэтому существуют\n"
"также двоичные процедуры @code{intmap-union} и @code{intmap-intersect}.\n"
"Если результат эквивалентен любому аргументу, этот аргумент возвращается\n"
"как есть; таким образом, можно определить, вызвала ли заданная операция\n"
"новый езультат просто выполнив проверку с помощью @code{eq?}.  Это делает\n"
"полезным intmaps при вычислении фиксированных точек(fixed points)."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1006
msgid ""
"If a key is present in both intmaps and the associated values are not\n"
"the same in the sense of @code{eq?}, the resulting value is determined\n"
"by a ``meet'' procedure, which is the optional last argument to\n"
"@code{intmap-union}, @code{intmap-intersect}, and also to\n"
"@code{intmap-add}, @code{intmap-replace}, and similar functions.  The\n"
"meet procedure will be called with the two values and should return the\n"
"intersected or unioned value in some domain-specific way.  If no meet\n"
"procedure is given, the default meet procedure will raise an error."
msgstr ""
"Если ключ присутствует в обоих intmaps и связанные значения не совпадают\n"
"в смысле @code{eq?}, результирующее значение определяется процедурой\n"
"``meet'', которая является необязательным последним аргументом \n"
"@code{intmap-union}, @code{intmap-intersect}, а также\n"
"@code{intmap-add}, @code{intmap-replace}, и аналогичных функций. Процедура\n"
"meet будет вызываться с двумя значениями и должна возвращать пересекающеся\n"
"или объединенное значение определяемое домен-специвфичным способом. Если\n"
"нет соответствующей процедуры, имеющаяся по умолчанию процедура meet \n"
"вызывает ошибку."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1010
msgid ""
"To traverse over the set of values in an intmap, there are the\n"
"@code{intmap-next} and @code{intmap-prev} procedures.  For example, if\n"
"intmap @var{x} has one entry mapping 42 to some value, we would have:"
msgstr ""
"Чтобы пройти по набору значений в intmap, есть процедуры @code{intmap-next}\n"
"и @code{intmap-prev}.  Например, если intmap @var{x} имеет одно отображение\n"
"записи 42 для нескольких значений, мы бы получили:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1020
msgid ""
"@example\n"
"(intmap-next x) @result{} 42\n"
"(intmap-next x 0) @result{} 42\n"
"(intmap-next x 42) @result{} 42\n"
"(intmap-next x 43) @result{} #f\n"
"(intmap-prev x) @result{} 42\n"
"(intmap-prev x 42) @result{} 42\n"
"(intmap-prev x 41) @result{} #f\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1026
msgid ""
"There is also the @code{intmap-fold} procedure, which folds over keys\n"
"and values in the intmap from lowest to highest value, and\n"
"@code{intmap-fold-right} which does so in the opposite direction.  These\n"
"procedures may take up to 3 seed values.  The number of values that the\n"
"fold procedure returns is the number of seed values."
msgstr ""
"Существует также процедура @code{intmap-fold}, которая складывает(folds)\n"
"по ключам и значениям в intmap от минимального до максимального значения, и\n"
"@code{intmap-fold-right} делающая тоже самое в противоположном направлении.\n"
"Эти процедуры могут принимать 3 начальных значений.  Количество значений,\n"
"которые складываются процедурой возвращаются как количество начальных\n"
"значений."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1032
msgid ""
"@example\n"
"(define q (intmap-add (intmap-add empty-intmap 1 2) 3 4))\n"
"(intmap-fold acons q '()) @result{} ((3 . 4) (1 . 2))\n"
"(intmap-fold-right acons q '()) @result{} ((1 . 2) (3 . 4))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1041
msgid ""
"When an entry in an intmap is updated (removed, added, or changed), a\n"
"new intmap is created that shares structure with the original intmap.\n"
"This operation ensures that the result of existing computations is not\n"
"affected by future computations: no mutation is ever visible to user\n"
"code.  This is a great property in a compiler data structure, as it lets\n"
"us hold a copy of a program before a transformation and use it while we\n"
"build a post-transformation program.  Updating an intmap is O(log\n"
"@var{n}) in the size of the intmap."
msgstr ""
"Когда запись в intmap обновляется (удаляется, добавляется или изменяется),\n"
"новый intmap создает разделяемую структуру с исходным intmap.\n"
"Эта операция гарантирует, что результат существующих вычислений не зависит\n"
"от будущих вычислений: никаких изменений невидимых для пользовательского\n"
"кода.  Это отличное свойство в структуре данных компилятора, поскольку\n"
"оно позволяет удерживать копию программы перед преобразованием и "
"использовать\n"
"ее, пока мы строим пост-преобразование программы. Обновление intmap это "
"операция\n"
"порядка O(log @var{n}) от размера intmap."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1049
msgid ""
"However, the O(log @var{n}) allocation costs are sometimes too much,\n"
"especially in cases when we know that we can just update the intmap in\n"
"place.  As an example, say we have an intmap mapping the integers 1 to\n"
"100 to the integers 42 to 141.  Let's say that we want to transform this\n"
"map by adding 1 to each value.  There is already an efficient\n"
"@code{intmap-map} procedure in the @code{(language cps utils}) module,\n"
"but if we didn't know about that we might do:"
msgstr ""
"Однако, затраты на размещение O(log @var{n}) иногда слишком велики, \n"
"особенно в тех случаях, когда мы знаем, что мы можем просто обновить\n"
"intmap на месте.  В качестве примера, скажем у нас есть intmap отображающий\n"
"целые числа от 1 до 100 в целые числа от 42 до 141. Предполжим, что мы "
"хотим\n"
"преобразовать это отображение, добавив 1 к каждому значению.  Уже "
"существует\n"
"эффективная процедура @code{intmap-map} в модуле @code{(language cps "
"utils}),\n"
"но если бы мы не знали об этом, мы могли бы делать так:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1059
msgid ""
"@example\n"
"(define (intmap-increment map)\n"
"  (let lp ((k 0) (map map))\n"
"    (let ((k (intmap-next map k)))\n"
"      (if k\n"
"          (let ((v (intmap-ref map k)))\n"
"            (lp (1+ k) (intmap-replace map k (1+ v))))\n"
"          map))))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1068
msgid ""
"@cindex intmap, transient\n"
"@cindex transient intmaps\n"
"Observe that the intermediate values created by @code{intmap-replace}\n"
"are completely invisible to the program -- only the last result of\n"
"@code{intmap-replace} value is needed.  The rest might as well share\n"
"state with the last one, and we could update in place.  Guile allows\n"
"this kind of interface via @dfn{transient intmaps}, inspired by\n"
"Clojure's transient interface (@uref{http://clojure.org/transients})."
msgstr ""
"@cindex intmap, transient\n"
"@cindex transient intmaps\n"
"Обратите внимание, что промежуточные значения, созданные методом\n"
"@code{intmap-replace}, полностью невидимы в программе -- нужен только\n"
"последний результат значения @code{intmap-replace}.  rest может совместно\n"
"использовать состояние с последним, чтобы мы могли обновить его.  Guile\n"
"позволяет этот вид интерфейса через @dfn{transient intmaps}, вдохновленный\n"
"переходным интерфейсом Замыканий. (@uref{http://clojure.org/transients})."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1076
msgid ""
"The in-place @code{intmap-add!} and @code{intmap-replace!} procedures\n"
"return transient intmaps.  If one of these in-place procedures is called\n"
"on a normal persistent intmap, a new transient intmap is created.  This\n"
"is an O(1) operation.  In all other respects the interface is like their\n"
"persistent counterparts, @code{intmap-add} and @code{intmap-replace}.\n"
"If an in-place procedure is called on a transient intmap, the intmap is\n"
"mutated in-place and the same value is returned."
msgstr ""
"Процедуры @code{intmap-add!} и @code{intmap-replace!} изменяющие входные \n"
"данные возвращают переходный intmaps.  Если одна из этих процедур "
"изменяющих\n"
"входные данные вызывается с постоянным intmap, создается новый переходный \n"
"intmap is.  Это операция O(1).  Во всех других отношениях интерфейс подобен\n"
"их постоянной копии, @code{intmap-add} и @code{intmap-replace}.\n"
"Если процедура меняющая входные данные вызывается с переходным  intmap, "
"intmap\n"
"изменяется на месте и возвращается одно и тоже значение(значение изменных "
"входных\n"
"данных)."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1084
msgid ""
"If a persistent operation like @code{intmap-add} is called on a\n"
"transient intmap, the transient's mutable substructure is then marked as\n"
"persistent, and @code{intmap-add} then runs on a new persistent intmap\n"
"sharing structure but not state with the original transient.  Mutating a\n"
"transient will cause enough copying to ensure that it can make its\n"
"change, but if part of its substructure is already ``owned'' by it, no\n"
"more copying is needed."
msgstr ""
"Если на временном intmap вызывается сохраняющая входные данные операция,\n"
"такая как @code{intmap-add}, изменяемая субструктура затем помечается как\n"
"постояная, и @code{intmap-add} запускается на новой постоянной структуре\n"
"intmap совместного использования, не имеющей пометки переходного\n"
"состояния. Изменение перходного состояния приводит к необходимому "
"копированию,\n"
"чтобы обеспечить это изменение, но если часть его подструктуры уже \n"
"``принадлежит'' им, копирование этой структуры больше требуется."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1087
msgid ""
"We can use transients to make @code{intmap-increment} more efficient.\n"
"The two changed elements have been marked @strong{like this}."
msgstr ""
"Мы можем использовать переходные initmap чтобы сделать @code{intmap-"
"increment}\n"
"более эффективным. Они изменяют элементы имеющие пометки @strong{следующим "
"образом}."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1097
msgid ""
"@example\n"
"(define (intmap-increment map)\n"
"  (let lp ((k 0) (map map))\n"
"    (let ((k (intmap-next map k)))\n"
"      (if k\n"
"          (let ((v (intmap-ref map k)))\n"
"            (lp (1+ k) (@strong{intmap-replace!} map k (1+ v))))\n"
"          (@strong{persistent-intmap} map)))))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1104
msgid ""
"Be sure to tag the result as persistent using the\n"
"@code{persistent-intmap} procedure to prevent the mutability from\n"
"leaking to other parts of the program.  For added paranoia, you could\n"
"call @code{persistent-intmap} on the incoming map, to ensure that if it\n"
"were already transient, that the mutations in the body of\n"
"@code{intmap-increment} wouldn't affect the incoming value."
msgstr ""
"Обязательно пометьте результат как постоянный, используя процедуру\n"
"@code{persistent-intmap}, чтобы предотвратить утечку памяти в другой\n"
"части программы.  Для дополнительной паранои, вы можете вызывать\n"
"@code{persistent-intmap} для входной initmap, чтобы убедиться, что\n"
"если она уже была временной, изменения в теле @code{intmap-increment}\n"
"не повлияют на входящее значение."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1108
msgid ""
"In summary, programs in CPS are intmaps whose values are continuations.\n"
"See the source code of @code{(language cps utils)} for a number of\n"
"useful facilities for working with CPS values."
msgstr ""
"Таким образом, программы в CPS представляют собой intmaps, значения "
"которого\n"
"являются продолжениями.\n"
"См. исходный код @code{(language cps utils)} для ряда полезных возможностей\n"
"для работы со значениями  CPS."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1111
msgid ""
"@node Compiling CPS\n"
"@subsubsection Compiling CPS"
msgstr ""
"@node Compiling CPS\n"
"@subsubsection Компиляция CPS"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1114
msgid ""
"Compiling CPS in Guile has three phases: conversion, optimization, and\n"
"code generation."
msgstr ""
"Компиляция CPS в Guile состоит из трех этапов: преобразование, оптимзация, "
"и\n"
"генерация кода."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1124
msgid ""
"CPS conversion is the process of taking a higher-level language and\n"
"compiling it to CPS.  Source languages can do this directly, or they can\n"
"convert to Tree-IL (which is probably easier) and let Tree-IL convert to\n"
"CPS later.  Going through Tree-IL has the advantage of running Tree-IL\n"
"optimization passes, like partial evaluation.  Also, the compiler from\n"
"Tree-IL to CPS handles assignment conversion, in which assigned local\n"
"variables (in Tree-IL, locals that are @code{<lexical-set>}) are\n"
"converted to being boxed values on the heap.  @xref{Variables and the\n"
"VM}."
msgstr ""
"Преобразование CPS это процесс взятия высокоуровнего языка и\n"
"компиляция его в  CPS.  Исходные языки могут делать это напрямую, или \n"
"они могут преобразовываться в Tree-IL (что, вероятно проще) и позже\n"
"Tree-IL преобразуется в CPS. Переход через Tree-IL имеет преимущество\n"
"выполнения оптимзационного этапа, как частичного выполнения.  Кроме того,\n"
"компилятор из Tree-IL в CPS обрабатывает преобразование присваивания, в "
"котором\n"
"назначаются локальные переменные (в Tree-IL, локальные переменные, которые\n"
"являются @code{<lexical-set>}) преобразуются в значения указанные в куче.\n"
" @xref{Variables and the VM}."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1129
msgid ""
"After CPS conversion, Guile runs some optimization passes over the CPS.\n"
"Most optimization in Guile is done on the CPS language.  The one major\n"
"exception is partial evaluation, which for historic reasons is done on\n"
"Tree-IL."
msgstr ""
"После преобразования CPS, Guile запускает некоторые проходы оптимизации\n"
"над CPS. Большинство оптимизаций в Guile делается на языке CPS. Одним из\n"
"основных исключений является частичное выполнение, которое по историческим\n"
"причинам сделано  на Tree-IL."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1137
msgid ""
"The major optimization performed on CPS is contification, in which\n"
"functions that are always called with the same continuation are\n"
"incorporated directly into a function's body.  This opens up space for\n"
"more optimizations, and turns procedure calls into @code{goto}.  It can\n"
"also make loops out of recursive function nests.  Guile also does dead\n"
"code elimination, common subexpression elimination, loop peeling and\n"
"invariant code motion, and range and type inference."
msgstr ""
"Основная оптимизация, выполняемая на CPS это contification, в котором\n"
"функции, которые всегда вызываются с тем же продолжением, включаются\n"
"непосредственно в тело функции. Это открывает пространство для большей\n"
"оптимизации и превращает вызовы процедур в @code{goto}.  Оно может \n"
"также делать петли из гнезд рекурсивных функций. Guile также уничтожает\n"
"мертвый код, устраняет код общегоподвыражения, пилинг(peeling) цикла и\n"
"инвариантного кода, а также диапазон и тип вывода."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1148
msgid ""
"The rest of the optimization passes are really cleanups and\n"
"canonicalizations.  CPS spans the gap between high-level languages and\n"
"low-level bytecodes, which allows much of the compilation process to be\n"
"expressed as source-to-source transformations.  Such is the case for\n"
"closure conversion, in which references to variables that are free in a\n"
"function are converted to closure references, and in which functions are\n"
"converted to closures.  There are a few more passes to ensure that the\n"
"only primcalls left in the term are those that have a corresponding\n"
"instruction in the virtual machine, and that their continuations expect\n"
"the right number of values."
msgstr ""
"Остальная часть проходов оптимизации это очистка и канонизация\n"
"(canonicalizations). CPS заполняет разрыв между языками высокого уровня\n"
"и байт-кодом низкого уровня, что позволяет выразить процесс компиляции \n"
"как трансформацию исходного кода в исходный код.  Таков случай для \n"
"преобразования замыкания, в котором ссылки на переменные, свободные\n"
"в функции, преобразуютя в ссылки замыкания, и в которых функция\n"
"преобразуется в замыкание. Есть еще несколько проходов, чтобы "
"гарантировать,\n"
"что единственные primcalls, оставшиеся в термах, это те, которые имеют\n"
"соответствующие инструкции на виртуальной машине, и что их продолжения\n"
"ожидают правильное количество значений."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1157
msgid ""
"Finally, the backend of the CPS compiler emits bytecode for each\n"
"function, one by one.  To do so, it determines the set of live variables\n"
"at all points in the function.  Using this liveness information, it\n"
"allocates stack slots to each variable, such that a variable can live in\n"
"one slot for the duration of its lifetime, without shuffling.  (Of\n"
"course, variables with disjoint lifetimes can share a slot.)  Finally\n"
"the backend emits code, typically just one VM instruction, for each\n"
"continuation in the function."
msgstr ""
"Наконец, в завершении компилятор CPS выдает байт-код для каждой функции,\n"
"одной за другой.  Для этого он определяет набор живых переменных во всех\n"
"точках функции. Използуя эту информацию, он выделяет слоты в стеке для\n"
"каждой переменной, так что переменная может жить в одном слоте все время\n"
"своей жизни, без перетасовки(перемещения). (Конечно, переменные с \n"
"непересекающимся временем жизни могут использовать совместно слот) Наконец\n"
"в завершении, генерируется код, как правило, только для одной виртуальной\n"
"машины, для каждого продолжения в функции."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1161
msgid ""
"@node Bytecode\n"
"@subsection Bytecode"
msgstr ""
"@node Bytecode\n"
"@subsection Байт Код"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1165
msgid ""
"As mentioned before, Guile compiles all code to bytecode, and that\n"
"bytecode is contained in ELF images.  @xref{Object File Format}, for\n"
"more on Guile's use of ELF."
msgstr ""
"Как упоминалось ранее, Guile компилирует весь код в байт-код и что\n"
"байт код содержиться в ELF образе.  @xref{Object File Format}, для\n"
"дополнительной информации о использовании в Guile формата ELF."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1167
msgid "To produce a bytecode image, Guile provides an assembler and a linker."
msgstr ""
"Чтобы создать образ байт-кода, Guile предоставляет ассемблер и \n"
"компоновщик."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1172
msgid ""
"The assembler, defined in the @code{(system vm assembler)} module, has a\n"
"relatively straightforward imperative interface.  It provides a\n"
"@code{make-assembler} function to instantiate an assembler and a set of\n"
"@code{emit-@var{inst}} procedures to emit instructions of each kind."
msgstr ""
"Ассемблер, определяется в модуле @code{(system vm assembler)}, он имеет\n"
"относительно прямолинейную струкуру внешнего императивного интерфейса.\n"
"Он предоставляет функцию @code{make-assembler} для создания экземпляра\n"
"ассемблера и набор процедур @code{emit-@var{inst}} для генерации инструкций\n"
"каждого типа."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1177
msgid ""
"The @code{emit-@var{inst}} procedures are actually generated at\n"
"compile-time from a machine-readable description of the VM.  With a few\n"
"exceptions for certain operand types, each operand of an emit procedure\n"
"corresponds to an operand of the corresponding instruction."
msgstr ""
"Процедуры @code{emit-@var{inst}} фактически генерируются во время \n"
"компиляции из машино-читаемого описания ВМ.  За некоторыми исключениями\n"
" для определенных типов операндов каждый опперанд генерирующей процедуры\n"
"соответствует операнду соответствующей инструкции."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1180
msgid ""
"Consider @code{vector-length}, from @pxref{Miscellaneous Instructions}.\n"
"It is documented as:"
msgstr ""
"Рассмотрим @code{vector-length}, из @pxref{Miscellaneous Instructions}.\n"
"Она задокументирована как:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1183
msgid ""
"@deftypefn Instruction {} vector-length u12:@var{dst} u12:@var{src}\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1185
msgid "Therefore the emit procedure has the form:"
msgstr "Поэтому генерирующая процедура имеет вид:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1188
msgid ""
"@deffn {Scheme Procedure} emit-vector-length asm dst src\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1191
msgid ""
"All emit procedure take the assembler as their first argument, and\n"
"return no useful values."
msgstr ""
"Все генерирующие процедуры получают ассемблер в качестве первого аргумента\n"
"и не возвращают никакого полезного значения."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1195
msgid ""
"The argument types depend on the operand types.  @xref{Instruction Set}.\n"
"Most are integers within a restricted range, though labels are generally\n"
"expressed as opaque symbols."
msgstr ""
"Типы аргументов зависят от типов операндов.  @xref{Instruction Set}.\n"
"Большинство из них представляют собой целые числа в ограниченном диапазоне,\n"
"хотя метки обычно выражаются как непрозрачные символы."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1197
msgid "There are a few macro-instructions as well."
msgstr "Есть также несколько макрокоманд."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1201
msgid ""
"@deffn {Scheme Procedure} emit-label asm label\n"
"Define a label at the current program point.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} emit-label asm label\n"
"Определяет метку в текущей программной точке.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1205
msgid ""
"@deffn {Scheme Procedure} emit-source asm source\n"
"Associate @var{source} with the current program point.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} emit-source asm source\n"
"Связывает исходный код(@var{source}) с текущей точкой программы.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1216
msgid ""
"@deffn {Scheme Procedure} emit-cache-current-module! asm module scope\n"
"@deffnx {Scheme Procedure} emit-cached-toplevel-box asm dst scope sym "
"bound?\n"
"@deffnx {Scheme Procedure} emit-cached-module-box asm dst module-name sym "
"public? bound?\n"
"Macro-instructions to implement caching of top-level variables.  The\n"
"first takes the current module, in the slot @var{module}, and associates\n"
"it with a cache location identified by @var{scope}.  The second takes a\n"
"@var{scope}, and resolves the variable.  @xref{Top-Level Environment\n"
"Instructions}.  The last does not need a cached module, rather taking\n"
"the module name directly.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} emit-cache-current-module! asm module scope\n"
"@deffnx {Scheme Procedure} emit-cached-toplevel-box asm dst scope sym "
"bound?\n"
"@deffnx {Scheme Procedure} emit-cached-module-box asm dst module-name sym "
"public? bound?\n"
"Макро инструкции реализующие кэширование переменных верхнего уровня. Первая\n"
"принимает текущий модуль, слоте  @var{module}, и связывает его с указанным\n"
"местоположением кэша в переменной @var{scope}.  Вторая принимает\n"
"@var{scope}, и разрешает(находит) переменную.  @xref{Top-Level Environment\n"
"Instructions}.  Последней не требуется модуль кэширования, вместо этого она\n"
"получает имя модуля напрямую.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1220
msgid ""
"@deffn {Scheme Procedure} emit-load-constant asm dst constant\n"
"Load the Scheme datum @var{constant} into @var{dst}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} emit-load-constant asm dst constant\n"
"Загружает исходные константы @var{constant} Scheme в @var{dst}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1226
msgid ""
"@deffn {Scheme Procedure} emit-begin-program asm label properties\n"
"@deffnx {Scheme Procedure} emit-end-program asm\n"
"Delimit the bounds of a procedure, with the given @var{label} and the\n"
"metadata @var{properties}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} emit-begin-program asm label properties\n"
"@deffnx {Scheme Procedure} emit-end-program asm\n"
"Отмечает границы процедуры, с указанной меткой @var{label} и мета\n"
"данными @var{properties}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1232
msgid ""
"@deffn {Scheme Procedure} emit-load-static-procedure asm dst label\n"
"Load a procedure with the given @var{label} into local @var{dst}.  This\n"
"macro-instruction should only be used with procedures without free\n"
"variables -- procedures that are not closures.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} emit-load-static-procedure asm dst label\n"
"Загружает процедуру с указанной меткой @var{label} в локальную переменную\n"
"@var{dst}.  Данная макро-инструкция должна использоваться только для "
"процедур\n"
"без свободных переменных --- т.е процдур не являющихся замыканиями.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1239
msgid ""
"@deffn {Scheme Procedure} emit-begin-standard-arity asm req nlocals "
"alternate\n"
"@deffnx {Scheme Procedure} emit-begin-opt-arity asm req opt rest nlocals "
"alternate\n"
"@deffnx {Scheme Procedure} emit-begin-kw-arity asm req opt rest kw-indices "
"allow-other-keys? nlocals alternate\n"
"@deffnx {Scheme Procedure} emit-end-arity asm\n"
"Delimit a clause of a procedure.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} emit-begin-standard-arity asm req nlocals "
"alternate\n"
"@deffnx {Scheme Procedure} emit-begin-opt-arity asm req opt rest nlocals "
"alternate\n"
"@deffnx {Scheme Procedure} emit-begin-kw-arity asm req opt rest kw-indices "
"allow-other-keys? nlocals alternate\n"
"@deffnx {Scheme Procedure} emit-end-arity asm\n"
"Разделительные предложения процедуры.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1250
msgid ""
"@deffn {Scheme Procedure} emit-br-if-symbol asm slot invert? label\n"
"@deffnx {Scheme Procedure} emit-br-if-variable asm slot invert? label\n"
"@deffnx {Scheme Procedure} emit-br-if-vector asm slot invert? label\n"
"@deffnx {Scheme Procedure} emit-br-if-string asm slot invert? label\n"
"@deffnx {Scheme Procedure} emit-br-if-bytevector asm slot invert? label\n"
"@deffnx {Scheme Procedure} emit-br-if-bitvector asm slot invert? label\n"
"TC7-specific test-and-branch instructions.  The TC7 is a 7-bit code that\n"
"is part of a heap object's type.  @xref{The SCM Type in Guile}.  Also,\n"
"@xref{Branch Instructions}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} emit-br-if-symbol asm slot invert? label\n"
"@deffnx {Scheme Procedure} emit-br-if-variable asm slot invert? label\n"
"@deffnx {Scheme Procedure} emit-br-if-vector asm slot invert? label\n"
"@deffnx {Scheme Procedure} emit-br-if-string asm slot invert? label\n"
"@deffnx {Scheme Procedure} emit-br-if-bytevector asm slot invert? label\n"
"@deffnx {Scheme Procedure} emit-br-if-bitvector asm slot invert? label\n"
"TC7-специфичные инструкции для тестирования и ветвления.  TC7 это \n"
"7-битный код который является частью типов объектов кучи.  \n"
"@xref{The SCM Type in Guile}.  Также см, @xref{Branch Instructions}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1259
msgid ""
"The linker is a complicated beast.  Hackers interested in how it works\n"
"would do well do read Ian Lance Taylor's series of articles on linkers.\n"
"Searching the internet should find them easily.  From the user's\n"
"perspective, there is only one knob to control: whether the resulting\n"
"image will be written out to a file or not.  If the user passes\n"
"@code{#:to-file? #t} as part of the compiler options (@pxref{The Scheme\n"
"Compiler}), the linker will align the resulting segments on page\n"
"boundaries, and otherwise not."
msgstr ""
"Линкер - сложный зверь. Хакеры, заинтересованные в том, чтобы узнать как\n"
"он работает, читайте серию статей Ian Lance Taylor о линкерах.\n"
"Поиск в интернете должен найти их без труда. С точки зрения пользователя,\n"
"есть только один признак для контроля: будет ли получен результирующий\n"
"образ для записи в файл или нет.  Если пользователь передает \n"
"@code{#:to-file? #t} как опцию компилятора (@pxref{The Scheme\n"
"Compiler}), компоновщик будет выравнивать результирующие сегменты на\n"
"границах страниц, в противном случае - нет."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1267
msgid ""
"@deffn {Scheme Procedure} link-assembly asm #:page-aligned?=#t\n"
"Link an ELF image, and return the bytevector.  If @var{page-aligned?} is\n"
"true, Guile will align the segments with different permissions on\n"
"page-sized boundaries, in order to maximize code sharing between\n"
"different processes.  Otherwise, padding is minimized, to minimize\n"
"address space consumption.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} link-assembly asm #:page-aligned?=#t\n"
"Связывает ELF образ, и возвращает байт-вектор.  Если @var{page-aligned?}\n"
"установлено в истину, Guile будет выравнивать сегменты с разными "
"разрешениями\n"
"на границах размера страниц, чтобы максимизировать совместное разделение "
"кода\n"
"между различными процессами. В противном случае заполнение минимизируется,\n"
"для минимизации использования адресного пространства.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1270
msgid ""
"To write an image to disk, just use @code{put-bytevector} from\n"
"@code{(ice-9 binary-ports)}."
msgstr ""
"Для записи на диск, просто используйте @code{put-bytevector} из\n"
"@code{(ice-9 binary-ports)}."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1277
msgid ""
"Compiling object code to the fake language, @code{value}, is performed\n"
"via loading objcode into a program, then executing that thunk with\n"
"respect to the compilation environment. Normally the environment\n"
"propagates through the compiler transparently, but users may specify the\n"
"compilation environment manually as well, as a module.  Procedures to\n"
"load images can be found in the @code{(system vm loader)} module:"
msgstr ""
"Компиляция объектного кода на фальшивый язык, @code{value}, выполняется\n"
"путем загрузки объектного кода(objcode) в программу, а затем выполняет\n"
"его относительно среды компиляции. Обычно среда передается через компилятор\n"
"прозрачно, но пользователи могут также указать среду компиляции как модуль.\n"
"Процедуры загрузки образов можно найти в модуле  @code{(system vm loader)}:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1281
msgid ""
"@lisp\n"
"(use-modules (system vm loader))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1287
msgid ""
"@deffn {Scheme Variable} load-thunk-from-file file\n"
"@deffnx {C Function} scm_load_thunk_from_file (file)\n"
"Load object code from a file named @var{file}. The file will be mapped\n"
"into memory via @code{mmap}, so this is a very fast operation.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Variable} load-thunk-from-file file\n"
"@deffnx {C Function} scm_load_thunk_from_file (file)\n"
"Загружает объектный код из файла с именем @var{file}. Файл будет "
"отображаться\n"
"в паметь через функцию @code{mmap}, так что это очень быстрая операция.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1294
msgid ""
"@deffn {Scheme Variable} load-thunk-from-memory bv\n"
"@deffnx {C Function} scm_load_thunk_from_memory (bv)\n"
"Load object code from a bytevector.  The data will be copied out of the\n"
"bytevector in order to ensure proper alignment of embedded Scheme\n"
"values.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Variable} load-thunk-from-memory bv\n"
"@deffnx {C Function} scm_load_thunk_from_memory (bv)\n"
"Загрузка объектного кода из байт-вектора.  Данные будут скопированы из\n"
"байтового вектора в порядке обечивающем правильное выравнивание встроенных\n"
"значений Scheme.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1297
msgid ""
"Additionally there are procedures to find the ELF image for a given\n"
"pointer, or to list all mapped ELF images:"
msgstr ""
"Кроме того, есть процедуры для поиска ELF образа для заданного\n"
"указателя, или списка всех отображенных(загруженных) ELF образов:"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1304
msgid ""
"@deffn {Scheme Variable} find-mapped-elf-image ptr\n"
"Given the integer value @var{ptr}, find and return the ELF image that\n"
"contains that pointer, as a bytevector.  If no image is found, return\n"
"@code{#f}.  This routine is mostly used by debuggers and other\n"
"introspective tools.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Variable} find-mapped-elf-image ptr\n"
"Учитывая целочисленное значение @var{ptr}, ищет и возвращает ELF образ\n"
"который содержит укзазатель, как байтовый вектор. Если изобржение не "
"найдено,\n"
"возвращает @code{#f}.  Эта процедура в основном используется отладчиком и "
"другими\n"
"интроспективными инструментами.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1308
msgid ""
"@deffn {Scheme Variable} all-mapped-elf-images\n"
"Return all mapped ELF images, as a list of bytevectors.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Variable} all-mapped-elf-images\n"
"Возвращает все отображенные(загруженные) ELF образы, как список\n"
"байт-векторов.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1312
msgid ""
"@node Writing New High-Level Languages\n"
"@subsection Writing New High-Level Languages"
msgstr ""
"@node Writing New High-Level Languages\n"
"@subsection Написание Новых Высоко-Уровневых Языков."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1321
msgid ""
"In order to integrate a new language @var{lang} into Guile's compiler\n"
"system, one has to create the module @code{(language @var{lang} spec)}\n"
"containing the language definition and referencing the parser,\n"
"compiler and other routines processing it. The module hierarchy in\n"
"@code{(language brainfuck)} defines a very basic Brainfuck\n"
"implementation meant to serve as easy-to-understand example on how to\n"
"do this. See for instance @url{http://en.wikipedia.org/wiki/Brainfuck}\n"
"for more information about the Brainfuck language itself."
msgstr ""
"Чтобы интегрировать новый язык @var{lang} в систему компилятора Guile,\n"
"нужно создать модуль @code{(language @var{lang} spec)} содержащий\n"
"определение языка и ссылающийся на анализатор, компилятор и другие\n"
"процедуры обрабатывающие его. Иерархия модулей в \n"
"@code{(language brainfuck)} определяет очень базовую реализацию\n"
"Brainfuck предназначенную для того чтобы служить легко понятным\n"
"примером о том как это сделать. См. например @url{http://en.wikipedia.org/"
"wiki/Brainfuck}\n"
"для дополнительной информации о языке Brainfuck."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1325
msgid ""
"@node Extending the Compiler\n"
"@subsection Extending the Compiler"
msgstr ""
"@node Extending the Compiler\n"
"@subsection Расширение Компилятора"

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1332
msgid ""
"At this point we take a detour from the impersonal tone of the rest of\n"
"the manual.  Admit it: if you've read this far into the compiler\n"
"internals manual, you are a junkie.  Perhaps a course at your university\n"
"left you unsated, or perhaps you've always harbored a desire to hack the\n"
"holy of computer science holies: a compiler.  Well you're in good\n"
"company, and in a good position.  Guile's compiler needs your help."
msgstr ""
"В этот момент мы отходим от безличного тона остальной части руководства.\n"
"Признайте это: если вы внимательно изучили руководство по внутреннему\n"
"компилятору, вы являетесь наркоманом! Возможно курс в вашем университете\n"
"оставил вас без внимания, или, возможно, вы всегда испытывали желание\n"
"взломать святость компьютерных наук: компилятор! Хорошо, что вы в хорошей\n"
"компании и в хорошем положении. Компилятор Guile нуждается в вашей помощи."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1340
msgid ""
"There are many possible avenues for improving Guile's compiler.\n"
"Probably the most important improvement, speed-wise, will be some form\n"
"of native compilation, both just-in-time and ahead-of-time. This could\n"
"be done in many ways. Probably the easiest strategy would be to extend\n"
"the compiled procedure structure to include a pointer to a native code\n"
"vector, and compile from bytecode to native code at run-time after a\n"
"procedure is called a certain number of times."
msgstr ""
"Существует множество возможностей для улучшения компилятора Guile.\n"
"Вероятно, наиболее важное улучшение, по скорости, будет представлять\n"
"собой некоторую форму нативной компиляции, как просто во время выполнения,\n"
"так и предварительной. Это можно сделать разными способами. Вероятно\n"
"самая простая стратегия была бы расширить скомпилированную процедуру\n"
"структурой включающей указатель на вектор исполняемого кода, и "
"скомпилировать\n"
"из байт кода исполняемый код во время выполнения, после того как\n"
"процедура вызывается определенное количество раз."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1346
msgid ""
"The name of the game is a profiling-based harvest of the low-hanging\n"
"fruit, running programs of interest under a system-level profiler and\n"
"determining which improvements would give the most bang for the buck.\n"
"It's really getting to the point though that native compilation is the\n"
"next step."
msgstr ""
"Название игры сбор урожая низкорослых фруктов на основе профилирования\n"
"программы, запуск программы представляющих интерес под профилировщиком\n"
"системного уровня определение того, какие улучшения даст самый удачный\n"
"buck. Это действительно доходит до того, что нативная компиляция - "
"следующий\n"
"шаг."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1352
msgid ""
"The compiler also needs help at the top end, enhancing the Scheme that\n"
"it knows to also understand R6RS, and adding new high-level compilers.\n"
"We have JavaScript and Emacs Lisp mostly complete, but they could use\n"
"some love; Lua would be nice as well, but whatever language it is\n"
"that strikes your fancy would be welcome too."
msgstr ""
"Компилятору также нужна помощь на верхнем уровне, улучшая Scheme \n"
"которая, как известно, также понимает R6RS, и добавляя новые\n"
"компиляторы высокого уровня. У нас есть JavaScript и Emacs Lisp\n"
"в основном завершены,  Lua тоже бы неплохо, да любой язык поразивший\n"
"ваше воображение, тоже будет приветствоваться."

#: /home/bear/work/guile/doc/guile/en/compiler.texi:1354
msgid ""
"Compilers are for hacking, not for admiring or for complaining about.\n"
"Get to it!"
msgstr ""
"Компиляторы предназначены для взлома, а не для восхищения или жалоб.\n"
"Доберитесь до него!"
