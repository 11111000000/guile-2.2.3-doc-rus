@c -*-texinfo-*-
@c This is part of the GNU Guile Reference Manual.
@c Copyright (C)  2008,2009,2010,2011,2013,2015
@c   Free Software Foundation, Inc.
@c See the file guile.texi for copying conditions.

@node A Virtual Machine for Guile
@section Виртуальная машина для Guile

У Guile есть и интерпретатор и компилятор. Для пользователя разница является
прозрачной --- интерпретируемые и скомпилированные процедуры могут вызывать
друг друга, как им нравиться.

Разница заключается в том, что компилятор создает и интерпретирует
байт-код для пользовательской виртуальной машины, вместо интерпретации
S-выражений напрямую. Загрузка и выполнение скомпилированного кода,
быстрее, чем загрузка и выполнение исходного кода.

Виртуальная машина, которая интерпретирует байт-код, является частью
самого Guile. Этот раздел описывает сущность виртуальой машины Guile.

@menu
* Why a VM?::                   
* VM Concepts::                 
* Stack Layout::                
* Variables and the VM::                   
* VM Programs::         
* Object File Format::
* Instruction Set::
@end menu

@node Why a VM?
@subsection Почему Виртуальная Машина(ВМ)?

@cindex interpreter
Долгое время в Guile был только интерпретатор. Интерпретатор Guile 
обрабатывал на прямую S-выражения представляющие исходный код на
Scheme.

Но даже в то время когда интерпретатор был очень оптимизирован и
настроен вручную, он все еще выполнял множество ненужных вычислений.
Например, применение функции к аргументам бесполезно повторяет
аргументы в списке. При вычисление выражения всегда приходилось
выяснять, что такое начало(car) выражения --- это процедура, форма или
что нибудь еще. Все значения должны быт размещены в куче. И т.д.

Решение этой проблемы состояло в том, чтобы скомпилировать язык более
высокого уровня Scheme, в язык более низкого уровня, для которого все
проверки и размещения уже выполнены. Код заменяется на минимальный 
минимумЖ необходимый для ``выполнения задания''.

Тогда возникает вопрос, какой язык низкого уровня выбрать? Есть много
вариантов. Мы можем напрямую скомпилировать программу в исполняемый 
код процессора. Но это создает проблемы с переносимостью для Guile, 
поскольку это очень кросс-платформенный проект.

Таким образом, мы хотим получить прирост производительности, который
дает компилияция, но мы также хотим поддерживать преимущества переносимости
выполняемого кода. Очевидное решение состоит в том, чтобы создать 
виртуальную машину, которая будет присутствовать во всех инсталяциях Guile. 

Самый простой (и самый интересный) способ зависеть от виртуальной
машины --- это реализовать виртуальную машину внутри самого Guile. 
Guile содержит интерпретатор байт-кода (написанного на Си) и
компилятор Scheme в байт-код (написанный на Scheme). Этот способ
построения виртуальной машины обеспечивает необходимые Scheme
конструкции (хвостовые вызовы(tail calls), множественные переменные
(multiple values), (продолжения) @code{call/cc}) и может обеспечить
оптимизацию встроенных инструкций Guile (@code{cons}, @code{struct-ref},
и т.д.).

Вот что делает Guile. В остальной части этого раздела описывается ВМ
которая реализована в Guile и скомпилированные процедуры которые
выполняются в ней.

Однако, прежде чем двигаться дальше, мы должны отметить, что, хотя
мы говорили об интерпретаторе в прошедшем времени, у Guile все еще
есть интерпретатор. Разница в том, что раньше это был главный 
исполнитель, и поэтому был реализован в сильно оптимизированном Си
коде; теперь он фактически реализован на Scheme, и скомпилирован
до байт-кода ВМ, как и любая другая программа на Guile.(Там есть
все еще и интерпретатор на Си, используемый для загрузки компилятора,
но он обычно не используется во время выполнения.)

Потенциал реализованного интерпретатора на Scheme состоит в том, что
мы сохраняем хвостовые вызовы и обработку множественных значений между
интерпретируемым и скомпилированным кодом. Недостатком является то,
что интерпретатор в Guile 2.2 все еще в два раза медленнее, чем
интерпретатор в 1.8.  Поскольку пользователи Scheme в основном
вполняют скомпилированный код, скорость скомпилированного кода 
выше, что компенсирует потерю скорости интерпретатором. В любом 
случае, если у нас есть встроенная компиляция кода Scheme, мы ожидаем,
что самообслуживаемый интерпретатор, легко обыграет старую настроенную
в ручную Си реализацию.

Также обратите внимание, что это решение реализовать компилятор
байт-кода не исключает компиляцию в исполняемый код базовой системы.
Мы можем скомпилировать из байт-кода в исполняемый код во время
выполнения, или даже сделать предварительную компиляцию. Дополнительные
возможности обсуждаются в @ref{Extending the Compiler}.

@node VM Concepts
@subsection Концепция Виртуальной Машины(ВМ)

Скомпилированный код запускается виртуальной машиной(ВМ). Каждый поток
имеет собственную виртуальную машину. Виртуальная машина выполняет
последовательность инструкций в процедуре.

Каждая инструкция ВМ начинается с указания, что это за операция, а затем
следуют закодированные ее исходные и целевые операнды. Каждая процедура
объявляет, какое она имеет количество локальных переменных, включая
аргументы функции. Эти локальные переменные образуют доступные операнды
в процедуре, и доступ к ним осуществляется по индексу.

Локальные переменные для процедуры храняться в стеке. Вызов процедуры
обычно увеличивает стек, и возврат из процедуры сокращает его. Память
стека является ограниченной по доступу виртуальной машиной, которой она
принадлежит.

В дополнение к своим стекам виртуальные машины также имеют доступ к
глобальной памяти (модули(modules), глобальные связанные перменные
(global bindings), и т.д), которые разделяются между другими частями
Guile, включая другие ВМ.

Регистры имеющиеся у ВМ следующие:

@itemize
@item ip - Указатель инструкции(Instruction pointer)
@item sp - Указатель стеа(Stack pointer)
@item fp - Указатель кадра(Frame pointer)
@end itemize

В других архитектурах указатель команд иногда называют ``программным
счетчиком(program counter)'' (pc). Этот набор регистров довольно типичен
для виртуальных машин; их точные значения в контексте виртуальной машины
Guile описаны в следующем разделе.

@node Stack Layout
@subsection Распределение Стека

Стек виртуальной машины Guile состоит из кадров(@dfn{frames}). Каждому
кадру соответствует применение одной скомпилированной процедуры, и
содержит пространство для хранения аргументов, локальных переменных и
некоторой другой учетной информации (например, что делать после завершения
кадра).

Хотя компилятор может делать все, что захочет, до тех пор пока
семантика вычислений сохраняется, на практике каждый раз, когда
вы вызываете функцию, создается новый кадр. (Заметным исключением,
конечно, является случай хвостового вызова, @pxref{Tail Calls}.)

Структура верхнего стекового кадра выглядит следующим образом:

@example
   | ...              |
   +==================+ <- fp + 2 = SCM_FRAME_PREVIOUS_SP (fp)
   | Dynamic link     |
   +------------------+
   | Return address   |
   +==================+ <- fp
   | Local 0          |
   +------------------+
   | Local 1          |
   +------------------+
   | ...              |
   +------------------+
   | Local N-1        |
   \------------------/ <- sp
@end example

В приведенном выше рисунке стек растет вниз. В начале вызова функции,
применяемая процедура находиться в Local 0, за которым следуют
аргументы из Local 1. После проверки процедурой, что ей передаются
совместимый набор аргументов, процедура выделяет некоторое дополнительное
пространство в кадре для хранения локальных для функции переменных.

Обратите внимание, что после того, как значение в слоте локальной
переменной больше не треубется, Guile может повторно использовать
этот слот. Это относиться и к слотам, которые первоначально использовались
для аргументов и вызываемого(?).  По этой причине, обратная трасса в
Guile не всегда может показать все аргументы: это может быть вызвано тем,
что слот, соответствующий этому аргументу, был повторно использован
какой-либо другой переменной.

@dfn{Обратный адрес(return address)} это @code{ip}, действоваший до применения
этой программы. Когда мы вернемся из этого активного кадра, мы вернемся к
этому  @code{ip}.  Аналогичным образом, динамическая ссылка(@dfn{dynamic link})
представляет собой смещение @code{fp} которое действовало до применения
этой программы, относительно текущего @code{fp}.

Чтобы подготовиться к не-хвостовому приложению, ВМ Guile выполняет код
который меняет размещает применяемую функцию и ее аргументы в соответствующие
слоты стека с двумя свободными слотами под ними.  Затем вызов инициализирует
эти два свободных слота текущими @code{ip} и @code{fp}, и изменяет
@code{ip} на точку входа в функцию, и @code{fp} на точку кадра нового 
вызова.

Таким образом, динамическая ссылка(dynamic link) связывает текущий кадр
стека с предыдущим. Вычисление трассировки стека включает в себя
перемещение по этим кадрам.

Каждый локальный стек Guile имеет ширину 64 бита, даже на 32-битных 
архитектурах. Это позволяет Guile сохранять единообразную обработку
локального стека, позволяя при необходимости использовать арифметику
64-битных целых и с плавающей точкой чисел.  
См. @xref{Instruction Set}, для получения дополнительной информации
об распакованной арифметике.

В качестве детали реализации, мы фактически сохраняем динамическую
ссылку как смещение, а не абсолютное значение, потому что стек
может перемещаться во время выполнения по мере его расширения или
во время вызова продолжений(continuation).  Если бы это было абсолютное
значение, нам пришлось бы ходить по кадрам, и пересчитывать
указатели кадров.

@node Variables and the VM
@subsection Переменные и Виртуальная Машина

В качестве примера рассмотрим следующий код Scheme:

@example
  (define (foo a)
    (lambda (b) (list foo a b)))
@end example

Внутри лямбда выражения, @code{foo} --- это переменная верхнего уровня,
@code{a} --- это лексически захваченная переменная, и @code{b} это локальная
перменная.

Другой путь, ссылки на @code{a} и @code{b} состоит в том, чтобы сказать,
что @code{a} является ``свободной'' переменной, поскольку не определена
в пределах лямбды, а @code{b} это ``сязанная(bound)'' переменная. Это
термины, исползуемые в лямбда исчислении (@dfn{lambda calculus}), 
математическом обозначении для описания функций. Лямбда исчисление
полезно потому что это язык, на котором можно точно рассуждать 
о функциях и переменных. Оно особенно хорошо при описании сферы отношений,
и именно по этой причине мы упоминаем об этом здесь.

Guile выделяет все переменные в стеке. Когда лексически замкнутая
процедура со свободными переменными --- замыкание(@dfn{closure})---
создается, она копирует эти переменные в вектор своей свободной 
переменной. Ссылки на свободные переменные затем перенаправляются
через вектор свободной переменной.

Если переменная когда-либо установлена @code{set!}, она должна быть
выделена в куче(heap-allocated) вместо выделения в стеке, так что
разные замыкания, которые захватывают одну и туже переменную,
могут видеть одно и тоже значение. Кроме того, это позволяеет 
продолжениям(continuations) захватывать ссылки на переменную, а
не на ее текущее значение. По этим причинам, @code{set!}
переменные выделяемые в ``рамках на рисунке стека(boxes)''---фактически, 
в ячейках переменных кучи. Дополнительную информацию см.
@xref{Variables},  Ссылка на переменные в @code{set!} являются
косвенными указывающими через boxes на ячекий в куче.

Таким образом, противоинтуитивное, казалось бы лучшее размещение ``ближе к телу'',
а именно @code{set!}, на самом деле способствует дополнительному выделению
памяти и косвенной адресации ячейки. Иногда оптимизатор Guile может удалить
это выделение, но не всегда.

Возвращаясь к нашему примеру, @code{b} может быть выделен в стеке, поскольку
он никогда не изменяется.

@code{a} также может быть выделено в стеке, поскольку она также
никогда не изменяется. В лямбда замыкании, его значение будет 
скопировано в (и указано откуда) из вектора свободных переменных.

@code{foo} --- это переменная верхнего уровня, потому что @code{foo} не
лексически связан в этом примере.

@node VM Programs
@subsection Скомпилированные Процедуры это программы Виртуальной Машины

По умолчанию, когда вы вводите выражения в Guile REPL, они сначала
компилируются в байт-код. Затем этот байт-код выполняется для
создания значения.  Если вычисляемое выражение является процедурой,
результатом этого процесса будет скомпилированная процедура.

Скомпилированная процедура представляет собой составной объект, состоящий
из его байт-кода и ссылки на любые лексически захваченные переменные. 
Кроме того, когда процедура компилируется, она ассоциируется с метаданными
записанными как таблица, например, сопоставление кода и номеров строк, или
docstring. Вы можете посмотреть эти части с помощью функций доступа из
модуля @code{(system vm program)}.  @xref{Compiled Procedures}, для полной
ссылки на API.

Процедура может ссылаться на данные, которые были статически
выделелены(распределены) когда процедура была скомпилирована.
Например, пара непосредственных(immediate) объектов 
(@pxref{Immediate objects}) может быть выделена непосредственно
в сегменте памяти, который содержит скомпилированный байт-код
и доступна непосредственно этому байт-коду.

Другое использование для статически распределенных данных - служить
кешем для байт-кода. Запросы к переменным верхнего уровеня обрабатываются
таким образом. Если инструкция @code{toplevel-box} обнаруживает, что
она не имеет кэшированной переменной для ссылки верхнего уровня, она 
обращается к другим статическим данным для разрешения ссылки и заполняет
ей слот кеша. После этого весь доступ к переменной происходит через
кэш-ячейку. Значение переменной может измениться в будущем, но сама
переменная изменена не будет.

Мы можем видеть, как эти понятия объединяются путем разбора
функции @code{foo}, которую мы определили раньше. Чтоыбы
посмотреть что происходит:

@smallexample
scheme@@(guile-user)> (define (foo a) (lambda (b) (list foo a b)))
scheme@@(guile-user)> ,x foo
Disassembly of #<procedure foo (a)> at #xea4ce4:

   0    (assert-nargs-ee/locals 2 0)    ;; 2 slots (1 arg)    at (unknown file):1:0
   1    (make-closure 1 7 1)            ;; anonymous procedure at #xea4d04 (1 free var)
   4    (free-set! 1 0 0)               ;; free var 0
   6    (mov 0 1)
   7    (return-values 2)               ;; 1 value

----------------------------------------
Disassembly of anonymous procedure at #xea4d04:

   0    (assert-nargs-ee/locals 2 2)    ;; 4 slots (1 arg)    at (unknown file):1:16
   1    (toplevel-box 1 74 58 68 #t)    ;; `foo'
   6    (box-ref 1 1)                   
   7    (make-short-immediate 0 772)    ;; ()                 at (unknown file):1:28
   8    (cons 2 2 0)                    
   9    (free-ref 3 3 0)                ;; free var 0
  11    (cons 3 3 2)
  12    (cons 2 1 3)
  13    (return-values 2)               ;; 1 value
@end smallexample

Сначала идет небольшая прелюдия, где @code{foo} проверяет, что она была
вызвана только с 1 аргументом. Затем на @code{ip} 1, мы выделяем новое
замыкание и сохраняем его в слоте 1 относительно @code{sp}.

Во время выполнения, локальные переменные в Guile обычно адресуются 
относительно указателя стека, что приводит к приятному эффективному
доступу @code{sp[@var{n}]}.  Однако это может затруднить дизасемблирование,
потому что @code{sp} может меняться во время работы функции и потому 
что входящие аргумекнты относятся к  @code{fp}, а не @code{sp}.

Чтобы узнать, какой ссылке на слот относительно @code{fp} соответствует 
ссылка относитеьно @code{sp}, просматривайте дизассемблированный код вверх,
пока вы не дойдете до анотации ``@var{n} slots''; в нашем случае 2, что
указывает на то, что кадру выделено место из 2 слотов.  Таким образом
слот адресуемый относительно @code{sp} с индексом 1 соответствует
слоту адресуему относительно @code{fp} с индексом 0, который первоначально
содержал значение вызванного замыкания.  Это означает. что Guile значение
этого замыкания не требуется и поэтому слот 0 был освобожден для
повторного использования, в данном случае для результата создания
нового замыкания.

Замыкание это код с данными.  @code{6} в вызове создания замыкания
@code{(make-closure 1 6 1)} является относительным смещением от точки
указателя кода(ip) для замыкания, и конечная @code{1} указывает, что
замыкание располагает местом для 1 свободной переменной.  @code{ip} 4 
инициализирует свободную переменную 0 в новом замыкании с помощью
значения из слота расположенного относительно  @code{sp}-со смещением
0, что соответствует слоту относительно @code{fp} со смещением 1, это
первый аргумент функции @code{foo}: @code{a}.  Наконец мы возвращаем
замыкание.

Вторая строфа разбирает код для замыкания. После прелюдии, мы загружаем
переменную для переменной верхнего уровня @code{foo} в слот 1.
Этот поиск происходит лениво, в первое время переменная, на которое
фактически ссылается переменная, и местоположение поиска кешируются так,
что будущие ссылки на них очень дешевы.  @xref{Top-Level Environment
Instructions}, для более подробной информации.  @code{box-ref} разыменовывает
ячейку переменной, заменяя содержимое слота 1.

Ниже следует последовательность созданий пар(conses) для построения
результирующего списка. @code{Ip} 7 создает хвост списка(непосредственный
пустой список). @code{Ip} 8 conses создает пару из значения в слоте 2,
соответствующее первому аргументу замыкания: @code{b} и хвоста.
@code{Ip} 9 загружает свободную переменную 0 слота 3-- вызыванной 
процедуры(a), в @code{fp}-относительно слота 0 -- будет слот 3, 
@code{ip} 11 conses создает следующую пару списка.  Наконец мы
cons создаем пару, из значения в слоте 1, содержащую  @code{foo} 
верхнего уровня(и хвоста), переднего плана списка, и затем возвращаем ее.

@node Object File Format
@subsection Формат Объектного Файла

Чтобы скомпилировать файл на диск, нам нужен формат для записи скомпилированного
кода на диск и позже загрузки его в Guile. Хороший формат объектного файла
@dfn{object file format}имеет ряд характеристик:

@itemize
@item Прежде всего, загрузка скомпилированного файла должна быть очень дешева.
@item Должна быть возможность статически выделять константы в файле. Например,
литерал байтовый вектор(bytevector) должен быть из исходного кода размещен
непосредственно в объектный файл.
@item Скомпилированный файл должен максимум кода и данных разделять между
различными процессами.
@item Скомпилированный файл должен содержать инофрмацию об отладке. такую
как номера строк, но эта информация должна быть отделена от самого кода.
должно быть возможность отлаживать информацию, если пространство заполнено.
@end itemize

Эти характеристики не специфичны для Scheme.  Действительно, основные
языки, такие как Си и Си++ решали эту проблему много раз в прошлом.
Guile строит свою работу на принятии ELF, формата объектных файлов
GNU и других Юникс подобных систем, как своего формата объектных файлов.
Хотя Guile исползует ELF на всех платформах, мы не используем поддержку
платформы для ELF. Guile реализует собственный компоновщик и загрузчик.
Преимущество использования ELF не в обмене кодом, но в обмене идеями.
ELF это просто хорошо продуманный формат объектного файла.

Файл ELF содержит две мета-таблицы, описывающих его содержимое. Первая
мета-таблица для загрузчика, и называется таблицей программ 
(@dfn{program table}), а иногда таблицей сегментов(@dfn{segment table}).
Таблица программ делит файл на большие куски, которые по разному
обрабатываются загрузчиком. В основном разница между этими сгментами
(@dfn{segments}) в их разрешениях(правах).

Обычно все сегменты файла ELF помечены как доступные только для чтения.
за исключением той части которая представляет собой модифицируемые
статические даные, которые необходио загрузить во время инициализации.
Загрузка ELF файла так же проста, как функция отображение файла в оперативную
память(mmapping) с флагом доступа только для чтения, затем используя таблицу
сегментов, отмечают небольшой субрегион, как доступный для записи.
Этот доступный для записи раздел обычно добавляют к корневому набору
сборщика мусора.

Один сегмент ELF обозначается как динамический(``dynamic''), что означает
что он имеет данные, представляющие интерез для загрузчика. Guile использует
этот сегмент для записи версии Guile, соответствующей этому файлу. Там также
записывается в динамическом сегменте адрес точки инициализационного  сегмента
(thunk) который запускается для выполнения любой необходиой инициализации
выполняемой во время связывания(link-time).  (Это похоже на динамическое 
перемещение для обычных ELF разделяемых объкетов, за исключением того, что мы
компилируем перестановки как процедуры, вместо того чтобы загрузчик
интерпретировал таблицу перемещенй) Наконец, динамический сегмент обозначает
местоположение  входного сегмента(``entry thunk'') объектного файла. этот сегмент
возвращается вызвавшему процедуру @code{load-thunk-from-memory} или
@code{load-thunk-from-file}.  При вызове, он выполнит ``тело'' скомпилированных
выражений.

Другая мета-таблица в  ELF файле это таблица разделов(@dfn{section table}).
В то время как таблица программ делит файл ELF на большие куски для 
загрузчика, в таблице разделов указаны небольшие разделы для использования
интроспективными инструментами, такими как отладчики или тому подоное.
Один сегмент(запись в таблице программ) обычно содержит много разделов.
Также могут быть разделы вне любого сегмента.

Типичные разделы в файле Guile @code{.go} включают:

@table @code
@item .rtl-text
Байт-код(Bytecode).
@item .data
Данные, которые требуют инициализации или которые могут быть изменены
во время выполнения.
@item .rodata
Статически распределенные данные, которые не требуют инициализации во
время выполнения, и поэтому могут быть разделены между процессами.
@item .dynamic
Динамический раздел, рассмотреный выше.@item .symtab
@itemx .strtab
Таблица отображения адресов в @code{.rtl-text} на имена процедур.
@code{.strtab} используется @code{.symtab}.
@item .guile.procprops
@itemx .guile.arities
@itemx .guile.arities.strtab
@itemx .guile.docstrs
@itemx .guile.docstrs.strtab
сторонние таблицы свойств процедур, arities и docstrings.
@item .guile.docstrs.strtab
сторонние таблицы отображений кадров, описывающие набор живых слотов
для любой точки возврата в тексте программы, и описывающих не являются
ли эти слоты - указателями. Используется сборщиком мусора.
@item .debug_info
@itemx .debug_abbrev
@itemx .debug_str
@itemx .debug_loc
@itemx .debug_line
Отладочная информация в формате DWARF.  См. спецификацию DWARF,
для большей информации.
@item .shstrtab
Таблица сторок названий разделов.
@end table

Для получения дополнительной информации, см @uref{http://linux.die.net/man/5/elf,,the
elf(5) man page}.  См. @uref{http://dwarfstd.org/,the DWARF
specification} для получения дополнительной информации о формате отладки DWARF.
Или если вы авантюрный исследователь, попробуйте запустить @code{readelf} или 
@code{objdump} на скомпилированных файлах @code{.go}.  Это хорошее время!

@node Instruction Set
@subsection Набор Инструкций

В настоящее время на виртуальной машине Guile существует около 175.
Эти инструкции представляют собой атомы единицы выполнения программы.
В идеале они выполняют одну задачу безусловной ветви, затем отправляют
на следующую инструкцию в потоке.

Инструкции сами по себе состоят из 1 или более 32 разрядных блоков. Младшие
8 бит первого слова указывают код операции, а остальные инструкции описывают
операнды. Есть несколько различных способов закодировать операнды.

@table @code
@item s@var{n}
Беззнаковое целое @var{n}-бит, указывает относительно @code{sp} смещение
локальной переменной.
@item f@var{n}
Беззнаковое целое @var{n}-бит, указывает относительно @code{fp} смещение
локальной переменной. Используется, когда продолжение(continuation) принимает
переменное количество переменных, чтобы переставить полученные значения в 
известные местоположения в кадре.
@item c@var{n}
Беззнаковое целое @var{n}-бит, указывет постоянное значение.
@item l24
Смещение от текущего @code{ip}, в 32-битных единицах, является 24-битным
значением со знаком.  Указывает адрес байт-кода, для относительного перехода.
@item i16
@itemx i32
Непосредственное значение Scheme (@pxref{Immediate objects}), закодированное
непосредственно в 16 или 32 битах.
@item a32
@itemx b32
Непосредственные значения Scheme, закодированнве как пара 32-битных слов.
Значения @code{a32} и @code{b32} всегда идут вместе для одного и тогоже
кода операции, и указывают на старшие и младшие биты, соответственно.
Обычно используются только в 64-битных системах.
@item n32
Статически выделенная опосредованное значение.  Адрес опосредованного
значения закодированный как знаковое целое 32-битное число, и указывающее
относительное смещение в 32-битных единицах. Думайте о нем как о
@code{SCM x = ip + offset}.
@item r32
Косвенное(не прямое) значение scheme, такое как @code{n32} но косвенное.
Думайте о нем как о: @code{SCM *x = ip + offset}.
@item l32
@item lo32
Адресс относительно ip, представляющий 32-битное знаковое целое. Может
указывать на адрес байт-кода, как в  @code{make-closure}, или на опосредованный
адрес, как в @code{static-patch!}.

@code{l32} и @code{lo32} одинаковы с точки зрения виртуальной машины.
Разница в том, что ассемблер может захотеть разрешить @code{lo32} как
адрес указывающий на метку и некоторое количество слов смещения от
этой метки, например когда исправляется поле для статически размещенного
объекта.
@item b1
Логическое значени: 1 для истины, иначе 0.
@item x@var{n}
Игнорируемая последовательность из @var{n} бит.
@end table

Инструкция указывается путем указания ее имени, а затем описания ее
операндов. Операнды упакованы в 32-битные слова, причем более ранние
операнды занимают младшие биты.

Например, рассмотрим следующую спецификацию инструкции:

@deftypefn Instruction {} free-set! s12:@var{dst} s12:@var{src} x8:@var{_} c24:@var{idx}
Установить свободную переменную @var{idx} из замыкания @var{dst} в @var{src}.
@end deftypefn

Первое слово в инструкции начнется с 8-битного значения, соответствующего
коду операции @var{free-set!} в младших битах, за которым последуют
@var{dst} и @var{src} как 12-битные значения.  Второе слово начинается
с 8 неиспользуемых битов, за которыми следует индех как 24-битное
непосредственное значение.

Иногда компилятор может понять, что он компилирует специальный случай,
который может быть запущен более эффективно. Так например, в то время
как Guile предлагает общую инструкцию test-and-branch, он также предлагает
конкретные инструкции для особых случаев,  так что в следующих случаях
все test-and-branch имеют свои инструкции:

@example
(if pred then else)
(if (not pred) then else)
(if (null? l) then else)
(if (not (null? l)) then else)
@end example

Кроме того, некотоыре примитивы Scheme имеют свои встроенные реализации.
Например, в предыдущем разделе мы видели @code{cons}.

Наконец, инструкции с операндами, которые кодируют ссылки на стек,
интерпретируются от этих значений стека вверх до самой инсрукции.
Большинство инструкций ожидают что их операнды помечены значениями
SCM (представление @code{scm}), но некоторые инструкции ожидают 
распакованных целых (представление @code{u64} и @code{s64}) или
числе с плавающей точкой (представление @var{f64}).  Инструкции
имеют статические типы: они должны получать свои операнды в 
формате, который они ожидают. Это зависит о компилятора, в данном
случае. Если не указано иное, все операнды и результаты помещаются
(упаковываются) в виде значений SCM.

@menu
* Lexical Environment Instructions::
* Top-Level Environment Instructions::
* Procedure Call and Return Instructions::
* Function Prologue Instructions::
* Trampoline Instructions::
* Branch Instructions::
* Constant Instructions::
* Dynamic Environment Instructions::
* Miscellaneous Instructions::
* Inlined Scheme Instructions::
* Inlined Atomic Instructions::
* Inlined Mathematical Instructions::
* Inlined Bytevector Instructions::
* Unboxed Integer Arithmetic::
* Unboxed Floating-Point Arithmetic::
@end menu

@node Lexical Environment Instructions
@subsubsection Инстркукции Лексической Среды(Окружения)

Эти инструкции получают доступ и изменяют лексическую среду скомпилированной
процедуры --- ее свободных и связанных переменных.  @xref{Stack Layout},
Для дополнительной информаций см. формат кадров стека.

@deftypefn Instruction {} mov s12:@var{dst} s12:@var{src}
@deftypefnx Instruction {} long-mov s24:@var{dst} x8:@var{_} s24:@var{src}
Скопировать значение из одного локального слота в другой.

Как обсуждалось ранее, аргументы процедуры и локальные переменные
распределяеются в локальные слоты. Компилятор  Guile пытается
измежать перестановки переменных в различные слоты, что часто
делает команды @code{mov} избыточными. Однако есть случаи, когда 
необходима перестановка, и в этих случаях @code{mov} это то, 
что нужно использовать.
@end deftypefn

@deftypefn Instruction {} long-fmov f24:@var{dst} x8:@var{_} f24:@var{src}
Копирует значение из одного локального слота в другой, но адресация
слотов относительно @code{fp} а не @code{sp}.  Команда используется при
перемещении значений после возврата множественного значения.
@end deftypefn

@deftypefn Instruction {} make-closure s24:@var{dst} l32:@var{offset} x8:@var{_} c24:@var{nfree}
Создать новое замыкание и записать его в @var{dst}.  Код для замыкания
надо искать по смещению @var{offset} слов от текущего значения регистра @code{ip}.
@var{offset} это 32-битное знаковое целое число.  Пространство для @var{nfree} свободных
переменных будет выделено.

Размер замыкания в настоящее время составляет два слова, плюс одно слово
на каждую свободную переменную.
@end deftypefn

@deftypefn Instruction {} free-ref s12:@var{dst} s12:@var{src} x8:@var{_} c24:@var{idx}
Загрузить свободную переменную @var{idx} из замыкания @var{src} в локальный слот
@var{dst}.
@end deftypefn

@deftypefn Instruction {} free-set! s12:@var{dst} s12:@var{src} x8:@var{_} c24:@var{idx}
Установить свободную перменную @var{idx} из замыкания @var{dst} в значение из @var{src}.

Эта инструкция обычно используется при инициализации свободных переменных
замыкания, но не для изменения свободных переменных, поскольку назначенные
переменные упакованы.
@end deftypefn

Напомним, что назначенные переменные обычно размещаются упакованными,
так что продолжения и замыкания могут захватывать их идентификаторы,
а не их значения которые они имеют в определенный момент времени.
Переменные также используются при реализации высоко-уровневого
связывания; см. следующий раздел для большей информации.

@deftypefn Instruction {} box s12:@var{dst} s12:@var{src}
Создать новую переменную хранящуюся(?) в @var{src}, поместить ее в @var{dst}.
@end deftypefn

@deftypefn Instruction {} box-ref s12:@var{dst} s12:@var{src}
Распаковать переменную из @var{src} в @var{dst}, проверяя что переменная
является связанной.
@end deftypefn

@deftypefn Instruction {} box-set! s12:@var{dst} s12:@var{src}
Установить содержимое переменной @var{dst} в значение @var{set}.
@end deftypefn

@node Top-Level Environment Instructions
@subsubsection Инструкции сред Верхнего Уровня

Эти инструкции получают значения в среде верхнего уровня: связывание
которых было не лексическим в то время когда этот код был скомпилирован.


Место, в котором храниться связанное значение верхнего урвня, можно разыскать
одирн раз и кэшировать для дальнейшего использования. Само связанное значение
может меняться со временем, но ее местоположение останется постоянным.

@deftypefn Instruction {} current-module s24:@var{dst}
Сохранить текущий модуль в @var{dst}.
@end deftypefn

@deftypefn Instruction {} resolve s24:@var{dst} b1:@var{bound?} x7:@var{_} s24:@var{sym}
Разрешить(найти) @var{sym} в текущем модуле и поместить полученную переменную
в @var{dst}.  Будет вызвана ошибка если переменная не найдена. Если
@var{bound?} - истина(переменная связана), ошибка будет сигнализировать о том
что переменная не связана.
@end deftypefn

@deftypefn Instruction {} define! s12:@var{dst} s12:@var{sym}
Найти связанную переменную для @var{sym} в текущем модуле, создать ее
если необходимо, Хранить эту переменную в @var{dst}.
@end deftypefn

@deftypefn Instruction {} toplevel-box s24:@var{dst} r32:@var{var-offset} r32:@var{mod-offset} n32:@var{sym-offset} b1:@var{bound?} x31:@var{_}
Загружает значение.  Значение будет извлекаться из памяти, используя значение
@var{var-offset} в 32-битных словах от ip(текщей точки указателя программы)
@var{var-offset} это значение со знаком.  Здесь, @code{toplevel-box} как
@code{static-ref}.

Затем, если загруженное значение является переменной, оно помещатеся в
@var{dst} и выполнение продолжается.

Иначе, мы должны разрешить(найти) эту переменную. В этом случае мы
загружаем модуль из @var{mod-offset}, также как мы грузим переменную.
Обычно модуль получает установки, когда замыкание создается.
@var{sym-offset} задает имя, как смещение к символу.

Мы используем модуль и символ для разрешения(поиска) переменной, помещая
ее в @var{dst}, и кеширования разрешенной(найденой) переменной, чтобы
в следующий раз мы попали в кеш. Если @var{bound?} это истина, а иначе
выдается сообщение об ошибке если переменная не связана.
@end deftypefn

@deftypefn Instruction {} module-box s24:@var{dst} r32:@var{var-offset} n32:@var{mod-offset} n32:@var{sym-offset} b1:@var{bound?} x31:@var{_}
Подобно @code{toplevel-box}, за исключением @var{mod-offset} указывает
на идентификатор модуля, вместо самого модуля.  Идентификатор модуля - 
это имя модуля, как список, предваряемый логическим значением. Если
это значение истинно, то переменная разрешена(найдена) относительно
общедоступного интерфейса модуля, вместо частного интерфеса.
@end deftypefn

@node Procedure Call and Return Instructions
@subsubsection Инструкции вызова Процедур и Возврата

Как описано выше (@pxref{Stack Layout}), соглашение о вызовах Guile
такое, что аргументы передаются а значения возвращаются в стеке.

Для вызовов, как в хвостовом положении, так и нехвостовом., мы требуем,
чтобы процедура и аргументы повторно перемещались на место перед
инструкцией вызова. ``На место'' для хвостового вызова означает, что
процедура должна быть в 0 слоте, относительно указателя кадра @code{fp},
и за ней должны следовать аргументы. Для не хвостового вызова, если 
процедура размещается в слоте  @var{n} относительно @code{fp},
аргументы должны следовать за слотом @var{n}+1, и должно быть два
свободных слота со смещением @var{n}-1 и @var{n}-2 для сохранения
текущих @code{ip} и @code{fp}.

Возвращение значений аналогично.  Многозначные значения повторно
перемещаются вниз, чтобы начать со слота номер 1 относительно @code{fp}
перед вызовом @code{return-values}.  Мы начинаем со слота 1 вместо слота
0 что бы сделать квостовые вызовы  (со значениями|значений?) @code{values}
тривиальными.

В обоих вызовах и возрватах @code{sp} используется для указания
вызываемомой процедуре числа аргументов или возвращаемых значений
для вызвавшей процедры, соответственно. После получения возвращаемых 
значений, вызвавшая процедура обязана востанановить кадр 
@dfn{restore the frame} и сбросить @code{sp} в его прежнее значение.

@deftypefn Instruction {} call f24:@var{proc} x8:@var{_} c24:@var{nlocals}
Вызо процедуры.  @var{proc} является локальной соответствущей
значению процедуре. Два значения ниже @var{proc} будут перезаписаны
сохраненными данными кадра вызова. Новый кадр будет иметь пространство для
@var{nlocals} локальных: одно для процедуры, а остальные для аргументов, которые
уже должны быть уже размещены.

Кода вызов завершается, выполнение продолжается со следующей 
инструкции. В стеке может быть возвращено любое количество значений;
точное их число может быть получено вычитанием адреса  @var{proc} из
установленого после возврата значения @code{sp}.
@end deftypefn

@deftypefn Instruction {} call-label f24:@var{proc} x8:@var{_} c24:@var{nlocals} l32:@var{label}
Вызов процедуры в томже компиляционном блоке.

Эта инструкция похожа на вызов @code{call}, за исключением того, что
вместо разыменовывания @var{proc} для поиска цели вызова, цель вызова
как известно находиться на метке @var{label}, знаковое целое 32-битное
смещение относительно текущего указателя программы @code{ip}.  Поскольу
@var{proc} на разыменовывается, это может быть какое-то другое
представление замыкания.
@end deftypefn

@deftypefn Instruction {} tail-call c24:@var{nlocals}
Хвостовой вызов процедуры. Требует чтобы процедура и все аргументы
уже были перемещены в позицию. Сбрасывает кадр на @var{nlocals}.
@end deftypefn

@deftypefn Instruction {} tail-call-label c24:@var{nlocals} l32:@var{label}
Хвостовой вызов известной процедуры.  В качестве вызываемой @code{call} 
стоит метка @code{call-label},
@code{tail-call} is to @code{tail-call-label}.
@end deftypefn

@deftypefn Instruction {} tail-call/shuffle f24:@var{from}
Хвостовой вызов процедуры.  Процедура уж должна быть уже размещена 
в 0 слоте. Остальная часть args берется из кадра, начиная с @var{from},
перемещаются вниз, чтобы начать со слота 0.  Это является частью
реализации встроенной @code{call-with-values}.
@end deftypefn

@deftypefn Instruction {} receive f12:@var{dst} f12:@var{proc} x8:@var{_} c24:@var{nlocals}
Получает одно возвращаемое значение из вызова, чья процедура была
@var{proc}, проверяя, что вызов фактически возвратил хотябы одно
значение.  После этого сбрасывает кадр на @var{nlocals} локальных.
@end deftypefn

@deftypefn Instruction {} receive-values f24:@var{proc} b1:@var{allow-extra?} x7:@var{_} c24:@var{nvalues}
Получает возвращаемое множество значений из вызвова, чья процедура
была @var{proc}.  Если возвращеных значений меньше чем @var{nvalues},
сигнализирует об ошибке. Если не @var{allow-extra?} является истинным,
требует чтобы число возвращаемых значений точно равнялось  @var{nvalues}.
После получения значений @code{receive-values}, значения могут быть
скопированы с помощью @code{mov}, или использованы на месте.
@end deftypefn

@deftypefn Instruction {} return-values c24:@var{nlocals}
Возвращает несколько значений из кадра вызова.  Этому коду операции 
соответствует применение значений @code{values} в хвостовой позиции.
Как и в случае с хвостовыми вызовами, мы ожидаем, что значения
уже перемещаются вниз, начиная со слота 1.  Если @var{nlocals} не ноль,
is nonzero, кадр сбрасывается, что бы удерживать это количество
локальных.  Обратите внимание, что кадр
сбрасывается до 1, local возвращает 0 значений.
@end deftypefn

@deftypefn Instruction {} call/cc x24:@var{_}
Захватывает текущее продолжение, и применяет(tail-apply) процедуру из
локального слота 1 к ней.  Эта инструкция является частью реализации @code{call/cc}, 
и не генерируется компилятором.
@end deftypefn

@node Function Prologue Instructions
@subsubsection Инструкции начинающие функции

Вызов функции в Guile очень дешев: Виртуальная Машина просто контролирует
процедуру. Сама процедура несет ответственность за проверку того, что ей
передано приемлемое количество аргументов. Эта стратегия позволяет разбирать
аргументы произвольной сложности анализирующими идиомами, без ущерба
для общего случая.

Например, только вызывая процедуры с ключевыми аргументами процедура 
платит за разбор ключевых аргументов. (На момент написания, вызов
процедур с ключевыми аргументами обычно в два-четыре раза дороже,
чем вызов процедур с фиксированным набором аргументов.)

@deftypefn Instruction {} assert-nargs-ee c24:@var{expected}
@deftypefnx Instruction {} assert-nargs-ge c24:@var{expected}
@deftypefnx Instruction {} assert-nargs-le c24:@var{expected}
If the number of actual arguments is not @code{==}, @code{>=}, or
@code{<=} @var{expected}, respectively, signal an error.

The number of arguments is determined by subtracting the stack pointer
from the frame pointer (@code{fp - sp}).  @xref{Stack Layout}, for more
details on stack frames.  Note that @var{expected} includes the
procedure itself.
@end deftypefn

@deftypefn Instruction {} br-if-nargs-ne c24:@var{expected} x8:@var{_} l24:@var{offset}
@deftypefnx Instruction {} br-if-nargs-lt c24:@var{expected} x8:@var{_} l24:@var{offset}
@deftypefnx Instruction {} br-if-nargs-gt c24:@var{expected} x8:@var{_} l24:@var{offset}
If the number of actual arguments is not equal, less than, or greater
than @var{expected}, respectively, add @var{offset}, a signed 24-bit
number, to the current instruction pointer.  Note that @var{expected}
includes the procedure itself.

These instructions are used to implement multiple arities, as in
@code{case-lambda}. @xref{Case-lambda}, for more information.
@end deftypefn

@deftypefn Instruction {} alloc-frame c24:@var{nlocals}
Ensure that there is space on the stack for @var{nlocals} local
variables, setting them all to @code{SCM_UNDEFINED}, except those values
that are already on the stack.
@end deftypefn

@deftypefn Instruction {} reset-frame c24:@var{nlocals}
Like @code{alloc-frame}, but doesn't check that the stack is big enough,
and doesn't initialize values to @code{SCM_UNDEFINED}.  Used to reset
the frame size to something less than the size that was previously set
via alloc-frame.
@end deftypefn

@deftypefn Instruction {} assert-nargs-ee/locals c12:@var{expected} c12:@var{nlocals}
Equivalent to a sequence of @code{assert-nargs-ee} and
@code{reserve-locals}.  The number of locals reserved is @var{expected}
+ @var{nlocals}.
@end deftypefn

@deftypefn Instruction {} br-if-npos-gt c24:@var{nreq} x8:@var{_} c24:@var{npos} x8:@var{_} l24:@var{offset}
Find the first positional argument after @var{nreq}.  If it is greater
than @var{npos}, jump to @var{offset}.

This instruction is only emitted for functions with multiple clauses,
and an earlier clause has keywords and no rest arguments.
@xref{Case-lambda}, for more on how @code{case-lambda} chooses the
clause to apply.
@end deftypefn

@deftypefn Instruction {} bind-kwargs c24:@var{nreq} c8:@var{flags} c24:@var{nreq-and-opt} x8:@var{_} c24:@var{ntotal} n32:@var{kw-offset}
@var{flags} is a bitfield, whose lowest bit is @var{allow-other-keys},
second bit is @var{has-rest}, and whose following six bits are unused.

Find the last positional argument, and shuffle all the rest above
@var{ntotal}.  Initialize the intervening locals to
@code{SCM_UNDEFINED}.  Then load the constant at @var{kw-offset} words
from the current @var{ip}, and use it and the @var{allow-other-keys}
flag to bind keyword arguments.  If @var{has-rest}, collect all shuffled
arguments into a list, and store it in @var{nreq-and-opt}.  Finally,
clear the arguments that we shuffled up.

The parsing is driven by a keyword arguments association list, looked up
using @var{kw-offset}.  The alist is a list of pairs of the form
@code{(@var{kw} . @var{index})}, mapping keyword arguments to their
local slot indices.  Unless @code{allow-other-keys} is set, the parser
will signal an error if an unknown key is found.

A macro-mega-instruction.
@end deftypefn

@deftypefn Instruction {} bind-rest f24:@var{dst}
Collect any arguments at or above @var{dst} into a list, and store that
list at @var{dst}.
@end deftypefn

@node Trampoline Instructions
@subsubsection Инструкции Траплины

Хотя наиболее применимыми объектами в Guile являются процедуры,
реализованные в байт-коде, это не все. Есть примитивы, продолжения и
другие подобные процедурам объекты, которые имеют собственной
соглашение о вызовах. Вместо добавления особых случаев в инстркцию
вызова @code{call}, Guile обертывает эти другие применимые объекты
в процедуры Трамплины Виртуальной Машины, затем предоставляя
специальную поддержку этих объектов в байт коде.

Процедуры Трамплины обычно генерируются Guile во время выполнения,
например, в ответ на вызов  @code{scm_c_make_gsubr}.  Таким образом,
компилятор, вероятно, не должен генерировать код с этими инструкциями.
Тем не менее, все еще интересно знать, как они работают, поэтому мы
запишем эти trampoline инструкции здесь.

@deftypefn Instruction {} subr-call x24:@var{_}
Call a subr, passing all locals in this frame as arguments.  Return from
the calling frame.
@end deftypefn

@deftypefn Instruction {} foreign-call c12:@var{cif-idx} c12:@var{ptr-idx}
Call a foreign function.  Fetch the @var{cif} and foreign pointer from
@var{cif-idx} and @var{ptr-idx}, both free variables.  Return from the calling
frame.  Arguments are taken from the stack.
@end deftypefn

@deftypefn Instruction {} continuation-call c24:@var{contregs}
Return to a continuation, nonlocally.  The arguments to the continuation
are taken from the stack.  @var{contregs} is a free variable containing
the reified continuation.
@end deftypefn

@deftypefn Instruction {} compose-continuation c24:@var{cont}
Compose a partial continution with the current continuation.  The
arguments to the continuation are taken from the stack.  @var{cont} is a
free variable containing the reified continuation.
@end deftypefn

@deftypefn Instruction {} tail-apply x24:@var{_}
Tail-apply the procedure in local slot 0 to the rest of the arguments.
This instruction is part of the implementation of @code{apply}, and is
not generated by the compiler.
@end deftypefn

@deftypefn Instruction {} builtin-ref s12:@var{dst} c12:@var{idx}
Load a builtin stub by index into @var{dst}.
@end deftypefn

@deftypefn Instruction {} apply-non-program x24:@var{_}
An instruction used only by a special trampoline that the VM uses to
apply non-programs.  Using that trampoline allows profilers and
backtrace utilities to avoid seeing the instruction pointer from the
calling frame.
@end deftypefn

@node Branch Instructions
@subsubsection Инструкции Ветвления

Все смещения в инструкциях ветвления это 24-битные числа со знаком, которые
подсчитвают 32-битовые единицы. Это дает  Guile эффективный  26-битный диапазон
адреов для относительных переходов.

@deftypefn Instruction {} br l24:@var{offset}
Add @var{offset} to the current instruction pointer.
@end deftypefn

All the conditional branch instructions described below have an
@var{invert} parameter, which if true reverses the test:
@code{br-if-true} becomes @code{br-if-false}, and so on.

@deftypefn Instruction {} br-if-true s24:@var{test} b1:@var{invert} x7:@var{_} l24:@var{offset}
If the value in @var{test} is true for the purposes of Scheme, add
@var{offset} to the current instruction pointer.
@end deftypefn

@deftypefn Instruction {} br-if-null s24:@var{test} b1:@var{invert} x7:@var{_} l24:@var{offset}
If the value in @var{test} is the end-of-list or Lisp nil, add
@var{offset} to the current instruction pointer.
@end deftypefn

@deftypefn Instruction {} br-if-nil s24:@var{test} b1:@var{invert} x7:@var{_} l24:@var{offset}
If the value in @var{test} is false to Lisp, add @var{offset} to the
current instruction pointer.
@end deftypefn

@deftypefn Instruction {} br-if-pair s24:@var{test} b1:@var{invert} x7:@var{_} l24:@var{offset}
If the value in @var{test} is a pair, add @var{offset} to the current
instruction pointer.
@end deftypefn

@deftypefn Instruction {} br-if-struct s24:@var{test} b1:@var{invert} x7:@var{_} l24:@var{offset}
If the value in @var{test} is a struct, add @var{offset} number to the
current instruction pointer.
@end deftypefn

@deftypefn Instruction {} br-if-char s24:@var{test} b1:@var{invert} x7:@var{_} l24:@var{offset}
If the value in @var{test} is a char, add @var{offset} to the current
instruction pointer.
@end deftypefn

@deftypefn Instruction {} br-if-tc7 s24:@var{test} b1:@var{invert} u7:@var{tc7} l24:@var{offset}
If the value in @var{test} has the TC7 given in the second word, add
@var{offset} to the current instruction pointer.  TC7 codes are part of
the way Guile represents non-immediate objects, and are deep wizardry.
See @code{libguile/tags.h} for all the details.
@end deftypefn

@deftypefn Instruction {} br-if-eq s24:@var{a} x8:@var{_} s24:@var{b} b1:@var{invert} x7:@var{_} l24:@var{offset}
@deftypefnx Instruction {} br-if-eqv s24:@var{a} x8:@var{_} s24:@var{b} b1:@var{invert} x7:@var{_} l24:@var{offset}
If the value in @var{a} is @code{eq?} or @code{eqv?} to the value in
@var{b}, respectively, add @var{offset} to the current instruction
pointer.
@end deftypefn

@deftypefn Instruction {} br-if-= s24:@var{a} x8:@var{_} s24:@var{b} b1:@var{invert} x7:@var{_} l24:@var{offset}
@deftypefnx Instruction {} br-if-< s24:@var{a} x8:@var{_} s24:@var{b} b1:@var{invert} x7:@var{_} l24:@var{offset}
@deftypefnx Instruction {} br-if-<= s24:@var{a} x8:@var{_} s24:@var{b} b1:@var{invert} x7:@var{_} l24:@var{offset}
If the value in @var{a} is @code{=}, @code{<}, or @code{<=} to the value
in @var{b}, respectively, add @var{offset} to the current instruction
pointer.
@end deftypefn

@deftypefn Instruction {} br-if-logtest s24:@var{a} x8:@var{_} s24:@var{b} b1:@var{invert} x7:@var{_} l24:@var{offset}
If the bitwise intersection of the integers in @var{a} and @var{b} is
nonzero, add @var{offset} to the current instruction pointer.
@end deftypefn

@node Constant Instructions
@subsubsection Constant Instructions

Следующие инструкции загружают литеральные данные в программу. Есть
два вида.

Первый набор инструкций загружает непосредственные значения. Эти инструкции
кодируют непосредственные данные в поток команд.

@deftypefn Instruction {} make-short-immediate s8:@var{dst} i16:@var{low-bits}
Make an immediate whose low bits are @var{low-bits}, and whose top bits are
0.
@end deftypefn

@deftypefn Instruction {} make-long-immediate s24:@var{dst} i32:@var{low-bits}
Make an immediate whose low bits are @var{low-bits}, and whose top bits are
0.
@end deftypefn

@deftypefn Instruction {} make-long-long-immediate s24:@var{dst} a32:@var{high-bits} b32:@var{low-bits}
Make an immediate with @var{high-bits} and @var{low-bits}.
@end deftypefn

Опосредованные постоянные литералы адресованы прямо или косвенно.
Например, Guile знает во время компиляции, как будет выглядеть
размщение строки, и организует встраивание этого объекта непосредственно
в скомпилированный образ. Ссылка на строку будет использовать вызов
@code{make-non-immediate} для непосредственного обращения с указателем
в скомпилированный блок как @code{SCM} значению.

@deftypefn Instruction {} make-non-immediate s24:@var{dst} n32:@var{offset}
Load a pointer to statically allocated memory into @var{dst}.  The
object's memory is will be found @var{offset} 32-bit words away from the
current instruction pointer.  Whether the object is mutable or immutable
depends on where it was allocated by the compiler, and loaded by the
loader.
@end deftypefn

Некоторые объект должны быть уникальрными во всей системе.
Это относится к символам и ключевым словам. Для этих объектов, Guile
организует инициализацию, когда скомпилированный блок загружается, сохраняя
их в слоты на образе(загруженном). Ссылки идут косвенно, через этот слот.
В этом случае используется @code{static-ref}.

@deftypefn Instruction {} static-ref s24:@var{dst} r32:@var{offset}
Load a @var{scm} value into @var{dst}.  The @var{scm} value will be fetched from
memory, @var{offset} 32-bit words away from the current instruction
pointer.  @var{offset} is a signed value.
@end deftypefn

Поля опосредованные возможно придется исправлять во время загрузки,
поэтому мы не знаем заранее, по какому адресу они будут загружены.
Это имеет место, наприимер для пары содержащей опосредованные данные
в одном из полей. В этих ситуациях используются  @code{static-ref} и
@code{static-patch!}.

@deftypefn Instruction {} static-set! s24:@var{src} lo32:@var{offset}
Store a @var{scm} value into memory, @var{offset} 32-bit words away from the
current instruction pointer.  @var{offset} is a signed value.
@end deftypefn

@deftypefn Instruction {} static-patch! x24:@var{_} lo32:@var{dst-offset} l32:@var{src-offset}
Patch a pointer at @var{dst-offset} to point to @var{src-offset}.  Both offsets
are signed 32-bit values, indicating a memory address as a number
of 32-bit words away from the current instruction pointer.
@end deftypefn

Many kinds of literals can be loaded with the above instructions, once
the compiler has prepared the statically allocated data.  This is the
case for vectors, strings, uniform vectors, pairs, and procedures with
no free variables.  Other kinds of data might need special initializers;
those instructions follow.

@deftypefn Instruction {} string->number s12:@var{dst} s12:@var{src}
Parse a string in @var{src} to a number, and store in @var{dst}.
@end deftypefn

@deftypefn Instruction {} string->symbol s12:@var{dst} s12:@var{src}
Parse a string in @var{src} to a symbol, and store in @var{dst}.
@end deftypefn

@deftypefn Instruction {} symbol->keyword s12:@var{dst} s12:@var{src}
Make a keyword from the symbol in @var{src}, and store it in @var{dst}.
@end deftypefn

@deftypefn Instruction {} load-typed-array s24:@var{dst} x8:@var{_} s24:@var{type} x8:@var{_} s24:@var{shape} n32:@var{offset} u32:@var{len}
Load the contiguous typed array located at @var{offset} 32-bit words away
from the instruction pointer, and store into @var{dst}.  @var{len} is a byte
length.  @var{offset} is signed.
@end deftypefn

@node Dynamic Environment Instructions
@subsubsection Инструкции Динамической Среды(Окружения)

Виртуальная машина Guile имеет низкоуровневую поддержку для @code{dynamic-wind},
динамического связывания и составных подсказок и прерываний.

@deftypefn Instruction {} abort x24:@var{_}
Abort to a prompt handler.  The tag is expected in slot 1, and the rest
of the values in the frame are returned to the prompt handler.  This
corresponds to a tail application of abort-to-prompt.

If no prompt can be found in the dynamic environment with the given tag,
an error is signalled.  Otherwise all arguments are passed to the
prompt's handler, along with the captured continuation, if necessary.

If the prompt's handler can be proven to not reference the captured
continuation, no continuation is allocated.  This decision happens
dynamically, at run-time; the general case is that the continuation may
be captured, and thus resumed.  A reinstated continuation will have its
arguments pushed on the stack from slot 1, as if from a multiple-value
return, and control resumes in the caller.  Thus to the calling
function, a call to @code{abort-to-prompt} looks like any other function
call.
@end deftypefn

@deftypefn Instruction {} prompt s24:@var{tag} b1:@var{escape-only?} x7:@var{_} f24:@var{proc-slot} x8:@var{_} l24:@var{handler-offset}
Push a new prompt on the dynamic stack, with a tag from @var{tag} and a
handler at @var{handler-offset} words from the current @var{ip}.

If an abort is made to this prompt, control will jump to the handler.
The handler will expect a multiple-value return as if from a call with
the procedure at @var{proc-slot}, with the reified partial continuation
as the first argument, followed by the values returned to the handler.
If control returns to the handler, the prompt is already popped off by
the abort mechanism.  (Guile's @code{prompt} implements Felleisen's
@dfn{--F--} operator.)

If @var{escape-only?} is nonzero, the prompt will be marked as
escape-only, which allows an abort to this prompt to avoid reifying the
continuation.

@xref{Prompts}, for more information on prompts.
@end deftypefn

@deftypefn Instruction {} wind s12:@var{winder} s12:@var{unwinder}
Push wind and unwind procedures onto the dynamic stack. Note that
neither are actually called; the compiler should emit calls to wind and
unwind for the normal dynamic-wind control flow.  Also note that the
compiler should have inserted checks that they wind and unwind procs are
thunks, if it could not prove that to be the case.  @xref{Dynamic Wind}.
@end deftypefn

@deftypefn Instruction {} unwind x24:@var{_}
@var{a} normal exit from the dynamic extent of an expression. Pop the top
entry off of the dynamic stack.
@end deftypefn

@deftypefn Instruction {} push-fluid s12:@var{fluid} s12:@var{value}
Dynamically bind @var{value} to @var{fluid} by creating a with-fluids
object and pushing that object on the dynamic stack.  @xref{Fluids and
Dynamic States}.
@end deftypefn

@deftypefn Instruction {} pop-fluid x24:@var{_}
Leave the dynamic extent of a @code{with-fluid*} expression, restoring
the fluid to its previous value.  @code{push-fluid} should always be
balanced with @code{pop-fluid}.
@end deftypefn

@deftypefn Instruction {} fluid-ref s12:@var{dst} s12:@var{src}
Reference the fluid in @var{src}, and place the value in @var{dst}.
@end deftypefn

@deftypefn Instruction {} fluid-set! s12:@var{fluid} s12:@var{val}
Set the value of the fluid in @var{dst} to the value in @var{src}.
@end deftypefn

@deftypefn Instruction {} current-thread s24:@var{dst}
Write the value of the current thread to @var{dst}.
@end deftypefn

@deftypefn Instruction {} push-dynamic-state s24:@var{state}
Save the current set of fluid bindings on the dynamic stack and instate
the bindings from @var{state} instead.  @xref{Fluids and Dynamic
States}.
@end deftypefn

@deftypefn Instruction {} pop-dynamic-state x24:@var{_}
Restore a saved set of fluid bindings from the dynamic stack.
@code{push-dynamic-state} should always be balanced with
@code{pop-dynamic-state}.
@end deftypefn

@node Miscellaneous Instructions
@subsubsection Разные Инструкции

@deftypefn Instruction {} halt x24:@var{_}
Bring the VM to a halt, returning all the values from the stack.  Used
in the ``boot continuation'', which is used when entering the VM from C.
@end deftypefn

@deftypefn Instruction {} push s24:@var{src}
Bump the stack pointer by one word, and fill it with the value from slot
@var{src}.  The offset to @var{src} is calculated before the stack
pointer is adjusted.
@end deftypefn

The @code{push} instruction is used when another instruction is unable
to address an operand because the operand is encoded with fewer than 24
bits.  In that case, Guile's assembler will transparently emit code that
temporarily pushes any needed operands onto the stack, emits the
original instruction to address those now-near variables, then shuffles
the result (if any) back into place.

@deftypefn Instruction {} pop s24:@var{dst}
Pop the stack pointer, storing the value that was there in slot
@var{dst}.  The offset to @var{dst} is calculated after the stack
pointer is adjusted.
@end deftypefn

@deftypefn Instruction {} drop c24:@var{count}
Pop the stack pointer by @var{count} words, discarding any values that
were stored there.
@end deftypefn

@deftypefn Instruction {} handle-interrupts x24:@var{_}
Handle pending asynchronous interrupts (asyncs).  @xref{Asyncs}.  The
compiler inserts @code{handle-interrupts} instructions before any call,
return, or loop back-edge.
@end deftypefn

@deftypefn Instruction {} return-from-interrupt x24:@var{_}
A special instruction to return from a call and also pop off the stack
frame from the call.  Used when returning from asynchronous interrupts.
@end deftypefn

@node Inlined Scheme Instructions
@subsubsection Встроенные Инструкции Scheme

Компилятор Scheme может распознать применение стандартных Scheme
процедур. Он пытается, встроить эти небольшие операции, чтобы избежать
накладных раходов на создание новых кадров стека. Это позволяет
компилятору лучше оптимизировать код.

@deftypefn Instruction {} make-vector s8:@var{dst} s8:@var{length} s8:@var{init}
Make a vector and write it to @var{dst}.  The vector will have space for
@var{length} slots.  They will be filled with the value in slot
@var{init}.
@end deftypefn

@deftypefn Instruction {} make-vector/immediate s8:@var{dst} s8:@var{length} c8:@var{init}
Make a short vector of known size and write it to @var{dst}.  The vector
will have space for @var{length} slots, an immediate value.  They will
be filled with the value in slot @var{init}.
@end deftypefn

@deftypefn Instruction {} vector-length s12:@var{dst} s12:@var{src}
Store the length of the vector in @var{src} in @var{dst}, as an unboxed
unsigned 64-bit integer.
@end deftypefn

@deftypefn Instruction {} vector-ref s8:@var{dst} s8:@var{src} s8:@var{idx}
Fetch the item at position @var{idx} in the vector in @var{src}, and
store it in @var{dst}.  The @var{idx} value should be an unboxed
unsigned 64-bit integer.
@end deftypefn

@deftypefn Instruction {} vector-ref/immediate s8:@var{dst} s8:@var{src} c8:@var{idx}
Fill @var{dst} with the item @var{idx} elements into the vector at
@var{src}.  Useful for building data types using vectors.
@end deftypefn

@deftypefn Instruction {} vector-set! s8:@var{dst} s8:@var{idx} s8:@var{src}
Store @var{src} into the vector @var{dst} at index @var{idx}.  The
@var{idx} value should be an unboxed unsigned 64-bit integer.
@end deftypefn

@deftypefn Instruction {} vector-set!/immediate s8:@var{dst} c8:@var{idx} s8:@var{src}
Store @var{src} into the vector @var{dst} at index @var{idx}.  Here
@var{idx} is an immediate value.
@end deftypefn

@deftypefn Instruction {} struct-vtable s12:@var{dst} s12:@var{src}
Store the vtable of @var{src} into @var{dst}.
@end deftypefn

@deftypefn Instruction {} allocate-struct s8:@var{dst} s8:@var{vtable} s8:@var{nfields}
Allocate a new struct with @var{vtable}, and place it in @var{dst}.  The
struct will be constructed with space for @var{nfields} fields, which
should correspond to the field count of the @var{vtable}.  The @var{idx}
value should be an unboxed unsigned 64-bit integer.
@end deftypefn

@deftypefn Instruction {} struct-ref s8:@var{dst} s8:@var{src} s8:@var{idx}
Fetch the item at slot @var{idx} in the struct in @var{src}, and store
it in @var{dst}.  The @var{idx} value should be an unboxed unsigned
64-bit integer.
@end deftypefn

@deftypefn Instruction {} struct-set! s8:@var{dst} s8:@var{idx} s8:@var{src}
Store @var{src} into the struct @var{dst} at slot @var{idx}.  The
@var{idx} value should be an unboxed unsigned 64-bit integer.
@end deftypefn

@deftypefn Instruction {} allocate-struct/immediate s8:@var{dst} s8:@var{vtable} c8:@var{nfields}
@deftypefnx Instruction {} struct-ref/immediate s8:@var{dst} s8:@var{src} c8:@var{idx}
@deftypefnx Instruction {} struct-set!/immediate s8:@var{dst} c8:@var{idx} s8:@var{src}
Variants of the struct instructions, but in which the @var{nfields} or
@var{idx} fields are immediate values.
@end deftypefn

@deftypefn Instruction {} class-of s12:@var{dst} s12:@var{type}
Store the vtable of @var{src} into @var{dst}.
@end deftypefn

@deftypefn Instruction {} make-array s24:@var{dst} x8:@var{_} s24:@var{type} x8:@var{_} s24:@var{fill} x8:@var{_} s24:@var{bounds}
Make a new array with @var{type}, @var{fill}, and @var{bounds}, storing it in @var{dst}.
@end deftypefn

@deftypefn Instruction {} string-length s12:@var{dst} s12:@var{src}
Store the length of the string in @var{src} in @var{dst}, as an unboxed
unsigned 64-bit integer.
@end deftypefn

@deftypefn Instruction {} string-ref s8:@var{dst} s8:@var{src} s8:@var{idx}
Fetch the character at position @var{idx} in the string in @var{src},
and store it in @var{dst}.  The @var{idx} value should be an unboxed
unsigned 64-bit integer.
@end deftypefn

@deftypefn Instruction {} string-set! s8:@var{dst} s8:@var{idx} s8:@var{src}
Store the character @var{src} into the string @var{dst} at index
@var{idx}.  The @var{idx} value should be an unboxed unsigned 64-bit
integer.
@end deftypefn

@deftypefn Instruction {} cons s8:@var{dst} s8:@var{car} s8:@var{cdr}
Cons @var{car} and @var{cdr}, and store the result in @var{dst}.
@end deftypefn

@deftypefn Instruction {} car s12:@var{dst} s12:@var{src}
Place the car of @var{src} in @var{dst}.
@end deftypefn

@deftypefn Instruction {} cdr s12:@var{dst} s12:@var{src}
Place the cdr of @var{src} in @var{dst}.
@end deftypefn

@deftypefn Instruction {} set-car! s12:@var{pair} s12:@var{car}
Set the car of @var{dst} to @var{src}.
@end deftypefn

@deftypefn Instruction {} set-cdr! s12:@var{pair} s12:@var{cdr}
Set the cdr of @var{dst} to @var{src}.
@end deftypefn

Note that @code{caddr} and friends compile to a series of @code{car}
and @code{cdr} instructions.

@deftypefn Instruction {} integer->char s12:@var{dst} s12:@var{src}
Convert the @code{u64} value in @var{src} to a Scheme character, and
place it in @var{dst}.
@end deftypefn

@deftypefn Instruction {} char->integer s12:@var{dst} s12:@var{src}
Convert the Scheme character in @var{src} to an integer, and place it in
@var{dst} as an unboxed @code{u64} value.
@end deftypefn

@node Inlined Atomic Instructions
@subsubsection Встроенные Атомарные Инструкции

@xref{Atomics}, для получения дополнительрной информации об атомарных
операциях в Guile.

@deftypefn Instruction {} make-atomic-box s12:@var{dst} s12:@var{src}
Create a new atomic box initialized to @var{src}, and place it in
@var{dst}.
@end deftypefn

@deftypefn Instruction {} atomic-box-ref s12:@var{dst} s12:@var{box}
Fetch the value of the atomic box at @var{box} into @var{dst}.
@end deftypefn

@deftypefn Instruction {} atomic-box-set! s12:@var{box} s12:@var{val}
Set the contents of the atomic box at @var{box} to @var{val}.
@end deftypefn

@deftypefn Instruction {} atomic-box-swap! s12:@var{dst} s12:@var{box} x8:@var{_} s24:@var{val}
Replace the contents of the atomic box at @var{box} to @var{val} and
store the previous value at @var{dst}.
@end deftypefn

@deftypefn Instruction {} atomic-box-compare-and-swap! s12:@var{dst} s12:@var{box} x8:@var{_} s24:@var{expected} x8:@var{_} s24:@var{desired}
If the value of the atomic box at @var{box} is the same as the SCM value
at @var{expected} (in the sense of @code{eq?}), replace the contents of
the box with the SCM value at @var{desired}.  Otherwise does not update
the box.  Set @var{dst} to the previous value of the box in either case.
@end deftypefn

@node Inlined Mathematical Instructions
@subsubsection Инструкции Встроенной Математики

Встраивание математических операций имеет очевидное преимущесвтво при 
работе с фиксированными числами без вызова фукнций или размещений.
Трюк конечно, когда знаете что результат операции будет fixnum, и здесь
может быть пара ошибок.

More instructions could be added here over time.

All of these operations place their result in their first operand,
@var{dst}.

@deftypefn Instruction {} add s8:@var{dst} s8:@var{a} s8:@var{b}
Add @var{a} to @var{b}.
@end deftypefn

@deftypefn Instruction {} add/immediate s8:@var{dst} s8:@var{src} c8:@var{imm}
Add the unsigned integer @var{imm} to the value in @var{src}.
@end deftypefn

@deftypefn Instruction {} sub s8:@var{dst} s8:@var{a} s8:@var{b}
Subtract @var{b} from @var{a}.
@end deftypefn

@deftypefn Instruction {} sub/immediate s8:@var{dst} s8:@var{src} s8:@var{imm}
Subtract the unsigned integer @var{imm} from the value in @var{src}.
@end deftypefn

@deftypefn Instruction {} mul s8:@var{dst} s8:@var{a} s8:@var{b}
Multiply @var{a} and @var{b}.
@end deftypefn

@deftypefn Instruction {} div s8:@var{dst} s8:@var{a} s8:@var{b}
Divide @var{a} by @var{b}.
@end deftypefn

@deftypefn Instruction {} quo s8:@var{dst} s8:@var{a} s8:@var{b}
Divide @var{a} by @var{b}.
@end deftypefn

@deftypefn Instruction {} rem s8:@var{dst} s8:@var{a} s8:@var{b}
Divide @var{a} by @var{b}.
@end deftypefn

@deftypefn Instruction {} mod s8:@var{dst} s8:@var{a} s8:@var{b}
Compute the modulo of @var{a} by @var{b}.
@end deftypefn

@deftypefn Instruction {} ash s8:@var{dst} s8:@var{a} s8:@var{b}
Shift @var{a} arithmetically by @var{b} bits.
@end deftypefn

@deftypefn Instruction {} logand s8:@var{dst} s8:@var{a} s8:@var{b}
Compute the bitwise @code{and} of @var{a} and @var{b}.
@end deftypefn

@deftypefn Instruction {} logior s8:@var{dst} s8:@var{a} s8:@var{b}
Compute the bitwise inclusive @code{or} of @var{a} with @var{b}.
@end deftypefn

@deftypefn Instruction {} logxor s8:@var{dst} s8:@var{a} s8:@var{b}
Compute the bitwise exclusive @code{or} of @var{a} with @var{b}.
@end deftypefn

@deftypefn Instruction {} logsub s8:@var{dst} s8:@var{a} s8:@var{b}
Place the bitwise @code{and} of @var{a} and the bitwise @code{not} of
@var{b} into @var{dst}.
@end deftypefn

@node Inlined Bytevector Instructions
@subsubsection Инструкции Встроенных Байтовых Векторов

Операторы байтовых векторов точно соответствуют тому, что может сделать
текущее оборудование, поэтому они сделаны что быть встроенными в инструкции
ВМ, обеспечивая четкий путь для возможной нативной компиляции.
Без этого программам Scheme понадобятся другие примитивы для доступа
к сырым(необработанным) данным - но эти примитивы так же хороши как и другие.

@deftypefn Instruction {} bv-length s12:@var{dst} s12:@var{src}
Store the length of the bytevector in @var{src} in @var{dst}, as an
unboxed unsigned 64-bit integer.
@end deftypefn

@deftypefn Instruction {} bv-u8-ref s8:@var{dst} s8:@var{src} s8:@var{idx}
@deftypefnx Instruction {} bv-s8-ref s8:@var{dst} s8:@var{src} s8:@var{idx}
@deftypefnx Instruction {} bv-u16-ref s8:@var{dst} s8:@var{src} s8:@var{idx}
@deftypefnx Instruction {} bv-s16-ref s8:@var{dst} s8:@var{src} s8:@var{idx}
@deftypefnx Instruction {} bv-u32-ref s8:@var{dst} s8:@var{src} s8:@var{idx}
@deftypefnx Instruction {} bv-s32-ref s8:@var{dst} s8:@var{src} s8:@var{idx}
@deftypefnx Instruction {} bv-u64-ref s8:@var{dst} s8:@var{src} s8:@var{idx}
@deftypefnx Instruction {} bv-s64-ref s8:@var{dst} s8:@var{src} s8:@var{idx}
@deftypefnx Instruction {} bv-f32-ref s8:@var{dst} s8:@var{src} s8:@var{idx}
@deftypefnx Instruction {} bv-f64-ref s8:@var{dst} s8:@var{src} s8:@var{idx}

Fetch the item at byte offset @var{idx} in the bytevector @var{src}, and
store it in @var{dst}.  All accesses use native endianness.

The @var{idx} value should be an unboxed unsigned 64-bit integer.

The results are all written to the stack as unboxed values, either as
signed 64-bit integers, unsigned 64-bit integers, or IEEE double
floating point numbers.
@end deftypefn

@deftypefn Instruction {} bv-u8-set! s8:@var{dst} s8:@var{idx} s8:@var{src}
@deftypefnx Instruction {} bv-s8-set! s8:@var{dst} s8:@var{idx} s8:@var{src}
@deftypefnx Instruction {} bv-u16-set! s8:@var{dst} s8:@var{idx} s8:@var{src}
@deftypefnx Instruction {} bv-s16-set! s8:@var{dst} s8:@var{idx} s8:@var{src}
@deftypefnx Instruction {} bv-u32-set! s8:@var{dst} s8:@var{idx} s8:@var{src}
@deftypefnx Instruction {} bv-s32-set! s8:@var{dst} s8:@var{idx} s8:@var{src}
@deftypefnx Instruction {} bv-u64-set! s8:@var{dst} s8:@var{idx} s8:@var{src}
@deftypefnx Instruction {} bv-s64-set! s8:@var{dst} s8:@var{idx} s8:@var{src}
@deftypefnx Instruction {} bv-f32-set! s8:@var{dst} s8:@var{idx} s8:@var{src}
@deftypefnx Instruction {} bv-f64-set! s8:@var{dst} s8:@var{idx} s8:@var{src}

Store @var{src} into the bytevector @var{dst} at byte offset @var{idx}.
Multibyte values are written using native endianness.

The @var{idx} value should be an unboxed unsigned 64-bit integer.

The @var{src} values are all unboxed, either as signed 64-bit integers,
unsigned 64-bit integers, or IEEE double floating point numbers.
@end deftypefn

@node Unboxed Integer Arithmetic
@subsubsection Арифметика Распакованных Целых Чисел

Guile поддерживает два типа распакованных целых чисел: беззнаковое
64-битное целое, и со знаковом  64-битное целое. Guile предпочитает
целые числа без знака, в том смысле. что компилятор Guile поддерживает
их лучше, а на виртуальной машине больше операций,которые с ними 
работают. Тем не менее, целые числа со знаком поддерживаются, по
крайней мере, для того, чтобы позволить @code{bv-s64-ref} и 
соответствующим инструкциям избегать упаковки значений.

@deftypefn Instruction {} scm->u64 s12:@var{dst} s12:@var{src}
Распаковка значения SCM из  @var{src} в беззнаковое 64-битное целое,
и поместить результат в @var{dst}.  Если значение  @var{src} не
является точным целым числом в 64-битном диапазоне, сигнализировать
об ошибке.
@end deftypefn

@deftypefn Instruction {} u64->scm s12:@var{dst} s12:@var{src}
Упаковать беззнаковое целое 64-битное число из  @var{src} в заначение
SCM и разметсит результат в @var{dst}.  Результат может быть
fixnum или bignum.
@end deftypefn

@deftypefn Instruction {} load-u64 s24:@var{dst} au32:@var{high-bits} au32:@var{low-bits}
Загрузить 64-битрное значение сформированное объединением  @var{high-bits} и
@var{low-bits}, и записать результат в @var{dst}.
@end deftypefn

@deftypefn Instruction {} scm->s64 s12:@var{dst} s12:@var{src}
@deftypefnx Instruction {} s64->scm s12:@var{dst} s12:@var{src}
@deftypefnx Instruction {} load-s64 s24:@var{dst} as32:@var{high-bits} as32:@var{low-bits}
Как и @code{scm->u64}, @code{u64->scm}, и @code{load-u64}, но для 64 битных целых чисел 
со знаком.
@end deftypefn

Иногда компилятор может знать, что нам понадобиться токль подмножество
бит в целом числе. В этом случае мы можем иногда распаковывать целое
число, даже если оно может быть вне диапазона.

@deftypefn Instruction {} scm->u64/truncate s12:@var{dst} s12:@var{src}
Взять заначение SCM в @var{dst} и @code{logand} с помощью @code{(1- (ash
1 64))}.  Поместить распакованный результат в @var{dst}.
@end deftypefn

@deftypefn Instruction {} br-if-u64-= s24:@var{a} x8:@var{_} s24:@var{b} b1:@var{invert} x7:@var{_} l24:@var{offset}
@deftypefnx Instruction {} br-if-u64-< s24:@var{a} x8:@var{_} s24:@var{b} b1:@var{invert} x7:@var{_} l24:@var{offset}
@deftypefnx Instruction {} br-if-u64-<= s24:@var{a} x8:@var{_} s24:@var{b} b1:@var{invert} x7:@var{_} l24:@var{offset}
Если для распакованного целого 64 битное численного значения из @var{a} выполненоs @code{=},
@code{<}, or @code{<=} по отношению к целому 64 битному числовому значению из @var{b}, 
сответственно, добавить смещение @var{offset} к ip(текущему значению указателя программ)
@end deftypefn

@deftypefn Instruction {} br-if-u64-=-scm s24:@var{a} x8:@var{_} s24:@var{b} b1:@var{invert} x7:@var{_} l24:@var{offset}
@deftypefnx Instruction {} br-if-u64-<-scm s24:@var{a} x8:@var{_} s24:@var{b} b1:@var{invert} x7:@var{_} l24:@var{offset}
@deftypefnx Instruction {} br-if-u64-<=-scm s24:@var{a} x8:@var{_} s24:@var{b} b1:@var{invert} x7:@var{_} l24:@var{offset}
Если для распакованного беззнакового целого 64-битного значения из @var{a} выполнено @code{=},
@code{<}, или @code{<=} по отношению к значению SCM из @var{b}, соответственно, добавить
смещение @var{offset} к ip(текущему значению указателя программы).
@end deftypefn

@deftypefn Instruction {} uadd s8:@var{dst} s8:@var{a} s8:@var{b}
@deftypefnx Instruction {} usub s8:@var{dst} s8:@var{a} s8:@var{b}
@deftypefnx Instruction {} umul s8:@var{dst} s8:@var{a} s8:@var{b}
Подобно @code{add}, @code{sub}, и @code{mul}, за искючением операндов
в качестве распакованных беззнаковых 64-битных целых, и получают
такой же результат. Результат будет молча обрезан до 64 бит.
@end deftypefn

@deftypefn Instruction {} uadd/immediate s8:@var{dst} s8:@var{a} c8:@var{b}
@deftypefnx Instruction {} usub/immediate s8:@var{dst} s8:@var{a} c8:@var{b}
@deftypefnx Instruction {} umul/immediate s8:@var{dst} s8:@var{a} c8:@var{b}
Подобно @code{uadd}, @code{usub}, и @code{umul}, за исключением
второго операнда, это непосредственное 8-битное целое число.
@end deftypefn

@deftypefn Instruction {} ulogand s8:@var{dst} s8:@var{a} s8:@var{b}
@deftypefnx Instruction {} ulogior s8:@var{dst} s8:@var{a} s8:@var{b}
@deftypefnx Instruction {} ulogxor s8:@var{dst} s8:@var{a} s8:@var{b}
@deftypefnx Instruction {} ulogsub s8:@var{dst} s8:@var{a} s8:@var{b}
Подобно @code{logand}, @code{logior}, @code{logxor}, и @code{logsub}, но
работает с распакованным беззнаковым 64-битным целым числом.
@end deftypefn

@deftypefn Instruction {} ulsh s8:@var{dst} s8:@var{a} s8:@var{b}
Сдвиг беззнакового 64битного целого числа из @var{a} влево на @var{b}
бит, результат также беззнаковое 64 битное целое. Обрезается до 64 бит
и записывается в  @var{dst} как распакованное значение.  Только нижние
6 бит из @var{b} используются.
@end deftypefn

@deftypefn Instruction {} ursh s8:@var{dst} s8:@var{a} s8:@var{b}
Тоже что и @code{ulsh}, но сдвиг вправо.
@end deftypefn

@deftypefn Instruction {} ulsh/immediate s8:@var{dst} s8:@var{a} c8:@var{b}
@deftypefnx Instruction {} ursh/immediate s8:@var{dst} s8:@var{a} c8:@var{b}
Тоже что и @code{ulsh} и @code{ursh}, но @code{b} рассматривается как 
непосредственное 8-битное беззнаковое целое.
@end deftypefn

@node Unboxed Floating-Point Arithmetic
@subsubsection Арифметика Распакованных чисел с плавающей точкой

@deftypefn Instruction {} scm->f64 s12:@var{dst} s12:@var{src}
Распаковать значение SCM в  @var{src} в формат IEEE двойной точности, 
разместив результат в  @var{dst}.  Если значение @var{src} не является
вещественным числом, выдать сигнал ошибки.
@end deftypefn

@deftypefn Instruction {} f64->scm s12:@var{dst} s12:@var{src}
Упокавать двойное IEEE из @var{src} в значение SCM и разместить результат
в @var{dst}.
@end deftypefn

@deftypefn Instruction {} load-f64 s24:@var{dst} au32:@var{high-bits} au32:@var{low-bits}
Загрузить 64-битное значение, сформированное путем объединения старших бит(@var{high-bits})
и младших бит(@var{low-bits}) и записать результат в @var{dst}.
@end deftypefn

@deftypefn Instruction {} fadd s8:@var{dst} s8:@var{a} s8:@var{b}
@deftypefnx Instruction {} fsub s8:@var{dst} s8:@var{a} s8:@var{b}
@deftypefnx Instruction {} fmul s8:@var{dst} s8:@var{a} s8:@var{b}
@deftypefnx Instruction {} fdiv s8:@var{dst} s8:@var{a} s8:@var{b}
Подобно @code{add}, @code{sub}, @code{div}, и @code{mul}, за исключением того,
что операнды являются распакованными двойными числами с плавающей точкой формата
IEEE и получают подобное число.
@end deftypefn

@deftypefn Instruction {} br-if-f64-= s24:@var{a} x8:@var{_} s24:@var{b} b1:@var{invert} x7:@var{_} l24:@var{offset}
@deftypefnx Instruction {} br-if-f64-< s24:@var{a} x8:@var{_} s24:@var{b} b1:@var{invert} x7:@var{_} l24:@var{offset}
@deftypefnx Instruction {} br-if-f64-<= s24:@var{a} x8:@var{_} s24:@var{b} b1:@var{invert} x7:@var{_} l24:@var{offset}
@deftypefnx Instruction {} br-if-f64-> s24:@var{a} x8:@var{_} s24:@var{b} b1:@var{invert} x7:@var{_} l24:@var{offset}
@deftypefnx Instruction {} br-if-f64->= s24:@var{a} x8:@var{_} s24:@var{b} b1:@var{invert} x7:@var{_} l24:@var{offset}
Если для значения распакованного двойного в формате IEEE в  @var{a} выполнено @code{=}, @code{<},
@code{<=}, @code{>}, or @code{>=} по отношению к значению распакованного двойного в формате IEEE
из @var{b}, ТО соотвественно , добавить смещение @var{offset} к текущей ip (указателю выплняемой
инструкции)
pointer.
@end deftypefn