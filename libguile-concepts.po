#
# Gagin <mikhail-gagin@yandex.ru>, 2018.
#
#. extracted from /home/bear/work/guile/doc/guile/en/libguile-concepts.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-07 12:37+0300\n"
"PO-Revision-Date: 2018-07-05 13:25+0300\n"
"Last-Translator: Gagin <mikhail-gagin@yandex.ru>\n"
"Language-Team: Russian <mikhail-gagin@yandex.ru>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C)  1996-1997, 2000-2005, 2010-2011, 2013-2016\n"
"@c   Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:9
msgid ""
"@node General Libguile Concepts\n"
"@section General concepts for using libguile"
msgstr ""
"@node General Libguile Concepts\n"
"@section Общие понятия для использования libguile"

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:16
msgid ""
"When you want to embed the Guile Scheme interpreter into your program or\n"
"library, you need to link it against the @file{libguile} library\n"
"(@pxref{Linking Programs With Guile}).  Once you have done this, your C\n"
"code has access to a number of data types and functions that can be used\n"
"to invoke the interpreter, or make new functions that you have written\n"
"in C available to be called from Scheme code, among other things."
msgstr ""
"Когда вы хотите встроить интерпретатор Guile Scheme в свою программу или\n"
"библиотеку, вам необходимо связать их с библиотекой @file{libguile} \n"
"(@pxref{Linking Programs With Guile}).  После того, как вы это сделали,\n"
"ваш код Си получает доступ к нескольким типам данных и функциям, которые\n"
"могут использоваться для вызова интерпретатора или создания новых функций,\n"
"которые вы хотите написать на Си и сделать их доступными для вызова из\n"
"кода Scheme, среди прочего."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:22
msgid ""
"Scheme is different from C in a number of significant ways, and Guile\n"
"tries to make the advantages of Scheme available to C as well.  Thus, in\n"
"addition to a Scheme interpreter, libguile also offers dynamic types,\n"
"garbage collection, continuations, arithmetic on arbitrary sized\n"
"numbers, and other things."
msgstr ""
"Scheme отличаетс от Си несколькими существенными моментами, и Guile\n"
"пытается сделать преимущества Scheme доступными для Си. Таким образом,\n"
"в дополнение к интерпретатору Scheme, libguile ткже предоставляет "
"динамические\n"
"типы, сборщика мусора, продолжения, арифметику с числами произвольной длины "
"и\n"
"другие вещи."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:27
msgid ""
"The two fundamental concepts are dynamic types and garbage collection.\n"
"You need to understand how libguile offers them to C programs in order\n"
"to use the rest of libguile.  Also, the more general control flow of\n"
"Scheme caused by continuations needs to be dealt with."
msgstr ""
"Двумя основными понятиями являются динамические типы и сборка мусора.\n"
"Вам необходимо понять, как libguile предлагает их программам Си, чтобы\n"
"использовать остальную часть libguile.  Также, должен быть рассмотрен\n"
"общий поток управления Scheme вызыванный продолжениями."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:31
msgid ""
"Running asynchronous signal handlers and multi-threading is known to C\n"
"code already, but there are of course a few additional rules when using\n"
"them together with libguile."
msgstr ""
"Запуск асинхронных обработчиков сигналов и многопоточность известны Си\n"
"коду, но есть несколько дополнительных правил при их использовании\n"
"совместно с libguile."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:39
msgid ""
"@menu\n"
"* Dynamic Types::               Dynamic Types.\n"
"* Garbage Collection::          Garbage Collection.\n"
"* Control Flow::                Control Flow.\n"
"* Asynchronous Signals::        Asynchronous Signals\n"
"* Multi-Threading::             Multi-Threading\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:42
msgid ""
"@node Dynamic Types\n"
"@subsection Dynamic Types"
msgstr ""
"@node Dynamic Types\n"
"@subsection Динамические типы"

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:49
msgid ""
"Scheme is a dynamically-typed language; this means that the system\n"
"cannot, in general, determine the type of a given expression at compile\n"
"time.  Types only become apparent at run time.  Variables do not have\n"
"fixed types; a variable may hold a pair at one point, an integer at the\n"
"next, and a thousand-element vector later.  Instead, values, not\n"
"variables, have fixed types."
msgstr ""
"Scheme --- динамически типизированный язык, это означает. что система\n"
"вообще не может определить тип данного выражения во время компиляции.\n"
"Типы становятся известными только во время выполнения. Переменные\n"
"не имеют фиксированных типов; переменная может содержать пару в один момент\n"
"времени; целое число в следующий и тысячный элемент позже. Вместо этого\n"
"значения имеют фиксированные типы, а не переменные."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:56
msgid ""
"In order to implement standard Scheme functions like @code{pair?} and\n"
"@code{string?} and provide garbage collection, the representation of\n"
"every value must contain enough information to accurately determine its\n"
"type at run time.  Often, Scheme systems also use this information to\n"
"determine whether a program has attempted to apply an operation to an\n"
"inappropriately typed value (such as taking the @code{car} of a string)."
msgstr ""
"В порядке реализации стандартных функций Scheme, таких как @code{pair?} и\n"
"@code{string?} и обеспечения сборки мусора, представление каждого значения\n"
"должно содержать достаточно информации для точного определения его типа во\n"
"время выполнения. Часто системы Scheme также используют эту информацию\n"
"для определения, пыталась ли программа применить операцию к неуместному\n"
"типу значения (например, получения первого элемента @code{car} от "
"строки(string))."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:61
msgid ""
"Because variables, pairs, and vectors may hold values of any type,\n"
"Scheme implementations use a uniform representation for values --- a\n"
"single type large enough to hold either a complete value or a pointer\n"
"to a complete value, along with the necessary typing information."
msgstr ""
"Поскольку переменные, пары и вектора могут содержать значения любого\n"
"типа, реализации Scheme используют единое представление для значений\n"
"--- один тип, достаточно большой. чтобы удерживать либо полное значение,\n"
"либо указатель на полное значение, а также необходимую информацию для\n"
"информации о типе."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:67
msgid ""
"In Guile, this uniform representation of all Scheme values is the C type\n"
"@code{SCM}.  This is an opaque type and its size is typically equivalent\n"
"to that of a pointer to @code{void}.  Thus, @code{SCM} values can be\n"
"passed around efficiently and they take up reasonably little storage on\n"
"their own."
msgstr ""
"В Guile, данное единое представление всех значений Scheme является\n"
"Си типом @code{SCM}.  Это непрозрачный тип и его размеры обычно "
"эквивалентны\n"
"указателю на @code{void}.  Таким образом, значения @code{SCM} могут "
"эффективно\n"
"передаваться, и они занимают мало достаточно мало места."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:70
msgid ""
"The most important rule is: You never access a @code{SCM} value\n"
"directly; you only pass it to functions or macros defined in libguile."
msgstr ""
"Самое важное правило: Вы никогда не получаеете доступ к значению \n"
"@code{SCM} напрямую; Вы передаете его только функции и ли макросу\n"
"определенным в libguile."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:75
msgid ""
"As an obvious example, although a @code{SCM} variable can contain\n"
"integers, you can of course not compute the sum of two @code{SCM} values\n"
"by adding them with the C @code{+} operator.  You must use the libguile\n"
"function @code{scm_sum}."
msgstr ""
"В качестве очевидного примера, хотя переменная @code{SCM} может содержать\n"
"целые числа, вы конечно не можете сложить их используя Си оператор "
"@code{+}.\n"
"Вы должны использовать функцию libguile @code{scm_sum}."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:83
msgid ""
"Less obvious and therefore more important to keep in mind is that you\n"
"also cannot directly test @code{SCM} values for trueness.  In Scheme,\n"
"the value @code{#f} is considered false and of course a @code{SCM}\n"
"variable can represent that value.  But there is no guarantee that the\n"
"@code{SCM} representation of @code{#f} looks false to C code as well.\n"
"You need to use @code{scm_is_true} or @code{scm_is_false} to test a\n"
"@code{SCM} value for trueness or falseness, respectively."
msgstr ""
"Менее очевидно и поэтому важно помнить, что вы также не можете \n"
"непосредственно проверять значения @code{SCM} на истинность.  В Scheme,\n"
"значение @code{#f} считается ложным и конечно, переменная @code{SCM}\n"
"может представлять это значения. Но нет никакой гарантии, что @code{SCM}\n"
"представление @code{#f} выглядит ложным и для Си кода. Вам нужно\n"
"использовать @code{scm_is_true} или @code{scm_is_false} для проверки\n"
"значения @code{SCM} на истинность или ложность, соответственно."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:87
msgid ""
"You also can not directly compare two @code{SCM} values to find out\n"
"whether they are identical (that is, whether they are @code{eq?} in\n"
"Scheme terms).  You need to use @code{scm_is_eq} for this."
msgstr ""
"Вы также не можете на прямую сравнить два значения @code{SCM}, чтобы\n"
"выяснить являются ли они идентичными (т.е. являются ли они\n"
"эквивалентными(@code{eq?}) в терминах Scheme).  Вам необходимо \n"
"использовать для этого @code{scm_is_eq}."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:90
msgid ""
"The one exception is that you can directly assign a @code{SCM} value to\n"
"a @code{SCM} variable by using the C @code{=} operator."
msgstr ""
"Единственное исключение состоит в том, что вы можете напрямую назначить\n"
"значение @code{SCM} переменной @code{SCM} используя Си оператор @code{=}."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:95
msgid ""
"The following (contrived) example shows how to do it right.  It\n"
"implements a function of two arguments (@var{a} and @var{flag}) that\n"
"returns @var{a}+1 if @var{flag} is true, else it returns @var{a}\n"
"unchanged."
msgstr ""
"Следующий (надуманный) пример показывает, как сделать это правильно.\n"
"Он реализует функцию двух аргументов (@var{a} и @var{flag}) которая\n"
"возвращает @var{a}+1 если @var{flag} является истиной, иначе она вернет\n"
"неизменненное @var{a}."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:101
msgid ""
"@example\n"
"SCM\n"
"my_incrementing_function (SCM a, SCM flag)\n"
"@{\n"
"  SCM result;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:106
msgid ""
"  if (scm_is_true (flag))\n"
"    result = scm_sum (a, scm_from_int (1));\n"
"  else\n"
"    result = a;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:110
msgid ""
"  return result;\n"
"@}\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:116
msgid ""
"Often, you need to convert between @code{SCM} values and appropriate C\n"
"values.  For example, we needed to convert the integer @code{1} to its\n"
"@code{SCM} representation in order to add it to @var{a}.  Libguile\n"
"provides many function to do these conversions, both from C to\n"
"@code{SCM} and from @code{SCM} to C."
msgstr ""
"Часто вам нужно преобразовать значения @code{SCM} в соответствующие\n"
"значения Си и наоборот. Например, нам нужно преобразовать целое @code{1}\n"
"в представление @code{SCM} чтобы добавить его в @var{a}.  Libguile\n"
"предоставляет множество функций для этих преобразований, как из Си в \n"
"@code{SCM}, таки из @code{SCM} в Си."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:121
msgid ""
"The conversion functions follow a common naming pattern: those that make\n"
"a @code{SCM} value from a C value have names of the form\n"
"@code{scm_from_@var{type} (@dots{})} and those that convert a @code{SCM}\n"
"value to a C value use the form @code{scm_to_@var{type} (@dots{})}."
msgstr ""
"Функции преобразования следуют общей схеме именования: те, которые создают\n"
"значение @code{SCM} из значения Си имеют имена в форме "
"@code{scm_from_@var{type} (@dots{})} \n"
"и те которые конвертируют из занчений @code{SCM} в значения Си используют "
"форму \n"
"@code{scm_to_@var{type} (@dots{})}."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:127
msgid ""
"However, it is best to avoid converting values when you can.  When you\n"
"must combine C values and @code{SCM} values in a computation, it is\n"
"often better to convert the C values to @code{SCM} values and do the\n"
"computation by using libguile functions than to the other way around\n"
"(converting @code{SCM} to C and doing the computation some other way)."
msgstr ""
"Однако лучше избегать преобразования значений, когда можете. Когда вы\n"
"должны объединить Си и @code{SCM} значения в вычислении, часто лучше\n"
"преобразовать Си значения в @code{SCM} значения и выполнить вычисления\n"
"с использованием функций libguile, а не наоборот (преобразовывать "
"@code{SCM}\n"
"в Си и выполнять вычисления другим способом)."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:130
msgid ""
"As a simple example, consider this version of\n"
"@code{my_incrementing_function} from above:"
msgstr ""
"В качестве простого примера рассмотрим эту версию\n"
"@code{my_incrementing_function}:"

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:136
msgid ""
"@example\n"
"SCM\n"
"my_other_incrementing_function (SCM a, SCM flag)\n"
"@{\n"
"  int result;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:141
msgid ""
"  if (scm_is_true (flag))\n"
"    result = scm_to_int (a) + 1;\n"
"  else\n"
"    result = scm_to_int (a);"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:145
msgid ""
"  return scm_from_int (result);\n"
"@}\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:152
msgid ""
"This version is much less general than the original one: it will only\n"
"work for values @var{A} that can fit into a @code{int}.  The original\n"
"function will work for all values that Guile can represent and that\n"
"@code{scm_sum} can understand, including integers bigger than @code{long\n"
"long}, floating point numbers, complex numbers, and new numerical types\n"
"that have been added to Guile by third-party libraries."
msgstr ""
"Эта версия гораздо менее общая, чем оригинальная: она будет работать\n"
"только для значений @var{A}, которые могуть вписаться в @code{int}.\n"
"Оригинальная функция работала для значений, которые может пердставлять\n"
"Guile и что @code{scm_sum} может понять, включая целые числа, большие чем\n"
"длинные, с плавающей запятой числа, комплексные числа и новые числовые\n"
"типы, которые были добавлены в Guile сторонними библиотеками."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:157
msgid ""
"Also, computing with @code{SCM} is not necessarily inefficient.  Small\n"
"integers will be encoded directly in the @code{SCM} value, for example,\n"
"and do not need any additional memory on the heap.  See @ref{Data\n"
"Representation} to find out the details."
msgstr ""
"Кроме того, вычисления с помощью @code{SCM} не обязательно не эффективны.\n"
"Малые целые числа будут закодированы непосредственно в значение @code{SCM},\n"
"например, и не нуждаются в дополнительной памяти в куче. См. @ref{Data\n"
"Representation}, чтобы узнать подробности."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:160
msgid ""
"Some special @code{SCM} values are available to C code without needing\n"
"to convert them from C values:"
msgstr ""
"Некоторые специальные значения @code{SCM} доступны для Си кода без "
"необходимости\n"
"их преобразования из Си значений:"

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:167
msgid ""
"@multitable {Scheme value} {C representation}\n"
"@item Scheme value @tab C representation\n"
"@item @nicode{#f}  @tab @nicode{SCM_BOOL_F}\n"
"@item @nicode{#t}  @tab @nicode{SCM_BOOL_T}\n"
"@item @nicode{()}  @tab @nicode{SCM_EOL}\n"
"@end multitable"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:174
msgid ""
"In addition to @code{SCM}, Guile also defines the related type\n"
"@code{scm_t_bits}.  This is an unsigned integral type of sufficient\n"
"size to hold all information that is directly contained in a\n"
"@code{SCM} value.  The @code{scm_t_bits} type is used internally by\n"
"Guile to do all the bit twiddling explained in @ref{Data Representation}, "
"but\n"
"you will encounter it occasionally in low-level user code as well."
msgstr ""
"В дополнении к @code{SCM}, Guile также определяет родственный тип\n"
"@code{scm_t_bits}.  Это беззнаковый интегральный тип достаточного размера\n"
"для хранения всей информации, которая содержиться непосредственно в "
"значении\n"
"@code{SCM}.  Тип @code{scm_t_bits} используется внутри Guile все объяснения\n"
"бит есть в @ref{Data Representation}, но вы будете сталкиваться с ним "
"иногда\n"
"в низкоуровневом коде пользователя."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:178
msgid ""
"@node Garbage Collection\n"
"@subsection Garbage Collection"
msgstr ""
"@node Garbage Collection\n"
"@subsection Сборщик Мусора"

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:185
msgid ""
"As explained above, the @code{SCM} type can represent all Scheme values.\n"
"Some values fit entirely into a @code{SCM} value (such as small\n"
"integers), but other values require additional storage in the heap (such\n"
"as strings and vectors).  This additional storage is managed\n"
"automatically by Guile.  You don't need to explicitly deallocate it\n"
"when a @code{SCM} value is no longer used."
msgstr ""
"Как объяснено выше, тип @code{SCM} может представлять все занчения Scheme.\n"
"Некоторые значения полностью содержаться в значениях @code{SCM} (такие как\n"
"небольшие целые числа), но для других значений требуется дополнительное\n"
"хранилище в куче(например, строки и векторы). Это дополнительное хранилище\n"
"управляется автоматически Guile.  Вам не нужно явно освобождать его. когда\n"
"значение @code{SCM} больше не используется."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:193
msgid ""
"Two things must be guaranteed so that Guile is able to manage the\n"
"storage automatically: it must know about all blocks of memory that have\n"
"ever been allocated for Scheme values, and it must know about all Scheme\n"
"values that are still being used.  Given this knowledge, Guile can\n"
"periodically free all blocks that have been allocated but are not used\n"
"by any active Scheme values.  This activity is called @dfn{garbage\n"
"collection}."
msgstr ""
"Необходимо гарантировать две вещи, чтобы Guile мог управлять хранилищем\n"
"автоматически: он должен знать обо всех блоках памяти, которые когда либо\n"
"были выделены для значений Scheme, и он должен знать обо всех значениях\n"
"Scheme которые еще используются. Учитывая эти знания, Guile может "
"переодически\n"
"освобождать все блоки, которые были выделены, но не используются никакими\n"
"активными значениями Scheme. Эта деятельность называется сборкой мусора\n"
"(@dfn{garbage collection})."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:205
msgid ""
"Guile's garbage collector will automatically discover references to\n"
"@code{SCM} objects that originate in global variables, static data\n"
"sections, function arguments or local variables on the C and Scheme\n"
"stacks, and values in machine registers.  Other references to @code{SCM}\n"
"objects, such as those in other random data structures in the C heap\n"
"that contain fields of type @code{SCM}, can be made visible to the\n"
"garbage collector by calling the functions @code{scm_gc_protect_object} or\n"
"@code{scm_permanent_object}.  Collectively, these values form the ``root\n"
"set'' of garbage collection; any value on the heap that is referenced\n"
"directly or indirectly by a member of the root set is preserved, and all\n"
"other objects are eligible for reclamation."
msgstr ""
"Сборщик мусора Guile автоматически обнаружит ссылки на объекты @code{SCM}\n"
"которые возникают в глобальных переменных, статических разделах данных,\n"
"аргументах функции или локальных переменных в стеках Си и Scheme и\n"
"значения в машинных регистрах. Другие ссылки на объекты @code{SCM},\n"
"такие как в других произвольных структурах в Си куче которая содержит\n"
"поля типа @code{SCM}, могут быть видимы сборщику мусора, вызовом функций\n"
"@code{scm_gc_protect_object} или  @code{scm_permanent_object}.  В "
"совокупности\n"
"эти знания образуют ``корневой набор'' сбора мусора; любое значение в "
"куче, \n"
"которое прямо или косвенно ссылается на члена корневого набора сохраняется,\n"
"и все остальные объекты имеют право на возврат."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:213
msgid ""
"In Guile, garbage collection has two logical phases: the @dfn{mark\n"
"phase}, in which the collector discovers the set of all live objects,\n"
"and the @dfn{sweep phase}, in which the collector reclaims the resources\n"
"associated with dead objects.  The mark phase pauses the program and\n"
"traces all @code{SCM} object references, starting with the root set.\n"
"The sweep phase actually runs concurrently with the main program,\n"
"incrementally reclaiming memory as needed by allocation."
msgstr ""
"В Guile, сбор мусора имеет две логические фазы: фазу пометки(@dfn{mark\n"
"phase}), в которой сборщик мусора обнаруживает набор всех живых объектов\n"
"и фазу уборки(@dfn{sweep phase}), в которой сборщик мусора возвращает\n"
"ресурсы системе, связанные с мертвыми объектами. Фаза пометки "
"приостанавливает\n"
"программу и отслеживает все ссылки на объекты @code{SCM} начиная с "
"корневого\n"
"набора. Фаза уборки фактически выполняется вместе с основной программой,\n"
"поэтапно востанавливая память по мере необходимости."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:238
msgid ""
"In the mark phase, the garbage collector traces the Scheme stack and\n"
"heap @dfn{precisely}.  Because the Scheme stack and heap are managed by\n"
"Guile, Guile can know precisely where in those data structures it might\n"
"find references to other heap objects.  This is not the case,\n"
"unfortunately, for pointers on the C stack and static data segment.\n"
"Instead of requiring the user to inform Guile about all variables in C\n"
"that might point to heap objects, Guile traces the C stack and static\n"
"data segment @dfn{conservatively}.  That is to say, Guile just treats\n"
"every word on the C stack and every C global variable as a potential\n"
"reference in to the Scheme heap@footnote{Note that Guile does not scan\n"
"the C heap for references, so a reference to a @code{SCM} object from a\n"
"memory segment allocated with @code{malloc} will have to use some other\n"
"means to keep the @code{SCM} object alive.  @xref{Garbage Collection\n"
"Functions}.}.  Any value that looks like a pointer to a GC-managed\n"
"object is treated as such, whether it actually is a reference or not.\n"
"Thus, scanning the C stack and static data segment is guaranteed to find\n"
"all actual references, but it might also find words that only\n"
"accidentally look like references.  These ``false positives'' might keep\n"
"@code{SCM} objects alive that would otherwise be considered dead.  While\n"
"this might waste memory, keeping an object around longer than it\n"
"strictly needs to is harmless.  This is why this technique is called\n"
"``conservative garbage collection''.  In practice, the wasted memory\n"
"seems to be no problem, as the static C root set is almost always finite\n"
"and small, given that the Scheme stack is separate from the C stack."
msgstr ""
"В фазе пометки, сборщик мусора отслеживает стек Scheme и кучу в\n"
"точности( @dfn{precisely}). Поскольку стек и куча Scheme управляются\n"
"Guile, Guile может точно знать, где в этих структурах данных сборщик\n"
"может найти сслылки на другие объекты кучи. Однако это не так,\n"
"для указателей в Си стеке и статическом сегменте данных Си.  Вместо\n"
"того чтобы требовать от пользователей необоходимости сообщать Guile\n"
"обо всех переменных в Си, которые могут указывать на объекты кучи,\n"
"Guile последовательно проверяет Си стек и статический сегмент данных\n"
"(@dfn{conservatively}).  Т.е., Guile просто проверяет каждое слово\n"
"Си стека и любую глобальную переменную Си в качестве потенциальной\n"
"ссылки на кучу Scheme@footnote{Обратите внимание, что Guile не сканирует\n"
"Си кучу для поиска ссылок на объект @code{SCM} из памяти сегмента, "
"выделенного\n"
"с помощью @code{malloc}. необходимо использовать некоторые другие средства\n"
"для сохранения объекта @code{SCM} живым.  @xref{Garbage Collection\n"
"Functions}.}.  Любое значение, которое выглядит как указатель на объект,\n"
"управляемый сборщиком мусора рассматривается например, является ли оно\n"
"ссылкой или нет. Таким образом, сканирование стека Си и сегмента "
"статических\n"
"данных гарантированно найдет все фактические сслыки, но оно также может\n"
"найти слова которые только случайно выглядят как ссылки.  Эти ``ложные\n"
"срабатывания'' могут сохранять объекты @code{SCM} живыми, котоыре иначе бы\n"
"считались мертвыми. Хотя это может повлечь потерю памяти, сохранять объект\n"
"дольше, чем это нужно, это не так страшно. Вот почему эта техника "
"называется\n"
"``консревативная сборка мусора''.  На практике потерянная память, не "
"проблема,\n"
"поскольку статическое множество Си корней почти вегда конечное и малое, \n"
"учитывая что стек Scheme отделен от Си стека."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:242
msgid ""
"The stack of every thread is scanned in this way and the registers of\n"
"the CPU and all other memory locations where local variables or function\n"
"parameters might show up are included in this scan as well."
msgstr ""
"Стек каждого потока сканируется таким образом, а регистры процессора и\n"
"всех други мест памяти, где могут появиться локальные переменные или\n"
"параметры функции также включены в это сканирование."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:247
msgid ""
"The consequence of the conservative scanning is that you can just\n"
"declare local variables and function parameters of type @code{SCM} and\n"
"be sure that the garbage collector will not free the corresponding\n"
"objects."
msgstr ""
"Следствием консервативного сканирования является то, что вы можете просто\n"
"объявить локальные переменные и параметры функций типа @code{SCM} и\n"
"убедиться что сборщик мусора не освободит соответствующие объекты."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:256
msgid ""
"However, a local variable or function parameter is only protected as\n"
"long as it is really on the stack (or in some register).  As an\n"
"optimization, the C compiler might reuse its location for some other\n"
"value and the @code{SCM} object would no longer be protected.  Normally,\n"
"this leads to exactly the right behavior: the compiler will only\n"
"overwrite a reference when it is no longer needed and thus the object\n"
"becomes unprotected precisely when the reference disappears, just as\n"
"wanted."
msgstr ""
"Однако локальная переменная или параметр защищены только при условиии,\n"
"что они находятся реально в стеке(или в каком либо регистре). В качесте\n"
"оптимизации компилятор Си может повторно использовать их местоположение\n"
"для другого значения, и объект @code{SCM} больше не будет защищен от \n"
"удаления.  Как обычно, это приводит к верному поведению: компилятор\n"
"перезаписывает ссылку, когда она больше не требуется, и таким образом,\n"
"объект становиться незащищенным, когда ссылка исчезает, что нам и надо."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:266
msgid ""
"There are situations, however, where a @code{SCM} object needs to be\n"
"around longer than its reference from a local variable or function\n"
"parameter.  This happens, for example, when you retrieve some pointer\n"
"from a foreign object and work with that pointer directly.  The\n"
"reference to the @code{SCM} foreign object might be dead after the\n"
"pointer has been retrieved, but the pointer itself (and the memory\n"
"pointed to) is still in use and thus the foreign object must be\n"
"protected.  The compiler does not know about this connection and might\n"
"overwrite the @code{SCM} reference too early."
msgstr ""
"Однако существуют ситуации, когда объект @code{SCM} должен существовать\n"
"дольше, чем ссылка на него из локальной переменной или параметра функции.\n"
"Это происходит например, когда вы извлекаете некоторый указатель из\n"
"внешнего объекта и работаете с этим указателем. Ссылка на внешний\n"
"объект @code{SCM} может быть мертва после того как указатель был извлечен,\n"
"но сам указатель(и указатель на память) все еще испльзуется и следовательно\n"
"внешний объект должен быть защищен. Компилятор не знает об этой связке и\n"
"может перезаписать ссылка @code{SCM} слишком рано."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:270
msgid ""
"To get around this problem, you can use @code{scm_remember_upto_here_1}\n"
"and its cousins.  It will keep the compiler from overwriting the\n"
"reference.  @xref{Foreign Object Memory Management}."
msgstr ""
"Чтобы обойти эту проблему, вы можете использовать "
"@code{scm_remember_upto_here_1}\n"
"и его аналоги.  Это заставить сохранить ссылку.  @xref{Foreign Object Memory "
"Management}."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:274
msgid ""
"@node Control Flow\n"
"@subsection Control Flow"
msgstr ""
"@node Control Flow\n"
"@subsection Управление потоком выполнения программы"

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:277
msgid ""
"Scheme has a more general view of program flow than C, both locally and\n"
"non-locally."
msgstr ""
"Scheme имеет более общий вид потока выполнения программы, чем Си, как "
"локально,\n"
"так и не локально."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:283
msgid ""
"Controlling the local flow of control involves things like gotos, loops,\n"
"calling functions and returning from them.  Non-local control flow\n"
"refers to situations where the program jumps across one or more levels\n"
"of function activations without using the normal call or return\n"
"operations."
msgstr ""
"Управление локальным потоком выполнения включает в себя такие вещи, как\n"
"переходы(gotos), циклы(loops), вызовы функций(calling) и возвраты\n"
"из них(returning). Нелокальный поток выполнения относится к ситуациям,\n"
"в которых программа перескакивает через один или несколько уровней\n"
"активации функций без использования обычных операций вызова(call) или \n"
"возврата(return)."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:291
msgid ""
"The primitive means of C for local control flow is the @code{goto}\n"
"statement, together with @code{if}.  Loops done with @code{for},\n"
"@code{while} or @code{do} could in principle be rewritten with just\n"
"@code{goto} and @code{if}.  In Scheme, the primitive means for local\n"
"control flow is the @emph{function call} (together with @code{if}).\n"
"Thus, the repetition of some computation in a loop is ultimately\n"
"implemented by a function that calls itself, that is, by recursion."
msgstr ""
"Примитивным средством Си для локального управления потоком выполнения\n"
"является операторы  @code{goto} вместе с  @code{if}.  Циклы выполняющиеся\n"
"с помощью конструкций @code{for}, @code{while} и @code{do} могут быть\n"
"переписаны с помощью операторов @code{goto} и @code{if}.  В Scheme, \n"
"примитивным средством для управления локальным потоком выполнения является\n"
"вызов функции(@emph{function call}) (вместе с оператором @code{if}).\n"
"Таким образом, повторение некоторых вычислений в цикле в конечном счете\n"
"реализуется функцией которая вызывает сама себя, то есть рекурсией."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:298
msgid ""
"This approach is theoretically very powerful since it is easier to\n"
"reason formally about recursion than about gotos.  In C, using\n"
"recursion exclusively would not be practical, though, since it would eat\n"
"up the stack very quickly.  In Scheme, however, it is practical:\n"
"function calls that appear in a @dfn{tail position} do not use any\n"
"additional stack space (@pxref{Tail Calls})."
msgstr ""
"Этот подход теоретически более сильный, поскольку формально рассуждать\n"
"о рекурсии, более проще чем о переходах(gotos).  В Си, использование\n"
"рекурсии исключительно не практично, т.к. она быстро съедает весь стек.\n"
"В Scheme, однако это практично: вызовы функций, которые появляются в \n"
"хвостовой позиции(@dfn{tail position}) не используют дополнительное\n"
"пространство в стеке(@pxref{Tail Calls})."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:305
msgid ""
"A function call is in a tail position when it is the last thing the\n"
"calling function does.  The value returned by the called function is\n"
"immediately returned from the calling function.  In the following\n"
"example, the call to @code{bar-1} is in a tail position, while the\n"
"call to @code{bar-2} is not.  (The call to @code{1-} in @code{foo-2}\n"
"is in a tail position, though.)"
msgstr ""
"Вызов функции находиться в хвостовой позиции, когда это последнее "
"дейтсвия, \n"
"которое выполняет вызывающая функция. Значение, возвращаемое вызываемой\n"
"функцией немедленно возвращается из вызывающей функции. В следующем\n"
"примере, вызов  @code{bar-1} находиться в хвостовой позиции, а вызов\n"
"@code{bar-2} нет.  (Однако вызов @code{1-} в @code{foo-2} находиться\n"
"в хвостовой позиции.)"

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:309
msgid ""
"@lisp\n"
"(define (foo-1 x)\n"
"  (bar-1 (1- x)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:313
msgid ""
"(define (foo-2 x)\n"
"  (1- (bar-2 x)))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:317
msgid ""
"Thus, when you take care to recurse only in tail positions, the\n"
"recursion will only use constant stack space and will be as good as a\n"
"loop constructed from gotos."
msgstr ""
"Таким образом, вы получаете чистую рекурсию только в хвостовой позиции,\n"
"такая рекурсия будет использовать постоянное пространство стека и  будет\n"
"такой же хорошей как цикл, построенный из переходов gotos."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:320
msgid ""
"Scheme offers a few syntactic abstractions (@code{do} and @dfn{named}\n"
"@code{let}) that make writing loops slightly easier."
msgstr ""
"Scheme предлагает несколько синтаксических абстракций (@code{do} и "
"@dfn{named}\n"
"@code{let}), которые создают циклы намного легче."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:326
msgid ""
"But only Scheme functions can call other functions in a tail position:\n"
"C functions can not.  This matters when you have, say, two functions\n"
"that call each other recursively to form a common loop.  The following\n"
"(unrealistic) example shows how one might go about determining whether a\n"
"non-negative integer @var{n} is even or odd."
msgstr ""
"Но только функции Scheme могут вызывать другие функции в хвостовой позиции:\n"
"Си функции этого не могут. Это имеет значение, если у вас есть, скажем, две\n"
"функции, которые рекурсивно вызывают друг друга, образуя общий цикл. "
"Следующий\n"
"(нереалиситчный) пример показывает как можно определить, является ли "
"неотритцательное\n"
"целое число @var{n} четным или нечетным."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:331
msgid ""
"@lisp\n"
"(define (my-even? n)\n"
"  (cond ((zero? n) #t)\n"
"        (else (my-odd? (1- n)))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:336
msgid ""
"(define (my-odd? n)\n"
"  (cond ((zero? n) #f)\n"
"        (else (my-even? (1- n)))))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:341
msgid ""
"Because the calls to @code{my-even?} and @code{my-odd?} are in tail\n"
"positions, these two procedures can be applied to arbitrary large\n"
"integers without overflowing the stack.  (They will still take a lot\n"
"of time, of course.)"
msgstr ""
"Поскольку вызовы @code{my-even?} и @code{my-odd?} находятся в хвостовой\n"
"позиции, эти две процедуры могут применяться к произвольно большим целым,\n"
"не переполняя стек. (Конечно, они все равно займут много времени.)"

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:347
msgid ""
"However, when one or both of the two procedures would be rewritten in\n"
"C, it could no longer call its companion in a tail position (since C\n"
"does not have this concept).  You might need to take this\n"
"consideration into account when deciding which parts of your program\n"
"to write in Scheme and which in C."
msgstr ""
"Однако, когда одна или обе из этих двух процедур будут переписаны на Си,\n"
"они не смогут больше вызывать своего компаньона в хвостовой позиции\n"
"(поскольку Си не имеет этого понятия).  Вам необходимо учитывать это\n"
"соображение при принятии решения о том, какие части вашей программы\n"
"писать на Scheme а какие на Си."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:352
msgid ""
"In addition to calling functions and returning from them, a Scheme\n"
"program can also exit non-locally from a function so that the control\n"
"flow returns directly to an outer level.  This means that some functions\n"
"might not return at all."
msgstr ""
"В дополнение к вызовам функций и возврату из них, программа Scheme\n"
"также может выходить из функций не локально, так что поток выполения\n"
"возвращается непосредственно на внешний уровень. Это означает, что \n"
"некотоыре функции могут вообще не иметь возврата."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:357
msgid ""
"Even more, it is not only possible to jump to some outer level of\n"
"control, a Scheme program can also jump back into the middle of a\n"
"function that has already exited.  This might cause some functions to\n"
"return more than once."
msgstr ""
"Более того, невозможно не только перейти на некоторый внешний уровень\n"
"контроля,  Scheme программа может также перепрыгнуть назад в середину\n"
"функции и повторно выйти. Это может вызвать возврат из некоторых функций\n"
"более одного раза."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:366
msgid ""
"In general, these non-local jumps are done by invoking\n"
"@dfn{continuations} that have previously been captured using\n"
"@code{call-with-current-continuation}.  Guile also offers a slightly\n"
"restricted set of functions, @code{catch} and @code{throw}, that can\n"
"only be used for non-local exits.  This restriction makes them more\n"
"efficient.  Error reporting (with the function @code{error}) is\n"
"implemented by invoking @code{throw}, for example.  The functions\n"
"@code{catch} and @code{throw} belong to the topic of @dfn{exceptions}."
msgstr ""
"В общем, эти не локальные переходы выполняются путем вызова\n"
"продолжений(@dfn{continuations}), которые ранее были перехвачены\n"
"с использованием @code{call-with-current-continuation}.  Guile также\n"
"предлагает ограниченный набор функций, @code{catch} и @code{throw}, котоыре\n"
"могут использоваться для нелокальных выходов. Это ограничение делает их\n"
"более эффективными. Отчет об ошибках (с функцией @code{error}) реализован\n"
"путем вызова например @code{throw}.  Функции @code{catch} и @code{throw} \n"
"входят в тему исключений(@dfn{exceptions})."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:374
msgid ""
"Since Scheme functions can call C functions and vice versa, C code can\n"
"experience the more general control flow of Scheme as well.  It is\n"
"possible that a C function will not return at all, or will return more\n"
"than once.  While C does offer @code{setjmp} and @code{longjmp} for\n"
"non-local exits, it is still an unusual thing for C code.  In\n"
"contrast, non-local exits are very common in Scheme, mostly to report\n"
"errors."
msgstr ""
"Поскольку функции Scheme могут вызывать Си функции и наоборот, код Си\n"
"может более широко управлять потоком выполнения  Scheme.  Возможно\n"
"Си функция никогда не возвращается, или возвращается более одного раза.\n"
"Хотя Си пердлагает @code{setjmp} и @code{longjmp} для нелокальных выходов.,\n"
"это все еще необычная вещь для кода Си. Напротив, нелокальные выходы\n"
"очень распространены в  Scheme, в основном для сообщения об ошибках."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:379
msgid ""
"You need to be prepared for the non-local jumps in the control flow\n"
"whenever you use a function from @code{libguile}: it is best to assume\n"
"that any @code{libguile} function might signal an error or run a pending\n"
"signal handler (which in turn can do arbitrary things)."
msgstr ""
"Вы должны быть готовыми к нелокальным скачкам в потоке выполнения всякий\n"
"раз, когда вы используете функции из @code{libguile}: лучше предположить,\n"
"что любая функция @code{libguile} может выдать сигнал ошибки ли запустить\n"
"обработки сигнала (который, в свою очередь, может выполнять произвольные\n"
"действия)."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:389
msgid ""
"It is often necessary to take cleanup actions when the control leaves a\n"
"function non-locally.  Also, when the control returns non-locally, some\n"
"setup actions might be called for.  For example, the Scheme function\n"
"@code{with-output-to-port} needs to modify the global state so that\n"
"@code{current-output-port} returns the port passed to\n"
"@code{with-output-to-port}.  The global output port needs to be reset to\n"
"its previous value when @code{with-output-to-port} returns normally or\n"
"when it is exited non-locally.  Likewise, the port needs to be set again\n"
"when control enters non-locally."
msgstr ""
"Часто бывает необходимо предпринять действия по очистке, когда управление\n"
"покидает функцию нелокально. Кроме того, когда управление возвращается\n"
"нелокально, могут потребоваться некоторые действия по настройке. Например,\n"
"функция Scheme @code{with-output-to-port} нуждается в изменении глобального\n"
"состояния, так что @code{current-output-port} вернул порт переданный\n"
"@code{with-output-to-port}.  Глобальный выходной порт должен быть сброшен\n"
"до своего предыдущего значения когда @code{with-output-to-port} возвращется\n"
"нормально или когда она возвращается не локально.  Аналогично, порт "
"необходимо\n"
"установить снова, когда управление возващается нелокально."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:395
msgid ""
"Scheme code can use the @code{dynamic-wind} function to arrange for\n"
"the setting and resetting of the global state.  C code can use the\n"
"corresponding @code{scm_internal_dynamic_wind} function, or a\n"
"@code{scm_dynwind_begin}/@code{scm_dynwind_end} pair together with\n"
"suitable 'dynwind actions' (@pxref{Dynamic Wind})."
msgstr ""
"Код Scheme может использовать функцию @code{dynamic-wind} для настройки\n"
"и сброса глобальных настроек.  Си код может использовать соответствующую\n"
"функцию @code{scm_internal_dynamic_wind} или пару \n"
"@code{scm_dynwind_begin}/@code{scm_dynwind_end} вместе с подходящими\n"
"'dynwind действиями' (@pxref{Dynamic Wind})."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:400
msgid ""
"Instead of coping with non-local control flow, you can also prevent it\n"
"by erecting a @emph{continuation barrier}, @xref{Continuation\n"
"Barriers}.  The function @code{scm_c_with_continuation_barrier}, for\n"
"example, is guaranteed to return exactly once."
msgstr ""
"Вместо того, чтобы справляться с нелокальным потоком управления, вы также\n"
"можете предотвратить его, установив барьер продолжения(@emph{continuation "
"barrier}),\n"
"@xref{Continuation Barriers}.  Например, функция "
"@code{scm_c_with_continuation_barrier},\n"
"гарантированно возвращается ровно один раз."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:403
msgid ""
"@node Asynchronous Signals\n"
"@subsection Asynchronous Signals"
msgstr ""
"@node Asynchronous Signals\n"
"@subsection Асинхронные Сигналы"

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:410
msgid ""
"You can not call libguile functions from handlers for POSIX signals, but\n"
"you can register Scheme handlers for POSIX signals such as\n"
"@code{SIGINT}.  These handlers do not run during the actual signal\n"
"delivery.  Instead, they are run when the program (more precisely, the\n"
"thread that the handler has been registered for) reaches the next\n"
"@emph{safe point}."
msgstr ""
"Вы не можете вызывать функции libguile из обработчиков POSIX сигналов, но\n"
"вы можете зарегистрировать Scheme обработчики для POSIX сигналов, таких как\n"
"@code{SIGINT}.  Эти обработчики не запускаются во время фактической "
"доставки\n"
"сигнала. Вместо этого они запускаются, когда программа(точнее поток который\n"
"зарегистрировал обработчик) достигает следующей безопасной точки\n"
"(@emph{safe point})."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:418
msgid ""
"The libguile functions themselves have many such safe points.\n"
"Consequently, you must be prepared for arbitrary actions anytime you\n"
"call a libguile function.  For example, even @code{scm_cons} can contain\n"
"a safe point and when a signal handler is pending for your thread,\n"
"calling @code{scm_cons} will run this handler and anything might happen,\n"
"including a non-local exit although @code{scm_cons} would not ordinarily\n"
"do such a thing on its own."
msgstr ""
"У самих функций libguile есть много таких безопасных точек. Следовательно,\n"
"вы должны быть готовы к произвольным действиям при вызове функции\n"
"libguile.  Например, даже @code{scm_cons} может содержать безопасную точку,\n"
"и когда обработчик сигнала ожидает для вашего потока, вызов @code{scm_cons}\n"
"будет запускать этот обработчик, и все может произойти, включая нелокальный\n"
"выход, хотя сам @code{scm_cons} обычно так не делает."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:422
msgid ""
"If you do not want to allow the running of asynchronous signal handlers,\n"
"you can block them temporarily with @code{scm_dynwind_block_asyncs}, for\n"
"example.  @xref{Asyncs}."
msgstr ""
"Если вы не хотите разрешать работу асинхронных обработчиков сигналов, вы "
"можете\n"
"временно заблокировать их с помощью например "
"@code{scm_dynwind_block_asyncs}\n"
"@xref{Asyncs}."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:429
msgid ""
"Since signal handling in Guile relies on safe points, you need to make\n"
"sure that your functions do offer enough of them.  Normally, calling\n"
"libguile functions in the normal course of action is all that is needed.\n"
"But when a thread might spent a long time in a code section that calls\n"
"no libguile function, it is good to include explicit safe points.  This\n"
"can allow the user to interrupt your code with @key{C-c}, for example."
msgstr ""
"Поскольку обработка сигналов в Guile зависит от безопасных точек, вам\n"
"необходимо убедиться, что ваши функции действительно предлагают их в\n"
"достаточном количестве. Обычно, вызов функции libguile в обычном режиме,\n"
"это все что необходимо. Но когда поток можт долгое время находиться\n"
"в секции кода, которая не вызывает функций libguile, полезно влючать\n"
"в код явные безопасные точки. Это позволит, например, пользователю\n"
"прервать ваш код с помощью @key{C-c}."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:432
msgid ""
"You can do this with the macro @code{SCM_TICK}.  This macro is\n"
"syntactically a statement.  That is, you could use it like this:"
msgstr ""
"Вы можете сделать это с помощью макроса @code{SCM_TICK}.  Этот макрос\n"
"синтаксически является выражением. То есть, вы можете использовать его\n"
"так:"

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:440
msgid ""
"@example\n"
"while (1)\n"
"  @{\n"
"    SCM_TICK;\n"
"    do_some_work ();\n"
"  @}\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:443
msgid ""
"Frequent execution of a safe point is even more important in multi\n"
"threaded programs, @xref{Multi-Threading}."
msgstr ""
"Частое выполнение безопасной точки еще более важно в многопоточных\n"
"программах, @xref{Multi-Threading}."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:446
msgid ""
"@node Multi-Threading\n"
"@subsection Multi-Threading"
msgstr ""
"@node Multi-Threading\n"
"@subsection МногоПоточность"

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:449
msgid ""
"Guile can be used in multi-threaded programs just as well as in\n"
"single-threaded ones."
msgstr ""
"Guile можно использовать в многопоточных программах, так же как и в\n"
"однопоточных."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:455
msgid ""
"Each thread that wants to use functions from libguile must put itself\n"
"into @emph{guile mode} and must then follow a few rules.  If it doesn't\n"
"want to honor these rules in certain situations, a thread can\n"
"temporarily leave guile mode (but can no longer use libguile functions\n"
"during that time, of course)."
msgstr ""
"Каждый поток, который хочет использовать функции из libguile, должен\n"
"поместить себя в режим @emph{guile mode} и должен следовать нескольким\n"
"правилам. Если он не хочет соблюдать эти правила в определенных ситуациях,\n"
"поток может покинуть режим guile (но больше, конечно, не сможет "
"использовать\n"
"функции libguile в это время)."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:463
msgid ""
"Threads enter guile mode by calling @code{scm_with_guile},\n"
"@code{scm_boot_guile}, or @code{scm_init_guile}.  As explained in the\n"
"reference documentation for these functions, Guile will then learn about\n"
"the stack bounds of the thread and can protect the @code{SCM} values\n"
"that are stored in local variables.  When a thread puts itself into\n"
"guile mode for the first time, it gets a Scheme representation and is\n"
"listed by @code{all-threads}, for example."
msgstr ""
"Поток входит в режим guile вызывая  @code{scm_with_guile},\n"
"@code{scm_boot_guile}, или @code{scm_init_guile}.  Как поясняется в "
"справочной\n"
"документации для этих функций, Guile тогда узнает о границах стека потока и\n"
"может защитить значения @code{SCM} сохраненные в локальных переменных. "
"Когда\n"
"поток впервые попадает в режим guile, он получает представление Scheme и "
"например,\n"
"список @code{all-threads}."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:476
msgid ""
"Threads in guile mode can block (e.g., do blocking I/O) without causing\n"
"any problems@footnote{In Guile 1.8, a thread blocking in guile mode\n"
"would prevent garbage collection to occur.  Thus, threads had to leave\n"
"guile mode whenever they could block.  This is no longer needed with\n"
"Guile 2.@var{x}.}; temporarily leaving guile mode with\n"
"@code{scm_without_guile} before blocking slightly improves GC\n"
"performance, though.  For some common blocking operations, Guile\n"
"provides convenience functions.  For example, if you want to lock a\n"
"pthread mutex while in guile mode, you might want to use\n"
"@code{scm_pthread_mutex_lock} which is just like\n"
"@code{pthread_mutex_lock} except that it leaves guile mode while\n"
"blocking."
msgstr ""
"Потоки в режиме guile могут блокироваться (например., выполняя блокирующий\n"
"I/O) не вызывая никаких проблем@footnote{В Guile 1.8, блокировка потока в\n"
"режиме guile прдотвращала сборку мусора. Таким образом приходилось покидать\n"
"режим guile когда он мог блокироваться. Это больше не нужно в Guile 2."
"@var{x}.};\n"
"временно покидать режим guile с @code{scm_without_guile} перед блокировкой "
"немного\n"
"улучшая производительность GC. Для некоторых общих операций блокировки,\n"
"Guile предоставляет удобные функции. Например, если вы хотите заблокировать "
"мьютексы\n"
"pthread в режиме guile, вы можете воспользоваться "
"@code{scm_pthread_mutex_lock} который\n"
"похож на @code{pthread_mutex_lock} за исключением того, что он покидает "
"режим guile \n"
"при блокировке."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:482
msgid ""
"All libguile functions are (intended to be) robust in the face of\n"
"multiple threads using them concurrently.  This means that there is no\n"
"risk of the internal data structures of libguile becoming corrupted in\n"
"such a way that the process crashes."
msgstr ""
"Все функции libguile (должны быть) надежны перед лицом нескольких потоков\n"
"использующих их одновременно. Это означает, что нет никаких рисков для \n"
"внутренней структуры данных libguile стать поврежденными таким образом,\n"
"что процесс завершиться крахом."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:493
msgid ""
"A program might still produce nonsensical results, though.  Taking\n"
"hashtables as an example, Guile guarantees that you can use them from\n"
"multiple threads concurrently and a hashtable will always remain a valid\n"
"hashtable and Guile will not crash when you access it.  It does not\n"
"guarantee, however, that inserting into it concurrently from two threads\n"
"will give useful results: only one insertion might actually happen, none\n"
"might happen, or the table might in general be modified in a totally\n"
"arbitrary manner.  (It will still be a valid hashtable, but not the one\n"
"that you might have expected.)  Guile might also signal an error when it\n"
"detects a harmful race condition."
msgstr ""
"Тем не менее, программа может по прежнему давать бессмысленные результаты.\n"
"Принимая  хэш-таблицу например, Guile гарантирует, что вы можете "
"использовать\n"
"ее из нескольких потоков одновременно и хеш-таблица всегда будет оставаться\n"
"допустимой хэш-таблицей и Guile не даст сбой при доступе к ней. Однако это\n"
"не гарантирует, что вставка в него одновременно из двух потоков будет "
"давать\n"
"полезные результаты: может произойти только одна вставка, ни одна из "
"вставок\n"
"не может произойти, или таблица вообще может быть изменена совершенно "
"произвольно.\n"
"(Она все равно будет действительной хеш-таблицей, но не той, которой вы "
"могли\n"
"ожидать.)  Guile также может сигнализировать об ошибке когда он "
"обнаруживает\n"
"состояние гонки."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:497
msgid ""
"Thus, you need to put in additional synchronizations when multiple\n"
"threads want to use a single hashtable, or any other mutable Scheme\n"
"object."
msgstr ""
"Таким образом, вам нужно добавлять дополнительную синхронизацию, когда \n"
"несколько потоков хотят использовать одну хеш-таблицу или любой другой\n"
"изменяемый объект Scheme."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:501
msgid ""
"When writing C code for use with libguile, you should try to make it\n"
"robust as well.  An example that converts a list into a vector will help\n"
"to illustrate.  Here is a correct version:"
msgstr ""
"При написании кода используемого с libguile, вы должны попытаться сделать\n"
"его надежным. Пример, который преобразует список в вектор, поможет это\n"
"проилюстрироать. Вот правильная версия:"

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:508
msgid ""
"@example\n"
"SCM\n"
"my_list_to_vector (SCM list)\n"
"@{\n"
"  SCM vector = scm_make_vector (scm_length (list), SCM_UNDEFINED);\n"
"  size_t len, i;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:517
msgid ""
"  len = scm_c_vector_length (vector);\n"
"  i = 0;\n"
"  while (i < len && scm_is_pair (list))\n"
"    @{\n"
"      scm_c_vector_set_x (vector, i, scm_car (list));\n"
"      list = scm_cdr (list);\n"
"      i++;\n"
"    @}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:521
msgctxt "/home/bear/work/guile/doc/guile/en/libguile-concepts.texi:521"
msgid ""
"  return vector;\n"
"@}\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:526
msgid ""
"The first thing to note is that storing into a @code{SCM} location\n"
"concurrently from multiple threads is guaranteed to be robust: you don't\n"
"know which value wins but it will in any case be a valid @code{SCM}\n"
"value."
msgstr ""
"Прежде всего следует отметить, что хранение в местоположении @code{SCM} \n"
"одновременно из нескольких потоков гарантирует надежность: вы не знаете,\n"
"какое значение выиграет, но оно будет в любом случаее действительным\n"
"значением @code{SCM}."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:535
msgid ""
"But there is no guarantee that the list referenced by @var{list} is not\n"
"modified in another thread while the loop iterates over it.  Thus, while\n"
"copying its elements into the vector, the list might get longer or\n"
"shorter.  For this reason, the loop must check both that it doesn't\n"
"overrun the vector and that it doesn't overrun the list.  Otherwise,\n"
"@code{scm_c_vector_set_x} would raise an error if the index is out of\n"
"range, and @code{scm_car} and @code{scm_cdr} would raise an error if the\n"
"value is not a pair."
msgstr ""
"Но нет никакой гарантии, что список на который ссылается переменная "
"@var{list}\n"
"не изменяется в другом потоке, в то время когда по нему проходит цикл "
"итерации.\n"
"Таким образом, копируя свои элементы в вектор, список может быть длиннее или "
"короче.\n"
"По этой причине цикл должен проверять, что он не перегрузит вектор и что он "
"не \n"
"выйдет за рамки списка. В противном случае @code{scm_c_vector_set_x} "
"вызовет\n"
"ошибку, если индекс будет вне допустимого диапазона, а @code{scm_car} и "
"@code{scm_cdr}\n"
"вызовет ошибку если значение не будет парой."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:541
msgid ""
"It is safe to use @code{scm_car} and @code{scm_cdr} on the local\n"
"variable @var{list} once it is known that the variable contains a pair.\n"
"The contents of the pair might change spontaneously, but it will always\n"
"stay a valid pair (and a local variable will of course not spontaneously\n"
"point to a different Scheme object)."
msgstr ""
"Безопасно использовать @code{scm_car} и @code{scm_cdr} с локальной\n"
"переменной @var{list}, когда будет известно что переменная содержит пару.\n"
"Содержание пары может измениться спонтанно, но это всегда будет "
"действительная\n"
"пара(и локальная переменная, конечно, не будет спонтанно указывать на "
"другой\n"
"объект Scheme)."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:548
msgid ""
"Likewise, a vector such as the one returned by @code{scm_make_vector} is\n"
"guaranteed to always stay the same length so that it is safe to only use\n"
"scm_c_vector_length once and store the result.  (In the example,\n"
"@var{vector} is safe anyway since it is a fresh object that no other\n"
"thread can possibly know about until it is returned from\n"
"@code{my_list_to_vector}.)"
msgstr ""
"Аналогично, вектор, такой как тот, который возвращается "
"@code{scm_make_vector}\n"
"всегда гарантированно сохраняет туже длину, что бы было безопасно "
"использовать\n"
"только scm_c_vector_length и сохранить результат.  (В этом примере "
"вектор(@var{vector})\n"
"является безопасным, так как он является новым объектом, и нет другого "
"потока который\n"
"может знать о нем, до тех пор пока он не будет возвращен из "
"@code{my_list_to_vector}.)"

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:555
msgid ""
"Of course the behavior of @code{my_list_to_vector} is suboptimal when\n"
"@var{list} does indeed get asynchronously lengthened or shortened in\n"
"another thread.  But it is robust: it will always return a valid vector.\n"
"That vector might be shorter than expected, or its last elements might\n"
"be unspecified, but it is a valid vector and if a program wants to rule\n"
"out these cases, it must avoid modifying the list asynchronously."
msgstr ""
"Конечно, поведение @code{my_list_to_vector} субоптимально когда список\n"
"(@var{list}) действительно асинхронно удлинняется или укорачивается в \n"
"другом потоке. Но он рабочий: он всегда будет возвращать действительный\n"
"вектор. Этот вектор может быть короче чем ожидалось, или его последние\n"
"элементы будут не указаны, но это действительный вектор, и если программа\n"
"хочет исключить эти случаи, она должна избегать асинхронного изменения \n"
"списка."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:557
msgid "Here is another version that is also correct:"
msgstr "Вот еще одна правильная версия:"

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:564
msgid ""
"@example\n"
"SCM\n"
"my_pedantic_list_to_vector (SCM list)\n"
"@{\n"
"  SCM vector = scm_make_vector (scm_length (list), SCM_UNDEFINED);\n"
"  size_t len, i;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:573
msgid ""
"  len = scm_c_vector_length (vector);\n"
"  i = 0;\n"
"  while (i < len)\n"
"    @{\n"
"      scm_c_vector_set_x (vector, i, scm_car (list));\n"
"      list = scm_cdr (list);\n"
"      i++;\n"
"    @}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:577
msgctxt "/home/bear/work/guile/doc/guile/en/libguile-concepts.texi:577"
msgid ""
"  return vector;\n"
"@}\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:582
msgid ""
"This version relies on the error-checking behavior of @code{scm_car} and\n"
"@code{scm_cdr}.  When the list is shortened (that is, when @var{list}\n"
"holds a non-pair), @code{scm_car} will throw an error.  This might be\n"
"preferable to just returning a half-initialized vector."
msgstr ""
"Эта версия основана на проверке ошибок @code{scm_car} и @code{scm_cdr}.\n"
"Когда список сокращается(т.е когда список( @var{list}) содержит не пары),\n"
" @code{scm_car} выдает ошибку. В этом случае предпочтительнее просто\n"
"вернуть полуинициализированный вектор."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:596
msgid ""
"The API for accessing vectors and arrays of various kinds from C takes a\n"
"slightly different approach to thread-robustness.  In order to get at\n"
"the raw memory that stores the elements of an array, you need to\n"
"@emph{reserve} that array as long as you need the raw memory.  During\n"
"the time an array is reserved, its elements can still spontaneously\n"
"change their values, but the memory itself and other things like the\n"
"size of the array are guaranteed to stay fixed.  Any operation that\n"
"would change these parameters of an array that is currently reserved\n"
"will signal an error.  In order to avoid these errors, a program should\n"
"of course put suitable synchronization mechanisms in place.  As you can\n"
"see, Guile itself is again only concerned about robustness, not about\n"
"correctness: without proper synchronization, your program will likely\n"
"not be correct, but the worst consequence is an error message."
msgstr ""
"API для доступа к векторам и массивам различных типов из Си имеет\n"
"несколько иной подход к обеспечению потоковой устойчивости.  Чтобы \n"
"получить необработанную(сырую) память, в которой храняться элементы\n"
"массива, вам нужно зарезервировать этот массив(@emph{reserve}), если\n"
"вам нужна необработанная память. В течении времени хранения массива, \n"
"его элементы могут спонтанно изменять свои значения, но сама память\n"
"и другие вещи, такие как размер массива, гарантированно остаются\n"
"фиксированными. Любая операция, которая изменяет эти параметры массива,\n"
"который в настоящее время зарезервирован, будет сигнализировать об ошибке.\n"
"Чтобы измежать этих ошибок, программа должна, конечно иметь механизмы\n"
"синхронизации. Как вы можете видеть, сам Guile беспокоиться о надежности,\n"
"а не о правильности: без правильной синхронизации ваша программа скорее "
"всего\n"
"не будет правильной, но худшим последствием будет сообщение об ошибке."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:606
msgid ""
"Real thread-safety often requires that a critical section of code is\n"
"executed in a certain restricted manner.  A common requirement is that\n"
"the code section is not entered a second time when it is already being\n"
"executed.  Locking a mutex while in that section ensures that no other\n"
"thread will start executing it, blocking asyncs ensures that no\n"
"asynchronous code enters the section again from the current thread, and\n"
"the error checking of Guile mutexes guarantees that an error is\n"
"signalled when the current thread accidentally reenters the critical\n"
"section via recursive function calls."
msgstr ""
"Реальная потоко-безопасность часто требует, чтобы критический раздел кода\n"
"выполнялся в определенной ограничивающей манере. Общим требованием является\n"
"то, что в раздел кода не входит второй поток управления во то время когда "
"он\n"
"уже выполняется. Блокировка мьютекса в этом разделе обеспечивает, что\n"
"никакаой другой поток не начнет ее выполнять, блокировка "
"асинхронности(asyncs)\n"
"гарантирует блокировку асинхронного кода снова входящего в раздел текущего\n"
"потока, а проверка ошибок мьютексов Guile гарантирует, что ошибка "
"сигнализируется,\n"
"когда текущий поток случайно возвращается в критический раздел через "
"рекурсивные\n"
"вызовы функций."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:612
msgid ""
"Guile provides two mechanisms to support critical sections as outlined\n"
"above.  You can either use the macros\n"
"@code{SCM_CRITICAL_SECTION_START} and @code{SCM_CRITICAL_SECTION_END}\n"
"for very simple sections; or use a dynwind context together with a\n"
"call to @code{scm_dynwind_critical_section}."
msgstr ""
"Guile предоставляет два механизма для поддержки критических разеделов, как\n"
"описано выше. Вы можете использовать макросы "
"@code{SCM_CRITICAL_SECTION_START}\n"
"и @code{SCM_CRITICAL_SECTION_END} для очень простых разделов; или "
"использовать\n"
"контекст dynwind вместе с вызовом @code{scm_dynwind_critical_section}."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:619
msgid ""
"The macros only work reliably for critical sections that are\n"
"guaranteed to not cause a non-local exit.  They also do not detect an\n"
"accidental reentry by the current thread.  Thus, you should probably\n"
"only use them to delimit critical sections that do not contain calls\n"
"to libguile functions or to other external functions that might do\n"
"complicated things."
msgstr ""
"Макросы работают надежно только для критических секций, которые "
"гарантированно\n"
"не содержат нелокальный выход. Они также не обнаруживают случайный "
"повторный\n"
"вход в текущем потоке. Таким образом, вы, вероятно должны использовать их "
"только\n"
"для разделения критических разделов, которые не содержат вызовов функций\n"
"libguile или других внешних функций, которые могут выполнять сложные вещи."

#: /home/bear/work/guile/doc/guile/en/libguile-concepts.texi:623
msgid ""
"The function @code{scm_dynwind_critical_section}, on the other hand,\n"
"will correctly deal with non-local exits because it requires a dynwind\n"
"context.  Also, by using a separate mutex for each critical section,\n"
"it can detect accidental reentries."
msgstr ""
"С другой стороны, функция @code{scm_dynwind_critical_section} будет "
"правильно\n"
"решать работу с нелокальными выходами, поскольку они требуют контекста "
"dynwind.\n"
"Кроме того, используя отдельный мьютекс для каждого критического участка он "
"может\n"
"обнаруживать случайные повторные попытки входа в критическую секцию."
