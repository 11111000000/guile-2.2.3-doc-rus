#
# NuINu <don't@send.my>, 2018.
#
#. extracted from /home/bear/work/guile/doc/guile/en/api-smobs.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-07 12:37+0300\n"
"PO-Revision-Date: 2018-12-25 10:45+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2009, 2013, "
"2014\n"
"@c   Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:9
msgid ""
"@node Smobs\n"
"@section Smobs"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:11
msgid "@cindex smob"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:19
msgid ""
"A @dfn{smob} is a ``small object''.  Before foreign objects were\n"
"introduced in Guile 2.0.12 (@pxref{Foreign Objects}), smobs were the\n"
"preferred way to for C code to define new kinds of Scheme objects.  With\n"
"the exception of the so-called ``applicable SMOBs'' discussed below,\n"
"smobs are now a legacy interface and are headed for eventual\n"
"deprecation.  @xref{Deprecation}.  New code should use the foreign\n"
"object interface."
msgstr ""
"@dfn{smob} это ``маленький объект(small object)''.  Прежде чем были введены\n"
"внешние объекты в Guile 2.0.12 (@pxref{Foreign Objects}), smobs были "
"предпочтительным\n"
"способом для Си кода для определения новых объектов Scheme.  За исключением\n"
"так называемых  ``применимых(applicable) SMOBs'' обсуждаемых ниже,\n"
"smobs теперь являются устаревшим интерфейсом и могут быть исключены из "
"использования.\n"
"@xref{Deprecation}.  Новый код должен использовать интерфейс внешних "
"объектов."

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:23
msgid ""
"This section contains reference information related to defining and\n"
"working with smobs.  For a tutorial-like introduction to smobs, see\n"
"``Defining New Types (Smobs)'' in previous versions of this manual."
msgstr ""
"Этот раздел содержит справочную информацию касающуюся определения и работы\n"
"со smobs.  Похожее на учебник введение в smobs, можно уведеть в\n"
"``Defining New Types (Smobs)'' в предыдущей версии данного руководства."

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:28
msgid ""
"@deftypefun scm_t_bits scm_make_smob_type (const char *name, size_t size)\n"
"This function adds a new smob type, named @var{name}, with instance size\n"
"@var{size}, to the system.  The return value is a tag that is used in\n"
"creating instances of the type."
msgstr ""
"@deftypefun scm_t_bits scm_make_smob_type (const char *name, size_t size)\n"
"Эта функция добавляет новый тип smob, с именем @var{name}, с размером "
"экземпляра\n"
"@var{size}, в систему.  Возвращаемое значение - это тег(метка) который "
"используется\n"
"для создания экземпляра данного типа."

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:30
msgid "If @var{size} is 0, the default @emph{free} function will do nothing."
msgstr ""
"Если @var{size} равно 0, функция по умолчнанию @emph{free} ничего не делает."

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:35
msgid ""
"If @var{size} is not 0, the default @emph{free} function will\n"
"deallocate the memory block pointed to by @code{SCM_SMOB_DATA} with\n"
"@code{scm_gc_free}.  The @var{what} parameter in the call to\n"
"@code{scm_gc_free} will be @var{name}."
msgstr ""
"Если @var{size} не равно 0, функция по умолчанию @emph{free} освобождает\n"
"блок памяти на который указывает @code{SCM_SMOB_DATA} с помощью\n"
"@code{scm_gc_free}.  Параметром @var{what} в вызове\n"
"@code{scm_gc_free} будет @var{name}."

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:43
msgid ""
"Default values are provided for the @emph{mark}, @emph{free},\n"
"@emph{print}, and @emph{equalp} functions.  If you want to customize any\n"
"of these functions, the call to @code{scm_make_smob_type} should be\n"
"immediately followed by calls to one or several of\n"
"@code{scm_set_smob_mark}, @code{scm_set_smob_free},\n"
"@code{scm_set_smob_print}, and/or @code{scm_set_smob_equalp}.\n"
"@end deftypefun"
msgstr ""
"Значения по умолчанию предоставляются для функций @emph{mark}, @emph{free},\n"
"@emph{print}, и @emph{equalp}.  Если вы хотите настроить любую из этих\n"
"функций, вызов @code{scm_make_smob_type} должен немедленно\n"
"сопровождаться вызовом одной или нескольких функций\n"
"@code{scm_set_smob_mark}, @code{scm_set_smob_free},\n"
"@code{scm_set_smob_print}, и/или @code{scm_set_smob_equalp}.\n"
"@end deftypefun"

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:46
msgid ""
"@cindex finalizer\n"
"@cindex finalization"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:51
msgid ""
"@deftypefn {C Function} void scm_set_smob_free (scm_t_bits tc, size_t "
"(*free) (SCM obj))\n"
"This function sets the smob freeing procedure (sometimes referred to as\n"
"a @dfn{finalizer}) for the smob type specified by the tag\n"
"@var{tc}. @var{tc} is the tag returned by @code{scm_make_smob_type}."
msgstr ""
"@deftypefn {C Function} void scm_set_smob_free (scm_t_bits tc, size_t "
"(*free) (SCM obj))\n"
"Эта функция устанавливает процедуру освобождения smob (иногда называемую "
"финализатором\n"
"a @dfn{finalizer}) для типаe smob указываемого тегом\n"
"@var{tc}. @var{tc} это тег, возвращаемый процедурой "
"@code{scm_make_smob_type}."

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:56
msgid ""
"The @var{free} procedure must deallocate all resources that are\n"
"directly associated with the smob instance @var{obj}.  It must assume\n"
"that all @code{SCM} values that it references have already been freed\n"
"and are thus invalid."
msgstr ""
"Процедура @var{free} должна освобождать все ресурсы, которые напрямую\n"
"связаны с экземпляром smob объекта @var{obj}.  Она должна предполагать,\n"
"что все значения @code{SCM} на которые он ссылается, уже были осовбождены и\n"
"таким образом, являются недействительными."

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:60
msgid ""
"It must also not call any libguile function or macro except\n"
"@code{scm_gc_free}, @code{SCM_SMOB_FLAGS}, @code{SCM_SMOB_DATA},\n"
"@code{SCM_SMOB_DATA_2}, and @code{SCM_SMOB_DATA_3}."
msgstr ""
"Она также не должна вызывать никакую функцию или макрос libguile, кроме\n"
"@code{scm_gc_free}, @code{SCM_SMOB_FLAGS}, @code{SCM_SMOB_DATA},\n"
"@code{SCM_SMOB_DATA_2}, и @code{SCM_SMOB_DATA_3}."

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:62
msgid "The @var{free} procedure must return 0."
msgstr "процедура @var{free} должна возвращать 0."

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:69
msgid ""
"Note that defining a freeing procedure is not necessary if the resources\n"
"associated with @var{obj} consists only of memory allocated with\n"
"@code{scm_gc_malloc} or @code{scm_gc_malloc_pointerless} because this\n"
"memory is automatically reclaimed by the garbage collector when it is no\n"
"longer needed (@pxref{Memory Blocks, @code{scm_gc_malloc}}).\n"
"@end deftypefn"
msgstr ""
"Обратите внимание, что определение процедуры осовбождения не требуется,\n"
"если ресурсы связанные с @var{obj} состоят только из памяти выделенной с\n"
"помощью @code{scm_gc_malloc} или @code{scm_gc_malloc_pointerless}, потому "
"что\n"
"эта память автоматически возвращается сборщиком мусора, когда она больше не "
"нужна\n"
"(@pxref{Memory Blocks, @code{scm_gc_malloc}}).\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:76
msgid ""
"Smob free functions must be thread-safe.  @xref{Foreign Object Memory\n"
"Management}, for a discussion on finalizers and concurrency.  If you are\n"
"embedding Guile in an application that is not thread-safe, and you\n"
"define smob types that need finalization, you might want to disable\n"
"automatic finalization, and arrange to call\n"
"@code{scm_manually_run_finalizers ()} yourself.  @xref{Foreign Objects}."
msgstr ""
"Функции освобождения Smob должны быть потоко-безопасными.  @xref{Foreign "
"Object Memory\n"
"Management}, для обсуждения финализаторов и параллелелизма.  Если вы\n"
"встраиваете Guile в приложение которое не является потокобезопасным, и вы\n"
"определяете smob типы которые нуждаются в финализации, вы можете отключить "
"автоматическую\n"
"финализацию, и организовать вызов @code{scm_manually_run_finalizers ()} "
"самостоятельно.\n"
"@xref{Foreign Objects}."

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:80
msgid ""
"@deftypefn {C Function} void scm_set_smob_mark (scm_t_bits tc, SCM (*mark) "
"(SCM obj))\n"
"This function sets the smob marking procedure for the smob type specified "
"by\n"
"the tag @var{tc}. @var{tc} is the tag returned by @code{scm_make_smob_type}."
msgstr ""
"@deftypefn {C Function} void scm_set_smob_mark (scm_t_bits tc, SCM (*mark) "
"(SCM obj))\n"
"Эта процедура устанавливает процедуру маркировки(отметки) smob для типа "
"smob, указываемого\n"
"тегом @var{tc}. @var{tc} это тег возвращаемый @code{scm_make_smob_type}."

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:85
msgid ""
"Defining a marking procedure is almost always the wrong thing to do.  It\n"
"is much, much preferable to allocate smob data with the\n"
"@code{scm_gc_malloc} and @code{scm_gc_malloc_pointerless} functions, and\n"
"allow the GC to trace pointers automatically."
msgstr ""
"Определение процедуры маркировки почти всегда НЕПРАВИЛЬНО! Это излишне,\n"
"гораздо предпочтительнее выделять данные для smob с помощью функций\n"
"@code{scm_gc_malloc} и @code{scm_gc_malloc_pointerless}, и позволять\n"
"Сборщику мусора(GC) отслеживать указатели автоматически."

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:90
msgid ""
"Any mark procedures you see currently almost surely date from the time\n"
"of Guile 1.8, before the switch to the Boehm-Demers-Weiser collector.\n"
"Such smob implementations should be changed to just use\n"
"@code{scm_gc_malloc} and friends, and to lose their mark function."
msgstr ""
"Любые процедуры маркировки, которые вы видите в настоящее время, почти\n"
"навенряка датируются временем Guile 1.8, перед переходом на сборщик\n"
"мусора Boehm-Demers-Weiser.\n"
"Такие реализации smob следует изменить, чтобы просто использовать\n"
"@code{scm_gc_malloc} и друзей, и забыть про свою функцию маркировки."

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:94
msgid ""
"If you decide to keep the mark function, note that it may be called on\n"
"objects that are on the free list.  Please read and digest the comments\n"
"from the BDW GC's @code{gc/gc_mark.h} header."
msgstr ""
"Если вы решили сохранить функцию маркировки, обратите внимание, что она\n"
"вызвается для объектов, которые находятся в списке освобождения(free list).\n"
"Пожалуйста почитайте комментарии от BDW GC's заголовка @code{gc/gc_mark.h}."

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:101
msgid ""
"The @var{mark} procedure must cause @code{scm_gc_mark} to be called\n"
"for every @code{SCM} value that is directly referenced by the smob\n"
"instance @var{obj}.  One of these @code{SCM} values can be returned\n"
"from the procedure and Guile will call @code{scm_gc_mark} for it.\n"
"This can be used to avoid deep recursions for smob instances that form\n"
"a list."
msgstr ""
"Процедура @var{mark} должна вызывать @code{scm_gc_mark} для каждого\n"
"значения @code{SCM} которое напрямую ссылается на ыьщи экземпляр @var{obj}.\n"
"Одно из этих значений @code{SCM} может быть возвращено из процедуры и\n"
"Guile вызовет @code{scm_gc_mark} для него.\n"
"Это можно использовать для того чтобы избежать глубокой рекурсиии для\n"
"экземпляров smob которые формируют список."

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:106
msgid ""
"It must not call any libguile function or macro except\n"
"@code{scm_gc_mark}, @code{SCM_SMOB_FLAGS}, @code{SCM_SMOB_DATA},\n"
"@code{SCM_SMOB_DATA_2}, and @code{SCM_SMOB_DATA_3}.\n"
"@end deftypefn"
msgstr ""
"Она не должна вызывать никаких функций или макросов libguile, кроме\n"
"@code{scm_gc_mark}, @code{SCM_SMOB_FLAGS}, @code{SCM_SMOB_DATA},\n"
"@code{SCM_SMOB_DATA_2}, и @code{SCM_SMOB_DATA_3}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:112
msgid ""
"@deftypefn {C Function} void scm_set_smob_print (scm_t_bits tc, int (*print) "
"(SCM obj, SCM port, scm_print_state* pstate))\n"
"This function sets the smob printing procedure for the smob type\n"
"specified by the tag @var{tc}. @var{tc} is the tag returned by\n"
"@code{scm_make_smob_type}."
msgstr ""
"@deftypefn {C Function} void scm_set_smob_print (scm_t_bits tc, int (*print) "
"(SCM obj, SCM port, scm_print_state* pstate))\n"
"Эта функция устанавливает процедуру печати smob для данного типа smob \n"
"определяемого тегом @var{tc}. @var{tc} это тег возвращаемый процедурой\n"
"регистрации типа @code{scm_make_smob_type}."

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:116
msgid ""
"The @var{print} procedure should output a textual representation of\n"
"the smob instance @var{obj} to @var{port}, using information in\n"
"@var{pstate}."
msgstr ""
"Процедура печати @var{print} должна вывести текстовое представление "
"экземпляра\n"
"smob @var{obj} в порт @var{port}, используя инофрмацию в\n"
"@var{pstate}."

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:120
msgid ""
"The textual representation should be of the form @code{#<name ...>}.\n"
"This ensures that @code{read} will not interpret it as some other\n"
"Scheme value."
msgstr ""
"Текстовое представление должно иметь форму @code{#<name ...>}.\n"
"Это гарантирует, что команда чтения @code{read} не будет интерпретировать "
"его\n"
"как какое либо другое значение Scheme."

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:125
msgid ""
"It is often best to ignore @var{pstate} and just print to @var{port}\n"
"with @code{scm_display}, @code{scm_write}, @code{scm_simple_format},\n"
"and @code{scm_puts}.\n"
"@end deftypefn"
msgstr ""
"Часто лучше игнорировать @var{pstate} и просто печатать в порь @var{port}\n"
"с помощью @code{scm_display}, @code{scm_write}, @code{scm_simple_format},\n"
"и @code{scm_puts}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:130
msgid ""
"@deftypefn {C Function} void scm_set_smob_equalp (scm_t_bits tc, SCM "
"(*equalp) (SCM obj1, SCM obj2))\n"
"This function sets the smob equality-testing predicate for the smob\n"
"type specified by the tag @var{tc}. @var{tc} is the tag returned by\n"
"@code{scm_make_smob_type}."
msgstr ""
"@deftypefn {C Function} void scm_set_smob_equalp (scm_t_bits tc, SCM "
"(*equalp) (SCM obj1, SCM obj2))\n"
"Эта функция устанавливает предикат проверки равенства объектов для типа "
"smob,\n"
"указанного тегом @var{tc}. @var{tc} это тег возвращаемый\n"
"@code{scm_make_smob_type}."

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:136
msgid ""
"The @var{equalp} procedure should return @code{SCM_BOOL_T} when\n"
"@var{obj1} is @code{equal?} to @var{obj2}.  Else it should return\n"
"@code{SCM_BOOL_F}.  Both @var{obj1} and @var{obj2} are instances of the\n"
"smob type @var{tc}.\n"
"@end deftypefn"
msgstr ""
"Процедура @var{equalp} должна возвращать @code{SCM_BOOL_T} когда объект\n"
"@var{obj1} равен @code{equal?} объекту @var{obj2}.  Иначе она должна "
"вернуть\n"
"@code{SCM_BOOL_F}.  Оба объекта @var{obj1} и @var{obj2} являются "
"экземплярами\n"
"типа smob с тегом @var{tc}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:141
msgid ""
"@deftypefn {C Function} void scm_assert_smob_type (scm_t_bits tag, SCM val)\n"
"When @var{val} is a smob of the type indicated by @var{tag}, do nothing.\n"
"Else, signal an error.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Function} void scm_assert_smob_type (scm_t_bits tag, SCM val)\n"
"Когда @var{val} является типом smob с указанным тегом @var{tag}, ничего не "
"делает.\n"
"Иначе, сигнализирует об ошибке.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:147
msgid ""
"@deftypefn {C Macro} int SCM_SMOB_PREDICATE (scm_t_bits tag, SCM exp)\n"
"Return true if @var{exp} is a smob instance of the type indicated by\n"
"@var{tag}, or false otherwise.  The expression @var{exp} can be\n"
"evaluated more than once, so it shouldn't contain any side effects.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Macro} int SCM_SMOB_PREDICATE (scm_t_bits tag, SCM exp)\n"
"Возращает истину если @var{exp} является экземпляром smob типа, "
"указываемого\n"
"тегом @var{tag}, или ложь в противном случае.  Выражение @var{exp} может "
"быть\n"
"вычислено больше одного раза, поэтому оно не должно содержать никаких "
"сторонних\n"
"эффектов(типа вывода на дисплей).\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:152
msgid ""
"@deftypefn {C Function} SCM scm_new_smob (scm_t_bits tag, void *data)\n"
"@deftypefnx {C Function} SCM scm_new_double_smob (scm_t_bits tag, void "
"*data, void *data2, void *data3)\n"
"Make a new smob of the type with tag @var{tag} and smob data @var{data},\n"
"@var{data2}, and @var{data3}, as appropriate."
msgstr ""
"@deftypefn {C Function} SCM scm_new_smob (scm_t_bits tag, void *data)\n"
"@deftypefnx {C Function} SCM scm_new_double_smob (scm_t_bits tag, void "
"*data, void *data2, void *data3)\n"
"Создает новый объект smob типа указываемого тэгом @var{tag} и данными smob - "
"@var{data},\n"
"@var{data2}, и @var{data3}, соответственно."

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:158
msgid ""
"The @var{tag} is what has been returned by @code{scm_make_smob_type}.\n"
"The initial values @var{data}, @var{data2}, and @var{data3} are of\n"
"type @code{scm_t_bits}; when you want to use them for @code{SCM}\n"
"values, these values need to be converted to a @code{scm_t_bits} first\n"
"by using @code{SCM_UNPACK}."
msgstr ""
"Тэг @var{tag} это то что было возвращено @code{scm_make_smob_type}.\n"
"Начальные значения @var{data}, @var{data2}, и @var{data3} имеют\n"
"тип @code{scm_t_bits}; когда вы хотите использовать их как значения "
"@code{SCM},\n"
"эти значения должны быть сначала преобразованы в @code{scm_t_bits} с "
"помощью\n"
"@code{SCM_UNPACK}."

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:161
msgid ""
"The flags of the smob instance start out as zero.\n"
"@end deftypefn"
msgstr ""
"Флаги экземпляра smob начинаются с нуля.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:166
msgid ""
"@deftypefn {C Macro} scm_t_bits SCM_SMOB_FLAGS (SCM obj)\n"
"Return the 16 extra bits of the smob @var{obj}.  No meaning is\n"
"predefined for these bits, you can use them freely.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Macro} scm_t_bits SCM_SMOB_FLAGS (SCM obj)\n"
"Возвращает дополнительные 16 бит объекта smob @var{obj}.  Для этих битов\n"
"не определено никакого значения, вы можете их свободно использовать.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:171
msgid ""
"@deftypefn {C Macro} scm_t_bits SCM_SET_SMOB_FLAGS (SCM obj, scm_t_bits "
"flags)\n"
"Set the 16 extra bits of the smob @var{obj} to @var{flags}.  No\n"
"meaning is predefined for these bits, you can use them freely.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Macro} scm_t_bits SCM_SET_SMOB_FLAGS (SCM obj, scm_t_bits "
"flags)\n"
"Устанавливает дополнительные 16 бит smob объекта @var{obj} в @var{flags}.  "
"Нет\n"
"предопределенного назначения для этих бит, вы можете свободно их "
"использовать.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:179
msgid ""
"@deftypefn {C Macro} scm_t_bits SCM_SMOB_DATA (SCM obj)\n"
"@deftypefnx {C Macro} scm_t_bits SCM_SMOB_DATA_2 (SCM obj)\n"
"@deftypefnx {C Macro} scm_t_bits SCM_SMOB_DATA_3 (SCM obj)\n"
"Return the first (second, third) immediate word of the smob @var{obj}\n"
"as a @code{scm_t_bits} value.  When the word contains a @code{SCM}\n"
"value, use @code{SCM_SMOB_OBJECT} (etc.) instead.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Macro} scm_t_bits SCM_SMOB_DATA (SCM obj)\n"
"@deftypefnx {C Macro} scm_t_bits SCM_SMOB_DATA_2 (SCM obj)\n"
"@deftypefnx {C Macro} scm_t_bits SCM_SMOB_DATA_3 (SCM obj)\n"
"Возвращает первое (второе, третье) непосредственное слово в smob объекте "
"@var{obj}\n"
"как значение @code{scm_t_bits}.  Если слово содержит значение @code{SCM},\n"
"используйте вместо них @code{SCM_SMOB_OBJECT} (и т.д.).\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:187
msgid ""
"@deftypefn {C Macro} void SCM_SET_SMOB_DATA (SCM obj, scm_t_bits val)\n"
"@deftypefnx {C Macro} void SCM_SET_SMOB_DATA_2 (SCM obj, scm_t_bits val)\n"
"@deftypefnx {C Macro} void SCM_SET_SMOB_DATA_3 (SCM obj, scm_t_bits val)\n"
"Set the first (second, third) immediate word of the smob @var{obj} to\n"
"@var{val}.  When the word should be set to a @code{SCM} value, use\n"
"@code{SCM_SMOB_SET_OBJECT} (etc.) instead.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Macro} void SCM_SET_SMOB_DATA (SCM obj, scm_t_bits val)\n"
"@deftypefnx {C Macro} void SCM_SET_SMOB_DATA_2 (SCM obj, scm_t_bits val)\n"
"@deftypefnx {C Macro} void SCM_SET_SMOB_DATA_3 (SCM obj, scm_t_bits val)\n"
"Устанавливает первое(второе, третье) непосредственное слово в smob объекте "
"@var{obj}\n"
"в значение @var{val}.  Когда слово должно быть установлено значение "
"@code{SCM}, используйте\n"
"вместо них @code{SCM_SMOB_SET_OBJECT} (и т.д.).\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:195
msgid ""
"@deftypefn {C Macro} SCM SCM_SMOB_OBJECT (SCM obj)\n"
"@deftypefnx {C Macro} SCM SCM_SMOB_OBJECT_2 (SCM obj)\n"
"@deftypefnx {C Macro} SCM SCM_SMOB_OBJECT_3 (SCM obj)\n"
"Return the first (second, third) immediate word of the smob @var{obj}\n"
"as a @code{SCM} value.  When the word contains a @code{scm_t_bits}\n"
"value, use @code{SCM_SMOB_DATA} (etc.) instead.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Macro} SCM SCM_SMOB_OBJECT (SCM obj)\n"
"@deftypefnx {C Macro} SCM SCM_SMOB_OBJECT_2 (SCM obj)\n"
"@deftypefnx {C Macro} SCM SCM_SMOB_OBJECT_3 (SCM obj)\n"
"Возвращает первое (второе, третье) непосредственное слово smob объекта "
"@var{obj}\n"
"как значение @code{SCM}.  Когда слово содержит значение @code{scm_t_bits}\n"
"используйте вместо них @code{SCM_SMOB_DATA} (и т.д.).\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:203
msgid ""
"@deftypefn {C Macro} void SCM_SET_SMOB_OBJECT (SCM obj, SCM val)\n"
"@deftypefnx {C Macro} void SCM_SET_SMOB_OBJECT_2 (SCM obj, SCM val)\n"
"@deftypefnx {C Macro} void SCM_SET_SMOB_OBJECT_3 (SCM obj, SCM val)\n"
"Set the first (second, third) immediate word of the smob @var{obj} to\n"
"@var{val}.  When the word should be set to a @code{scm_t_bits} value, use\n"
"@code{SCM_SMOB_SET_DATA} (etc.) instead.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Macro} void SCM_SET_SMOB_OBJECT (SCM obj, SCM val)\n"
"@deftypefnx {C Macro} void SCM_SET_SMOB_OBJECT_2 (SCM obj, SCM val)\n"
"@deftypefnx {C Macro} void SCM_SET_SMOB_OBJECT_3 (SCM obj, SCM val)\n"
"Устанавливает первое (второе, третье) непосредственное слово smob объекта "
"@var{obj}\n"
"в значение @var{val}.  Когда слово должно быть установлено значением "
"@code{scm_t_bits}, \n"
"используйте вместо них @code{SCM_SMOB_SET_DATA} (и т.д.)\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:212
msgid ""
"@deftypefn {C Macro} {SCM *} SCM_SMOB_OBJECT_LOC (SCM obj)\n"
"@deftypefnx {C Macro} {SCM *} SCM_SMOB_OBJECT_2_LOC (SCM obj)\n"
"@deftypefnx {C Macro} {SCM *} SCM_SMOB_OBJECT_3_LOC (SCM obj)\n"
"Return a pointer to the first (second, third) immediate word of the\n"
"smob @var{obj}.  Note that this is a pointer to @code{SCM}.  If you\n"
"need to work with @code{scm_t_bits} values, use @code{SCM_PACK} and\n"
"@code{SCM_UNPACK}, as appropriate.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Macro} {SCM *} SCM_SMOB_OBJECT_LOC (SCM obj)\n"
"@deftypefnx {C Macro} {SCM *} SCM_SMOB_OBJECT_2_LOC (SCM obj)\n"
"@deftypefnx {C Macro} {SCM *} SCM_SMOB_OBJECT_3_LOC (SCM obj)\n"
"Возвращает указатель на первое (второе, третье) непосредственное слово в\n"
"smob объекте @var{obj}.  Заметьте что это указатель на @code{SCM}.  Если\n"
"вам нужно работать со значением @code{scm_t_bits}, используйте "
"@code{SCM_PACK} и\n"
"@code{SCM_UNPACK}, в зависимости от ситуации.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:218
msgid ""
"@deftypefun SCM scm_markcdr (SCM @var{x})\n"
"Mark the references in the smob @var{x}, assuming that @var{x}'s first\n"
"data word contains an ordinary Scheme object, and @var{x} refers to no\n"
"other objects.  This function simply returns @var{x}'s first data word.\n"
"@end deftypefun"
msgstr ""
"@deftypefun SCM scm_markcdr (SCM @var{x})\n"
"Отмечает ссылку в smob @var{x}, предполагая что первое слово данных в "
"@var{x} содержит\n"
"обычный объект Scheme, а @var{x} не сссылается ни на какие другие объекты.\n"
"Эта функция просто возвращает первое слово данных @var{x}.\n"
"@end deftypefun"

#: /home/bear/work/guile/doc/guile/en/api-smobs.texi:221
msgid ""
"@c Local Variables:\n"
"@c TeX-master: \"guile.texi\"\n"
"@c End:"
msgstr ""
