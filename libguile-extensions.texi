@c -*-texinfo-*-
@c This is part of the GNU Guile Reference Manual.
@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2011
@c   Free Software Foundation, Inc.
@c See the file guile.texi for copying conditions.

@node Linking Guile with Libraries
@section Связывание Guile с Библиотеками

Предыдущий раздел кратко объяснил, как писать программы использующие
встроенный интерпретатор Guile.  Но иногда, все что вы хотите сделать,
это создать новую примитивную процедуру или тип данных доступным для
программиста Scheme.  Написание новой версии @code{guile} в этом случае
неудобно, и это сделает жизнь пользователей, вашей новой функции, без
необходимости, трудной.

Например, предположим есть программа @code{guile-db} которая явлляется
версией Guile с дополнительной функцией доступа к базам данных.
Людям, которые хотят писать программы Scheme для использования этих
функций придеся использовать @code{guile-db} вместо обычной программы
@code{guile}. Теперь предположим, что есть также программа 
@code{guile-gtk} которая расширяет Guile доступок к популярному
инструментарию Gtk+ для разработки графических интерфейсов.
Людям которые хотят писать GUI на Scheme придется использовать
@code{guile-gtk}.  Теперь, что произойдет когда вы захотите написать
приложение Scheme которое использует GUI чтобы предоставить пользователю
доступ к базе данных?  Вы должны были бы написать третью(@emph{third})
программу, которая включает в себя как базы данных, так и GUI.  Это
может быть не легко (поскольку, скажем, @code{guile-gtk} может быть довольно
непонятной программой) и этот пример дополнительно позволяет легко увидеть, что
этот подход не может работать на практике.

Было бы намного лучше, если бы функции базы данных, и функции GUI
были предоставлены в виде библиотек которые можно просто подсоединить к
@code{guile}.  Guile позволяет легко сделать это, и мы рекомендуем вам
делать ваши расширения  Guile доступными в виде библиотек, всякий раз,
когда это возможно.

Вы пишите новые примитивные процедуры и типы данных обычным способом, и
связываете их в общую(разделяемую) библиотеку, а не в отдельную программу.
Общая библиотека может затем динамически загружаться с помощью Guile.

@menu
* A Sample Guile Extension::
@end menu

@node A Sample Guile Extension
@subsection Пример Guile Расширения

В этом разделе объясняется, как сделать функцию Bessel из библиотеки на Си
доступной в Scheme.  Сначала нам нужно написать склеивающий код  для
преобразования аргументов и  возвращаемых значений из Scheme в Си и обратно.
Кроме того, нам нужна функция которая добавит наши функции к набору
примитивов Guile.  Поскольку это всего лишь пример, мы будем реализовывать
это только для функции @code{j0}.

Рассмотрим следующий файл @file{bessel.c}.

@smallexample
#include <math.h>
#include <libguile.h>

SCM
j0_wrapper (SCM x)
@{
  return scm_from_double (j0 (scm_to_double (x)));
@}

void
init_bessel ()
@{
  scm_c_define_gsubr ("j0", 1, 0, 0, j0_wrapper);
@}
@end smallexample

Этот исходный Си файл необходимо скомпилировать в разделяемую библиотеку. Вот как
это сделать на GNU/Linux:

@smallexample
gcc `pkg-config --cflags guile-@value{EFFECTIVE-VERSION}` \
  -shared -o libguile-bessel.so -fPIC bessel.c
@end smallexample

Для создания переносимых разделяемых библиотек, мы рекомендуем использовать
GNU Libtool (@pxref{Top, , Introduction, libtool, GNU Libtool}).

Разделяемая библиотека может быть загружена в работающий процесс Guile
с помощью функции @code{load-extension}.  В дополнении к имени библиотеки
для загрузки, эта функция также ожидает имя функции из этой библиотеки,
которая будет вызвана для ее инициализации.  Для нашего примера,
мы собираемся вызвать функцию @code{init_bessel} которая сделает
@code{j0_wrapper} доступной для программ Scheme с именем
@code{j0}.  Обратите внимание, что мы не указываем расширение в имени файла,
такое как @file{.so} при вызове @code{load-extension}.  Правильное расширение
для базовой платформы будет предоставлено автоматически.

@lisp
(load-extension "libguile-bessel" "init_bessel")
(j0 2)
@result{} 0.223890779141236
@end lisp

Конечно, чтобы это работало, @code{load-extension} должно быть в состоянии
найти @file{libguile-bessel}.  Оно будет искать в тех местах, которые являются
обчыными для вашей операционной системы, и будет дополнительно просматривать
директории перечисленные в переменной среды @code{LTDL_LIBRARY_PATH}.

Чтобы увидеть, как эти расширения Guile через разделяемые библиотеки относятся
к модульной системе, смотрите, @xref{Putting Extensions into Modules}.

@c Local Variables:
@c TeX-master: "guile.texi"
@c End: