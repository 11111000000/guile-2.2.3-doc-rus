#
# Gagin <mikhail-gagin@yandex.ru>, 2018.
# NuINu <don't@send.my>, 2018.
#
#. extracted from /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-07 12:37+0300\n"
"PO-Revision-Date: 2018-11-26 15:49+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2010, "
"2011, 2013, 2014\n"
"@c   Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:9
msgid ""
"@node Defining New Foreign Object Types\n"
"@section Defining New Foreign Object Types"
msgstr ""
"@node Defining New Foreign Object Types\n"
"@section Определение новых типов внешних объектов"

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:15
msgid ""
"The @dfn{foreign object type} facility is Guile's mechanism for\n"
"importing object and types from C or other languages into Guile's\n"
"system.  If you have a C @code{struct foo} type, for example, you can\n"
"define a corresponding Guile foreign object type that allows Scheme code\n"
"to handle @code{struct foo *} objects."
msgstr ""
"Тип внешних объектов(@dfn{foreign object type}) является механизмом Guile\n"
"для импорта объектов и типов из Си или других языков в систему Guile.\n"
"Если у вас есть Си тип @code{struct foo}, например, вы можете определить\n"
"соответствующий тип внешнего объекта Guile, который позволит обрабатывать\n"
"коду Scheme объекты указывающие @code{struct foo *}."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:21
msgid ""
"To define a new foreign object type, the programmer provides Guile with\n"
"some essential information about the type --- what its name is, how many\n"
"fields it has, and its finalizer (if any) --- and Guile allocates a\n"
"fresh type for it.  Foreign objects can be accessed from Scheme or from\n"
"C."
msgstr ""
"Чтобы определить новый тип внешних объектов, программист предоставляет "
"Guile\n"
"некоторую существенную информацию о типе --- какое у него имя, сколько у "
"него\n"
"полей, и есть ли финализатор (если есть) --- и Guile выделяет для него новый "
"тип\n"
"для него. Внешние объекты могут быть доступны из  Scheme или из Си."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:29
msgid ""
"@menu\n"
"* Defining Foreign Object Types::       \n"
"* Creating Foreign Objects::          \n"
"* Type Checking of Foreign Objects::                \n"
"* Foreign Object Memory Management::    \n"
"* Foreign Objects and Scheme::    \n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:32
msgid ""
"@node Defining Foreign Object Types\n"
"@subsection Defining Foreign Object Types"
msgstr ""
"@node Defining Foreign Object Types\n"
"@subsection Определение типов Внешних Объектов"

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:36
msgid ""
"To create a new foreign object type from C, call\n"
"@code{scm_make_foreign_object_type}.  It returns a value of type\n"
"@code{SCM} which identifies the new type."
msgstr ""
"Чтобы создать новый тип внешних объектов из Си, вызовите\n"
"@code{scm_make_foreign_object_type}.  Он возвращает значение типа\n"
"@code{SCM}, которое идентифицирует новый тип."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:39
msgid ""
"Here is how one might declare a new type representing eight-bit\n"
"gray-scale images:"
msgstr ""
"Вот как можно объявить новый тип, представляющий восьмибитные черно-белые\n"
"изображения:"

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:42
msgid ""
"@example\n"
"#include <libguile.h>"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:46
msgid ""
"struct image @{\n"
"  int width, height;\n"
"  char *pixels;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:49
msgid ""
"  /* The name of this image */\n"
"  SCM name;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:55
msgid ""
"  /* A function to call when this image is\n"
"     modified, e.g., to update the screen,\n"
"     or SCM_BOOL_F if no action necessary */\n"
"  SCM update_func;\n"
"@};"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:57
msgid "static SCM image_type image_type;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:63
msgid ""
"void\n"
"init_image_type (void)\n"
"@{\n"
"  SCM name, slots;\n"
"  scm_t_struct_finalize finalizer;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:67
msgid ""
"  name = scm_from_utf8_symbol (\"image\");\n"
"  slots = scm_list_1 (scm_from_utf8_symbol (\"data\"));\n"
"  finalizer = NULL;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:72
msgid ""
"  image_type =\n"
"    scm_make_foreign_object_type (name, slots, finalizer);\n"
"@}\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:76
msgid ""
"The result is an initialized @code{image_type} value that identifies the\n"
"new foreign object type.  The next section describes how to create\n"
"foreign objects and how to access their slots."
msgstr ""
"Результатом является инициализированное значение @code{image_type}, которое\n"
"идентифицирует новый тип внешних объектов. В следующем разделе описано, как\n"
"создавать внешние объекты и как обращаться к их слотам."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:80
msgid ""
"@node Creating Foreign Objects\n"
"@subsection Creating Foreign Objects"
msgstr ""
"@node Creating Foreign Objects\n"
"@subsection Создание Внешних Объектов"

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:84
msgid ""
"Foreign objects contain zero or more ``slots'' of data.  A slot can hold\n"
"a pointer, an integer that fits into a @code{size_t} or @code{ssize_t},\n"
"or a @code{SCM} value."
msgstr ""
"Внешние объекты содержат ноль и более ``слотов'' данных.  Слот может "
"содержать\n"
"указатель, целое число которое вписывается в @code{size_t} или "
"@code{ssize_t},\n"
"или значение @code{SCM}."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:91
msgid ""
"All objects of a given foreign type have the same number of slots.  In\n"
"the example from the previous section, the @code{image} type has one\n"
"slot, because the slots list passed to\n"
"@code{scm_make_foreign_object_type} is of length one.  (The actual names\n"
"given to slots are unimportant for most users of the C interface, but\n"
"can be used on the Scheme side to introspect on the foreign object.)"
msgstr ""
"Все объекты данного типа внешних объектов имеют одинаковое количество\n"
"слотов. В примере из предыдущего раздела, тип изображение(@code{image})\n"
"имеет один слот, потому что список слотов переданый в "
"@code{scm_make_foreign_object_type}\n"
"имеет длину равную одному.  (Фактические имена , присвоенные слотам,\n"
"несущественны для большинства пользователей интерфейса Си, но могут быть\n"
"испльзованы на стороне  Scheme, чтобы осмотреть внешний объект.)"

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:98
msgid ""
"To construct a foreign object and initialize its first slot, call\n"
"@code{scm_make_foreign_object_1 (@var{type}, @var{first_slot_value})}.\n"
"There are similarly named constructors for initializing 0, 1, 2, or 3\n"
"slots, or initializing @var{n} slots via an array.  @xref{Foreign\n"
"Objects}, for full details.  Any fields that are not explicitly\n"
"initialized are set to 0."
msgstr ""
"Чтобы создать внешний объект и инициализировать его первый слот, вызовите\n"
"@code{scm_make_foreign_object_1 (@var{type}, @var{first_slot_value})}.\n"
"Аналогично вызываютсся конструкторы для инициализции 0, 1, 2, или 3\n"
"слотов, или инициализация @var{n} слотов через массив.  @xref{Foreign\n"
"Objects}, для получения полной информации. Любые поля, которые явно не \n"
"инициализированы, устанавливаются в 0."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:105
msgid ""
"To get or set the value of a slot by index, you can use the\n"
"@code{scm_foreign_object_ref} and @code{scm_foreign_object_set_x}\n"
"functions.  These functions take and return values as @code{void *}\n"
"pointers; there are corresponding convenience procedures like\n"
"@code{_signed_ref}, @code{_unsigned_set_x} and so on for dealing with\n"
"slots as signed or unsigned integers."
msgstr ""
"Чтобы получить или установить значение слота по индексу, вы можете \n"
"использовать функции @code{scm_foreign_object_ref} и "
"@code{scm_foreign_object_set_x}.\n"
"Эти функции принимают и возвращают значения как указатели @code{void *};\n"
"существуют процедуры для  доступа к слотам целых чисел со знаком и без "
"знака,\n"
"соответственно, такие как @code{_signed_ref} и @code{_unsigned_set_x}"

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:115
msgid ""
"Foreign objects fields that are pointers can be tricky to manage.  If\n"
"possible, it is best that all memory that is referenced by a foreign\n"
"object be managed by the garbage collector.  That way, the GC can\n"
"automatically ensure that memory is accessible when it is needed, and\n"
"freed when it becomes inaccessible.  If this is not the case for your\n"
"program -- for example, if you are exposing an object to Scheme that was\n"
"allocated by some other, Guile-unaware part of your program -- then you\n"
"will probably need to implement a finalizer.  @xref{Foreign Object\n"
"Memory Management}, for more."
msgstr ""
"Поля внешних объектов, которые являются указателями, могут быть сложными\n"
"для управления. Если возможно, лучше всего что бы вся память, на которую\n"
"ссылается внешний объект, управлялась сборщиком мусора. Такимо образом,\n"
"сборщик мусора может автоматически гарантировать доступность памяти, когда\n"
"это необходимо, и освобождать память, когда она становиться недоступной.\n"
"Если это не так для вашей программы - например, если вы предоставляете\n"
"объект Scheme который был выделен какой-либо другой не Guile частью вашей\n"
"программы -- тогда вам, вероятно, понадобиться реализовать финализатор.  \n"
"@xref{Foreign Object Memory Management}, для получения дополнительной "
"информации."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:121
msgid ""
"Continuing the example from the previous section, if the global variable\n"
"@code{image_type} contains the type returned by\n"
"@code{scm_make_foreign_object_type}, here is how we could construct a\n"
"foreign object whose ``data'' field contains a pointer to a freshly\n"
"allocated @code{struct image}:"
msgstr ""
"Продолжая пример из предыдущего раздела, если глобальная переменная\n"
"@code{image_type} содержит тип возвращаемый "
"@code{scm_make_foreign_object_type}, \n"
"вот как мы могли бы построить внешний объект, чье поле ``data'' содержит "
"указатель\n"
"на только что выделенную структуру @code{struct image}:"

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:129
msgid ""
"@example\n"
"SCM\n"
"make_image (SCM name, SCM s_width, SCM s_height)\n"
"@{\n"
"  struct image *image;\n"
"  int width = scm_to_int (s_width);\n"
"  int height = scm_to_int (s_height);"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:137
msgid ""
"  /* Allocate the `struct image'.  Because we\n"
"     use scm_gc_malloc, this memory block will\n"
"     be automatically reclaimed when it becomes\n"
"     inaccessible, and its members will be traced\n"
"     by the garbage collector.  */\n"
"  image = (struct image *)\n"
"    scm_gc_malloc (sizeof (struct image), \"image\");"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:140
msgid ""
"  image->width = width;\n"
"  image->height = height;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:149
msgid ""
"  /* Allocating the pixels with\n"
"     scm_gc_malloc_pointerless means that the\n"
"     pixels data is collectable by GC, but\n"
"     that GC shouldn't spend time tracing its\n"
"     contents for nested pointers because there\n"
"     aren't any.  */\n"
"  image->pixels =\n"
"    scm_gc_malloc_pointerless (width * height, \"image pixels\");"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:152
msgid ""
"  image->name = name;\n"
"  image->update_func = SCM_BOOL_F;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:158
msgid ""
"  /* Now wrap the struct image* in a new foreign\n"
"     object, and return that object.  */\n"
"  return scm_make_foreign_object_1 (image_type, image);\n"
"@}\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:165
msgid ""
"We use @code{scm_gc_malloc_pointerless} for the pixel buffer to tell the\n"
"garbage collector not to scan it for pointers.  Calls to\n"
"@code{scm_gc_malloc}, @code{scm_make_foreign_object_1}, and\n"
"@code{scm_gc_malloc_pointerless} raise an exception in out-of-memory\n"
"conditions; the garbage collector is able to reclaim previously\n"
"allocated memory if that happens."
msgstr ""
"Мы используем @code{scm_gc_malloc_pointerless} для буфера пикселей, чтобы\n"
"сообщить сборщику мусора не сканировать его на указатели. Вызов\n"
"@code{scm_gc_malloc}, @code{scm_make_foreign_object_1}, и\n"
"@code{scm_gc_malloc_pointerless} вызывает исключение в условиях отсутствия\n"
"памяти; сборщик мусора может вернуть ране выделенную память, если это\n"
"призойдет."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:169
msgid ""
"@node Type Checking of Foreign Objects\n"
"@subsection Type Checking of Foreign Objects"
msgstr ""
"@node Type Checking of Foreign Objects\n"
"@subsection Проверка Типа Внешнего Объекта"

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:173
msgid ""
"Functions that operate on foreign objects should check that the passed\n"
"@code{SCM} value indeed is of the correct type before accessing its\n"
"data.  They can do this with @code{scm_assert_foreign_object_type}."
msgstr ""
"Функции, работающие с внешними объектами, должны проверять, что принятое\n"
"@code{SCM} значение действительно правильного типа перед доступом к его\n"
"данным. Они могут сделать это с помощью "
"@code{scm_assert_foreign_object_type}."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:176
msgid ""
"For example, here is a simple function that operates on an image object,\n"
"and checks the type of its argument."
msgstr ""
"Например, вот простая функция, которая работает с объектом изображения и\n"
"проверяет тип своего аргумента."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:183
msgid ""
"@example\n"
"SCM\n"
"clear_image (SCM image_obj)\n"
"@{\n"
"  int area;\n"
"  struct image *image;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:185
msgid "  scm_assert_foreign_object_type (image_type, image_obj);"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:189
msgid ""
"  image = scm_foreign_object_ref (image_obj, 0);\n"
"  area = image->width * image->height;\n"
"  memset (image->pixels, 0, area);"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:193
msgid ""
"  /* Invoke the image's update function.  */\n"
"  if (scm_is_true (image->update_func))\n"
"    scm_call_0 (image->update_func);"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:197
msgid ""
"  return SCM_UNSPECIFIED;\n"
"@}\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:201
msgid ""
"@node Foreign Object Memory Management\n"
"@subsection Foreign Object Memory Management"
msgstr ""
"@node Foreign Object Memory Management\n"
"@subsection Управление памятью Внешних Объектов"

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:208
msgid ""
"Once a foreign object has been released to the tender mercies of the\n"
"Scheme system, it must be prepared to survive garbage collection.  In\n"
"the example above, all the memory associated with the foreign object is\n"
"managed by the garbage collector because we used the @code{scm_gc_}\n"
"allocation functions.  Thus, no special care must be taken: the garbage\n"
"collector automatically scans them and reclaims any unused memory."
msgstr ""
"После того как внешний объект был освобожден для системы Scheme, он\n"
"должен быть готов к сборке мусора.  В приведенном выше примере, вся память\n"
"связанная с внешним объектом, управляется сборщиком мусора, поскольку\n"
"мы использовали функции распределения памяти @code{scm_gc_}. \n"
"Таким образом, особого внимания не требуется: сборщик мусора автоматически\n"
"сканирует ее и восстанавливает неиспользуемую память."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:213
msgid ""
"However, when data associated with a foreign object is managed in some\n"
"other way---e.g., @code{malloc}'d memory or file descriptors---it is\n"
"possible to specify a @dfn{finalizer} function to release those\n"
"resources when the foreign object is reclaimed."
msgstr ""
"Однако, когда данные связанные с внешним объектом, управляются каким-либо "
"другим способом -\n"
"например, память выделяемая @code{malloc} или файловые дискрипторы--- для "
"них можно указать\n"
"функцию @dfn{finalizer} для освобождения этих ресурсов, когда внешний объект "
"будет утилизироваться."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:223
msgid ""
"As discussed in @pxref{Garbage Collection}, Guile's garbage collector\n"
"will reclaim inaccessible memory as needed.  This reclamation process\n"
"runs concurrently with the main program.  When Guile analyzes the heap\n"
"and determines that an object's memory can be reclaimed, that memory is\n"
"put on a ``free list'' of objects that can be reclaimed.  Usually that's\n"
"the end of it---the object is available for immediate re-use.  However\n"
"some objects can have ``finalizers'' associated with them---functions\n"
"that are called on reclaimable objects to effect any external cleanup\n"
"actions."
msgstr ""
"Как описано в разделе @pxref{Garbage Collection}, сборщик мусора Guile\n"
"при необходимости восстановит недоступную память. Этот процесс утилизации\n"
"выполняется одновременно с основной программой. Когда Guile анализирует\n"
"кучу и определяет, что память объекта может быть восстановлена, эта память\n"
"помещается в   ``список свободной памяти(free list)'' объектов, которые "
"могут\n"
"быть утилизированы. Обычно это его конец ---объект доступен для "
"немедленного\n"
"повторного использования.  Однако некоторые объекты могут иметь связанные с "
"ними\n"
"``финализаторы(finalizers)'' --- функции, которые вызываются для "
"утилизируемых\n"
"объектов для выполнения любых действий по внешней очистки."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:234
msgid ""
"Finalizers are tricky business and it is best to avoid them.  They can\n"
"be invoked at unexpected times, or not at all---for example, they are\n"
"not invoked on process exit.  They don't help the garbage collector do\n"
"its job; in fact, they are a hindrance.  Furthermore, they perturb the\n"
"garbage collector's internal accounting.  The GC decides to scan the\n"
"heap when it thinks that it is necessary, after some amount of\n"
"allocation.  Finalizable objects almost always represent an amount of\n"
"allocation that is invisible to the garbage collector.  The effect can\n"
"be that the actual resource usage of a system with finalizable objects\n"
"is higher than what the GC thinks it should be."
msgstr ""
"Финализаторы это сложная работа и лучше их избегать. Они могут быть вызваны\n"
"в неожиданное время, или вообще не вызваны --- например, они не вызываются\n"
"при завершении процесса.  Они не помогают сборщику мусора в его работе; на "
"самом\n"
"деле, они являются препятствием.  Кроме того, они нарушают внутренний учет\n"
"сборщика мусора. Сборщик мусора(GC) решает сканировать кучу, когда он "
"думает, что\n"
"это необходимо, после некоторого выделения. Финализируемые объекты всегда "
"представляют\n"
"собой некоторый выделенный объем, который невидим для сборщика мусора. "
"Эффект может заключаться\n"
"в том, что фактическое использование ресурсов системы с финализируемыми "
"объектами выше\n"
"чем предполагает о них сборщик мусора(GC)."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:239
msgid ""
"All those caveats aside, some foreign object types will need finalizers.\n"
"For example, if we had a foreign object type that wrapped file\n"
"descriptors---and we aren't suggesting this, as Guile already has ports\n"
"---then you might define the type like this:"
msgstr ""
"Все это оговорки в сторону, некоторые типы внешних объектов требуют "
"финализаторов.\n"
"Например, если у нас тип внешнего объекта, который являлся оберткой для "
"файлового\n"
"дескриптора--- и мы не предлагаем это, поскольку у Guile уже есть порты\n"
"---тогда вы можете определить этот тип следующим образом:"

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:242
msgid ""
"@example\n"
"static SCM file_type;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:253
msgid ""
"static void\n"
"finalize_file (SCM file)\n"
"@{\n"
"  int fd = scm_foreign_object_signed_ref (file, 0);\n"
"  if (fd >= 0)\n"
"    @{\n"
"      scm_foreign_object_signed_set_x (file, 0, -1);\n"
"      close (fd);\n"
"    @}\n"
"@}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:259
msgid ""
"static void\n"
"init_file_type (void)\n"
"@{\n"
"  SCM name, slots;\n"
"  scm_t_struct_finalize finalizer;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:263
msgid ""
"  name = scm_from_utf8_symbol (\"file\");\n"
"  slots = scm_list_1 (scm_from_utf8_symbol (\"fd\"));\n"
"  finalizer = finalize_file;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:267
msgid ""
"  image_type =\n"
"    scm_make_foreign_object_type (name, slots, finalizer);\n"
"@}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:274
msgid ""
"static SCM\n"
"make_file (int fd)\n"
"@{\n"
"  return scm_make_foreign_object_1 (file_type, (void *) fd);\n"
"@}\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:277
msgid ""
"@cindex finalizer\n"
"@cindex finalization"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:286
msgid ""
"Note that the finalizer may be invoked in ways and at times you might\n"
"not expect.  In particular, if the user's Guile is built with support\n"
"for threads, the finalizer may be called from any thread that is running\n"
"Guile.  In Guile 2.0, finalizers are invoked via ``asyncs'', which\n"
"interleaves them with running Scheme code; @pxref{Asyncs}.  In Guile 2.2\n"
"there will be a dedicated finalization thread, to ensure that the\n"
"finalization doesn't run within the critical section of any other thread\n"
"known to Guile."
msgstr ""
"Обратите внимание, что финализатор может быть вызван способами и во время,\n"
"которое вы не ожидаете. В частности, если пользовательский Guile построен\n"
"с поддержкой потоков, финализатор может быть вызван из любого потока, в\n"
"котором работает Guile.  В Guile 2.0, финализаторы вызываются через "
"``asyncs'',\n"
"который перемежает их с помощью кода Scheme; @pxref{Asyncs}.  В Guile 2.2\n"
"будет выделенный поток финализации, чтобы быть уверенными что поток\n"
"финализации не работает в критической секции другого потока не известного\n"
"Guile."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:297
msgid ""
"In either case, finalizers run concurrently with the main program, and\n"
"so they need to be async-safe and thread-safe.  If for some reason this\n"
"is impossible, perhaps because you are embedding Guile in some\n"
"application that is not itself thread-safe, you have a few options.  One\n"
"is to use guardians instead of finalizers, and arrange to pump the\n"
"guardians for finalizable objects.  @xref{Guardians}, for more\n"
"information.  The other option is to disable automatic finalization\n"
"entirely, and arrange to call @code{scm_run_finalizers ()} at\n"
"appropriate points.  @xref{Foreign Objects}, for more on these\n"
"interfaces."
msgstr ""
"В любом случае, финализаторы запускаются одновременно с основной "
"программой,\n"
"и поэтому им необходимо быть асинхронными и потоко-безопасными(thread-"
"safe).\n"
"Если по какой-то причине это невозможно, например потому что вы "
"встраиваете \n"
"Guile в какое-то приложение, которое не является потоко-безопасным, у\n"
"вас есть несколько способов действий. Один заключается в том, чтобы "
"использовать\n"
"опекунов(guardians) вместо финализаторов и организовать передачу объектов\n"
"опекунам для финализации. @xref{Guardians}, за дальнейшей инофрмацией.\n"
"Другой способ  - полностью отключить автоматическую финализацию и "
"организовать\n"
"вызов @code{scm_run_finalizers ()} в соответствующих точках.  @xref{Foreign "
"Objects}, \n"
"для получения дополнительной информации об этих интерфейсах."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:309
msgid ""
"Finalizers are allowed to allocate memory, access GC-managed memory, and\n"
"in general can do anything any Guile user code can do.  This was not the\n"
"case in Guile 1.8, where finalizers were much more restricted.  In\n"
"particular, in Guile 2.0, finalizers can resuscitate objects.  We do not\n"
"recommend that users avail themselves of this possibility, however, as a\n"
"resuscitated object can re-expose other finalizable objects that have\n"
"been already finalized back to Scheme.  These objects will not be\n"
"finalized again, but they could cause use-after-free problems to code\n"
"that handles objects of that particular foreign object type.  To guard\n"
"against this possibility, robust finalization routines should clear\n"
"state from the foreign object, as in the above @code{free_file} example."
msgstr ""
"Финализаторам разрешено выделять память, иметь доступ к памяти управляемой\n"
"сборщиком мусора(GC), и вообще делать все, что может сделать любой код\n"
"пользователя Guile.  Это было не так в 1.8, где финализаторы были гораздо\n"
"более ограничены. В частности, в Guile 2.0, финализаторы могут "
"реанимировать\n"
"объекты. Мы не рекомендуем, чтобы пользователи использовали эту "
"возможность,\n"
"однако как реанимированный объект может повторно открыть другие "
"финализированные\n"
"объекты которые повторно финализируются при возвращении обратно в Scheme.\n"
"Эти объекты не будут финилизироваться повторно, но они могут привести "
"проблеме\n"
"использования памяти после освобождения(use-after-free) для кода, который "
"обрабатывает\n"
"объекты этого конкретного типа внешних объектов.  Защищаясь от этой "
"возможности,\n"
"надежные процедуры финализации должны очищать состояние от внешнего объекта, "
"как в\n"
"приведенном выше примере @code{free_file}."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:315
msgid ""
"One final caveat.  Foreign object finalizers are associated with the\n"
"lifetime of a foreign object, not of its fields.  If you access a field\n"
"of a finalizable foreign object, and do not arrange to keep a reference\n"
"on the foreign object itself, it could be that the outer foreign object\n"
"gets finalized while you are working with its field."
msgstr ""
"Одно, последнее предостережение.  Финализаторы внешних объектов связвны со\n"
"сроком жизни внешнего бъекта, но не его полей. Если вы получаете доступ к\n"
"полю финализируемого внешнего объекта, и не организуете сохранение ссылки "
"на\n"
"сам внешний объект, может случиться так, что внешний объект будет "
"финализирован,\n"
"пока вы работаете с его полем."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:318
msgid ""
"For example, consider a procedure to read some data from a file, from\n"
"our example above."
msgstr ""
"Например, рассмотрим процедуру чтения некоторых данных из файла, из нашего "
"примера\n"
"выше."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:326
msgid ""
"@example\n"
"SCM\n"
"read_bytes (SCM file, SCM n)\n"
"@{\n"
"  int fd;\n"
"  SCM buf;\n"
"  size_t len, pos;"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:328
msgid "  scm_assert_foreign_object_type (file_type, file);"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:333
msgid ""
"  fd = scm_foreign_object_signed_ref (file, 0);\n"
"  if (fd < 0)\n"
"    scm_wrong_type_arg_msg (\"read-bytes\", SCM_ARG1,\n"
"                            file, \"open file\");"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:336
msgid ""
"  len = scm_to_size_t (n);\n"
"  SCM buf = scm_c_make_bytevector (scm_to_size_t (n));"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:348
msgid ""
"  pos = 0;\n"
"  while (pos < len)\n"
"    @{\n"
"      char *bytes = SCM_BYTEVECTOR_CONTENTS (buf);\n"
"      ssize_t count = read (fd, bytes + pos, len - pos);\n"
"      if (count < 0)\n"
"        scm_syserror (\"read-bytes\");\n"
"      if (count == 0)\n"
"        break;\n"
"      pos += count;\n"
"    @}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:350
msgid "  scm_remember_upto_here_1 (file);"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:354
msgid ""
"  return scm_values (scm_list_2 (buf, scm_from_size_t (pos)));\n"
"@}\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:364
msgid ""
"After the prelude, only the @code{fd} value is used and the C compiler\n"
"has no reason to keep the @code{file} object around.  If\n"
"@code{scm_c_make_bytevector} results in a garbage collection,\n"
"@code{file} might not be on the stack or anywhere else and could be\n"
"finalized, leaving @code{read} to read a closed (or, in a multi-threaded\n"
"program, possibly re-used) file descriptor.  The use of\n"
"@code{scm_remember_upto_here_1} prevents this, by creating a reference\n"
"to @code{file} after all data accesses.  @xref{Garbage Collection\n"
"Functions}."
msgstr ""
"После прелюдии, используется только значение @code{fd} и компилятору C \n"
"нет необходимости сохранять объект @code{file}(т.е оптимизирующий код\n"
"компилятора может уничтожить ссылку на этот объект и выделить ее для \n"
"использования другим объектом).  Если вызов @code{scm_c_make_bytevector}\n"
"приведет к сборке мусора, ссылки на @code{file} может не оказаться в стеке "
"или\n"
"где нибудь еще и он может быть финализирован(закрыт), оставив вызов "
"@code{read}\n"
"для чтения закрытого (или, в многопоточной программе, возможно повторно "
"используемый)\n"
"файлового дескриптора.  Использование вызова @code{scm_remember_upto_here_1} "
"предотвращает это,\n"
"создавая ссылку на @code{file} полсе доступа ко всем данным.  @xref{Garbage "
"Collection\n"
"Functions}."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:370
msgid ""
"@code{scm_remember_upto_here_1} is only needed on finalizable objects,\n"
"because garbage collection of other values is invisible to the program\n"
"-- it happens when needed, and is not observable.  But if you can, save\n"
"yourself the headache and build your program in such a way that it\n"
"doesn't need finalization."
msgstr ""
"@code{scm_remember_upto_here_1} требуется только для финализируемых "
"объектов,\n"
"поскольку сбор мусора других значений невидим для программы\n"
"-- он происходит когда это необходимо, и не является наблюдаемым. Но если "
"вы\n"
"сможете, уберечь себя от головной боли, создайте свою программу таким "
"образом,\n"
"чтобы финализация в ней была бы не нужна."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:374
msgid ""
"@node Foreign Objects and Scheme\n"
"@subsection Foreign Objects and Scheme"
msgstr ""
"@node Foreign Objects and Scheme\n"
"@subsection Внешние Объекты и Scheme"

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:379
msgid ""
"It is also possible to create foreign objects and object types from\n"
"Scheme, and to access fields of foreign objects from Scheme.  For\n"
"example, the file example from the last section could be equivalently\n"
"expressed as:"
msgstr ""
"Также возможно создавать внешние объекты и типы объектов из\n"
"Scheme и получать доступ к полям внешних объектов из Scheme.  Например,\n"
"пример файла(file) из последнего раздела может быть эквивалентно выражен\n"
"следующим образом:"

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:385
msgid ""
"@example\n"
"(define-module (my-file)\n"
"  #:use-module (system foreign-object)\n"
"  #:use-module ((oop goops) #:select (make))\n"
"  #:export (make-file))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:391
msgid ""
"(define (finalize-file file)\n"
"  (let ((fd (struct-ref file 0)))\n"
"    (unless (< fd 0)\n"
"      (struct-set! file 0 -1)\n"
"      (close-fdes fd))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:395
msgid ""
"(define <file>\n"
"  (make-foreign-object-type '<file> '(fd)\n"
"                            #:finalizer finalize-file))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:399
msgid ""
"(define (make-file fd)\n"
"  (make <file> #:fd fd))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:408
msgid ""
"Here we see that the result of @code{make-foreign-object-type}, which is\n"
"the equivalent of @code{scm_make_foreign_object_type}, is a struct\n"
"vtable.  @xref{Vtables}, for more information.  To instantiate the\n"
"foreign object, which is really a Guile struct, we use @code{make}.  (We\n"
"could have used @code{make-struct/no-tail}, but as an implementation\n"
"detail, finalizers are attached in the @code{initialize} method called\n"
"by @code{make}).  To access the fields, we use @code{struct-ref} and\n"
"@code{struct-set!}.  @xref{Structure Basics}."
msgstr ""
"Здесь мы видим, что результат @code{make-foreign-object-type}, который\n"
"эквивалентен вызову@code{scm_make_foreign_object_type}, является структурой\n"
"vtable.  @xref{Vtables}, для получения дополнительной информацииn. Чтобы "
"создать\n"
"экземпляр внешнего объекта, который действительно является структурой Guile, "
"мы\n"
"использкем @code{make}.  (Мы моглибы использовать @code{make-struct/no-"
"tail}, \n"
"но для детализации, добавляем финализатор в метод инициализации "
"@code{initialize} \n"
"вызываемый @code{make}).  Для доспупа к полям, мы используем @code{struct-"
"ref} и\n"
"@code{struct-set!}.  @xref{Structure Basics}."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:413
msgid ""
"There is a convenience syntax, @code{define-foreign-object-type}, that\n"
"defines a type along with a constructor, and getters for the fields.  An\n"
"appropriate invocation of @code{define-foreign-object-type} for the\n"
"file object type could look like this:"
msgstr ""
"Существует удобный синтаксис @code{define-foreign-object-type}, который\n"
"определяет тип, наряду с констурктором и процедурами доступа(getters) для "
"полей.\n"
"Сооответствующий вызов @code{define-foreign-object-type} для объекта\n"
"типа файла(file) может выглядеть так:"

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:416
msgid ""
"@example\n"
"(use-modules (system foreign-object))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:422
msgid ""
"(define-foreign-object-type <file>\n"
"  make-file\n"
"  (fd)\n"
"  #:finalizer finalize-file)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:425
msgid ""
"This defines the @code{<file>} type with one field, a @code{make-file}\n"
"constructor, and a getter for the @code{fd} field, bound to @code{fd}."
msgstr ""
"Здесь определяется тип @code{<file>} с одним полем, конструктором @code{make-"
"file},\n"
"и процедурой доступа для поля @code{fd}, связанная с @code{fd}."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:430
msgid ""
"Foreign object types are not only vtables but are actually GOOPS\n"
"classes, as hinted at above.  @xref{GOOPS}, for more on Guile's\n"
"object-oriented programming system.  Thus one can define print and\n"
"equality methods using GOOPS:"
msgstr ""
"Типы внешних объектов это не только vtable, но и фактически классы GOOPS,\n"
"как это отмечено выше.  см. @xref{GOOPS}, для получения дополнительной\n"
"информации о системе объектно-ориентированного программирования  Guile.\n"
"Таким образом, можно определить методы печать(print) и равно(equality)\n"
"используя GOOPS:"

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:433
msgid ""
"@example\n"
"(use-modules (oop goops))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:437
msgid ""
"(define-method (write (file <file>) port)\n"
"  ;; Assuming existence of the `fd' getter\n"
"  (format port \"#<<file> ~a>\" (fd file)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:441
msgid ""
"(define-method (equal? (a <file>) (b <file>))\n"
"  (eqv? (fd a) (fd b)))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:443
msgid "One can even sub-class foreign types."
msgstr "Можно даже создавать подклассы внешних объектов."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:448
msgid ""
"@example\n"
"(define-class <named-file> (<file>)\n"
"  (name #:init-keyword #:name #:init-value #f #:accessor name))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:453
msgid ""
"The question arises of how to construct these values, given that\n"
"@code{make-file} returns a plain old @code{<file>} object.  It turns out\n"
"that you can use the GOOPS construction interface, where every field of\n"
"the foreign object has an associated initialization keyword argument."
msgstr ""
"Возникает вопрос, как строяться эти значения, учитвывая что, @code{make-"
"file}\n"
"возвращает просто старый объект @code{<file>}.  Оказывается, вы можете "
"использовать\n"
"интерфейс постороения GOOPS, где каждое поле внешнего объекта имеет "
"связанный\n"
"аргумент инициализации - ключевое слово."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:457
msgid ""
"@example\n"
"(define* (my-open-file name #:optional (flags O_RDONLY))\n"
"  (make <named-file> #:fd (open-fdes name flags) #:name name))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:461
msgid ""
"(define-method (write (file <named-file>) port)\n"
"  (format port \"#<<file> ~s ~a>\" (name file) (fd file)))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:464
msgid ""
"@xref{Foreign Objects}, for full documentation on the Scheme interface\n"
"to foreign objects.  @xref{GOOPS}, for more on GOOPS."
msgstr ""
"См. @xref{Foreign Objects}, для полной документации по интерфейсам Scheme\n"
"к внешним объектам. См.  @xref{GOOPS}, для получения дополнительных "
"сведений\n"
"о GOOPS."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:474
msgid ""
"As a final note, you might wonder how this system supports encapsulation\n"
"of sensitive values.  First, we have to recognize that some facilities\n"
"are essentially unsafe and have global scope.  For example, in C, the\n"
"integrity and confidentiality of a part of a program is at the mercy of\n"
"every other part of that program -- because any part of the program can\n"
"read and write anything in its address space.  At the same time,\n"
"principled access to structured data is organized in C on lexical\n"
"boundaries; if you don't expose accessors for your object, you trust\n"
"other parts of the program not to work around that barrier."
msgstr ""
"В заключении, вы можете удивиться, как эта система поддерживает "
"инкапсуляцию\n"
"чувствительных(sensitive) значений.  Первое, мы должны признать, что "
"некоторые\n"
"объекты по существу не безопасны и имеют глобальных охват(область действия). "
"Например,\n"
"в Си, целостность и конфеденциальность части программы находиться в милости "
"от каждой\n"
"другой части этой программы, поскольку любая часть программы может читать "
"или писать\n"
"что нибудь в это адресное пространство.  В то же время, принципиальный "
"доступ к струрированным\n"
"данным организован в Си в лексических границах(области видимости); если вы "
"не не открываете\n"
"процедуры доступа для своего объекта, вы доверяете другим частям программы, "
"что они не \n"
"обошли этот барьер."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:484
msgid ""
"The situation is not dissimilar in Scheme.  Although Scheme's unsafe\n"
"constructs are fewer in number than in C, they do exist.  The\n"
"@code{(system foreign)} module can be used to violate confidentiality\n"
"and integrity, and shouldn't be exposed to untrusted code.  Although\n"
"@code{struct-ref} and @code{struct-set!} are less unsafe, they still\n"
"have a cross-cutting capability of drilling through abstractions.\n"
"Performing a @code{struct-set!} on a foreign object slot could cause\n"
"unsafe foreign code to crash.  Ultimately, structures in Scheme are\n"
"capabilities for abstraction, and not abstractions themselves."
msgstr ""
"Ситуация не отличается в Scheme.  Хотя небезопасных конструкций в Scheme\n"
"значительно меньше чем в Си, они существуют. Модуль @code{(system foreign)}\n"
"может использоваться для нарушения конфиденциальности и целостности, и\n"
"не должен размещаться ненадежным кодом. Хотя @code{struct-ref} и \n"
"@code{struct-set!} менее опасны, они по прежнему имеют способность\n"
"насквозь проходить сквозь абстракции.\n"
"Выполнение @code{struct-set!} на слоте с внешним объектом может вызвать\n"
"сбой небезопасного внешнего кода. В конечном счете, структуры в Scheme\n"
"являются возможностью для абстрагирования, а не самими абстракциями."

#: /home/bear/work/guile/doc/guile/en/libguile-foreign-objects.texi:493
msgid ""
"That leaves us with the lexical capabilities, like constructors and\n"
"accessors.  Here is where encapsulation lies: the practical degree to\n"
"which the innards of your foreign objects are exposed is the degree to\n"
"which their accessors are lexically available in user code.  If you want\n"
"to allow users to reference fields of your foreign object, provide them\n"
"with a getter.  Otherwise you should assume that the only access to your\n"
"object may come from your code, which has the relevant authority, or via\n"
"code with access to cross-cutting @code{struct-ref} and such, which also\n"
"has the cross-cutting authority."
msgstr ""
"Это оставляет нам лексические возможности, такие как конструкторы и\n"
"процедуры доступа. Здесь, где заключается инкапсуляция: практическая "
"степень,\n"
"в которой внутренности ваших внешних объектов раскрывается степень,\n"
"которой их процедуры доступа являются лексически доступными в коде "
"пользователя.\n"
"Если вы хотите разрешить пользователям ссылаться на поля вашего внешнего "
"объекта,\n"
"предоставьте им процедуру получения доступа к полю(getter).  В противном "
"случае\n"
"вы должны предположить, что доступ к вашему объекту возможен только из "
"вашего кода,\n"
"который имеет соответствующие полномочия, или через код со сквозным "
"доступом\n"
"@code{struct-ref} и такой, который имеет сквозные полномочия."
