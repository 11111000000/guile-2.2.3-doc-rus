@c -*-texinfo-*-
@c This is part of the GNU Guile Reference Manual.
@c Copyright (C)  1996, 1997, 2000-2005, 2010, 2011, 2013, 2014,
@c   2016 Free Software Foundation, Inc.
@c See the file guile.texi for copying conditions.

@node Invoking Guile
@section Вызов Guile
@cindex invocation

Многие функции Guile зависят и могут быть изменены информацией, которую предоставляет
пользователь либо до, либо во время запуска Guile.  Ниже приводиться описание того,
какую информацию предоставлять и как это сделать.

@menu
* Command-line Options::        Command-line options understood by Guile.
* Environment Variables::       Variables that affect Guile's behavior.
@end menu

@node Command-line Options
@subsection Command-line Options
@cindex Command-line Options
@cindex command-line arguments
@cindex arguments (command line)
@cindex options (command line)
@cindex switches (command line)
@cindex startup (command-line arguments)
@cindex invocation (command-line arguments)

Здесь мы подробно опишем обработку командной строки Guile.  Guile
обрабатываепт свои аргументы слева на право, распознавая переключатели
описаные ниже.  Например, см @ref{Scripting Examples}.

@table @code

@item @var{script} @var{arg...}
@itemx -s @var{script} @var{arg...}
@cindex script mode
По умолчанию, Guile будет читать файл с именем в командной строке как скрипт.
Любые аргументы командной строки @var{arg...} следующие за @var{script}
становяться аргументами скрипта; функция @code{command-line} возвращает список
строк вида @code{(@var{script} @var{arg...})}.

Возможно называть файла используя начальный дефис, например,
@file{-myfile.scm}.  Этом случае имени файла должна предшествовать
@option{-s} чтобы соообщить Guile что файл (скрипт) имеет такое название.

Скрипты читаются и выполняются как исходный код Scheme так же как если бы
использовалась функция @code{load}.  После выполнения загруженного скрипта 
@var{script}, Guile завершает работу.

@item -c @var{expr} @var{arg...}
@cindex evaluate expression, command-line argument
Вычисляет @var{expr} как код Scheme, и завершает работу.  Любые аргументы
командной строки @var{arg...} следующие за @var{expr} становяться аргументами
командной строки; функция @code{command-line} возвращает список строк вида
@code{(@var{guile} @var{arg...})}, где @var{guile} это путь исполняемого файла
Guile.

@item -- @var{arg...}
Запускается в интерактивном режиме, выдавая пользователю приглашение для 
ввода выражений и вычисляя их. Любые аргументы командной строки
 @var{arg...} следующие за @option{--} становяться аргументами командной
строки для интерактивного сеанса; функция @code{command-line} возвращает 
список строк вида @code{(@var{guile} @var{arg...})}, где @var{guile} это
путь к исполняемому файлу Guile.

@item -L @var{directory}
Добавляет @var{directory} в начало пути загрузки Guile.  Данные каталоги
используютя для поиска в порядке, указанном в командной строке и перед
любыми каталогами из переменной среды @env{GUILE_LOAD_PATH}.  Пути,
добавленные здесь, не оказывают эффекта во время исполнения пользовательского
файла @file{.guile}.

@item -C @var{directory}
Подобно @option{-L}, но корректирует путь загрузки для скомпилированных(@emph{compiled}) файлов.

@item -x @var{extension}
Добавляет расришения @var{extension} в начало списка загружаемых расширений Guile
(@pxref{Load Paths, @code{%load-extensions}}).  Указанные расширения пробуются в
порядке указанном в командной строке, и до расширений загружаемых по умолчанию.
Добавленные здесь расширения не действуют во время выполнения пользовательского файла
@file{.guile}.

@item -l @var{file}
Загружает исходный код Scheme из @var{file}, и продолжает обработку командной
строки.

@item -e @var{function}
Делает функцию @var{function}  @dfn{точкой входа} скрипта.  После загрузки
файла скрипта (с @option{-s}) или  вычисляя выражение (с @option{-c}), 
применяет функцию @var{function} к списку, содержащему имя программы и
аргументы командной строки ---списку предоставляемому функцией 
@code{command-line}.

Клюя @option{-e} может появиться в любом месте списка аргументов, но Guile
всегда вызывает функцию @var{function} как @emph{последнее} действие которое она
выполняет. Это странно, но так как вызов скрипта работает в POSIX, опция @option{-s}
всегда должна быть последней в списке.

Функция @var{function} чаще всего является простым символом, котоырй именует
определенную функцию в скрипте.  Он также может иметь форму @code{(@@
@var{module-name} @var{symbol})}, и в этом случае символ ищется в модуле с 
именем @var{module-name}.

В качестве сокращения вы можете использовать форму @code{(symbol ...)}, то есть
списко, только символы, котолого не начинаются с @code{@@}.  Это эквивалентно
@code{(@@ @var{module-name} main)}, где @var{module-name} имеет вид
@code{(symbol ...)}.  @xref{Using Guile Modules} и @ref{Scripting
Examples}.

@item -ds
Обрабатывает последний параметр @option{-s} как если бы она была в этой точке командной строки;
загружая скрипт здесь.

Этот переключатель необходим, потому что, хотя механизм вызова сценария
POSIX эффективно требует, чтобы опция @option{-s} появлялась последней,
программисту может потребоваться запустить скрипт перед другими действиями,
запрошенными в командной строке.  Пример, см. @ref{Scripting
Examples}.

@item \
Читать больше аргументов командной строки, начиная со второй строки файла скрипта.
@xref{The Meta Switch}.

@item --use-srfi=@var{list}
@cindex loading srfi modules (command line)
Опция @option{--use-srfi} ожидает разделенный запятыми список чисел,
какждое из которых представляет модуль SRFI для загрузки в интерпретатор
перед выполнением файла скрипта или запуска REPL.  Кроме того,
идентификаторы функции для загружаемых SRFIs распознаются процедурой
@code{cond-expand} когда эта опция используется.

Вот пример, который загружает модули SRFI-8 ('receive') и SRFI-13
('string library') перед запуском интерпретатора GUILE:

@example
guile --use-srfi=8,13
@end example

@item --debug
@cindex debugging virtual machine (command line)
Стартует guile с отладочной виртуальной машиной (VM).  Использование
отладочной VM включает поддержку хуков(hooks) VM, которые необходимы для
трассировки, устновки точек прерывания, и точного подсчета количества 
вызовов при профилировании.  Отладочная VM, медленнее обычной VM, приблизительно
на десять процентов.  @xref{VM Hooks}, для получения дополнительной информации.

По умолчанию, движок отладочной виртуальной машины VM используется 
только при входе в интерактивную сессию. При выполнении сценария с
@option{-s} или @option{-c}, исползуется обычная, более быстрая
виртуальная машина VM по умолчанию.

@vnew{1.8}
@item --no-debug
@cindex debugging virtual machine (command line)
Не использовать движок отладочной VM, даже при входе в интерактивный сеанс.

Обратите внимание, что несмотря на название, Guile рабтающая с опцией @option{--no-debug}
@emph{дает} поддержку обычным средствам отладки, таким как распечатка подробной трассировки
при ошибке.  Единственное отличие от @option{--debug} отсутствие поддержки VM hooks и
средств которые опираются на них (см выше).

@item -q
@cindex init file, not loading
@cindex @file{.guile} file, not loading
Не загружать файл инициализации @file{.guile}.  Эта опция влияет только при
работе в интерактивном режиме; Запуск скриптов не загружает файл  @file{.guile}.
@xref{Init File}.

@item --listen[=@var{p}]
Во время работы программы, прослушивает локальный порт или путь для
клиентов REPL.  Если @var{p} начинается с числа, предполагается, что это
локальный порт для прослушивания. Если он начинается с прямой косой черты(слеша),
предполагается, что это имя файла домена UNIX сокетов для прослушивания.

Если @var{p} не задано, по умолчанию используется локальный порт 37146.
Если вы посмотрите на него перевернув, это будет почти ``Guile''.  
Если у вас установлен netcat, вы имеете возможность дать команду 
@kbd{nc localhost 37146} и получить приглашение Guile.  После чего,
вы можете запустить Emacs и подсоединиться к процессу; см.
 @ref{Using Guile in Emacs} для получения подробной информации.

@quotation Примечание
Открытие порта позволяет любому, кто может подключиться к этому порту, делать все,
что может делать Guile, как пользователь запустивший процесс
Guile.  Не используйте опцию @option{--listen} на многопользовательских машинах.
Конечно, если вы не передаете @option{--listen} в Guile, порт не будет открыт.

Guile защищается от 
@uref{https://en.wikipedia.org/wiki/Inter-protocol_exploitation,
@dfn{HTTP inter-protocol exploitation attack}}, сценария, при котором
атакующий может, @i{через} HTML страницу, заставить веб-браузер отправлять данные
на TCP сервер прослушивающий loopback интерфейс или частную сеть.
Тем не менее, вам рекомендуется использовать сокеты домена UNI, как в
@code{--listen=/some/local/file}, когда это возможно.
@end quotation

Тем не менее, @option{--listen} отлично подходит для интерактивной отладки и разработки.

@vnew{2.0}

@item --auto-compile
Автоматическая компиляция исходных файлов (поведение по умолчанию).

@vnew{2.0.1}

@item --fresh-auto-compile
Обозначить кеш автокомпиляции, как недействительный, вызывая перекомпиляцию.


@vnew{2.0}

@item --no-auto-compile
Отменяет автоматическую компиляцию исходного файла.

@vnew{2.0.8}

@item --language=@var{lang}
Для оставшихся аргументов командной строки, предполагает, что упомянутые
файлы с @code{-l} и выражения переданные с  @code{-c} являются
написаными на языке @var{lang}.  @var{lang} должно быть одним из языков,
поддерживаемых компилятором (@pxref{Compiler Tower}).  При запуске в
интерактивном режиме устанавливает язык REPL в @var{lang} (@pxref{Using Guile
Interactively}).

По умолчанияю язык @code{scheme}; другие интересные значения включают
@code{elisp} (для Emacs Lisp), и @code{ecmascript}.

Пример ниже показывает вычисление выражения на Scheme, Emacs
Lisp и ECMAScript:

@example
guile -c "(apply + '(1 2))"
guile --language=elisp -c "(= (funcall (symbol-function '+) 1 2) 3)"
guile --language=ecmascript -c '(function (x) @{ return x * x; @})(2);'
@end example

Чтобы загрузить файл, написаный на Scheme, а другой написаный на Emacs Lisp, и затем
запустить Scheme REPL, наберите:

@example
guile -l foo.scm --language=elisp -l foo.el --language=scheme
@end example

@vnew{2.0}

@item -h@r{, }--help
Показывает справку по вызовам Guile, и завершает работу.

@item -v@r{, }--version
Показывает текущую версию Guile, и затем завершает работу.

@end table

@node Переменные окружающей среды
@subsection Environment Variables
@cindex environment variables
@cindex shell
@cindex initialization
Окружающая среда(@dfn{environment}) это функция(свойство) предоставляемая
операционной системой; она состоит из набора переменных с именами и значениями.
Каждая переменная называется переменной среды(@dfn{environment variable})
 (или, иногда, переменной оболочки (``shell variable''); Имена переменных среды
чувствительны к регистру и обычно используют только заглавные буквы. Значения это
текстовые строки, даже те, которые записаны как числа.  (Обратите внимание, что здесь
мы имеем в виду имена и значения, которые определены в оболочке операционной системы,
из которой вызывается Guile.  Это не тоже самое. что среда Scheme определяемая в 
работающем экземпляре Guile.
Для описания среды Scheme, см. @pxref{About Environments}.)

Как установить переменные среды перед запуском Guile, зависит от операционной
системы и особенно от используемой вами оболочки.  Например, вот как сказать
Guile предоставлять подробные сообщения об устаревших функциях, путем установки
@env{GUILE_WARN_DEPRECATED} используя Bash:

@example
$ export GUILE_WARN_DEPRECATED="detailed"
$ guile
@end example

@noindent
Или, подробные предупреждения могут быть включены для одного вызова,
с помощью:

@example
$ env GUILE_WARN_DEPRECATED="detailed" guile
@end example

Если вы хотите получить или изменить значение переменных среды облочки,
которые влияют на поведение  Guile во время выполнения из запущенного
экземпляра Guile, см. @ref{Runtime Environment}.

Вот переменные окружения, которые влияют на поведение Guile во время выполнения:

@table @env
@item GUILE_AUTO_COMPILE
@vindex GUILE_AUTO_COMPILE
Этот флаг, который может использоваться для указания Guile, компилировать
или нет исходные файлы Scheme автоматически.  Начиная с Guile 2.0, исходные
файлы Scheme будут компилироваться автоматически, по умолчанию.

Если скомпилированный файл (@file{.go}) соответствующий файлу @file{.scm} 
не найден, или не новее чем файл @file{.scm}, файл @file{.scm} будет
скомпилирован на лету, и результирующий файл @file{.go} сохранен.
Консультирующее уведомление будет напечатано на консоли.

Скомпилированные файлы будут храниться в каталоге
@file{$XDG_CACHE_HOME/@/guile/@/ccache}, где @env{XDG_CACHE_HOME}
по умолчанию это директория @file{$HOME/.cache}.  Этот каталог будет создан,
если он до этого не существовал.

Обратите внимание, что механизм зависит от временной отметки файла @file{.go},
являющейся более новой, чем у файла @file{.scm}; если файлы @file{.scm} или
@file{.go} перемещаются полсе установки, следует соблюдать осторожность, чтобы
сохранить их оригинальные метки времени.

Установите @env{GUILE_AUTO_COMPILE} в ноль (0), чтобы предотвратить 
автоматическую компиляцию файлов Scheme. Установите эту переменную в
``fresh'', чтобы сообщить Guile о компиляции файлов Scheme, в не зависимости
от того, являются ли они новее скомпилированных или нет.

@xref{Compilation}.

@item GUILE_HISTORY
@vindex GUILE_HISTORY
Эта переменная именует файл, содержащий историю команд Guile REPL.
Вы можете указать другой файл истории, установив эту переменную среды.
По умолчанию файл истории это @file{$HOME/.guile_history}.

@item GUILE_INSTALL_LOCALE
@vindex GUILE_INSTALL_LOCALE
Это флаг, который может использоваться, чтобы сообщить Guile, устанавливать или
нет текущую локаль при запуске через вызов @code{(setlocale LC_ALL
"")}@footnote{Переменная среды @code{GUILE_INSTALL_LOCALE} была проигнорирована в
версиях Guile до 2.0.9.}.  @xref{Locales}, для дальнейшей информации о локалях.

Вы можете явно указать, что не хотите устанавливать локаль, установив
 @env{GUILE_INSTALL_LOCALE} в @code{0}, или явно включить ее,
установив переменную в @code{1}.

Обычно, установка текущей локали это правильная вещь. Это позволяет 
Guile правильно анализировать и печатать строки с не-ASCII символьными
знаками. Следовательно по умолчанию эта опция включена.

@item GUILE_STACK_SIZE
@vindex GUILE_STACK_SIZE
Guile в настоящее время имеет ограниченный размер стека для вычислений Scheme.
Попытка вызова слишком большого количества вложенных функций будет сигнализировать
об ошибке. Это хорошо обнаруживает бесконечную рекурсию, но иногда предел достигается
и для обычных вычислений.  Эта переменная среды, если задано положительное целое числ,
указывает число слотов значений Scheme размещаемых в стеке.

В будущем мы будем внедрять стеки, которые могут расти и уменьшаться, но пока этот
хак придется делать вам.

@item GUILE_LOAD_COMPILED_PATH
@vindex GUILE_LOAD_COMPILED_PATH
Эта переменная может использоваться для дополнения пути, по которому ищутся
скомпилированные файлы Scheme (@file{.go}) при загрузке.  Его значение должно
быть списком каталогов, разделенным двоеточиями. Если он содержит специальный
компонент пути @code{...} (многоточия), то вместо многоточия указывается путь по
умолчанию в конце. Результат сохраняется в @code{%load-compiled-path} (@pxref{Load Paths}).

Вот пример использования оболочки Bash, которая доббавляет текущий каталог @file{.}, 
 и относительный каталог @file{../my-library} к @code{%load-compiled-path}:

@example
$ export GUILE_LOAD_COMPILED_PATH=".:../my-library"
$ guile -c '(display %load-compiled-path) (newline)'
(. ../my-library /usr/local/lib/guile/2.2/ccache)
@end example

@item GUILE_LOAD_PATH
@vindex GUILE_LOAD_PATH
Эта переменная может быть использована для дополнения пути, по которому
Scheme ищет файлы для загрузки.  Ее значение должно быть разделенным двоеточиями
списком каталогов.  Если она содержит специальный компонент пути @code{...}
(многоточие), тогда путь по умолчанию подставляется вместо многоточия,
в противном случае путь по умолчанию находитсья в конце.  результат сохраняется в
 @code{%load-path} (@pxref{Load Paths}).

Вот пример использования оболочки Bash, который добавляет текущий каталог в
@code{%load-path}, и добавляет относительный каталог
@file{../srfi} в конец:

@example
$ env GUILE_LOAD_PATH=".:...:../srfi" \
guile -c '(display %load-path) (newline)'
(. /usr/local/share/guile/2.2 \
/usr/local/share/guile/site/2.2 \
/usr/local/share/guile/site \
/usr/local/share/guile \
../srfi)
@end example

(Примечание: Разрывы строк, приведенные выше, предназначены только для документирования,
и не требуются в реальном примере.)

@item GUILE_WARN_DEPRECATED
@vindex GUILE_WARN_DEPRECATED
По мере развития Guile, некоторые функции будут удалены или заменены новыми.
Чтобы помочь пользователям перенести свой код по мере развития, Guile выдаст
предупреждения о коде, который исползует функции, которые были отмечены для
возможного отключения.  @env{GUILE_WARN_DEPRECATED}
может быть установлен в  нет``no'', чтобы сказать Guile не отображать эти
предупреждающие сообщения, или установлен ``detailed''(подробно), чтобы сообщить
Guile об отображении более длинных сообщений с описанием предупреждения.
@xref{Deprecation}.

@item HOME
@vindex HOME
Guile использует переменную среды окружения @env{HOME}, имя вашего домашнего
каталога, чтобы найти различные файлы, такие как @file{.guile} или
@file{.guile_history}.

@end table

@c Local Variables: 
@c mode: texinfo
@c TeX-master: "guile"
@c End: