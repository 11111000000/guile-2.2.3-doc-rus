#
# Gagin <mikhail-gagin@yandex.ru>, 2018.
#
#. extracted from /home/bear/work/guile/doc/guile/en/vm.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-07 12:37+0300\n"
"PO-Revision-Date: 2018-05-17 14:49+0300\n"
"Last-Translator: Gagin <mikhail-gagin@yandex.ru>\n"
"Language-Team: Russian <mikhail-gagin@yandex.ru>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: /home/bear/work/guile/doc/guile/en/vm.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C)  2008,2009,2010,2011,2013,2015\n"
"@c   Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:9
msgid ""
"@node A Virtual Machine for Guile\n"
"@section A Virtual Machine for Guile"
msgstr ""
"@node A Virtual Machine for Guile\n"
"@section Виртуальная машина для Guile"

#: /home/bear/work/guile/doc/guile/en/vm.texi:13
msgid ""
"Guile has both an interpreter and a compiler. To a user, the difference\n"
"is transparent---interpreted and compiled procedures can call each other\n"
"as they please."
msgstr ""
"У Guile есть и интерпретатор и компилятор. Для пользователя разница "
"является\n"
"прозрачной --- интерпретируемые и скомпилированные процедуры могут вызывать\n"
"друг друга, как им нравиться."

#: /home/bear/work/guile/doc/guile/en/vm.texi:18
msgid ""
"The difference is that the compiler creates and interprets bytecode\n"
"for a custom virtual machine, instead of interpreting the\n"
"S-expressions directly. Loading and running compiled code is faster\n"
"than loading and running source code."
msgstr ""
"Разница заключается в том, что компилятор создает и интерпретирует\n"
"байт-код для пользовательской виртуальной машины, вместо интерпретации\n"
"S-выражений напрямую. Загрузка и выполнение скомпилированного кода,\n"
"быстрее, чем загрузка и выполнение исходного кода."

#: /home/bear/work/guile/doc/guile/en/vm.texi:22
msgid ""
"The virtual machine that does the bytecode interpretation is a part of\n"
"Guile itself. This section describes the nature of Guile's virtual\n"
"machine."
msgstr ""
"Виртуальная машина, которая интерпретирует байт-код, является частью\n"
"самого Guile. Этот раздел описывает сущность виртуальой машины Guile."

#: /home/bear/work/guile/doc/guile/en/vm.texi:32
msgid ""
"@menu\n"
"* Why a VM?::                   \n"
"* VM Concepts::                 \n"
"* Stack Layout::                \n"
"* Variables and the VM::                   \n"
"* VM Programs::         \n"
"* Object File Format::\n"
"* Instruction Set::\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:35
msgid ""
"@node Why a VM?\n"
"@subsection Why a VM?"
msgstr ""
"@node Why a VM?\n"
"@subsection Почему Виртуальная Машина(ВМ)?"

#: /home/bear/work/guile/doc/guile/en/vm.texi:40
msgid ""
"@cindex interpreter\n"
"For a long time, Guile only had an interpreter. Guile's interpreter\n"
"operated directly on the S-expression representation of Scheme source\n"
"code."
msgstr ""
"@cindex interpreter\n"
"Долгое время в Guile был только интерпретатор. Интерпретатор Guile \n"
"обрабатывал на прямую S-выражения представляющие исходный код на\n"
"Scheme."

#: /home/bear/work/guile/doc/guile/en/vm.texi:48
msgid ""
"But while the interpreter was highly optimized and hand-tuned, it still\n"
"performed many needless computations during the course of evaluating an\n"
"expression. For example, application of a function to arguments\n"
"needlessly consed up the arguments in a list. Evaluation of an\n"
"expression always had to figure out what the car of the expression is --\n"
"a procedure, a memoized form, or something else. All values have to be\n"
"allocated on the heap. Et cetera."
msgstr ""
"Но даже в то время когда интерпретатор был очень оптимизирован и\n"
"настроен вручную, он все еще выполнял множество ненужных вычислений.\n"
"Например, применение функции к аргументам бесполезно повторяет\n"
"аргументы в списке. При вычисление выражения всегда приходилось\n"
"выяснять, что такое начало(car) выражения --- это процедура, форма или\n"
"что нибудь еще. Все значения должны быт размещены в куче. И т.д."

#: /home/bear/work/guile/doc/guile/en/vm.texi:53
msgid ""
"The solution to this problem was to compile the higher-level language,\n"
"Scheme, into a lower-level language for which all of the checks and\n"
"dispatching have already been done---the code is instead stripped to\n"
"the bare minimum needed to ``do the job''."
msgstr ""
"Решение этой проблемы состояло в том, чтобы скомпилировать язык более\n"
"высокого уровня Scheme, в язык более низкого уровня, для которого все\n"
"проверки и размещения уже выполнены. Код заменяется на минимальный \n"
"минимумЖ необходимый для ``выполнения задания''."

#: /home/bear/work/guile/doc/guile/en/vm.texi:58
msgid ""
"The question becomes then, what low-level language to choose? There\n"
"are many options. We could compile to native code directly, but that\n"
"poses portability problems for Guile, as it is a highly cross-platform\n"
"project."
msgstr ""
"Тогда возникает вопрос, какой язык низкого уровня выбрать? Есть много\n"
"вариантов. Мы можем напрямую скомпилировать программу в исполняемый \n"
"код процессора. Но это создает проблемы с переносимостью для Guile, \n"
"поскольку это очень кросс-платформенный проект."

#: /home/bear/work/guile/doc/guile/en/vm.texi:63
msgid ""
"So we want the performance gains that compilation provides, but we\n"
"also want to maintain the portability benefits of a single code path.\n"
"The obvious solution is to compile to a virtual machine that is\n"
"present on all Guile installations."
msgstr ""
"Таким образом, мы хотим получить прирост производительности, который\n"
"дает компилияция, но мы также хотим поддерживать преимущества переносимости\n"
"выполняемого кода. Очевидное решение состоит в том, чтобы создать \n"
"виртуальную машину, которая будет присутствовать во всех инсталяциях Guile. "

#: /home/bear/work/guile/doc/guile/en/vm.texi:71
msgid ""
"The easiest (and most fun) way to depend on a virtual machine is to\n"
"implement the virtual machine within Guile itself. Guile contains a\n"
"bytecode interpreter (written in C) and a Scheme to bytecode compiler\n"
"(written in Scheme). This way the virtual machine provides what Scheme\n"
"needs (tail calls, multiple values, @code{call/cc}) and can provide\n"
"optimized inline instructions for Guile (@code{cons}, @code{struct-ref},\n"
"etc.)."
msgstr ""
"Самый простой (и самый интересный) способ зависеть от виртуальной\n"
"машины --- это реализовать виртуальную машину внутри самого Guile. \n"
"Guile содержит интерпретатор байт-кода (написанного на Си) и\n"
"компилятор Scheme в байт-код (написанный на Scheme). Этот способ\n"
"построения виртуальной машины обеспечивает необходимые Scheme\n"
"конструкции (хвостовые вызовы(tail calls), множественные переменные\n"
"(multiple values), (продолжения) @code{call/cc}) и может обеспечить\n"
"оптимизацию встроенных инструкций Guile (@code{cons}, @code{struct-ref},\n"
"и т.д.)."

#: /home/bear/work/guile/doc/guile/en/vm.texi:74
msgid ""
"So this is what Guile does. The rest of this section describes that VM\n"
"that Guile implements, and the compiled procedures that run on it."
msgstr ""
"Вот что делает Guile. В остальной части этого раздела описывается ВМ\n"
"которая реализована в Guile и скомпилированные процедуры которые\n"
"выполняются в ней."

#: /home/bear/work/guile/doc/guile/en/vm.texi:82
msgid ""
"Before moving on, though, we should note that though we spoke of the\n"
"interpreter in the past tense, Guile still has an interpreter. The\n"
"difference is that before, it was Guile's main evaluator, and so was\n"
"implemented in highly optimized C; now, it is actually implemented in\n"
"Scheme, and compiled down to VM bytecode, just like any other program.\n"
"(There is still a C interpreter around, used to bootstrap the compiler,\n"
"but it is not normally used at runtime.)"
msgstr ""
"Однако, прежде чем двигаться дальше, мы должны отметить, что, хотя\n"
"мы говорили об интерпретаторе в прошедшем времени, у Guile все еще\n"
"есть интерпретатор. Разница в том, что раньше это был главный \n"
"исполнитель, и поэтому был реализован в сильно оптимизированном Си\n"
"коде; теперь он фактически реализован на Scheme, и скомпилирован\n"
"до байт-кода ВМ, как и любая другая программа на Guile.(Там есть\n"
"все еще и интерпретатор на Си, используемый для загрузки компилятора,\n"
"но он обычно не используется во время выполнения.)"

#: /home/bear/work/guile/doc/guile/en/vm.texi:91
msgid ""
"The upside of implementing the interpreter in Scheme is that we preserve\n"
"tail calls and multiple-value handling between interpreted and compiled\n"
"code. The downside is that the interpreter in Guile 2.2 is still about\n"
"twice as slow as the interpreter in 1.8.  Since Scheme users are mostly\n"
"running compiled code, the compiler's speed more than makes up for the\n"
"loss.  In any case, once we have native compilation for Scheme code, we\n"
"expect the self-hosted interpreter to handily beat the old hand-tuned C\n"
"implementation."
msgstr ""
"Потенциал реализованного интерпретатора на Scheme состоит в том, что\n"
"мы сохраняем хвостовые вызовы и обработку множественных значений между\n"
"интерпретируемым и скомпилированным кодом. Недостатком является то,\n"
"что интерпретатор в Guile 2.2 все еще в два раза медленнее, чем\n"
"интерпретатор в 1.8.  Поскольку пользователи Scheme в основном\n"
"вполняют скомпилированный код, скорость скомпилированного кода \n"
"выше, что компенсирует потерю скорости интерпретатором. В любом \n"
"случае, если у нас есть встроенная компиляция кода Scheme, мы ожидаем,\n"
"что самообслуживаемый интерпретатор, легко обыграет старую настроенную\n"
"в ручную Си реализацию."

#: /home/bear/work/guile/doc/guile/en/vm.texi:96
msgid ""
"Also note that this decision to implement a bytecode compiler does not\n"
"preclude native compilation. We can compile from bytecode to native\n"
"code at runtime, or even do ahead of time compilation. More\n"
"possibilities are discussed in @ref{Extending the Compiler}."
msgstr ""
"Также обратите внимание, что это решение реализовать компилятор\n"
"байт-кода не исключает компиляцию в исполняемый код базовой системы.\n"
"Мы можем скомпилировать из байт-кода в исполняемый код во время\n"
"выполнения, или даже сделать предварительную компиляцию. Дополнительные\n"
"возможности обсуждаются в @ref{Extending the Compiler}."

#: /home/bear/work/guile/doc/guile/en/vm.texi:99
msgid ""
"@node VM Concepts\n"
"@subsection VM Concepts"
msgstr ""
"@node VM Concepts\n"
"@subsection Концепция Виртуальной Машины(ВМ)"

#: /home/bear/work/guile/doc/guile/en/vm.texi:103
msgid ""
"Compiled code is run by a virtual machine (VM).  Each thread has its own\n"
"VM.  The virtual machine executes the sequence of instructions in a\n"
"procedure."
msgstr ""
"Скомпилированный код запускается виртуальной машиной(ВМ). Каждый поток\n"
"имеет собственную виртуальную машину. Виртуальная машина выполняет\n"
"последовательность инструкций в процедуре."

#: /home/bear/work/guile/doc/guile/en/vm.texi:109
msgid ""
"Each VM instruction starts by indicating which operation it is, and then\n"
"follows by encoding its source and destination operands.  Each procedure\n"
"declares that it has some number of local variables, including the\n"
"function arguments.  These local variables form the available operands\n"
"of the procedure, and are accessed by index."
msgstr ""
"Каждая инструкция ВМ начинается с указания, что это за операция, а затем\n"
"следуют закодированные ее исходные и целевые операнды. Каждая процедура\n"
"объявляет, какое она имеет количество локальных переменных, включая\n"
"аргументы функции. Эти локальные переменные образуют доступные операнды\n"
"в процедуре, и доступ к ним осуществляется по индексу."

#: /home/bear/work/guile/doc/guile/en/vm.texi:114
msgid ""
"The local variables for a procedure are stored on a stack.  Calling a\n"
"procedure typically enlarges the stack, and returning from a procedure\n"
"shrinks it.  Stack memory is exclusive to the virtual machine that owns\n"
"it."
msgstr ""
"Локальные переменные для процедуры храняться в стеке. Вызов процедуры\n"
"обычно увеличивает стек, и возврат из процедуры сокращает его. Память\n"
"стека является ограниченной по доступу виртуальной машиной, которой она\n"
"принадлежит."

#: /home/bear/work/guile/doc/guile/en/vm.texi:118
msgid ""
"In addition to their stacks, virtual machines also have access to the\n"
"global memory (modules, global bindings, etc) that is shared among other\n"
"parts of Guile, including other VMs."
msgstr ""
"В дополнение к своим стекам виртуальные машины также имеют доступ к\n"
"глобальной памяти (модули(modules), глобальные связанные перменные\n"
"(global bindings), и т.д), которые разделяются между другими частями\n"
"Guile, включая другие ВМ."

#: /home/bear/work/guile/doc/guile/en/vm.texi:120
msgid "The registers that a VM has are as follows:"
msgstr "Регистры имеющиеся у ВМ следующие:"

#: /home/bear/work/guile/doc/guile/en/vm.texi:126
msgid ""
"@itemize\n"
"@item ip - Instruction pointer\n"
"@item sp - Stack pointer\n"
"@item fp - Frame pointer\n"
"@end itemize"
msgstr ""
"@itemize\n"
"@item ip - Указатель инструкции(Instruction pointer)\n"
"@item sp - Указатель стеа(Stack pointer)\n"
"@item fp - Указатель кадра(Frame pointer)\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/vm.texi:131
msgid ""
"In other architectures, the instruction pointer is sometimes called the\n"
"``program counter'' (pc). This set of registers is pretty typical for\n"
"virtual machines; their exact meanings in the context of Guile's VM are\n"
"described in the next section."
msgstr ""
"В других архитектурах указатель команд иногда называют ``программным\n"
"счетчиком(program counter)'' (pc). Этот набор регистров довольно типичен\n"
"для виртуальных машин; их точные значения в контексте виртуальной машины\n"
"Guile описаны в следующем разделе."

#: /home/bear/work/guile/doc/guile/en/vm.texi:134
msgid ""
"@node Stack Layout\n"
"@subsection Stack Layout"
msgstr ""
"@node Stack Layout\n"
"@subsection Распределение Стека"

#: /home/bear/work/guile/doc/guile/en/vm.texi:140
msgid ""
"The stack of Guile's virtual machine is composed of @dfn{frames}. Each\n"
"frame corresponds to the application of one compiled procedure, and\n"
"contains storage space for arguments, local variables, and some\n"
"bookkeeping information (such as what to do after the frame is\n"
"finished)."
msgstr ""
"Стек виртуальной машины Guile состоит из кадров(@dfn{frames}). Каждому\n"
"кадру соответствует применение одной скомпилированной процедуры, и\n"
"содержит пространство для хранения аргументов, локальных переменных и\n"
"некоторой другой учетной информации (например, что делать после завершения\n"
"кадра)."

#: /home/bear/work/guile/doc/guile/en/vm.texi:145
msgid ""
"While the compiler is free to do whatever it wants to, as long as the\n"
"semantics of a computation are preserved, in practice every time you\n"
"call a function, a new frame is created. (The notable exception of\n"
"course is the tail call case, @pxref{Tail Calls}.)"
msgstr ""
"Хотя компилятор может делать все, что захочет, до тех пор пока\n"
"семантика вычислений сохраняется, на практике каждый раз, когда\n"
"вы вызываете функцию, создается новый кадр. (Заметным исключением,\n"
"конечно, является случай хвостового вызова, @pxref{Tail Calls}.)"

#: /home/bear/work/guile/doc/guile/en/vm.texi:147
msgid "The structure of the top stack frame is as follows:"
msgstr "Структура верхнего стекового кадра выглядит следующим образом:"

#: /home/bear/work/guile/doc/guile/en/vm.texi:164
msgid ""
"@example\n"
"   | ...              |\n"
"   +==================+ <- fp + 2 = SCM_FRAME_PREVIOUS_SP (fp)\n"
"   | Dynamic link     |\n"
"   +------------------+\n"
"   | Return address   |\n"
"   +==================+ <- fp\n"
"   | Local 0          |\n"
"   +------------------+\n"
"   | Local 1          |\n"
"   +------------------+\n"
"   | ...              |\n"
"   +------------------+\n"
"   | Local N-1        |\n"
"   \\------------------/ <- sp\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:170
msgid ""
"In the above drawing, the stack grows downward.  At the beginning of a\n"
"function call, the procedure being applied is in local 0, followed by\n"
"the arguments from local 1.  After the procedure checks that it is being\n"
"passed a compatible set of arguments, the procedure allocates some\n"
"additional space in the frame to hold variables local to the function."
msgstr ""
"В приведенном выше рисунке стек растет вниз. В начале вызова функции,\n"
"применяемая процедура находиться в Local 0, за которым следуют\n"
"аргументы из Local 1. После проверки процедурой, что ей передаются\n"
"совместимый набор аргументов, процедура выделяет некоторое дополнительное\n"
"пространство в кадре для хранения локальных для функции переменных."

#: /home/bear/work/guile/doc/guile/en/vm.texi:177
msgid ""
"Note that once a value in a local variable slot is no longer needed,\n"
"Guile is free to re-use that slot.  This applies to the slots that were\n"
"initially used for the callee and arguments, too.  For this reason,\n"
"backtraces in Guile aren't always able to show all of the arguments: it\n"
"could be that the slot corresponding to that argument was re-used by\n"
"some other variable."
msgstr ""
"Обратите внимание, что после того, как значение в слоте локальной\n"
"переменной больше не треубется, Guile может повторно использовать\n"
"этот слот. Это относиться и к слотам, которые первоначально использовались\n"
"для аргументов и вызываемого(?).  По этой причине, обратная трасса в\n"
"Guile не всегда может показать все аргументы: это может быть вызвано тем,\n"
"что слот, соответствующий этому аргументу, был повторно использован\n"
"какой-либо другой переменной."

#: /home/bear/work/guile/doc/guile/en/vm.texi:183
msgid ""
"The @dfn{return address} is the @code{ip} that was in effect before this\n"
"program was applied.  When we return from this activation frame, we will\n"
"jump back to this @code{ip}.  Likewise, the @dfn{dynamic link} is the\n"
"offset of the @code{fp} that was in effect before this program was\n"
"applied, relative to the current @code{fp}."
msgstr ""
"@dfn{Обратный адрес(return address)} это @code{ip}, действоваший до "
"применения\n"
"этой программы. Когда мы вернемся из этого активного кадра, мы вернемся к\n"
"этому  @code{ip}.  Аналогичным образом, динамическая ссылка(@dfn{dynamic "
"link})\n"
"представляет собой смещение @code{fp} которое действовало до применения\n"
"этой программы, относительно текущего @code{fp}."

#: /home/bear/work/guile/doc/guile/en/vm.texi:190
msgid ""
"To prepare for a non-tail application, Guile's VM will emit code that\n"
"shuffles the function to apply and its arguments into appropriate stack\n"
"slots, with two free slots below them.  The call then initializes those\n"
"free slots with the current @code{ip} and @code{fp}, and updates\n"
"@code{ip} to point to the function entry, and @code{fp} to point to the\n"
"new call frame."
msgstr ""
"Чтобы подготовиться к не-хвостовому приложению, ВМ Guile выполняет код\n"
"который меняет размещает применяемую функцию и ее аргументы в "
"соответствующие\n"
"слоты стека с двумя свободными слотами под ними.  Затем вызов "
"инициализирует\n"
"эти два свободных слота текущими @code{ip} и @code{fp}, и изменяет\n"
"@code{ip} на точку входа в функцию, и @code{fp} на точку кадра нового \n"
"вызова."

#: /home/bear/work/guile/doc/guile/en/vm.texi:193
msgid ""
"In this way, the dynamic link links the current frame to the previous\n"
"frame.  Computing a stack trace involves traversing these frames."
msgstr ""
"Таким образом, динамическая ссылка(dynamic link) связывает текущий кадр\n"
"стека с предыдущим. Вычисление трассировки стека включает в себя\n"
"перемещение по этим кадрам."

#: /home/bear/work/guile/doc/guile/en/vm.texi:199
msgid ""
"Each stack local in Guile is 64 bits wide, even on 32-bit architectures.\n"
"This allows Guile to preserve its uniform treatment of stack locals\n"
"while allowing for unboxed arithmetic on 64-bit integers and\n"
"floating-point numbers.  @xref{Instruction Set}, for more on unboxed\n"
"arithmetic."
msgstr ""
"Каждый локальный стек Guile имеет ширину 64 бита, даже на 32-битных \n"
"архитектурах. Это позволяет Guile сохранять единообразную обработку\n"
"локального стека, позволяя при необходимости использовать арифметику\n"
"64-битных целых и с плавающей точкой чисел.  \n"
"См. @xref{Instruction Set}, для получения дополнительной информации\n"
"об распакованной арифметике."

#: /home/bear/work/guile/doc/guile/en/vm.texi:205
msgid ""
"As an implementation detail, we actually store the dynamic link as an\n"
"offset and not an absolute value because the stack can move at runtime\n"
"as it expands or during partial continuation calls.  If it were an\n"
"absolute value, we would have to walk the frames, relocating frame\n"
"pointers."
msgstr ""
"В качестве детали реализации, мы фактически сохраняем динамическую\n"
"ссылку как смещение, а не абсолютное значение, потому что стек\n"
"может перемещаться во время выполнения по мере его расширения или\n"
"во время вызова продолжений(continuation).  Если бы это было абсолютное\n"
"значение, нам пришлось бы ходить по кадрам, и пересчитывать\n"
"указатели кадров."

#: /home/bear/work/guile/doc/guile/en/vm.texi:208
msgid ""
"@node Variables and the VM\n"
"@subsection Variables and the VM"
msgstr ""
"@node Variables and the VM\n"
"@subsection Переменные и Виртуальная Машина"

#: /home/bear/work/guile/doc/guile/en/vm.texi:210
msgid "Consider the following Scheme code as an example:"
msgstr "В качестве примера рассмотрим следующий код Scheme:"

#: /home/bear/work/guile/doc/guile/en/vm.texi:215
msgid ""
"@example\n"
"  (define (foo a)\n"
"    (lambda (b) (list foo a b)))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:219
msgid ""
"Within the lambda expression, @code{foo} is a top-level variable,\n"
"@code{a} is a lexically captured variable, and @code{b} is a local\n"
"variable."
msgstr ""
"Внутри лямбда выражения, @code{foo} --- это переменная верхнего уровня,\n"
"@code{a} --- это лексически захваченная переменная, и @code{b} это "
"локальная\n"
"перменная."

#: /home/bear/work/guile/doc/guile/en/vm.texi:228
msgid ""
"Another way to refer to @code{a} and @code{b} is to say that @code{a} is\n"
"a ``free'' variable, since it is not defined within the lambda, and\n"
"@code{b} is a ``bound'' variable. These are the terms used in the\n"
"@dfn{lambda calculus}, a mathematical notation for describing functions.\n"
"The lambda calculus is useful because it is a language in which to\n"
"reason precisely about functions and variables.  It is especially good\n"
"at describing scope relations, and it is for that reason that we mention\n"
"it here."
msgstr ""
"Другой путь, ссылки на @code{a} и @code{b} состоит в том, чтобы сказать,\n"
"что @code{a} является ``свободной'' переменной, поскольку не определена\n"
"в пределах лямбды, а @code{b} это ``сязанная(bound)'' переменная. Это\n"
"термины, исползуемые в лямбда исчислении (@dfn{lambda calculus}), \n"
"математическом обозначении для описания функций. Лямбда исчисление\n"
"полезно потому что это язык, на котором можно точно рассуждать \n"
"о функциях и переменных. Оно особенно хорошо при описании сферы отношений,\n"
"и именно по этой причине мы упоминаем об этом здесь."

#: /home/bear/work/guile/doc/guile/en/vm.texi:233
msgid ""
"Guile allocates all variables on the stack. When a lexically enclosed\n"
"procedure with free variables---a @dfn{closure}---is created, it copies\n"
"those variables into its free variable vector. References to free\n"
"variables are then redirected through the free variable vector."
msgstr ""
"Guile выделяет все переменные в стеке. Когда лексически замкнутая\n"
"процедура со свободными переменными --- замыкание(@dfn{closure})---\n"
"создается, она копирует эти переменные в вектор своей свободной \n"
"переменной. Ссылки на свободные переменные затем перенаправляются\n"
"через вектор свободной переменной."

#: /home/bear/work/guile/doc/guile/en/vm.texi:242
msgid ""
"If a variable is ever @code{set!}, however, it will need to be\n"
"heap-allocated instead of stack-allocated, so that different closures\n"
"that capture the same variable can see the same value. Also, this\n"
"allows continuations to capture a reference to the variable, instead\n"
"of to its value at one point in time. For these reasons, @code{set!}\n"
"variables are allocated in ``boxes''---actually, in variable cells.\n"
"@xref{Variables}, for more information. References to @code{set!}\n"
"variables are indirected through the boxes."
msgstr ""
"Если переменная когда-либо установлена @code{set!}, она должна быть\n"
"выделена в куче(heap-allocated) вместо выделения в стеке, так что\n"
"разные замыкания, которые захватывают одну и туже переменную,\n"
"могут видеть одно и тоже значение. Кроме того, это позволяеет \n"
"продолжениям(continuations) захватывать ссылки на переменную, а\n"
"не на ее текущее значение. По этим причинам, @code{set!}\n"
"переменные выделяемые в ``рамках на рисунке стека(boxes)''---фактически, \n"
"в ячейках переменных кучи. Дополнительную информацию см.\n"
"@xref{Variables},  Ссылка на переменные в @code{set!} являются\n"
"косвенными указывающими через boxes на ячекий в куче."

#: /home/bear/work/guile/doc/guile/en/vm.texi:247
msgid ""
"Thus perhaps counterintuitively, what would seem ``closer to the\n"
"metal'', viz @code{set!}, actually forces an extra memory allocation and\n"
"indirection.  Sometimes Guile's optimizer can remove this allocation,\n"
"but not always."
msgstr ""
"Таким образом, противоинтуитивное, казалось бы лучшее размещение ``ближе к "
"телу'',\n"
"а именно @code{set!}, на самом деле способствует дополнительному выделению\n"
"памяти и косвенной адресации ячейки. Иногда оптимизатор Guile может удалить\n"
"это выделение, но не всегда."

#: /home/bear/work/guile/doc/guile/en/vm.texi:250
msgid ""
"Going back to our example, @code{b} may be allocated on the stack, as\n"
"it is never mutated."
msgstr ""
"Возвращаясь к нашему примеру, @code{b} может быть выделен в стеке, "
"поскольку\n"
"он никогда не изменяется."

#: /home/bear/work/guile/doc/guile/en/vm.texi:254
msgid ""
"@code{a} may also be allocated on the stack, as it too is never\n"
"mutated. Within the enclosed lambda, its value will be copied into\n"
"(and referenced from) the free variables vector."
msgstr ""
"@code{a} также может быть выделено в стеке, поскольку она также\n"
"никогда не изменяется. В лямбда замыкании, его значение будет \n"
"скопировано в (и указано откуда) из вектора свободных переменных."

#: /home/bear/work/guile/doc/guile/en/vm.texi:257
msgid ""
"@code{foo} is a top-level variable, because @code{foo} is not\n"
"lexically bound in this example."
msgstr ""
"@code{foo} --- это переменная верхнего уровня, потому что @code{foo} не\n"
"лексически связан в этом примере."

#: /home/bear/work/guile/doc/guile/en/vm.texi:260
msgid ""
"@node VM Programs\n"
"@subsection Compiled Procedures are VM Programs"
msgstr ""
"@node VM Programs\n"
"@subsection Скомпилированные Процедуры это программы Виртуальной Машины"

#: /home/bear/work/guile/doc/guile/en/vm.texi:265
msgid ""
"By default, when you enter in expressions at Guile's REPL, they are\n"
"first compiled to bytecode.  Then that bytecode is executed to produce a\n"
"value.  If the expression evaluates to a procedure, the result of this\n"
"process is a compiled procedure."
msgstr ""
"По умолчанию, когда вы вводите выражения в Guile REPL, они сначала\n"
"компилируются в байт-код. Затем этот байт-код выполняется для\n"
"создания значения.  Если вычисляемое выражение является процедурой,\n"
"результатом этого процесса будет скомпилированная процедура."

#: /home/bear/work/guile/doc/guile/en/vm.texi:272
msgid ""
"A compiled procedure is a compound object consisting of its bytecode and\n"
"a reference to any captured lexical variables.  In addition, when a\n"
"procedure is compiled, it has associated metadata written to side\n"
"tables, for instance a line number mapping, or its docstring.  You can\n"
"pick apart these pieces with the accessors in @code{(system vm\n"
"program)}.  @xref{Compiled Procedures}, for a full API reference."
msgstr ""
"Скомпилированная процедура представляет собой составной объект, состоящий\n"
"из его байт-кода и ссылки на любые лексически захваченные переменные. \n"
"Кроме того, когда процедура компилируется, она ассоциируется с метаданными\n"
"записанными как таблица, например, сопоставление кода и номеров строк, или\n"
"docstring. Вы можете посмотреть эти части с помощью функций доступа из\n"
"модуля @code{(system vm program)}.  @xref{Compiled Procedures}, для полной\n"
"ссылки на API."

#: /home/bear/work/guile/doc/guile/en/vm.texi:278
msgid ""
"A procedure may reference data that was statically allocated when the\n"
"procedure was compiled.  For example, a pair of immediate objects\n"
"(@pxref{Immediate objects}) can be allocated directly in the memory\n"
"segment that contains the compiled bytecode, and accessed directly by\n"
"the bytecode."
msgstr ""
"Процедура может ссылаться на данные, которые были статически\n"
"выделелены(распределены) когда процедура была скомпилирована.\n"
"Например, пара непосредственных(immediate) объектов \n"
"(@pxref{Immediate objects}) может быть выделена непосредственно\n"
"в сегменте памяти, который содержит скомпилированный байт-код\n"
"и доступна непосредственно этому байт-коду."

#: /home/bear/work/guile/doc/guile/en/vm.texi:286
msgid ""
"Another use for statically allocated data is to serve as a cache for a\n"
"bytecode.  Top-level variable lookups are handled in this way.  If the\n"
"@code{toplevel-box} instruction finds that it does not have a cached\n"
"variable for a top-level reference, it accesses other static data to\n"
"resolve the reference, and fills in the cache slot.  Thereafter all\n"
"access to the variable goes through the cache cell.  The variable's\n"
"value may change in the future, but the variable itself will not."
msgstr ""
"Другое использование для статически распределенных данных - служить\n"
"кешем для байт-кода. Запросы к переменным верхнего уровеня обрабатываются\n"
"таким образом. Если инструкция @code{toplevel-box} обнаруживает, что\n"
"она не имеет кэшированной переменной для ссылки верхнего уровня, она \n"
"обращается к другим статическим данным для разрешения ссылки и заполняет\n"
"ей слот кеша. После этого весь доступ к переменной происходит через\n"
"кэш-ячейку. Значение переменной может измениться в будущем, но сама\n"
"переменная изменена не будет."

#: /home/bear/work/guile/doc/guile/en/vm.texi:289
msgid ""
"We can see how these concepts tie together by disassembling the\n"
"@code{foo} function we defined earlier to see what is going on:"
msgstr ""
"Мы можем видеть, как эти понятия объединяются путем разбора\n"
"функции @code{foo}, которую мы определили раньше. Чтоыбы\n"
"посмотреть что происходит:"

#: /home/bear/work/guile/doc/guile/en/vm.texi:294
msgid ""
"@smallexample\n"
"scheme@@(guile-user)> (define (foo a) (lambda (b) (list foo a b)))\n"
"scheme@@(guile-user)> ,x foo\n"
"Disassembly of #<procedure foo (a)> at #xea4ce4:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:300
msgid ""
"   0    (assert-nargs-ee/locals 2 0)    ;; 2 slots (1 arg)    at (unknown "
"file):1:0\n"
"   1    (make-closure 1 7 1)            ;; anonymous procedure at #xea4d04 "
"(1 free var)\n"
"   4    (free-set! 1 0 0)               ;; free var 0\n"
"   6    (mov 0 1)\n"
"   7    (return-values 2)               ;; 1 value"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:303
msgid ""
"----------------------------------------\n"
"Disassembly of anonymous procedure at #xea4d04:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:314
msgid ""
"   0    (assert-nargs-ee/locals 2 2)    ;; 4 slots (1 arg)    at (unknown "
"file):1:16\n"
"   1    (toplevel-box 1 74 58 68 #t)    ;; `foo'\n"
"   6    (box-ref 1 1)                   \n"
"   7    (make-short-immediate 0 772)    ;; ()                 at (unknown "
"file):1:28\n"
"   8    (cons 2 2 0)                    \n"
"   9    (free-ref 3 3 0)                ;; free var 0\n"
"  11    (cons 3 3 2)\n"
"  12    (cons 2 1 3)\n"
"  13    (return-values 2)               ;; 1 value\n"
"@end smallexample"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:318
msgid ""
"First there's some prelude, where @code{foo} checks that it was called\n"
"with only 1 argument.  Then at @code{ip} 1, we allocate a new closure\n"
"and store it in slot 1, relative to the @code{sp}."
msgstr ""
"Сначала идет небольшая прелюдия, где @code{foo} проверяет, что она была\n"
"вызвана только с 1 аргументом. Затем на @code{ip} 1, мы выделяем новое\n"
"замыкание и сохраняем его в слоте 1 относительно @code{sp}."

#: /home/bear/work/guile/doc/guile/en/vm.texi:324
msgid ""
"At run-time, local variables in Guile are usually addressed relative to\n"
"the stack pointer, which leads to a pleasantly efficient\n"
"@code{sp[@var{n}]} access.  However it can make the disassembly hard to\n"
"read, because the @code{sp} can change during the function, and because\n"
"incoming arguments are relative to the @code{fp}, not the @code{sp}."
msgstr ""
"Во время выполнения, локальные переменные в Guile обычно адресуются \n"
"относительно указателя стека, что приводит к приятному эффективному\n"
"доступу @code{sp[@var{n}]}.  Однако это может затруднить дизасемблирование,\n"
"потому что @code{sp} может меняться во время работы функции и потому \n"
"что входящие аргумекнты относятся к  @code{fp}, а не @code{sp}."

#: /home/bear/work/guile/doc/guile/en/vm.texi:334
msgid ""
"To know what @code{fp}-relative slot corresponds to an\n"
"@code{sp}-relative reference, scan up in the disassembly until you get\n"
"to a ``@var{n} slots'' annotation; in our case, 2, indicating that the\n"
"frame has space for 2 slots.  Thus a zero-indexed @code{sp}-relative\n"
"slot of 1 corresponds to the @code{fp}-relative slot of 0, which\n"
"initially held the value of the closure being called.  This means that\n"
"Guile doesn't need the value of the closure to compute its result, and\n"
"so slot 0 was free for re-use, in this case for the result of making a\n"
"new closure."
msgstr ""
"Чтобы узнать, какой ссылке на слот относительно @code{fp} соответствует \n"
"ссылка относитеьно @code{sp}, просматривайте дизассемблированный код вверх,\n"
"пока вы не дойдете до анотации ``@var{n} slots''; в нашем случае 2, что\n"
"указывает на то, что кадру выделено место из 2 слотов.  Таким образом\n"
"слот адресуемый относительно @code{sp} с индексом 1 соответствует\n"
"слоту адресуему относительно @code{fp} с индексом 0, который первоначально\n"
"содержал значение вызванного замыкания.  Это означает. что Guile значение\n"
"этого замыкания не требуется и поэтому слот 0 был освобожден для\n"
"повторного использования, в данном случае для результата создания\n"
"нового замыкания."

#: /home/bear/work/guile/doc/guile/en/vm.texi:342
msgid ""
"A closure is code with data.  The @code{6} in the @code{(make-closure 1\n"
"6 1)} is a relative offset from the instruction pointer of the code for\n"
"the closure, and the final @code{1} indicates that the closure has space\n"
"for 1 free variable.  @code{Ip} 4 initializes free variable 0 in the new\n"
"closure with the value from @code{sp}-relative slot 0, which corresponds\n"
"to @code{fp}-relative slot 1, the first argument of @code{foo}:\n"
"@code{a}.  Finally we return the closure."
msgstr ""
"Замыкание это код с данными.  @code{6} в вызове создания замыкания\n"
"@code{(make-closure 1 6 1)} является относительным смещением от точки\n"
"указателя кода(ip) для замыкания, и конечная @code{1} указывает, что\n"
"замыкание располагает местом для 1 свободной переменной.  @code{ip} 4 \n"
"инициализирует свободную переменную 0 в новом замыкании с помощью\n"
"значения из слота расположенного относительно  @code{sp}-со смещением\n"
"0, что соответствует слоту относительно @code{fp} со смещением 1, это\n"
"первый аргумент функции @code{foo}: @code{a}.  Наконец мы возвращаем\n"
"замыкание."

#: /home/bear/work/guile/doc/guile/en/vm.texi:350
msgid ""
"The second stanza disassembles the code for the closure.  After the\n"
"prelude, we load the variable for the toplevel variable @code{foo} into\n"
"slot 1.  This lookup occurs lazily, the first time the variable is\n"
"actually referenced, and the location of the lookup is cached so that\n"
"future references are very cheap.  @xref{Top-Level Environment\n"
"Instructions}, for more details.  The @code{box-ref} dereferences the\n"
"variable cell, replacing the contents of slot 1."
msgstr ""
"Вторая строфа разбирает код для замыкания. После прелюдии, мы загружаем\n"
"переменную для переменной верхнего уровня @code{foo} в слот 1.\n"
"Этот поиск происходит лениво, в первое время переменная, на которое\n"
"фактически ссылается переменная, и местоположение поиска кешируются так,\n"
"что будущие ссылки на них очень дешевы.  @xref{Top-Level Environment\n"
"Instructions}, для более подробной информации.  @code{box-ref} "
"разыменовывает\n"
"ячейку переменной, заменяя содержимое слота 1."

#: /home/bear/work/guile/doc/guile/en/vm.texi:359
msgid ""
"What follows is a sequence of conses to build up the result list.\n"
"@code{Ip} 7 makes the tail of the list.  @code{Ip} 8 conses on the value\n"
"in slot 2, corresponding to the first argument to the closure: @code{b}.\n"
"@code{Ip} 9 loads free variable 0 of slot 3 -- the procedure being\n"
"called, in @code{fp}-relative slot 0 -- into slot 3, then @code{ip} 11\n"
"conses it onto the list.  Finally we cons the value in slot 1,\n"
"containing the @code{foo} toplevel, onto the front of the list, and we\n"
"return it."
msgstr ""
"Ниже следует последовательность созданий пар(conses) для построения\n"
"результирующего списка. @code{Ip} 7 создает хвост списка(непосредственный\n"
"пустой список). @code{Ip} 8 conses создает пару из значения в слоте 2,\n"
"соответствующее первому аргументу замыкания: @code{b} и хвоста.\n"
"@code{Ip} 9 загружает свободную переменную 0 слота 3-- вызыванной \n"
"процедуры(a), в @code{fp}-относительно слота 0 -- будет слот 3, \n"
"@code{ip} 11 conses создает следующую пару списка.  Наконец мы\n"
"cons создаем пару, из значения в слоте 1, содержащую  @code{foo} \n"
"верхнего уровня(и хвоста), переднего плана списка, и затем возвращаем ее."

#: /home/bear/work/guile/doc/guile/en/vm.texi:363
msgid ""
"@node Object File Format\n"
"@subsection Object File Format"
msgstr ""
"@node Object File Format\n"
"@subsection Формат Объектного Файла"

#: /home/bear/work/guile/doc/guile/en/vm.texi:367
msgid ""
"To compile a file to disk, we need a format in which to write the\n"
"compiled code to disk, and later load it into Guile.  A good @dfn{object\n"
"file format} has a number of characteristics:"
msgstr ""
"Чтобы скомпилировать файл на диск, нам нужен формат для записи "
"скомпилированного\n"
"кода на диск и позже загрузки его в Guile. Хороший формат объектного файла\n"
"@dfn{object file format}имеет ряд характеристик:"

#: /home/bear/work/guile/doc/guile/en/vm.texi:380
msgid ""
"@itemize\n"
"@item Above all else, it should be very cheap to load a compiled file.\n"
"@item It should be possible to statically allocate constants in the\n"
"file.  For example, a bytevector literal in source code can be emitted\n"
"directly into the object file.\n"
"@item The compiled file should enable maximum code and data sharing\n"
"between different processes.\n"
"@item The compiled file should contain debugging information, such as\n"
"line numbers, but that information should be separated from the code\n"
"itself.  It should be possible to strip debugging information if space\n"
"is tight.\n"
"@end itemize"
msgstr ""
"@itemize\n"
"@item Прежде всего, загрузка скомпилированного файла должна быть очень "
"дешева.\n"
"@item Должна быть возможность статически выделять константы в файле. "
"Например,\n"
"литерал байтовый вектор(bytevector) должен быть из исходного кода размещен\n"
"непосредственно в объектный файл.\n"
"@item Скомпилированный файл должен максимум кода и данных разделять между\n"
"различными процессами.\n"
"@item Скомпилированный файл должен содержать инофрмацию об отладке. такую\n"
"как номера строк, но эта информация должна быть отделена от самого кода.\n"
"должно быть возможность отлаживать информацию, если пространство заполнено.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/vm.texi:389
msgid ""
"These characteristics are not specific to Scheme.  Indeed, mainstream\n"
"languages like C and C++ have solved this issue many times in the past.\n"
"Guile builds on their work by adopting ELF, the object file format of\n"
"GNU and other Unix-like systems, as its object file format.  Although\n"
"Guile uses ELF on all platforms, we do not use platform support for ELF.\n"
"Guile implements its own linker and loader.  The advantage of using ELF\n"
"is not sharing code, but sharing ideas.  ELF is simply a well-designed\n"
"object file format."
msgstr ""
"Эти характеристики не специфичны для Scheme.  Действительно, основные\n"
"языки, такие как Си и Си++ решали эту проблему много раз в прошлом.\n"
"Guile строит свою работу на принятии ELF, формата объектных файлов\n"
"GNU и других Юникс подобных систем, как своего формата объектных файлов.\n"
"Хотя Guile исползует ELF на всех платформах, мы не используем поддержку\n"
"платформы для ELF. Guile реализует собственный компоновщик и загрузчик.\n"
"Преимущество использования ELF не в обмене кодом, но в обмене идеями.\n"
"ELF это просто хорошо продуманный формат объектного файла."

#: /home/bear/work/guile/doc/guile/en/vm.texi:396
msgid ""
"An ELF file has two meta-tables describing its contents.  The first\n"
"meta-table is for the loader, and is called the @dfn{program table} or\n"
"sometimes the @dfn{segment table}.  The program table divides the file\n"
"into big chunks that should be treated differently by the loader.\n"
"Mostly the difference between these @dfn{segments} is their\n"
"permissions."
msgstr ""
"Файл ELF содержит две мета-таблицы, описывающих его содержимое. Первая\n"
"мета-таблица для загрузчика, и называется таблицей программ \n"
"(@dfn{program table}), а иногда таблицей сегментов(@dfn{segment table}).\n"
"Таблица программ делит файл на большие куски, которые по разному\n"
"обрабатываются загрузчиком. В основном разница между этими сгментами\n"
"(@dfn{segments}) в их разрешениях(правах)."

#: /home/bear/work/guile/doc/guile/en/vm.texi:404
msgid ""
"Typically all segments of an ELF file are marked as read-only, except\n"
"that part that represents modifiable static data or static data that\n"
"needs load-time initialization.  Loading an ELF file is as simple as\n"
"mmapping the thing into memory with read-only permissions, then using\n"
"the segment table to mark a small sub-region of the file as writable.\n"
"This writable section is typically added to the root set of the garbage\n"
"collector as well."
msgstr ""
"Обычно все сегменты файла ELF помечены как доступные только для чтения.\n"
"за исключением той части которая представляет собой модифицируемые\n"
"статические даные, которые необходио загрузить во время инициализации.\n"
"Загрузка ELF файла так же проста, как функция отображение файла в "
"оперативную\n"
"память(mmapping) с флагом доступа только для чтения, затем используя "
"таблицу\n"
"сегментов, отмечают небольшой субрегион, как доступный для записи.\n"
"Этот доступный для записи раздел обычно добавляют к корневому набору\n"
"сборщика мусора."

#: /home/bear/work/guile/doc/guile/en/vm.texi:417
msgid ""
"One ELF segment is marked as ``dynamic'', meaning that it has data of\n"
"interest to the loader.  Guile uses this segment to record the Guile\n"
"version corresponding to this file.  There is also an entry in the\n"
"dynamic segment that points to the address of an initialization thunk\n"
"that is run to perform any needed link-time initialization.  (This is\n"
"like dynamic relocations for normal ELF shared objects, except that we\n"
"compile the relocations as a procedure instead of having the loader\n"
"interpret a table of relocations.)  Finally, the dynamic segment marks\n"
"the location of the ``entry thunk'' of the object file.  This thunk is\n"
"returned to the caller of @code{load-thunk-from-memory} or\n"
"@code{load-thunk-from-file}.  When called, it will execute the ``body''\n"
"of the compiled expression."
msgstr ""
"Один сегмент ELF обозначается как динамический(``dynamic''), что означает\n"
"что он имеет данные, представляющие интерез для загрузчика. Guile "
"использует\n"
"этот сегмент для записи версии Guile, соответствующей этому файлу. Там "
"также\n"
"записывается в динамическом сегменте адрес точки инициализационного  "
"сегмента\n"
"(thunk) который запускается для выполнения любой необходиой инициализации\n"
"выполняемой во время связывания(link-time).  (Это похоже на динамическое \n"
"перемещение для обычных ELF разделяемых объкетов, за исключением того, что "
"мы\n"
"компилируем перестановки как процедуры, вместо того чтобы загрузчик\n"
"интерпретировал таблицу перемещенй) Наконец, динамический сегмент "
"обозначает\n"
"местоположение  входного сегмента(``entry thunk'') объектного файла. этот "
"сегмент\n"
"возвращается вызвавшему процедуру @code{load-thunk-from-memory} или\n"
"@code{load-thunk-from-file}.  При вызове, он выполнит ``тело'' "
"скомпилированных\n"
"выражений."

#: /home/bear/work/guile/doc/guile/en/vm.texi:424
msgid ""
"The other meta-table in an ELF file is the @dfn{section table}.  Whereas\n"
"the program table divides an ELF file into big chunks for the loader,\n"
"the section table specifies small sections for use by introspective\n"
"tools like debuggers or the like.  One segment (program table entry)\n"
"typically contains many sections.  There may be sections outside of any\n"
"segment, as well."
msgstr ""
"Другая мета-таблица в  ELF файле это таблица разделов(@dfn{section table}).\n"
"В то время как таблица программ делит файл ELF на большие куски для \n"
"загрузчика, в таблице разделов указаны небольшие разделы для использования\n"
"интроспективными инструментами, такими как отладчики или тому подоное.\n"
"Один сегмент(запись в таблице программ) обычно содержит много разделов.\n"
"Также могут быть разделы вне любого сегмента."

#: /home/bear/work/guile/doc/guile/en/vm.texi:426
msgid "Typical sections in a Guile @code{.go} file include:"
msgstr "Типичные разделы в файле Guile @code{.go} включают:"

#: /home/bear/work/guile/doc/guile/en/vm.texi:461
msgid ""
"@table @code\n"
"@item .rtl-text\n"
"Bytecode.\n"
"@item .data\n"
"Data that needs initialization, or which may be modified at runtime.\n"
"@item .rodata\n"
"Statically allocated data that needs no run-time initialization, and\n"
"which therefore can be shared between processes.\n"
"@item .dynamic\n"
"The dynamic section, discussed above.\n"
"@item .symtab\n"
"@itemx .strtab\n"
"A table mapping addresses in the @code{.rtl-text} to procedure names.\n"
"@code{.strtab} is used by @code{.symtab}.\n"
"@item .guile.procprops\n"
"@itemx .guile.arities\n"
"@itemx .guile.arities.strtab\n"
"@itemx .guile.docstrs\n"
"@itemx .guile.docstrs.strtab\n"
"Side tables of procedure properties, arities, and docstrings.\n"
"@item .guile.docstrs.strtab\n"
"Side table of frame maps, describing the set of live slots for ever\n"
"return point in the program text, and whether those slots are pointers\n"
"are not.  Used by the garbage collector.\n"
"@item .debug_info\n"
"@itemx .debug_abbrev\n"
"@itemx .debug_str\n"
"@itemx .debug_loc\n"
"@itemx .debug_line\n"
"Debugging information, in DWARF format.  See the DWARF specification,\n"
"for more information.\n"
"@item .shstrtab\n"
"Section name string table.\n"
"@end table"
msgstr ""
"@table @code\n"
"@item .rtl-text\n"
"Байт-код(Bytecode).\n"
"@item .data\n"
"Данные, которые требуют инициализации или которые могут быть изменены\n"
"во время выполнения.\n"
"@item .rodata\n"
"Статически распределенные данные, которые не требуют инициализации во\n"
"время выполнения, и поэтому могут быть разделены между процессами.\n"
"@item .dynamic\n"
"Динамический раздел, рассмотреный выше.@item .symtab\n"
"@itemx .strtab\n"
"Таблица отображения адресов в @code{.rtl-text} на имена процедур.\n"
"@code{.strtab} используется @code{.symtab}.\n"
"@item .guile.procprops\n"
"@itemx .guile.arities\n"
"@itemx .guile.arities.strtab\n"
"@itemx .guile.docstrs\n"
"@itemx .guile.docstrs.strtab\n"
"сторонние таблицы свойств процедур, arities и docstrings.\n"
"@item .guile.docstrs.strtab\n"
"сторонние таблицы отображений кадров, описывающие набор живых слотов\n"
"для любой точки возврата в тексте программы, и описывающих не являются\n"
"ли эти слоты - указателями. Используется сборщиком мусора.\n"
"@item .debug_info\n"
"@itemx .debug_abbrev\n"
"@itemx .debug_str\n"
"@itemx .debug_loc\n"
"@itemx .debug_line\n"
"Отладочная информация в формате DWARF.  См. спецификацию DWARF,\n"
"для большей информации.\n"
"@item .shstrtab\n"
"Таблица сторок названий разделов.\n"
"@end table"

#: /home/bear/work/guile/doc/guile/en/vm.texi:467
msgid ""
"For more information, see @uref{http://linux.die.net/man/5/elf,,the\n"
"elf(5) man page}.  See @uref{http://dwarfstd.org/,the DWARF\n"
"specification} for more on the DWARF debugging format.  Or if you are an\n"
"adventurous explorer, try running @code{readelf} or @code{objdump} on\n"
"compiled @code{.go} files.  It's good times!"
msgstr ""
"Для получения дополнительной информации, см @uref{http://linux.die.net/man/5/"
"elf,,the\n"
"elf(5) man page}.  См. @uref{http://dwarfstd.org/,the DWARF\n"
"specification} для получения дополнительной информации о формате отладки "
"DWARF.\n"
"Или если вы авантюрный исследователь, попробуйте запустить @code{readelf} "
"или \n"
"@code{objdump} на скомпилированных файлах @code{.go}.  Это хорошее время!"

#: /home/bear/work/guile/doc/guile/en/vm.texi:471
msgid ""
"@node Instruction Set\n"
"@subsection Instruction Set"
msgstr ""
"@node Instruction Set\n"
"@subsection Набор Инструкций"

#: /home/bear/work/guile/doc/guile/en/vm.texi:476
msgid ""
"There are currently about 175 instructions in Guile's virtual machine.\n"
"These instructions represent atomic units of a program's execution.\n"
"Ideally, they perform one task without conditional branches, then\n"
"dispatch to the next instruction in the stream."
msgstr ""
"В настоящее время на виртуальной машине Guile существует около 175.\n"
"Эти инструкции представляют собой атомы единицы выполнения программы.\n"
"В идеале они выполняют одну задачу безусловной ветви, затем отправляют\n"
"на следующую инструкцию в потоке."

#: /home/bear/work/guile/doc/guile/en/vm.texi:481
msgid ""
"Instructions themselves are composed of 1 or more 32-bit units.  The low\n"
"8 bits of the first word indicate the opcode, and the rest of\n"
"instruction describe the operands.  There are a number of different ways\n"
"operands can be encoded."
msgstr ""
"Инструкции сами по себе состоят из 1 или более 32 разрядных блоков. Младшие\n"
"8 бит первого слова указывают код операции, а остальные инструкции "
"описывают\n"
"операнды. Есть несколько различных способов закодировать операнды."

#: /home/bear/work/guile/doc/guile/en/vm.texi:518
msgid ""
"@table @code\n"
"@item s@var{n}\n"
"An unsigned @var{n}-bit integer, indicating the @code{sp}-relative index\n"
"of a local variable.\n"
"@item f@var{n}\n"
"An unsigned @var{n}-bit integer, indicating the @code{fp}-relative index\n"
"of a local variable.  Used when a continuation accepts a variable number\n"
"of values, to shuffle received values into known locations in the\n"
"frame.\n"
"@item c@var{n}\n"
"An unsigned @var{n}-bit integer, indicating a constant value.\n"
"@item l24\n"
"An offset from the current @code{ip}, in 32-bit units, as a signed\n"
"24-bit value.  Indicates a bytecode address, for a relative jump.\n"
"@item i16\n"
"@itemx i32\n"
"An immediate Scheme value (@pxref{Immediate objects}), encoded directly\n"
"in 16 or 32 bits.\n"
"@item a32\n"
"@itemx b32\n"
"An immediate Scheme value, encoded as a pair of 32-bit words.\n"
"@code{a32} and @code{b32} values always go together on the same opcode,\n"
"and indicate the high and low bits, respectively.  Normally only used on\n"
"64-bit systems.\n"
"@item n32\n"
"A statically allocated non-immediate.  The address of the non-immediate\n"
"is encoded as a signed 32-bit integer, and indicates a relative offset\n"
"in 32-bit units.  Think of it as @code{SCM x = ip + offset}.\n"
"@item r32\n"
"Indirect scheme value, like @code{n32} but indirected.  Think of it as\n"
"@code{SCM *x = ip + offset}.\n"
"@item l32\n"
"@item lo32\n"
"An ip-relative address, as a signed 32-bit integer.  Could indicate a\n"
"bytecode address, as in @code{make-closure}, or a non-immediate address,\n"
"as with @code{static-patch!}."
msgstr ""
"@table @code\n"
"@item s@var{n}\n"
"Беззнаковое целое @var{n}-бит, указывает относительно @code{sp} смещение\n"
"локальной переменной.\n"
"@item f@var{n}\n"
"Беззнаковое целое @var{n}-бит, указывает относительно @code{fp} смещение\n"
"локальной переменной. Используется, когда продолжение(continuation) "
"принимает\n"
"переменное количество переменных, чтобы переставить полученные значения в \n"
"известные местоположения в кадре.\n"
"@item c@var{n}\n"
"Беззнаковое целое @var{n}-бит, указывет постоянное значение.\n"
"@item l24\n"
"Смещение от текущего @code{ip}, в 32-битных единицах, является 24-битным\n"
"значением со знаком.  Указывает адрес байт-кода, для относительного "
"перехода.\n"
"@item i16\n"
"@itemx i32\n"
"Непосредственное значение Scheme (@pxref{Immediate objects}), "
"закодированное\n"
"непосредственно в 16 или 32 битах.\n"
"@item a32\n"
"@itemx b32\n"
"Непосредственные значения Scheme, закодированнве как пара 32-битных слов.\n"
"Значения @code{a32} и @code{b32} всегда идут вместе для одного и тогоже\n"
"кода операции, и указывают на старшие и младшие биты, соответственно.\n"
"Обычно используются только в 64-битных системах.\n"
"@item n32\n"
"Статически выделенная опосредованное значение.  Адрес опосредованного\n"
"значения закодированный как знаковое целое 32-битное число, и указывающее\n"
"относительное смещение в 32-битных единицах. Думайте о нем как о\n"
"@code{SCM x = ip + offset}.\n"
"@item r32\n"
"Косвенное(не прямое) значение scheme, такое как @code{n32} но косвенное.\n"
"Думайте о нем как о: @code{SCM *x = ip + offset}.\n"
"@item l32\n"
"@item lo32\n"
"Адресс относительно ip, представляющий 32-битное знаковое целое. Может\n"
"указывать на адрес байт-кода, как в  @code{make-closure}, или на "
"опосредованный\n"
"адрес, как в @code{static-patch!}."

#: /home/bear/work/guile/doc/guile/en/vm.texi:529
msgid ""
"@code{l32} and @code{lo32} are the same from the perspective of the\n"
"virtual machine.  The difference is that an assembler might want to\n"
"allow an @code{lo32} address to be specified as a label and then some\n"
"number of words offset from that label, for example when patching a\n"
"field of a statically allocated object.\n"
"@item b1\n"
"A boolean value: 1 for true, otherwise 0.\n"
"@item x@var{n}\n"
"An ignored sequence of @var{n} bits.\n"
"@end table"
msgstr ""
"@code{l32} и @code{lo32} одинаковы с точки зрения виртуальной машины.\n"
"Разница в том, что ассемблер может захотеть разрешить @code{lo32} как\n"
"адрес указывающий на метку и некоторое количество слов смещения от\n"
"этой метки, например когда исправляется поле для статически размещенного\n"
"объекта.\n"
"@item b1\n"
"Логическое значени: 1 для истины, иначе 0.\n"
"@item x@var{n}\n"
"Игнорируемая последовательность из @var{n} бит.\n"
"@end table"

#: /home/bear/work/guile/doc/guile/en/vm.texi:533
msgid ""
"An instruction is specified by giving its name, then describing its\n"
"operands.  The operands are packed by 32-bit words, with earlier\n"
"operands occupying the lower bits."
msgstr ""
"Инструкция указывается путем указания ее имени, а затем описания ее\n"
"операндов. Операнды упакованы в 32-битные слова, причем более ранние\n"
"операнды занимают младшие биты."

#: /home/bear/work/guile/doc/guile/en/vm.texi:535
msgid "For example, consider the following instruction specification:"
msgstr "Например, рассмотрим следующую спецификацию инструкции:"

#: /home/bear/work/guile/doc/guile/en/vm.texi:539
msgid ""
"@deftypefn Instruction {} free-set! s12:@var{dst} s12:@var{src} x8:@var{_} "
"c24:@var{idx}\n"
"Set free variable @var{idx} from the closure @var{dst} to @var{src}.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} free-set! s12:@var{dst} s12:@var{src} x8:@var{_} "
"c24:@var{idx}\n"
"Установить свободную переменную @var{idx} из замыкания @var{dst} в "
"@var{src}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:544
msgid ""
"The first word in the instruction will start with the 8-bit value\n"
"corresponding to the @var{free-set!} opcode in the low bits, followed by\n"
"@var{dst} and @var{src} as 12-bit values.  The second word starts with 8\n"
"dead bits, followed by the index as a 24-bit immediate value."
msgstr ""
"Первое слово в инструкции начнется с 8-битного значения, соответствующего\n"
"коду операции @var{free-set!} в младших битах, за которым последуют\n"
"@var{dst} и @var{src} как 12-битные значения.  Второе слово начинается\n"
"с 8 неиспользуемых битов, за которыми следует индех как 24-битное\n"
"непосредственное значение."

#: /home/bear/work/guile/doc/guile/en/vm.texi:550
msgid ""
"Sometimes the compiler can figure out that it is compiling a special\n"
"case that can be run more efficiently. So, for example, while Guile\n"
"offers a generic test-and-branch instruction, it also offers specific\n"
"instructions for special cases, so that the following cases all have\n"
"their own test-and-branch instructions:"
msgstr ""
"Иногда компилятор может понять, что он компилирует специальный случай,\n"
"который может быть запущен более эффективно. Так например, в то время\n"
"как Guile предлагает общую инструкцию test-and-branch, он также предлагает\n"
"конкретные инструкции для особых случаев,  так что в следующих случаях\n"
"все test-and-branch имеют свои инструкции:"

#: /home/bear/work/guile/doc/guile/en/vm.texi:557
msgid ""
"@example\n"
"(if pred then else)\n"
"(if (not pred) then else)\n"
"(if (null? l) then else)\n"
"(if (not (null? l)) then else)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:561
msgid ""
"In addition, some Scheme primitives have their own inline\n"
"implementations.  For example, in the previous section we saw\n"
"@code{cons}."
msgstr ""
"Кроме того, некотоыре примитивы Scheme имеют свои встроенные реализации.\n"
"Например, в предыдущем разделе мы видели @code{cons}."

#: /home/bear/work/guile/doc/guile/en/vm.texi:571
msgid ""
"Finally, for instructions with operands that encode references to the\n"
"stack, the interpretation of those stack values is up to the instruction\n"
"itself.  Most instructions expect their operands to be tagged SCM values\n"
"(@code{scm} representation), but some instructions expect unboxed\n"
"integers (@code{u64} and @code{s64} representations) or floating-point\n"
"numbers (@var{f64} representation).  Instructions have static types:\n"
"they must receive their operands in the format they expect.  It's up to\n"
"the compiler to ensure this is the case.  Unless otherwise mentioned,\n"
"all operands and results are boxed as SCM values."
msgstr ""
"Наконец, инструкции с операндами, которые кодируют ссылки на стек,\n"
"интерпретируются от этих значений стека вверх до самой инсрукции.\n"
"Большинство инструкций ожидают что их операнды помечены значениями\n"
"SCM (представление @code{scm}), но некоторые инструкции ожидают \n"
"распакованных целых (представление @code{u64} и @code{s64}) или\n"
"числе с плавающей точкой (представление @var{f64}).  Инструкции\n"
"имеют статические типы: они должны получать свои операнды в \n"
"формате, который они ожидают. Это зависит о компилятора, в данном\n"
"случае. Если не указано иное, все операнды и результаты помещаются\n"
"(упаковываются) в виде значений SCM."

#: /home/bear/work/guile/doc/guile/en/vm.texi:589
msgid ""
"@menu\n"
"* Lexical Environment Instructions::\n"
"* Top-Level Environment Instructions::\n"
"* Procedure Call and Return Instructions::\n"
"* Function Prologue Instructions::\n"
"* Trampoline Instructions::\n"
"* Branch Instructions::\n"
"* Constant Instructions::\n"
"* Dynamic Environment Instructions::\n"
"* Miscellaneous Instructions::\n"
"* Inlined Scheme Instructions::\n"
"* Inlined Atomic Instructions::\n"
"* Inlined Mathematical Instructions::\n"
"* Inlined Bytevector Instructions::\n"
"* Unboxed Integer Arithmetic::\n"
"* Unboxed Floating-Point Arithmetic::\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:593
msgid ""
"@node Lexical Environment Instructions\n"
"@subsubsection Lexical Environment Instructions"
msgstr ""
"@node Lexical Environment Instructions\n"
"@subsubsection Инстркукции Лексической Среды(Окружения)"

#: /home/bear/work/guile/doc/guile/en/vm.texi:597
msgid ""
"These instructions access and mutate the lexical environment of a\n"
"compiled procedure---its free and bound variables.  @xref{Stack Layout},\n"
"for more information on the format of stack frames."
msgstr ""
"Эти инструкции получают доступ и изменяют лексическую среду "
"скомпилированной\n"
"процедуры --- ее свободных и связанных переменных.  @xref{Stack Layout},\n"
"Для дополнительной информаций см. формат кадров стека."

#: /home/bear/work/guile/doc/guile/en/vm.texi:601
msgid ""
"@deftypefn Instruction {} mov s12:@var{dst} s12:@var{src}\n"
"@deftypefnx Instruction {} long-mov s24:@var{dst} x8:@var{_} s24:@var{src}\n"
"Copy a value from one local slot to another."
msgstr ""
"@deftypefn Instruction {} mov s12:@var{dst} s12:@var{src}\n"
"@deftypefnx Instruction {} long-mov s24:@var{dst} x8:@var{_} s24:@var{src}\n"
"Скопировать значение из одного локального слота в другой."

#: /home/bear/work/guile/doc/guile/en/vm.texi:608
msgid ""
"As discussed previously, procedure arguments and local variables are\n"
"allocated to local slots.  Guile's compiler tries to avoid shuffling\n"
"variables around to different slots, which often makes @code{mov}\n"
"instructions redundant.  However there are some cases in which shuffling\n"
"is necessary, and in those cases, @code{mov} is the thing to use.\n"
"@end deftypefn"
msgstr ""
"Как обсуждалось ранее, аргументы процедуры и локальные переменные\n"
"распределяеются в локальные слоты. Компилятор  Guile пытается\n"
"измежать перестановки переменных в различные слоты, что часто\n"
"делает команды @code{mov} избыточными. Однако есть случаи, когда \n"
"необходима перестановка, и в этих случаях @code{mov} это то, \n"
"что нужно использовать.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:614
msgid ""
"@deftypefn Instruction {} long-fmov f24:@var{dst} x8:@var{_} f24:@var{src}\n"
"Copy a value from one local slot to another, but addressing slots\n"
"relative to the @code{fp} instead of the @code{sp}.  This is used when\n"
"shuffling values into place after multiple-value returns.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} long-fmov f24:@var{dst} x8:@var{_} f24:@var{src}\n"
"Копирует значение из одного локального слота в другой, но адресация\n"
"слотов относительно @code{fp} а не @code{sp}.  Команда используется при\n"
"перемещении значений после возврата множественного значения.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:620
msgid ""
"@deftypefn Instruction {} make-closure s24:@var{dst} l32:@var{offset} x8:"
"@var{_} c24:@var{nfree}\n"
"Make a new closure, and write it to @var{dst}.  The code for the closure\n"
"will be found at @var{offset} words from the current @code{ip}.\n"
"@var{offset} is a signed 32-bit integer.  Space for @var{nfree} free\n"
"variables will be allocated."
msgstr ""
"@deftypefn Instruction {} make-closure s24:@var{dst} l32:@var{offset} x8:"
"@var{_} c24:@var{nfree}\n"
"Создать новое замыкание и записать его в @var{dst}.  Код для замыкания\n"
"надо искать по смещению @var{offset} слов от текущего значения регистра "
"@code{ip}.\n"
"@var{offset} это 32-битное знаковое целое число.  Пространство для "
"@var{nfree} свободных\n"
"переменных будет выделено."

#: /home/bear/work/guile/doc/guile/en/vm.texi:624
msgid ""
"The size of a closure is currently two words, plus one word per free\n"
"variable.\n"
"@end deftypefn"
msgstr ""
"Размер замыкания в настоящее время составляет два слова, плюс одно слово\n"
"на каждую свободную переменную.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:629
msgid ""
"@deftypefn Instruction {} free-ref s12:@var{dst} s12:@var{src} x8:@var{_} "
"c24:@var{idx}\n"
"Load free variable @var{idx} from the closure @var{src} into local slot\n"
"@var{dst}.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} free-ref s12:@var{dst} s12:@var{src} x8:@var{_} "
"c24:@var{idx}\n"
"Загрузить свободную переменную @var{idx} из замыкания @var{src} в локальный "
"слот\n"
"@var{dst}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:632
msgid ""
"@deftypefn Instruction {} free-set! s12:@var{dst} s12:@var{src} x8:@var{_} "
"c24:@var{idx}\n"
"Set free variable @var{idx} from the closure @var{dst} to @var{src}."
msgstr ""
"@deftypefn Instruction {} free-set! s12:@var{dst} s12:@var{src} x8:@var{_} "
"c24:@var{idx}\n"
"Установить свободную перменную @var{idx} из замыкания @var{dst} в значение "
"из @var{src}."

#: /home/bear/work/guile/doc/guile/en/vm.texi:637
msgid ""
"This instruction is usually used when initializing a closure's free\n"
"variables, but not to mutate free variables, as variables that are\n"
"assigned are boxed.\n"
"@end deftypefn"
msgstr ""
"Эта инструкция обычно используется при инициализации свободных переменных\n"
"замыкания, но не для изменения свободных переменных, поскольку назначенные\n"
"переменные упакованы.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:643
msgid ""
"Recall that variables that are assigned are usually allocated in boxes,\n"
"so that continuations and closures can capture their identity and not\n"
"their value at one point in time.  Variables are also used in the\n"
"implementation of top-level bindings; see the next section for more\n"
"information."
msgstr ""
"Напомним, что назначенные переменные обычно размещаются упакованными,\n"
"так что продолжения и замыкания могут захватывать их идентификаторы,\n"
"а не их значения которые они имеют в определенный момент времени.\n"
"Переменные также используются при реализации высоко-уровневого\n"
"связывания; см. следующий раздел для большей информации."

#: /home/bear/work/guile/doc/guile/en/vm.texi:647
msgid ""
"@deftypefn Instruction {} box s12:@var{dst} s12:@var{src}\n"
"Create a new variable holding @var{src}, and place it in @var{dst}.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} box s12:@var{dst} s12:@var{src}\n"
"Создать новую переменную хранящуюся(?) в @var{src}, поместить ее в "
"@var{dst}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:652
msgid ""
"@deftypefn Instruction {} box-ref s12:@var{dst} s12:@var{src}\n"
"Unpack the variable at @var{src} into @var{dst}, asserting that the\n"
"variable is actually bound.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} box-ref s12:@var{dst} s12:@var{src}\n"
"Распаковать переменную из @var{src} в @var{dst}, проверяя что переменная\n"
"является связанной.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:656
msgid ""
"@deftypefn Instruction {} box-set! s12:@var{dst} s12:@var{src}\n"
"Set the contents of the variable at @var{dst} to @var{set}.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} box-set! s12:@var{dst} s12:@var{src}\n"
"Установить содержимое переменной @var{dst} в значение @var{set}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:660
msgid ""
"@node Top-Level Environment Instructions\n"
"@subsubsection Top-Level Environment Instructions"
msgstr ""
"@node Top-Level Environment Instructions\n"
"@subsubsection Инструкции сред Верхнего Уровня"

#: /home/bear/work/guile/doc/guile/en/vm.texi:664
msgid ""
"These instructions access values in the top-level environment: bindings\n"
"that were not lexically apparent at the time that the code in question\n"
"was compiled."
msgstr ""
"Эти инструкции получают значения в среде верхнего уровня: связывание\n"
"которых было не лексическим в то время когда этот код был скомпилирован.\n"

#: /home/bear/work/guile/doc/guile/en/vm.texi:668
msgid ""
"The location in which a toplevel binding is stored can be looked up once\n"
"and cached for later. The binding itself may change over time, but its\n"
"location will stay constant."
msgstr ""
"Место, в котором храниться связанное значение верхнего урвня, можно "
"разыскать\n"
"одирн раз и кэшировать для дальнейшего использования. Само связанное "
"значение\n"
"может меняться со временем, но ее местоположение останется постоянным."

#: /home/bear/work/guile/doc/guile/en/vm.texi:672
msgid ""
"@deftypefn Instruction {} current-module s24:@var{dst}\n"
"Store the current module in @var{dst}.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} current-module s24:@var{dst}\n"
"Сохранить текущий модуль в @var{dst}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:679
msgid ""
"@deftypefn Instruction {} resolve s24:@var{dst} b1:@var{bound?} x7:@var{_} "
"s24:@var{sym}\n"
"Resolve @var{sym} in the current module, and place the resulting\n"
"variable in @var{dst}.  An error will be signalled if no variable is\n"
"found.  If @var{bound?} is true, an error will be signalled if the\n"
"variable is unbound.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} resolve s24:@var{dst} b1:@var{bound?} x7:@var{_} "
"s24:@var{sym}\n"
"Разрешить(найти) @var{sym} в текущем модуле и поместить полученную "
"переменную\n"
"в @var{dst}.  Будет вызвана ошибка если переменная не найдена. Если\n"
"@var{bound?} - истина(переменная связана), ошибка будет сигнализировать о "
"том\n"
"что переменная не связана.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:684
msgid ""
"@deftypefn Instruction {} define! s12:@var{dst} s12:@var{sym}\n"
"Look up a binding for @var{sym} in the current module, creating it if\n"
"necessary.  Store that variable to @var{dst}.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} define! s12:@var{dst} s12:@var{sym}\n"
"Найти связанную переменную для @var{sym} в текущем модуле, создать ее\n"
"если необходимо, Хранить эту переменную в @var{dst}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:690
msgid ""
"@deftypefn Instruction {} toplevel-box s24:@var{dst} r32:@var{var-offset} "
"r32:@var{mod-offset} n32:@var{sym-offset} b1:@var{bound?} x31:@var{_}\n"
"Load a value.  The value will be fetched from memory, @var{var-offset}\n"
"32-bit words away from the current instruction pointer.\n"
"@var{var-offset} is a signed value.  Up to here, @code{toplevel-box} is\n"
"like @code{static-ref}."
msgstr ""
"@deftypefn Instruction {} toplevel-box s24:@var{dst} r32:@var{var-offset} "
"r32:@var{mod-offset} n32:@var{sym-offset} b1:@var{bound?} x31:@var{_}\n"
"Загружает значение.  Значение будет извлекаться из памяти, используя "
"значение\n"
"@var{var-offset} в 32-битных словах от ip(текщей точки указателя программы)\n"
"@var{var-offset} это значение со знаком.  Здесь, @code{toplevel-box} как\n"
"@code{static-ref}."

#: /home/bear/work/guile/doc/guile/en/vm.texi:693
msgid ""
"Then, if the loaded value is a variable, it is placed in @var{dst}, and\n"
"control flow continues."
msgstr ""
"Затем, если загруженное значение является переменной, оно помещатеся в\n"
"@var{dst} и выполнение продолжается."

#: /home/bear/work/guile/doc/guile/en/vm.texi:698
msgid ""
"Otherwise, we have to resolve the variable.  In that case we load the\n"
"module from @var{mod-offset}, just as we loaded the variable.  Usually\n"
"the module gets set when the closure is created.  @var{sym-offset}\n"
"specifies the name, as an offset to a symbol."
msgstr ""
"Иначе, мы должны разрешить(найти) эту переменную. В этом случае мы\n"
"загружаем модуль из @var{mod-offset}, также как мы грузим переменную.\n"
"Обычно модуль получает установки, когда замыкание создается.\n"
"@var{sym-offset} задает имя, как смещение к символу."

#: /home/bear/work/guile/doc/guile/en/vm.texi:704
msgid ""
"We use the module and the symbol to resolve the variable, placing it in\n"
"@var{dst}, and caching the resolved variable so that we will hit the\n"
"cache next time.  If @var{bound?} is true, an error will be signalled if\n"
"the variable is unbound.\n"
"@end deftypefn"
msgstr ""
"Мы используем модуль и символ для разрешения(поиска) переменной, помещая\n"
"ее в @var{dst}, и кеширования разрешенной(найденой) переменной, чтобы\n"
"в следующий раз мы попали в кеш. Если @var{bound?} это истина, а иначе\n"
"выдается сообщение об ошибке если переменная не связана.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:712
msgid ""
"@deftypefn Instruction {} module-box s24:@var{dst} r32:@var{var-offset} n32:"
"@var{mod-offset} n32:@var{sym-offset} b1:@var{bound?} x31:@var{_}\n"
"Like @code{toplevel-box}, except @var{mod-offset} points at a module\n"
"identifier instead of the module itself.  A module identifier is a\n"
"module name, as a list, prefixed by a boolean.  If the prefix is true,\n"
"then the variable is resolved relative to the module's public interface\n"
"instead of its private interface.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} module-box s24:@var{dst} r32:@var{var-offset} n32:"
"@var{mod-offset} n32:@var{sym-offset} b1:@var{bound?} x31:@var{_}\n"
"Подобно @code{toplevel-box}, за исключением @var{mod-offset} указывает\n"
"на идентификатор модуля, вместо самого модуля.  Идентификатор модуля - \n"
"это имя модуля, как список, предваряемый логическим значением. Если\n"
"это значение истинно, то переменная разрешена(найдена) относительно\n"
"общедоступного интерфейса модуля, вместо частного интерфеса.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:716
msgid ""
"@node Procedure Call and Return Instructions\n"
"@subsubsection Procedure Call and Return Instructions"
msgstr ""
"@node Procedure Call and Return Instructions\n"
"@subsubsection Инструкции вызова Процедур и Возврата"

#: /home/bear/work/guile/doc/guile/en/vm.texi:719
msgid ""
"As described earlier (@pxref{Stack Layout}), Guile's calling convention\n"
"is that arguments are passed and values returned on the stack."
msgstr ""
"Как описано выше (@pxref{Stack Layout}), соглашение о вызовах Guile\n"
"такое, что аргументы передаются а значения возвращаются в стеке."

#: /home/bear/work/guile/doc/guile/en/vm.texi:728
msgid ""
"For calls, both in tail position and in non-tail position, we require\n"
"that the procedure and the arguments already be shuffled into place\n"
"befor the call instruction.  ``Into place'' for a tail call means that\n"
"the procedure should be in slot 0, relative to the @code{fp}, and the\n"
"arguments should follow.  For a non-tail call, if the procedure is in\n"
"@code{fp}-relative slot @var{n}, the arguments should follow from slot\n"
"@var{n}+1, and there should be two free slots at @var{n}-1 and @var{n}-2\n"
"in which to save the @code{ip} and @code{fp}."
msgstr ""
"Для вызовов, как в хвостовом положении, так и нехвостовом., мы требуем,\n"
"чтобы процедура и аргументы повторно перемещались на место перед\n"
"инструкцией вызова. ``На место'' для хвостового вызова означает, что\n"
"процедура должна быть в 0 слоте, относительно указателя кадра @code{fp},\n"
"и за ней должны следовать аргументы. Для не хвостового вызова, если \n"
"процедура размещается в слоте  @var{n} относительно @code{fp},\n"
"аргументы должны следовать за слотом @var{n}+1, и должно быть два\n"
"свободных слота со смещением @var{n}-1 и @var{n}-2 для сохранения\n"
"текущих @code{ip} и @code{fp}."

#: /home/bear/work/guile/doc/guile/en/vm.texi:733
msgid ""
"Returning values is similar.  Multiple-value returns should have values\n"
"already shuffled down to start from @code{fp}-relative slot 1 before\n"
"emitting @code{return-values}.  We start from slot 1 instead of slot 0\n"
"to make tail calls to @code{values} trivial."
msgstr ""
"Возвращение значений аналогично.  Многозначные значения повторно\n"
"перемещаются вниз, чтобы начать со слота номер 1 относительно @code{fp}\n"
"перед вызовом @code{return-values}.  Мы начинаем со слота 1 вместо слота\n"
"0 что бы сделать квостовые вызовы  (со значениями|значений?) @code{values}\n"
"тривиальными."

#: /home/bear/work/guile/doc/guile/en/vm.texi:738
msgid ""
"In both calls and returns, the @code{sp} is used to indicate to the\n"
"callee or caller the number of arguments or return values, respectively.\n"
"After receiving return values, it is the caller's responsibility to\n"
"@dfn{restore the frame} by resetting the @code{sp} to its former value."
msgstr ""
"В обоих вызовах и возрватах @code{sp} используется для указания\n"
"вызываемомой процедуре числа аргументов или возвращаемых значений\n"
"для вызвавшей процедры, соответственно. После получения возвращаемых \n"
"значений, вызвавшая процедура обязана востанановить кадр \n"
"@dfn{restore the frame} и сбросить @code{sp} в его прежнее значение."

#: /home/bear/work/guile/doc/guile/en/vm.texi:745
msgid ""
"@deftypefn Instruction {} call f24:@var{proc} x8:@var{_} c24:@var{nlocals}\n"
"Call a procedure.  @var{proc} is the local corresponding to a procedure.\n"
"The two values below @var{proc} will be overwritten by the saved call\n"
"frame data.  The new frame will have space for @var{nlocals} locals: one\n"
"for the procedure, and the rest for the arguments which should already\n"
"have been pushed on."
msgstr ""
"@deftypefn Instruction {} call f24:@var{proc} x8:@var{_} c24:@var{nlocals}\n"
"Вызо процедуры.  @var{proc} является локальной соответствущей\n"
"значению процедуре. Два значения ниже @var{proc} будут перезаписаны\n"
"сохраненными данными кадра вызова. Новый кадр будет иметь пространство для\n"
"@var{nlocals} локальных: одно для процедуры, а остальные для аргументов, "
"которые\n"
"уже должны быть уже размещены."

#: /home/bear/work/guile/doc/guile/en/vm.texi:751
msgid ""
"When the call returns, execution proceeds with the next instruction.\n"
"There may be any number of values on the return stack; the precise\n"
"number can be had by subtracting the address of @var{proc} from the\n"
"post-call @code{sp}.\n"
"@end deftypefn"
msgstr ""
"Кода вызов завершается, выполнение продолжается со следующей \n"
"инструкции. В стеке может быть возвращено любое количество значений;\n"
"точное их число может быть получено вычитанием адреса  @var{proc} из\n"
"установленого после возврата значения @code{sp}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:754
msgid ""
"@deftypefn Instruction {} call-label f24:@var{proc} x8:@var{_} c24:"
"@var{nlocals} l32:@var{label}\n"
"Call a procedure in the same compilation unit."
msgstr ""
"@deftypefn Instruction {} call-label f24:@var{proc} x8:@var{_} c24:"
"@var{nlocals} l32:@var{label}\n"
"Вызов процедуры в томже компиляционном блоке."

#: /home/bear/work/guile/doc/guile/en/vm.texi:761
msgid ""
"This instruction is just like @code{call}, except that instead of\n"
"dereferencing @var{proc} to find the call target, the call target is\n"
"known to be at @var{label}, a signed 32-bit offset in 32-bit units from\n"
"the current @code{ip}.  Since @var{proc} is not dereferenced, it may be\n"
"some other representation of the closure.\n"
"@end deftypefn"
msgstr ""
"Эта инструкция похожа на вызов @code{call}, за исключением того, что\n"
"вместо разыменовывания @var{proc} для поиска цели вызова, цель вызова\n"
"как известно находиться на метке @var{label}, знаковое целое 32-битное\n"
"смещение относительно текущего указателя программы @code{ip}.  Поскольу\n"
"@var{proc} на разыменовывается, это может быть какое-то другое\n"
"представление замыкания.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:767
msgid ""
"@deftypefn Instruction {} tail-call c24:@var{nlocals}\n"
"Tail-call a procedure.  Requires that the procedure and all of the\n"
"arguments have already been shuffled into position.  Will reset the\n"
"frame to @var{nlocals}.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} tail-call c24:@var{nlocals}\n"
"Хвостовой вызов процедуры. Требует чтобы процедура и все аргументы\n"
"уже были перемещены в позицию. Сбрасывает кадр на @var{nlocals}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:772
msgid ""
"@deftypefn Instruction {} tail-call-label c24:@var{nlocals} l32:@var{label}\n"
"Tail-call a known procedure.  As @code{call} is to @code{call-label},\n"
"@code{tail-call} is to @code{tail-call-label}.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} tail-call-label c24:@var{nlocals} l32:@var{label}\n"
"Хвостовой вызов известной процедуры.  В качестве вызываемой @code{call} \n"
"стоит метка @code{call-label},\n"
"@code{tail-call} is to @code{tail-call-label}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:779
msgid ""
"@deftypefn Instruction {} tail-call/shuffle f24:@var{from}\n"
"Tail-call a procedure.  The procedure should already be set to slot 0.\n"
"The rest of the args are taken from the frame, starting at @var{from},\n"
"shuffled down to start at slot 0.  This is part of the implementation of\n"
"the @code{call-with-values} builtin.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} tail-call/shuffle f24:@var{from}\n"
"Хвостовой вызов процедуры.  Процедура уж должна быть уже размещена \n"
"в 0 слоте. Остальная часть args берется из кадра, начиная с @var{from},\n"
"перемещаются вниз, чтобы начать со слота 0.  Это является частью\n"
"реализации встроенной @code{call-with-values}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:785
msgid ""
"@deftypefn Instruction {} receive f12:@var{dst} f12:@var{proc} x8:@var{_} "
"c24:@var{nlocals}\n"
"Receive a single return value from a call whose procedure was in\n"
"@var{proc}, asserting that the call actually returned at least one\n"
"value.  Afterwards, resets the frame to @var{nlocals} locals.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} receive f12:@var{dst} f12:@var{proc} x8:@var{_} "
"c24:@var{nlocals}\n"
"Получает одно возвращаемое значение из вызова, чья процедура была\n"
"@var{proc}, проверяя, что вызов фактически возвратил хотябы одно\n"
"значение.  После этого сбрасывает кадр на @var{nlocals} локальных.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:793
msgid ""
"@deftypefn Instruction {} receive-values f24:@var{proc} b1:@var{allow-"
"extra?} x7:@var{_} c24:@var{nvalues}\n"
"Receive a return of multiple values from a call whose procedure was in\n"
"@var{proc}.  If fewer than @var{nvalues} values were returned, signal an\n"
"error.  Unless @var{allow-extra?} is true, require that the number of\n"
"return values equals @var{nvalues} exactly.  After @code{receive-values}\n"
"has run, the values can be copied down via @code{mov}, or used in place.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} receive-values f24:@var{proc} b1:@var{allow-"
"extra?} x7:@var{_} c24:@var{nvalues}\n"
"Получает возвращаемое множество значений из вызвова, чья процедура\n"
"была @var{proc}.  Если возвращеных значений меньше чем @var{nvalues},\n"
"сигнализирует об ошибке. Если не @var{allow-extra?} является истинным,\n"
"требует чтобы число возвращаемых значений точно равнялось  @var{nvalues}.\n"
"После получения значений @code{receive-values}, значения могут быть\n"
"скопированы с помощью @code{mov}, или использованы на месте.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:802
msgid ""
"@deftypefn Instruction {} return-values c24:@var{nlocals}\n"
"Return a number of values from a call frame.  This opcode corresponds to\n"
"an application of @code{values} in tail position.  As with tail calls,\n"
"we expect that the values have already been shuffled down to a\n"
"contiguous array starting at slot 1.  If @var{nlocals} is nonzero, reset\n"
"the frame to hold that number of locals.  Note that a frame reset to 1\n"
"local returns 0 values.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} return-values c24:@var{nlocals}\n"
"Возвращает несколько значений из кадра вызова.  Этому коду операции \n"
"соответствует применение значений @code{values} в хвостовой позиции.\n"
"Как и в случае с хвостовыми вызовами, мы ожидаем, что значения\n"
"уже перемещаются вниз, начиная со слота 1.  Если @var{nlocals} не ноль,\n"
"is nonzero, кадр сбрасывается, что бы удерживать это количество\n"
"локальных.  Обратите внимание, что кадр\n"
"сбрасывается до 1, local возвращает 0 значений.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:808
msgid ""
"@deftypefn Instruction {} call/cc x24:@var{_}\n"
"Capture the current continuation, and tail-apply the procedure in local\n"
"slot 1 to it.  This instruction is part of the implementation of\n"
"@code{call/cc}, and is not generated by the compiler.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} call/cc x24:@var{_}\n"
"Захватывает текущее продолжение, и применяет(tail-apply) процедуру из\n"
"локального слота 1 к ней.  Эта инструкция является частью реализации "
"@code{call/cc}, \n"
"и не генерируется компилятором.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:812
msgid ""
"@node Function Prologue Instructions\n"
"@subsubsection Function Prologue Instructions"
msgstr ""
"@node Function Prologue Instructions\n"
"@subsubsection Инструкции начинающие функции"

#: /home/bear/work/guile/doc/guile/en/vm.texi:818
msgid ""
"A function call in Guile is very cheap: the VM simply hands control to\n"
"the procedure. The procedure itself is responsible for asserting that it\n"
"has been passed an appropriate number of arguments. This strategy allows\n"
"arbitrarily complex argument parsing idioms to be developed, without\n"
"harming the common case."
msgstr ""
"Вызов функции в Guile очень дешев: Виртуальная Машина просто контролирует\n"
"процедуру. Сама процедура несет ответственность за проверку того, что ей\n"
"передано приемлемое количество аргументов. Эта стратегия позволяет "
"разбирать\n"
"аргументы произвольной сложности анализирующими идиомами, без ущерба\n"
"для общего случая."

#: /home/bear/work/guile/doc/guile/en/vm.texi:823
msgid ""
"For example, only calls to keyword-argument procedures ``pay'' for the\n"
"cost of parsing keyword arguments. (At the time of this writing, calling\n"
"procedures with keyword arguments is typically two to four times as\n"
"costly as calling procedures with a fixed set of arguments.)"
msgstr ""
"Например, только вызывая процедуры с ключевыми аргументами процедура \n"
"платит за разбор ключевых аргументов. (На момент написания, вызов\n"
"процедур с ключевыми аргументами обычно в два-четыре раза дороже,\n"
"чем вызов процедур с фиксированным набором аргументов.)"

#: /home/bear/work/guile/doc/guile/en/vm.texi:829
msgid ""
"@deftypefn Instruction {} assert-nargs-ee c24:@var{expected}\n"
"@deftypefnx Instruction {} assert-nargs-ge c24:@var{expected}\n"
"@deftypefnx Instruction {} assert-nargs-le c24:@var{expected}\n"
"If the number of actual arguments is not @code{==}, @code{>=}, or\n"
"@code{<=} @var{expected}, respectively, signal an error."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:835
msgid ""
"The number of arguments is determined by subtracting the stack pointer\n"
"from the frame pointer (@code{fp - sp}).  @xref{Stack Layout}, for more\n"
"details on stack frames.  Note that @var{expected} includes the\n"
"procedure itself.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:843
msgid ""
"@deftypefn Instruction {} br-if-nargs-ne c24:@var{expected} x8:@var{_} l24:"
"@var{offset}\n"
"@deftypefnx Instruction {} br-if-nargs-lt c24:@var{expected} x8:@var{_} l24:"
"@var{offset}\n"
"@deftypefnx Instruction {} br-if-nargs-gt c24:@var{expected} x8:@var{_} l24:"
"@var{offset}\n"
"If the number of actual arguments is not equal, less than, or greater\n"
"than @var{expected}, respectively, add @var{offset}, a signed 24-bit\n"
"number, to the current instruction pointer.  Note that @var{expected}\n"
"includes the procedure itself."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:847
msgid ""
"These instructions are used to implement multiple arities, as in\n"
"@code{case-lambda}. @xref{Case-lambda}, for more information.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:853
msgid ""
"@deftypefn Instruction {} alloc-frame c24:@var{nlocals}\n"
"Ensure that there is space on the stack for @var{nlocals} local\n"
"variables, setting them all to @code{SCM_UNDEFINED}, except those values\n"
"that are already on the stack.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:860
msgid ""
"@deftypefn Instruction {} reset-frame c24:@var{nlocals}\n"
"Like @code{alloc-frame}, but doesn't check that the stack is big enough,\n"
"and doesn't initialize values to @code{SCM_UNDEFINED}.  Used to reset\n"
"the frame size to something less than the size that was previously set\n"
"via alloc-frame.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:866
msgid ""
"@deftypefn Instruction {} assert-nargs-ee/locals c12:@var{expected} c12:"
"@var{nlocals}\n"
"Equivalent to a sequence of @code{assert-nargs-ee} and\n"
"@code{reserve-locals}.  The number of locals reserved is @var{expected}\n"
"+ @var{nlocals}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:870
msgid ""
"@deftypefn Instruction {} br-if-npos-gt c24:@var{nreq} x8:@var{_} c24:"
"@var{npos} x8:@var{_} l24:@var{offset}\n"
"Find the first positional argument after @var{nreq}.  If it is greater\n"
"than @var{npos}, jump to @var{offset}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:876
msgid ""
"This instruction is only emitted for functions with multiple clauses,\n"
"and an earlier clause has keywords and no rest arguments.\n"
"@xref{Case-lambda}, for more on how @code{case-lambda} chooses the\n"
"clause to apply.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:880
msgid ""
"@deftypefn Instruction {} bind-kwargs c24:@var{nreq} c8:@var{flags} c24:"
"@var{nreq-and-opt} x8:@var{_} c24:@var{ntotal} n32:@var{kw-offset}\n"
"@var{flags} is a bitfield, whose lowest bit is @var{allow-other-keys},\n"
"second bit is @var{has-rest}, and whose following six bits are unused."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:888
msgid ""
"Find the last positional argument, and shuffle all the rest above\n"
"@var{ntotal}.  Initialize the intervening locals to\n"
"@code{SCM_UNDEFINED}.  Then load the constant at @var{kw-offset} words\n"
"from the current @var{ip}, and use it and the @var{allow-other-keys}\n"
"flag to bind keyword arguments.  If @var{has-rest}, collect all shuffled\n"
"arguments into a list, and store it in @var{nreq-and-opt}.  Finally,\n"
"clear the arguments that we shuffled up."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:894
msgid ""
"The parsing is driven by a keyword arguments association list, looked up\n"
"using @var{kw-offset}.  The alist is a list of pairs of the form\n"
"@code{(@var{kw} . @var{index})}, mapping keyword arguments to their\n"
"local slot indices.  Unless @code{allow-other-keys} is set, the parser\n"
"will signal an error if an unknown key is found."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:897
msgid ""
"A macro-mega-instruction.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:902
msgid ""
"@deftypefn Instruction {} bind-rest f24:@var{dst}\n"
"Collect any arguments at or above @var{dst} into a list, and store that\n"
"list at @var{dst}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:906
msgid ""
"@node Trampoline Instructions\n"
"@subsubsection Trampoline Instructions"
msgstr ""
"@node Trampoline Instructions\n"
"@subsubsection Инструкции Траплины"

#: /home/bear/work/guile/doc/guile/en/vm.texi:913
msgid ""
"Though most applicable objects in Guile are procedures implemented in\n"
"bytecode, not all are.  There are primitives, continuations, and other\n"
"procedure-like objects that have their own calling convention.  Instead\n"
"of adding special cases to the @code{call} instruction, Guile wraps\n"
"these other applicable objects in VM trampoline procedures, then\n"
"provides special support for these objects in bytecode."
msgstr ""
"Хотя наиболее применимыми объектами в Guile являются процедуры,\n"
"реализованные в байт-коде, это не все. Есть примитивы, продолжения и\n"
"другие подобные процедурам объекты, которые имеют собственной\n"
"соглашение о вызовах. Вместо добавления особых случаев в инстркцию\n"
"вызова @code{call}, Guile обертывает эти другие применимые объекты\n"
"в процедуры Трамплины Виртуальной Машины, затем предоставляя\n"
"специальную поддержку этих объектов в байт коде."

#: /home/bear/work/guile/doc/guile/en/vm.texi:919
msgid ""
"Trampoline procedures are typically generated by Guile at runtime, for\n"
"example in response to a call to @code{scm_c_make_gsubr}.  As such, a\n"
"compiler probably shouldn't emit code with these instructions.  However,\n"
"it's still interesting to know how these things work, so we document\n"
"these trampoline instructions here."
msgstr ""
"Процедуры Трамплины обычно генерируются Guile во время выполнения,\n"
"например, в ответ на вызов  @code{scm_c_make_gsubr}.  Таким образом,\n"
"компилятор, вероятно, не должен генерировать код с этими инструкциями.\n"
"Тем не менее, все еще интересно знать, как они работают, поэтому мы\n"
"запишем эти trampoline инструкции здесь."

#: /home/bear/work/guile/doc/guile/en/vm.texi:924
msgid ""
"@deftypefn Instruction {} subr-call x24:@var{_}\n"
"Call a subr, passing all locals in this frame as arguments.  Return from\n"
"the calling frame.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:930
msgid ""
"@deftypefn Instruction {} foreign-call c12:@var{cif-idx} c12:@var{ptr-idx}\n"
"Call a foreign function.  Fetch the @var{cif} and foreign pointer from\n"
"@var{cif-idx} and @var{ptr-idx}, both free variables.  Return from the "
"calling\n"
"frame.  Arguments are taken from the stack.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:936
msgid ""
"@deftypefn Instruction {} continuation-call c24:@var{contregs}\n"
"Return to a continuation, nonlocally.  The arguments to the continuation\n"
"are taken from the stack.  @var{contregs} is a free variable containing\n"
"the reified continuation.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:942
msgid ""
"@deftypefn Instruction {} compose-continuation c24:@var{cont}\n"
"Compose a partial continution with the current continuation.  The\n"
"arguments to the continuation are taken from the stack.  @var{cont} is a\n"
"free variable containing the reified continuation.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:948
msgid ""
"@deftypefn Instruction {} tail-apply x24:@var{_}\n"
"Tail-apply the procedure in local slot 0 to the rest of the arguments.\n"
"This instruction is part of the implementation of @code{apply}, and is\n"
"not generated by the compiler.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:952
msgid ""
"@deftypefn Instruction {} builtin-ref s12:@var{dst} c12:@var{idx}\n"
"Load a builtin stub by index into @var{dst}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:959
msgid ""
"@deftypefn Instruction {} apply-non-program x24:@var{_}\n"
"An instruction used only by a special trampoline that the VM uses to\n"
"apply non-programs.  Using that trampoline allows profilers and\n"
"backtrace utilities to avoid seeing the instruction pointer from the\n"
"calling frame.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:963
msgid ""
"@node Branch Instructions\n"
"@subsubsection Branch Instructions"
msgstr ""
"@node Branch Instructions\n"
"@subsubsection Инструкции Ветвления"

#: /home/bear/work/guile/doc/guile/en/vm.texi:967
msgid ""
"All offsets to branch instructions are 24-bit signed numbers, which\n"
"count 32-bit units.  This gives Guile effectively a 26-bit address range\n"
"for relative jumps."
msgstr ""
"Все смещения в инструкциях ветвления это 24-битные числа со знаком, которые\n"
"подсчитвают 32-битовые единицы. Это дает  Guile эффективный  26-битный "
"диапазон\n"
"адреов для относительных переходов."

#: /home/bear/work/guile/doc/guile/en/vm.texi:971
msgid ""
"@deftypefn Instruction {} br l24:@var{offset}\n"
"Add @var{offset} to the current instruction pointer.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:975
msgid ""
"All the conditional branch instructions described below have an\n"
"@var{invert} parameter, which if true reverses the test:\n"
"@code{br-if-true} becomes @code{br-if-false}, and so on."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:980
msgid ""
"@deftypefn Instruction {} br-if-true s24:@var{test} b1:@var{invert} x7:"
"@var{_} l24:@var{offset}\n"
"If the value in @var{test} is true for the purposes of Scheme, add\n"
"@var{offset} to the current instruction pointer.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:985
msgid ""
"@deftypefn Instruction {} br-if-null s24:@var{test} b1:@var{invert} x7:"
"@var{_} l24:@var{offset}\n"
"If the value in @var{test} is the end-of-list or Lisp nil, add\n"
"@var{offset} to the current instruction pointer.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:990
msgid ""
"@deftypefn Instruction {} br-if-nil s24:@var{test} b1:@var{invert} x7:"
"@var{_} l24:@var{offset}\n"
"If the value in @var{test} is false to Lisp, add @var{offset} to the\n"
"current instruction pointer.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:995
msgid ""
"@deftypefn Instruction {} br-if-pair s24:@var{test} b1:@var{invert} x7:"
"@var{_} l24:@var{offset}\n"
"If the value in @var{test} is a pair, add @var{offset} to the current\n"
"instruction pointer.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1000
msgid ""
"@deftypefn Instruction {} br-if-struct s24:@var{test} b1:@var{invert} x7:"
"@var{_} l24:@var{offset}\n"
"If the value in @var{test} is a struct, add @var{offset} number to the\n"
"current instruction pointer.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1005
msgid ""
"@deftypefn Instruction {} br-if-char s24:@var{test} b1:@var{invert} x7:"
"@var{_} l24:@var{offset}\n"
"If the value in @var{test} is a char, add @var{offset} to the current\n"
"instruction pointer.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1012
msgid ""
"@deftypefn Instruction {} br-if-tc7 s24:@var{test} b1:@var{invert} u7:"
"@var{tc7} l24:@var{offset}\n"
"If the value in @var{test} has the TC7 given in the second word, add\n"
"@var{offset} to the current instruction pointer.  TC7 codes are part of\n"
"the way Guile represents non-immediate objects, and are deep wizardry.\n"
"See @code{libguile/tags.h} for all the details.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1019
msgid ""
"@deftypefn Instruction {} br-if-eq s24:@var{a} x8:@var{_} s24:@var{b} b1:"
"@var{invert} x7:@var{_} l24:@var{offset}\n"
"@deftypefnx Instruction {} br-if-eqv s24:@var{a} x8:@var{_} s24:@var{b} b1:"
"@var{invert} x7:@var{_} l24:@var{offset}\n"
"If the value in @var{a} is @code{eq?} or @code{eqv?} to the value in\n"
"@var{b}, respectively, add @var{offset} to the current instruction\n"
"pointer.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1027
msgid ""
"@deftypefn Instruction {} br-if-= s24:@var{a} x8:@var{_} s24:@var{b} b1:"
"@var{invert} x7:@var{_} l24:@var{offset}\n"
"@deftypefnx Instruction {} br-if-< s24:@var{a} x8:@var{_} s24:@var{b} b1:"
"@var{invert} x7:@var{_} l24:@var{offset}\n"
"@deftypefnx Instruction {} br-if-<= s24:@var{a} x8:@var{_} s24:@var{b} b1:"
"@var{invert} x7:@var{_} l24:@var{offset}\n"
"If the value in @var{a} is @code{=}, @code{<}, or @code{<=} to the value\n"
"in @var{b}, respectively, add @var{offset} to the current instruction\n"
"pointer.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1032
msgid ""
"@deftypefn Instruction {} br-if-logtest s24:@var{a} x8:@var{_} s24:@var{b} "
"b1:@var{invert} x7:@var{_} l24:@var{offset}\n"
"If the bitwise intersection of the integers in @var{a} and @var{b} is\n"
"nonzero, add @var{offset} to the current instruction pointer.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1036
msgid ""
"@node Constant Instructions\n"
"@subsubsection Constant Instructions"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1039
msgid ""
"The following instructions load literal data into a program.  There are\n"
"two kinds."
msgstr ""
"Следующие инструкции загружают литеральные данные в программу. Есть\n"
"два вида."

#: /home/bear/work/guile/doc/guile/en/vm.texi:1042
msgid ""
"The first set of instructions loads immediate values.  These\n"
"instructions encode the immediate directly into the instruction stream."
msgstr ""
"Первый набор инструкций загружает непосредственные значения. Эти инструкции\n"
"кодируют непосредственные данные в поток команд."

#: /home/bear/work/guile/doc/guile/en/vm.texi:1047
msgid ""
"@deftypefn Instruction {} make-short-immediate s8:@var{dst} i16:@var{low-"
"bits}\n"
"Make an immediate whose low bits are @var{low-bits}, and whose top bits are\n"
"0.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1052
msgid ""
"@deftypefn Instruction {} make-long-immediate s24:@var{dst} i32:@var{low-"
"bits}\n"
"Make an immediate whose low bits are @var{low-bits}, and whose top bits are\n"
"0.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1056
msgid ""
"@deftypefn Instruction {} make-long-long-immediate s24:@var{dst} a32:"
"@var{high-bits} b32:@var{low-bits}\n"
"Make an immediate with @var{high-bits} and @var{low-bits}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1063
msgid ""
"Non-immediate constant literals are referenced either directly or\n"
"indirectly.  For example, Guile knows at compile-time what the layout of\n"
"a string will be like, and arranges to embed that object directly in the\n"
"compiled image.  A reference to a string will use\n"
"@code{make-non-immediate} to treat a pointer into the compilation unit\n"
"as a @code{SCM} value directly."
msgstr ""
"Опосредованные постоянные литералы адресованы прямо или косвенно.\n"
"Например, Guile знает во время компиляции, как будет выглядеть\n"
"размщение строки, и организует встраивание этого объекта непосредственно\n"
"в скомпилированный образ. Ссылка на строку будет использовать вызов\n"
"@code{make-non-immediate} для непосредственного обращения с указателем\n"
"в скомпилированный блок как @code{SCM} значению."

#: /home/bear/work/guile/doc/guile/en/vm.texi:1071
msgid ""
"@deftypefn Instruction {} make-non-immediate s24:@var{dst} n32:@var{offset}\n"
"Load a pointer to statically allocated memory into @var{dst}.  The\n"
"object's memory is will be found @var{offset} 32-bit words away from the\n"
"current instruction pointer.  Whether the object is mutable or immutable\n"
"depends on where it was allocated by the compiler, and loaded by the\n"
"loader.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1077
msgid ""
"Some objects must be unique across the whole system.  This is the case\n"
"for symbols and keywords.  For these objects, Guile arranges to\n"
"initialize them when the compilation unit is loaded, storing them into a\n"
"slot in the image.  References go indirectly through that slot.\n"
"@code{static-ref} is used in this case."
msgstr ""
"Некоторые объект должны быть уникальрными во всей системе.\n"
"Это относится к символам и ключевым словам. Для этих объектов, Guile\n"
"организует инициализацию, когда скомпилированный блок загружается, сохраняя\n"
"их в слоты на образе(загруженном). Ссылки идут косвенно, через этот слот.\n"
"В этом случае используется @code{static-ref}."

#: /home/bear/work/guile/doc/guile/en/vm.texi:1083
msgid ""
"@deftypefn Instruction {} static-ref s24:@var{dst} r32:@var{offset}\n"
"Load a @var{scm} value into @var{dst}.  The @var{scm} value will be fetched "
"from\n"
"memory, @var{offset} 32-bit words away from the current instruction\n"
"pointer.  @var{offset} is a signed value.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1089
msgid ""
"Fields of non-immediates may need to be fixed up at load time, because\n"
"we do not know in advance at what address they will be loaded.  This is\n"
"the case, for example, for a pair containing a non-immediate in one of\n"
"its fields.  @code{static-ref} and @code{static-patch!} are used in\n"
"these situations."
msgstr ""
"Поля опосредованные возможно придется исправлять во время загрузки,\n"
"поэтому мы не знаем заранее, по какому адресу они будут загружены.\n"
"Это имеет место, наприимер для пары содержащей опосредованные данные\n"
"в одном из полей. В этих ситуациях используются  @code{static-ref} и\n"
"@code{static-patch!}."

#: /home/bear/work/guile/doc/guile/en/vm.texi:1094
msgid ""
"@deftypefn Instruction {} static-set! s24:@var{src} lo32:@var{offset}\n"
"Store a @var{scm} value into memory, @var{offset} 32-bit words away from "
"the\n"
"current instruction pointer.  @var{offset} is a signed value.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1100
msgid ""
"@deftypefn Instruction {} static-patch! x24:@var{_} lo32:@var{dst-offset} "
"l32:@var{src-offset}\n"
"Patch a pointer at @var{dst-offset} to point to @var{src-offset}.  Both "
"offsets\n"
"are signed 32-bit values, indicating a memory address as a number\n"
"of 32-bit words away from the current instruction pointer.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1106
msgid ""
"Many kinds of literals can be loaded with the above instructions, once\n"
"the compiler has prepared the statically allocated data.  This is the\n"
"case for vectors, strings, uniform vectors, pairs, and procedures with\n"
"no free variables.  Other kinds of data might need special initializers;\n"
"those instructions follow."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1110
msgid ""
"@deftypefn Instruction {} string->number s12:@var{dst} s12:@var{src}\n"
"Parse a string in @var{src} to a number, and store in @var{dst}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1114
msgid ""
"@deftypefn Instruction {} string->symbol s12:@var{dst} s12:@var{src}\n"
"Parse a string in @var{src} to a symbol, and store in @var{dst}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1118
msgid ""
"@deftypefn Instruction {} symbol->keyword s12:@var{dst} s12:@var{src}\n"
"Make a keyword from the symbol in @var{src}, and store it in @var{dst}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1124
msgid ""
"@deftypefn Instruction {} load-typed-array s24:@var{dst} x8:@var{_} s24:"
"@var{type} x8:@var{_} s24:@var{shape} n32:@var{offset} u32:@var{len}\n"
"Load the contiguous typed array located at @var{offset} 32-bit words away\n"
"from the instruction pointer, and store into @var{dst}.  @var{len} is a "
"byte\n"
"length.  @var{offset} is signed.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1128
msgid ""
"@node Dynamic Environment Instructions\n"
"@subsubsection Dynamic Environment Instructions"
msgstr ""
"@node Dynamic Environment Instructions\n"
"@subsubsection Инструкции Динамической Среды(Окружения)"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1131
msgid ""
"Guile's virtual machine has low-level support for @code{dynamic-wind},\n"
"dynamic binding, and composable prompts and aborts."
msgstr ""
"Виртуальная машина Guile имеет низкоуровневую поддержку для @code{dynamic-"
"wind},\n"
"динамического связывания и составных подсказок и прерываний."

#: /home/bear/work/guile/doc/guile/en/vm.texi:1136
msgid ""
"@deftypefn Instruction {} abort x24:@var{_}\n"
"Abort to a prompt handler.  The tag is expected in slot 1, and the rest\n"
"of the values in the frame are returned to the prompt handler.  This\n"
"corresponds to a tail application of abort-to-prompt."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1140
msgid ""
"If no prompt can be found in the dynamic environment with the given tag,\n"
"an error is signalled.  Otherwise all arguments are passed to the\n"
"prompt's handler, along with the captured continuation, if necessary."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1150
msgid ""
"If the prompt's handler can be proven to not reference the captured\n"
"continuation, no continuation is allocated.  This decision happens\n"
"dynamically, at run-time; the general case is that the continuation may\n"
"be captured, and thus resumed.  A reinstated continuation will have its\n"
"arguments pushed on the stack from slot 1, as if from a multiple-value\n"
"return, and control resumes in the caller.  Thus to the calling\n"
"function, a call to @code{abort-to-prompt} looks like any other function\n"
"call.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1154
msgid ""
"@deftypefn Instruction {} prompt s24:@var{tag} b1:@var{escape-only?} x7:"
"@var{_} f24:@var{proc-slot} x8:@var{_} l24:@var{handler-offset}\n"
"Push a new prompt on the dynamic stack, with a tag from @var{tag} and a\n"
"handler at @var{handler-offset} words from the current @var{ip}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1162
msgid ""
"If an abort is made to this prompt, control will jump to the handler.\n"
"The handler will expect a multiple-value return as if from a call with\n"
"the procedure at @var{proc-slot}, with the reified partial continuation\n"
"as the first argument, followed by the values returned to the handler.\n"
"If control returns to the handler, the prompt is already popped off by\n"
"the abort mechanism.  (Guile's @code{prompt} implements Felleisen's\n"
"@dfn{--F--} operator.)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1166
msgid ""
"If @var{escape-only?} is nonzero, the prompt will be marked as\n"
"escape-only, which allows an abort to this prompt to avoid reifying the\n"
"continuation."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1169
msgid ""
"@xref{Prompts}, for more information on prompts.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1177
msgid ""
"@deftypefn Instruction {} wind s12:@var{winder} s12:@var{unwinder}\n"
"Push wind and unwind procedures onto the dynamic stack. Note that\n"
"neither are actually called; the compiler should emit calls to wind and\n"
"unwind for the normal dynamic-wind control flow.  Also note that the\n"
"compiler should have inserted checks that they wind and unwind procs are\n"
"thunks, if it could not prove that to be the case.  @xref{Dynamic Wind}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1182
msgid ""
"@deftypefn Instruction {} unwind x24:@var{_}\n"
"@var{a} normal exit from the dynamic extent of an expression. Pop the top\n"
"entry off of the dynamic stack.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1188
msgid ""
"@deftypefn Instruction {} push-fluid s12:@var{fluid} s12:@var{value}\n"
"Dynamically bind @var{value} to @var{fluid} by creating a with-fluids\n"
"object and pushing that object on the dynamic stack.  @xref{Fluids and\n"
"Dynamic States}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1194
msgid ""
"@deftypefn Instruction {} pop-fluid x24:@var{_}\n"
"Leave the dynamic extent of a @code{with-fluid*} expression, restoring\n"
"the fluid to its previous value.  @code{push-fluid} should always be\n"
"balanced with @code{pop-fluid}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1198
msgid ""
"@deftypefn Instruction {} fluid-ref s12:@var{dst} s12:@var{src}\n"
"Reference the fluid in @var{src}, and place the value in @var{dst}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1202
msgid ""
"@deftypefn Instruction {} fluid-set! s12:@var{fluid} s12:@var{val}\n"
"Set the value of the fluid in @var{dst} to the value in @var{src}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1206
msgid ""
"@deftypefn Instruction {} current-thread s24:@var{dst}\n"
"Write the value of the current thread to @var{dst}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1212
msgid ""
"@deftypefn Instruction {} push-dynamic-state s24:@var{state}\n"
"Save the current set of fluid bindings on the dynamic stack and instate\n"
"the bindings from @var{state} instead.  @xref{Fluids and Dynamic\n"
"States}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1218
msgid ""
"@deftypefn Instruction {} pop-dynamic-state x24:@var{_}\n"
"Restore a saved set of fluid bindings from the dynamic stack.\n"
"@code{push-dynamic-state} should always be balanced with\n"
"@code{pop-dynamic-state}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1222
msgid ""
"@node Miscellaneous Instructions\n"
"@subsubsection Miscellaneous Instructions"
msgstr ""
"@node Miscellaneous Instructions\n"
"@subsubsection Разные Инструкции"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1227
msgid ""
"@deftypefn Instruction {} halt x24:@var{_}\n"
"Bring the VM to a halt, returning all the values from the stack.  Used\n"
"in the ``boot continuation'', which is used when entering the VM from C.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1233
msgid ""
"@deftypefn Instruction {} push s24:@var{src}\n"
"Bump the stack pointer by one word, and fill it with the value from slot\n"
"@var{src}.  The offset to @var{src} is calculated before the stack\n"
"pointer is adjusted.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1240
msgid ""
"The @code{push} instruction is used when another instruction is unable\n"
"to address an operand because the operand is encoded with fewer than 24\n"
"bits.  In that case, Guile's assembler will transparently emit code that\n"
"temporarily pushes any needed operands onto the stack, emits the\n"
"original instruction to address those now-near variables, then shuffles\n"
"the result (if any) back into place."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1246
msgid ""
"@deftypefn Instruction {} pop s24:@var{dst}\n"
"Pop the stack pointer, storing the value that was there in slot\n"
"@var{dst}.  The offset to @var{dst} is calculated after the stack\n"
"pointer is adjusted.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1251
msgid ""
"@deftypefn Instruction {} drop c24:@var{count}\n"
"Pop the stack pointer by @var{count} words, discarding any values that\n"
"were stored there.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1257
msgid ""
"@deftypefn Instruction {} handle-interrupts x24:@var{_}\n"
"Handle pending asynchronous interrupts (asyncs).  @xref{Asyncs}.  The\n"
"compiler inserts @code{handle-interrupts} instructions before any call,\n"
"return, or loop back-edge.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1262
msgid ""
"@deftypefn Instruction {} return-from-interrupt x24:@var{_}\n"
"A special instruction to return from a call and also pop off the stack\n"
"frame from the call.  Used when returning from asynchronous interrupts.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1266
msgid ""
"@node Inlined Scheme Instructions\n"
"@subsubsection Inlined Scheme Instructions"
msgstr ""
"@node Inlined Scheme Instructions\n"
"@subsubsection Встроенные Инструкции Scheme"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1271
msgid ""
"The Scheme compiler can recognize the application of standard Scheme\n"
"procedures.  It tries to inline these small operations to avoid the\n"
"overhead of creating new stack frames.  This allows the compiler to\n"
"optimize better."
msgstr ""
"Компилятор Scheme может распознать применение стандартных Scheme\n"
"процедур. Он пытается, встроить эти небольшие операции, чтобы избежать\n"
"накладных раходов на создание новых кадров стека. Это позволяет\n"
"компилятору лучше оптимизировать код."

#: /home/bear/work/guile/doc/guile/en/vm.texi:1277
msgid ""
"@deftypefn Instruction {} make-vector s8:@var{dst} s8:@var{length} s8:"
"@var{init}\n"
"Make a vector and write it to @var{dst}.  The vector will have space for\n"
"@var{length} slots.  They will be filled with the value in slot\n"
"@var{init}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1283
msgid ""
"@deftypefn Instruction {} make-vector/immediate s8:@var{dst} s8:@var{length} "
"c8:@var{init}\n"
"Make a short vector of known size and write it to @var{dst}.  The vector\n"
"will have space for @var{length} slots, an immediate value.  They will\n"
"be filled with the value in slot @var{init}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1288
msgid ""
"@deftypefn Instruction {} vector-length s12:@var{dst} s12:@var{src}\n"
"Store the length of the vector in @var{src} in @var{dst}, as an unboxed\n"
"unsigned 64-bit integer.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1294
msgid ""
"@deftypefn Instruction {} vector-ref s8:@var{dst} s8:@var{src} s8:@var{idx}\n"
"Fetch the item at position @var{idx} in the vector in @var{src}, and\n"
"store it in @var{dst}.  The @var{idx} value should be an unboxed\n"
"unsigned 64-bit integer.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1299
msgid ""
"@deftypefn Instruction {} vector-ref/immediate s8:@var{dst} s8:@var{src} c8:"
"@var{idx}\n"
"Fill @var{dst} with the item @var{idx} elements into the vector at\n"
"@var{src}.  Useful for building data types using vectors.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1304
msgid ""
"@deftypefn Instruction {} vector-set! s8:@var{dst} s8:@var{idx} s8:"
"@var{src}\n"
"Store @var{src} into the vector @var{dst} at index @var{idx}.  The\n"
"@var{idx} value should be an unboxed unsigned 64-bit integer.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1309
msgid ""
"@deftypefn Instruction {} vector-set!/immediate s8:@var{dst} c8:@var{idx} s8:"
"@var{src}\n"
"Store @var{src} into the vector @var{dst} at index @var{idx}.  Here\n"
"@var{idx} is an immediate value.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1313
msgid ""
"@deftypefn Instruction {} struct-vtable s12:@var{dst} s12:@var{src}\n"
"Store the vtable of @var{src} into @var{dst}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1320
msgid ""
"@deftypefn Instruction {} allocate-struct s8:@var{dst} s8:@var{vtable} s8:"
"@var{nfields}\n"
"Allocate a new struct with @var{vtable}, and place it in @var{dst}.  The\n"
"struct will be constructed with space for @var{nfields} fields, which\n"
"should correspond to the field count of the @var{vtable}.  The @var{idx}\n"
"value should be an unboxed unsigned 64-bit integer.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1326
msgid ""
"@deftypefn Instruction {} struct-ref s8:@var{dst} s8:@var{src} s8:@var{idx}\n"
"Fetch the item at slot @var{idx} in the struct in @var{src}, and store\n"
"it in @var{dst}.  The @var{idx} value should be an unboxed unsigned\n"
"64-bit integer.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1331
msgid ""
"@deftypefn Instruction {} struct-set! s8:@var{dst} s8:@var{idx} s8:"
"@var{src}\n"
"Store @var{src} into the struct @var{dst} at slot @var{idx}.  The\n"
"@var{idx} value should be an unboxed unsigned 64-bit integer.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1338
msgid ""
"@deftypefn Instruction {} allocate-struct/immediate s8:@var{dst} s8:"
"@var{vtable} c8:@var{nfields}\n"
"@deftypefnx Instruction {} struct-ref/immediate s8:@var{dst} s8:@var{src} c8:"
"@var{idx}\n"
"@deftypefnx Instruction {} struct-set!/immediate s8:@var{dst} c8:@var{idx} "
"s8:@var{src}\n"
"Variants of the struct instructions, but in which the @var{nfields} or\n"
"@var{idx} fields are immediate values.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1342
msgid ""
"@deftypefn Instruction {} class-of s12:@var{dst} s12:@var{type}\n"
"Store the vtable of @var{src} into @var{dst}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1346
msgid ""
"@deftypefn Instruction {} make-array s24:@var{dst} x8:@var{_} s24:@var{type} "
"x8:@var{_} s24:@var{fill} x8:@var{_} s24:@var{bounds}\n"
"Make a new array with @var{type}, @var{fill}, and @var{bounds}, storing it "
"in @var{dst}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1351
msgid ""
"@deftypefn Instruction {} string-length s12:@var{dst} s12:@var{src}\n"
"Store the length of the string in @var{src} in @var{dst}, as an unboxed\n"
"unsigned 64-bit integer.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1357
msgid ""
"@deftypefn Instruction {} string-ref s8:@var{dst} s8:@var{src} s8:@var{idx}\n"
"Fetch the character at position @var{idx} in the string in @var{src},\n"
"and store it in @var{dst}.  The @var{idx} value should be an unboxed\n"
"unsigned 64-bit integer.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1363
msgid ""
"@deftypefn Instruction {} string-set! s8:@var{dst} s8:@var{idx} s8:"
"@var{src}\n"
"Store the character @var{src} into the string @var{dst} at index\n"
"@var{idx}.  The @var{idx} value should be an unboxed unsigned 64-bit\n"
"integer.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1367
msgid ""
"@deftypefn Instruction {} cons s8:@var{dst} s8:@var{car} s8:@var{cdr}\n"
"Cons @var{car} and @var{cdr}, and store the result in @var{dst}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1371
msgid ""
"@deftypefn Instruction {} car s12:@var{dst} s12:@var{src}\n"
"Place the car of @var{src} in @var{dst}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1375
msgid ""
"@deftypefn Instruction {} cdr s12:@var{dst} s12:@var{src}\n"
"Place the cdr of @var{src} in @var{dst}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1379
msgid ""
"@deftypefn Instruction {} set-car! s12:@var{pair} s12:@var{car}\n"
"Set the car of @var{dst} to @var{src}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1383
msgid ""
"@deftypefn Instruction {} set-cdr! s12:@var{pair} s12:@var{cdr}\n"
"Set the cdr of @var{dst} to @var{src}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1386
msgid ""
"Note that @code{caddr} and friends compile to a series of @code{car}\n"
"and @code{cdr} instructions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1391
msgid ""
"@deftypefn Instruction {} integer->char s12:@var{dst} s12:@var{src}\n"
"Convert the @code{u64} value in @var{src} to a Scheme character, and\n"
"place it in @var{dst}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1396
msgid ""
"@deftypefn Instruction {} char->integer s12:@var{dst} s12:@var{src}\n"
"Convert the Scheme character in @var{src} to an integer, and place it in\n"
"@var{dst} as an unboxed @code{u64} value.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1400
msgid ""
"@node Inlined Atomic Instructions\n"
"@subsubsection Inlined Atomic Instructions"
msgstr ""
"@node Inlined Atomic Instructions\n"
"@subsubsection Встроенные Атомарные Инструкции"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1402
msgid "@xref{Atomics}, for more on atomic operations in Guile."
msgstr ""
"@xref{Atomics}, для получения дополнительрной информации об атомарных\n"
"операциях в Guile."

#: /home/bear/work/guile/doc/guile/en/vm.texi:1407
msgid ""
"@deftypefn Instruction {} make-atomic-box s12:@var{dst} s12:@var{src}\n"
"Create a new atomic box initialized to @var{src}, and place it in\n"
"@var{dst}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1411
msgid ""
"@deftypefn Instruction {} atomic-box-ref s12:@var{dst} s12:@var{box}\n"
"Fetch the value of the atomic box at @var{box} into @var{dst}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1415
msgid ""
"@deftypefn Instruction {} atomic-box-set! s12:@var{box} s12:@var{val}\n"
"Set the contents of the atomic box at @var{box} to @var{val}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1420
msgid ""
"@deftypefn Instruction {} atomic-box-swap! s12:@var{dst} s12:@var{box} x8:"
"@var{_} s24:@var{val}\n"
"Replace the contents of the atomic box at @var{box} to @var{val} and\n"
"store the previous value at @var{dst}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1427
msgid ""
"@deftypefn Instruction {} atomic-box-compare-and-swap! s12:@var{dst} s12:"
"@var{box} x8:@var{_} s24:@var{expected} x8:@var{_} s24:@var{desired}\n"
"If the value of the atomic box at @var{box} is the same as the SCM value\n"
"at @var{expected} (in the sense of @code{eq?}), replace the contents of\n"
"the box with the SCM value at @var{desired}.  Otherwise does not update\n"
"the box.  Set @var{dst} to the previous value of the box in either case.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1431
msgid ""
"@node Inlined Mathematical Instructions\n"
"@subsubsection Inlined Mathematical Instructions"
msgstr ""
"@node Inlined Mathematical Instructions\n"
"@subsubsection Инструкции Встроенной Математики"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1436
msgid ""
"Inlining mathematical operations has the obvious advantage of handling\n"
"fixnums without function calls or allocations. The trick, of course,\n"
"is knowing when the result of an operation will be a fixnum, and there\n"
"might be a couple bugs here."
msgstr ""
"Встраивание математических операций имеет очевидное преимущесвтво при \n"
"работе с фиксированными числами без вызова фукнций или размещений.\n"
"Трюк конечно, когда знаете что результат операции будет fixnum, и здесь\n"
"может быть пара ошибок."

#: /home/bear/work/guile/doc/guile/en/vm.texi:1438
msgid "More instructions could be added here over time."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1441
msgid ""
"All of these operations place their result in their first operand,\n"
"@var{dst}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1445
msgid ""
"@deftypefn Instruction {} add s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Add @var{a} to @var{b}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1449
msgid ""
"@deftypefn Instruction {} add/immediate s8:@var{dst} s8:@var{src} c8:"
"@var{imm}\n"
"Add the unsigned integer @var{imm} to the value in @var{src}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1453
msgid ""
"@deftypefn Instruction {} sub s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Subtract @var{b} from @var{a}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1457
msgid ""
"@deftypefn Instruction {} sub/immediate s8:@var{dst} s8:@var{src} s8:"
"@var{imm}\n"
"Subtract the unsigned integer @var{imm} from the value in @var{src}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1461
msgid ""
"@deftypefn Instruction {} mul s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Multiply @var{a} and @var{b}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1465
msgid ""
"@deftypefn Instruction {} div s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Divide @var{a} by @var{b}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1469
msgid ""
"@deftypefn Instruction {} quo s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Divide @var{a} by @var{b}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1473
msgid ""
"@deftypefn Instruction {} rem s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Divide @var{a} by @var{b}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1477
msgid ""
"@deftypefn Instruction {} mod s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Compute the modulo of @var{a} by @var{b}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1481
msgid ""
"@deftypefn Instruction {} ash s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Shift @var{a} arithmetically by @var{b} bits.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1485
msgid ""
"@deftypefn Instruction {} logand s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Compute the bitwise @code{and} of @var{a} and @var{b}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1489
msgid ""
"@deftypefn Instruction {} logior s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Compute the bitwise inclusive @code{or} of @var{a} with @var{b}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1493
msgid ""
"@deftypefn Instruction {} logxor s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Compute the bitwise exclusive @code{or} of @var{a} with @var{b}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1498
msgid ""
"@deftypefn Instruction {} logsub s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Place the bitwise @code{and} of @var{a} and the bitwise @code{not} of\n"
"@var{b} into @var{dst}.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1501
msgid ""
"@node Inlined Bytevector Instructions\n"
"@subsubsection Inlined Bytevector Instructions"
msgstr ""
"@node Inlined Bytevector Instructions\n"
"@subsubsection Инструкции Встроенных Байтовых Векторов"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1507
msgid ""
"Bytevector operations correspond closely to what the current hardware\n"
"can do, so it makes sense to inline them to VM instructions, providing\n"
"a clear path for eventual native compilation. Without this, Scheme\n"
"programs would need other primitives for accessing raw bytes -- but\n"
"these primitives are as good as any."
msgstr ""
"Операторы байтовых векторов точно соответствуют тому, что может сделать\n"
"текущее оборудование, поэтому они сделаны что быть встроенными в инструкции\n"
"ВМ, обеспечивая четкий путь для возможной нативной компиляции.\n"
"Без этого программам Scheme понадобятся другие примитивы для доступа\n"
"к сырым(необработанным) данным - но эти примитивы так же хороши как и другие."

#: /home/bear/work/guile/doc/guile/en/vm.texi:1512
msgid ""
"@deftypefn Instruction {} bv-length s12:@var{dst} s12:@var{src}\n"
"Store the length of the bytevector in @var{src} in @var{dst}, as an\n"
"unboxed unsigned 64-bit integer.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1523
msgid ""
"@deftypefn Instruction {} bv-u8-ref s8:@var{dst} s8:@var{src} s8:@var{idx}\n"
"@deftypefnx Instruction {} bv-s8-ref s8:@var{dst} s8:@var{src} s8:@var{idx}\n"
"@deftypefnx Instruction {} bv-u16-ref s8:@var{dst} s8:@var{src} s8:"
"@var{idx}\n"
"@deftypefnx Instruction {} bv-s16-ref s8:@var{dst} s8:@var{src} s8:"
"@var{idx}\n"
"@deftypefnx Instruction {} bv-u32-ref s8:@var{dst} s8:@var{src} s8:"
"@var{idx}\n"
"@deftypefnx Instruction {} bv-s32-ref s8:@var{dst} s8:@var{src} s8:"
"@var{idx}\n"
"@deftypefnx Instruction {} bv-u64-ref s8:@var{dst} s8:@var{src} s8:"
"@var{idx}\n"
"@deftypefnx Instruction {} bv-s64-ref s8:@var{dst} s8:@var{src} s8:"
"@var{idx}\n"
"@deftypefnx Instruction {} bv-f32-ref s8:@var{dst} s8:@var{src} s8:"
"@var{idx}\n"
"@deftypefnx Instruction {} bv-f64-ref s8:@var{dst} s8:@var{src} s8:@var{idx}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1526
msgid ""
"Fetch the item at byte offset @var{idx} in the bytevector @var{src}, and\n"
"store it in @var{dst}.  All accesses use native endianness."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1528
msgctxt "/home/bear/work/guile/doc/guile/en/vm.texi:1528"
msgid "The @var{idx} value should be an unboxed unsigned 64-bit integer."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1533
msgid ""
"The results are all written to the stack as unboxed values, either as\n"
"signed 64-bit integers, unsigned 64-bit integers, or IEEE double\n"
"floating point numbers.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1544
msgid ""
"@deftypefn Instruction {} bv-u8-set! s8:@var{dst} s8:@var{idx} s8:@var{src}\n"
"@deftypefnx Instruction {} bv-s8-set! s8:@var{dst} s8:@var{idx} s8:"
"@var{src}\n"
"@deftypefnx Instruction {} bv-u16-set! s8:@var{dst} s8:@var{idx} s8:"
"@var{src}\n"
"@deftypefnx Instruction {} bv-s16-set! s8:@var{dst} s8:@var{idx} s8:"
"@var{src}\n"
"@deftypefnx Instruction {} bv-u32-set! s8:@var{dst} s8:@var{idx} s8:"
"@var{src}\n"
"@deftypefnx Instruction {} bv-s32-set! s8:@var{dst} s8:@var{idx} s8:"
"@var{src}\n"
"@deftypefnx Instruction {} bv-u64-set! s8:@var{dst} s8:@var{idx} s8:"
"@var{src}\n"
"@deftypefnx Instruction {} bv-s64-set! s8:@var{dst} s8:@var{idx} s8:"
"@var{src}\n"
"@deftypefnx Instruction {} bv-f32-set! s8:@var{dst} s8:@var{idx} s8:"
"@var{src}\n"
"@deftypefnx Instruction {} bv-f64-set! s8:@var{dst} s8:@var{idx} s8:@var{src}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1547
msgid ""
"Store @var{src} into the bytevector @var{dst} at byte offset @var{idx}.\n"
"Multibyte values are written using native endianness."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1549
msgctxt "/home/bear/work/guile/doc/guile/en/vm.texi:1549"
msgid "The @var{idx} value should be an unboxed unsigned 64-bit integer."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1553
msgid ""
"The @var{src} values are all unboxed, either as signed 64-bit integers,\n"
"unsigned 64-bit integers, or IEEE double floating point numbers.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/vm.texi:1557
msgid ""
"@node Unboxed Integer Arithmetic\n"
"@subsubsection Unboxed Integer Arithmetic"
msgstr ""
"@node Unboxed Integer Arithmetic\n"
"@subsubsection Арифметика Распакованных Целых Чисел"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1564
msgid ""
"Guile supports two kinds of unboxed integers: unsigned 64-bit integers,\n"
"and signed 64-bit integers.  Guile prefers unsigned integers, in the\n"
"sense that Guile's compiler supports them better and the virtual machine\n"
"has more operations that work on them.  Still, signed integers are\n"
"supported at least to allow @code{bv-s64-ref} and related instructions\n"
"to avoid boxing their values."
msgstr ""
"Guile поддерживает два типа распакованных целых чисел: беззнаковое\n"
"64-битное целое, и со знаковом  64-битное целое. Guile предпочитает\n"
"целые числа без знака, в том смысле. что компилятор Guile поддерживает\n"
"их лучше, а на виртуальной машине больше операций,которые с ними \n"
"работают. Тем не менее, целые числа со знаком поддерживаются, по\n"
"крайней мере, для того, чтобы позволить @code{bv-s64-ref} и \n"
"соответствующим инструкциям избегать упаковки значений."

#: /home/bear/work/guile/doc/guile/en/vm.texi:1570
msgid ""
"@deftypefn Instruction {} scm->u64 s12:@var{dst} s12:@var{src}\n"
"Unbox the SCM value at @var{src} to a unsigned 64-bit integer, placing\n"
"the result in @var{dst}.  If the @var{src} value is not an exact integer\n"
"in the unsigned 64-bit range, signal an error.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} scm->u64 s12:@var{dst} s12:@var{src}\n"
"Распаковка значения SCM из  @var{src} в беззнаковое 64-битное целое,\n"
"и поместить результат в @var{dst}.  Если значение  @var{src} не\n"
"является точным целым числом в 64-битном диапазоне, сигнализировать\n"
"об ошибке.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1575
msgid ""
"@deftypefn Instruction {} u64->scm s12:@var{dst} s12:@var{src}\n"
"Box the unsigned 64-bit integer at @var{src} to a SCM value and place\n"
"the result in @var{dst}.  The result will be a fixnum or a bignum.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} u64->scm s12:@var{dst} s12:@var{src}\n"
"Упаковать беззнаковое целое 64-битное число из  @var{src} в заначение\n"
"SCM и разметсит результат в @var{dst}.  Результат может быть\n"
"fixnum или bignum.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1580
msgid ""
"@deftypefn Instruction {} load-u64 s24:@var{dst} au32:@var{high-bits} au32:"
"@var{low-bits}\n"
"Load a 64-bit value formed by joining @var{high-bits} and\n"
"@var{low-bits}, and write it to @var{dst}.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} load-u64 s24:@var{dst} au32:@var{high-bits} au32:"
"@var{low-bits}\n"
"Загрузить 64-битрное значение сформированное объединением  @var{high-bits} "
"и\n"
"@var{low-bits}, и записать результат в @var{dst}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1587
msgid ""
"@deftypefn Instruction {} scm->s64 s12:@var{dst} s12:@var{src}\n"
"@deftypefnx Instruction {} s64->scm s12:@var{dst} s12:@var{src}\n"
"@deftypefnx Instruction {} load-s64 s24:@var{dst} as32:@var{high-bits} as32:"
"@var{low-bits}\n"
"Like @code{scm->u64}, @code{u64->scm}, and @code{load-u64}, but for\n"
"signed 64-bit integers.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} scm->s64 s12:@var{dst} s12:@var{src}\n"
"@deftypefnx Instruction {} s64->scm s12:@var{dst} s12:@var{src}\n"
"@deftypefnx Instruction {} load-s64 s24:@var{dst} as32:@var{high-bits} as32:"
"@var{low-bits}\n"
"Как и @code{scm->u64}, @code{u64->scm}, и @code{load-u64}, но для 64 битных "
"целых чисел \n"
"со знаком.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1591
msgid ""
"Sometimes the compiler can know that we will only need a subset of the\n"
"bits in an integer.  In that case we can sometimes unbox an integer even\n"
"if it might be out of range."
msgstr ""
"Иногда компилятор может знать, что нам понадобиться токль подмножество\n"
"бит в целом числе. В этом случае мы можем иногда распаковывать целое\n"
"число, даже если оно может быть вне диапазона."

#: /home/bear/work/guile/doc/guile/en/vm.texi:1596
msgid ""
"@deftypefn Instruction {} scm->u64/truncate s12:@var{dst} s12:@var{src}\n"
"Take the SCM value in @var{dst} and @code{logand} it with @code{(1- (ash\n"
"1 64))}.  Place the unboxed result in @var{dst}.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} scm->u64/truncate s12:@var{dst} s12:@var{src}\n"
"Взять заначение SCM в @var{dst} и @code{logand} с помощью @code{(1- (ash\n"
"1 64))}.  Поместить распакованный результат в @var{dst}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1605
msgid ""
"@deftypefn Instruction {} br-if-u64-= s24:@var{a} x8:@var{_} s24:@var{b} b1:"
"@var{invert} x7:@var{_} l24:@var{offset}\n"
"@deftypefnx Instruction {} br-if-u64-< s24:@var{a} x8:@var{_} s24:@var{b} b1:"
"@var{invert} x7:@var{_} l24:@var{offset}\n"
"@deftypefnx Instruction {} br-if-u64-<= s24:@var{a} x8:@var{_} s24:@var{b} "
"b1:@var{invert} x7:@var{_} l24:@var{offset}\n"
"If the unboxed unsigned 64-bit integer value in @var{a} is @code{=},\n"
"@code{<}, or @code{<=} to the unboxed unsigned 64-bit integer value in\n"
"@var{b}, respectively, add @var{offset} to the current instruction\n"
"pointer.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} br-if-u64-= s24:@var{a} x8:@var{_} s24:@var{b} b1:"
"@var{invert} x7:@var{_} l24:@var{offset}\n"
"@deftypefnx Instruction {} br-if-u64-< s24:@var{a} x8:@var{_} s24:@var{b} b1:"
"@var{invert} x7:@var{_} l24:@var{offset}\n"
"@deftypefnx Instruction {} br-if-u64-<= s24:@var{a} x8:@var{_} s24:@var{b} "
"b1:@var{invert} x7:@var{_} l24:@var{offset}\n"
"Если для распакованного целого 64 битное численного значения из @var{a} "
"выполненоs @code{=},\n"
"@code{<}, or @code{<=} по отношению к целому 64 битному числовому значению "
"из @var{b}, \n"
"сответственно, добавить смещение @var{offset} к ip(текущему значению "
"указателя программ)\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1613
msgid ""
"@deftypefn Instruction {} br-if-u64-=-scm s24:@var{a} x8:@var{_} s24:@var{b} "
"b1:@var{invert} x7:@var{_} l24:@var{offset}\n"
"@deftypefnx Instruction {} br-if-u64-<-scm s24:@var{a} x8:@var{_} s24:"
"@var{b} b1:@var{invert} x7:@var{_} l24:@var{offset}\n"
"@deftypefnx Instruction {} br-if-u64-<=-scm s24:@var{a} x8:@var{_} s24:"
"@var{b} b1:@var{invert} x7:@var{_} l24:@var{offset}\n"
"If the unboxed unsigned 64-bit integer value in @var{a} is @code{=},\n"
"@code{<}, or @code{<=} to the SCM value in @var{b}, respectively, add\n"
"@var{offset} to the current instruction pointer.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} br-if-u64-=-scm s24:@var{a} x8:@var{_} s24:@var{b} "
"b1:@var{invert} x7:@var{_} l24:@var{offset}\n"
"@deftypefnx Instruction {} br-if-u64-<-scm s24:@var{a} x8:@var{_} s24:"
"@var{b} b1:@var{invert} x7:@var{_} l24:@var{offset}\n"
"@deftypefnx Instruction {} br-if-u64-<=-scm s24:@var{a} x8:@var{_} s24:"
"@var{b} b1:@var{invert} x7:@var{_} l24:@var{offset}\n"
"Если для распакованного беззнакового целого 64-битного значения из @var{a} "
"выполнено @code{=},\n"
"@code{<}, или @code{<=} по отношению к значению SCM из @var{b}, "
"соответственно, добавить\n"
"смещение @var{offset} к ip(текущему значению указателя программы).\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1621
msgid ""
"@deftypefn Instruction {} uadd s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"@deftypefnx Instruction {} usub s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"@deftypefnx Instruction {} umul s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Like @code{add}, @code{sub}, and @code{mul}, except taking\n"
"the operands as unboxed unsigned 64-bit integers, and producing the\n"
"same.  The result will be silently truncated to 64 bits.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} uadd s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"@deftypefnx Instruction {} usub s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"@deftypefnx Instruction {} umul s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Подобно @code{add}, @code{sub}, и @code{mul}, за искючением операндов\n"
"в качестве распакованных беззнаковых 64-битных целых, и получают\n"
"такой же результат. Результат будет молча обрезан до 64 бит.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1628
msgid ""
"@deftypefn Instruction {} uadd/immediate s8:@var{dst} s8:@var{a} c8:@var{b}\n"
"@deftypefnx Instruction {} usub/immediate s8:@var{dst} s8:@var{a} c8:"
"@var{b}\n"
"@deftypefnx Instruction {} umul/immediate s8:@var{dst} s8:@var{a} c8:"
"@var{b}\n"
"Like @code{uadd}, @code{usub}, and @code{umul}, except the second\n"
"operand is an immediate unsigned 8-bit integer.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} uadd/immediate s8:@var{dst} s8:@var{a} c8:@var{b}\n"
"@deftypefnx Instruction {} usub/immediate s8:@var{dst} s8:@var{a} c8:"
"@var{b}\n"
"@deftypefnx Instruction {} umul/immediate s8:@var{dst} s8:@var{a} c8:"
"@var{b}\n"
"Подобно @code{uadd}, @code{usub}, и @code{umul}, за исключением\n"
"второго операнда, это непосредственное 8-битное целое число.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1636
msgid ""
"@deftypefn Instruction {} ulogand s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"@deftypefnx Instruction {} ulogior s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"@deftypefnx Instruction {} ulogxor s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"@deftypefnx Instruction {} ulogsub s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Like @code{logand}, @code{logior}, @code{logxor}, and @code{logsub}, but\n"
"operating on unboxed unsigned 64-bit integers.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} ulogand s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"@deftypefnx Instruction {} ulogior s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"@deftypefnx Instruction {} ulogxor s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"@deftypefnx Instruction {} ulogsub s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Подобно @code{logand}, @code{logior}, @code{logxor}, и @code{logsub}, но\n"
"работает с распакованным беззнаковым 64-битным целым числом.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1643
msgid ""
"@deftypefn Instruction {} ulsh s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Shift the unboxed unsigned 64-bit integer in @var{a} left by @var{b}\n"
"bits, also an unboxed unsigned 64-bit integer.  Truncate to 64 bits and\n"
"write to @var{dst} as an unboxed value.  Only the lower 6 bits of\n"
"@var{b} are used.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} ulsh s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Сдвиг беззнакового 64битного целого числа из @var{a} влево на @var{b}\n"
"бит, результат также беззнаковое 64 битное целое. Обрезается до 64 бит\n"
"и записывается в  @var{dst} как распакованное значение.  Только нижние\n"
"6 бит из @var{b} используются.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1647
msgid ""
"@deftypefn Instruction {} ursh s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Like @code{ulsh}, but shifting right.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} ursh s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Тоже что и @code{ulsh}, но сдвиг вправо.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1653
msgid ""
"@deftypefn Instruction {} ulsh/immediate s8:@var{dst} s8:@var{a} c8:@var{b}\n"
"@deftypefnx Instruction {} ursh/immediate s8:@var{dst} s8:@var{a} c8:"
"@var{b}\n"
"Like @code{ulsh} and @code{ursh}, but encoding @code{b} as an immediate\n"
"8-bit unsigned integer.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} ulsh/immediate s8:@var{dst} s8:@var{a} c8:@var{b}\n"
"@deftypefnx Instruction {} ursh/immediate s8:@var{dst} s8:@var{a} c8:"
"@var{b}\n"
"Тоже что и @code{ulsh} и @code{ursh}, но @code{b} рассматривается как \n"
"непосредственное 8-битное беззнаковое целое.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1657
msgid ""
"@node Unboxed Floating-Point Arithmetic\n"
"@subsubsection Unboxed Floating-Point Arithmetic"
msgstr ""
"@node Unboxed Floating-Point Arithmetic\n"
"@subsubsection Арифметика Распакованных чисел с плавающей точкой"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1663
msgid ""
"@deftypefn Instruction {} scm->f64 s12:@var{dst} s12:@var{src}\n"
"Unbox the SCM value at @var{src} to an IEEE double, placing the result\n"
"in @var{dst}.  If the @var{src} value is not a real number, signal an\n"
"error.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} scm->f64 s12:@var{dst} s12:@var{src}\n"
"Распаковать значение SCM в  @var{src} в формат IEEE двойной точности, \n"
"разместив результат в  @var{dst}.  Если значение @var{src} не является\n"
"вещественным числом, выдать сигнал ошибки.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1668
msgid ""
"@deftypefn Instruction {} f64->scm s12:@var{dst} s12:@var{src}\n"
"Box the IEEE double at @var{src} to a SCM value and place the result in\n"
"@var{dst}.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} f64->scm s12:@var{dst} s12:@var{src}\n"
"Упокавать двойное IEEE из @var{src} в значение SCM и разместить результат\n"
"в @var{dst}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1673
msgid ""
"@deftypefn Instruction {} load-f64 s24:@var{dst} au32:@var{high-bits} au32:"
"@var{low-bits}\n"
"Load a 64-bit value formed by joining @var{high-bits} and\n"
"@var{low-bits}, and write it to @var{dst}.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} load-f64 s24:@var{dst} au32:@var{high-bits} au32:"
"@var{low-bits}\n"
"Загрузить 64-битное значение, сформированное путем объединения старших "
"бит(@var{high-bits})\n"
"и младших бит(@var{low-bits}) и записать результат в @var{dst}.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1682
msgid ""
"@deftypefn Instruction {} fadd s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"@deftypefnx Instruction {} fsub s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"@deftypefnx Instruction {} fmul s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"@deftypefnx Instruction {} fdiv s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Like @code{add}, @code{sub}, @code{div}, and @code{mul}, except taking\n"
"the operands as unboxed IEEE double floating-point numbers, and producing\n"
"the same.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} fadd s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"@deftypefnx Instruction {} fsub s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"@deftypefnx Instruction {} fmul s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"@deftypefnx Instruction {} fdiv s8:@var{dst} s8:@var{a} s8:@var{b}\n"
"Подобно @code{add}, @code{sub}, @code{div}, и @code{mul}, за исключением "
"того,\n"
"что операнды являются распакованными двойными числами с плавающей точкой "
"формата\n"
"IEEE и получают подобное число.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/vm.texi:1692
msgid ""
"@deftypefn Instruction {} br-if-f64-= s24:@var{a} x8:@var{_} s24:@var{b} b1:"
"@var{invert} x7:@var{_} l24:@var{offset}\n"
"@deftypefnx Instruction {} br-if-f64-< s24:@var{a} x8:@var{_} s24:@var{b} b1:"
"@var{invert} x7:@var{_} l24:@var{offset}\n"
"@deftypefnx Instruction {} br-if-f64-<= s24:@var{a} x8:@var{_} s24:@var{b} "
"b1:@var{invert} x7:@var{_} l24:@var{offset}\n"
"@deftypefnx Instruction {} br-if-f64-> s24:@var{a} x8:@var{_} s24:@var{b} b1:"
"@var{invert} x7:@var{_} l24:@var{offset}\n"
"@deftypefnx Instruction {} br-if-f64->= s24:@var{a} x8:@var{_} s24:@var{b} "
"b1:@var{invert} x7:@var{_} l24:@var{offset}\n"
"If the unboxed IEEE double value in @var{a} is @code{=}, @code{<},\n"
"@code{<=}, @code{>}, or @code{>=} to the unboxed IEEE double value in\n"
"@var{b}, respectively, add @var{offset} to the current instruction\n"
"pointer.\n"
"@end deftypefn"
msgstr ""
"@deftypefn Instruction {} br-if-f64-= s24:@var{a} x8:@var{_} s24:@var{b} b1:"
"@var{invert} x7:@var{_} l24:@var{offset}\n"
"@deftypefnx Instruction {} br-if-f64-< s24:@var{a} x8:@var{_} s24:@var{b} b1:"
"@var{invert} x7:@var{_} l24:@var{offset}\n"
"@deftypefnx Instruction {} br-if-f64-<= s24:@var{a} x8:@var{_} s24:@var{b} "
"b1:@var{invert} x7:@var{_} l24:@var{offset}\n"
"@deftypefnx Instruction {} br-if-f64-> s24:@var{a} x8:@var{_} s24:@var{b} b1:"
"@var{invert} x7:@var{_} l24:@var{offset}\n"
"@deftypefnx Instruction {} br-if-f64->= s24:@var{a} x8:@var{_} s24:@var{b} "
"b1:@var{invert} x7:@var{_} l24:@var{offset}\n"
"Если для значения распакованного двойного в формате IEEE в  @var{a} "
"выполнено @code{=}, @code{<},\n"
"@code{<=}, @code{>}, or @code{>=} по отношению к значению распакованного "
"двойного в формате IEEE\n"
"из @var{b}, ТО соотвественно , добавить смещение @var{offset} к текущей ip "
"(указателю выплняемой\n"
"инструкции)\n"
"pointer.\n"
"@end deftypefn"
