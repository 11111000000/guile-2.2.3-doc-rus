#
# Gagin <mikhail-gagin@yandex.ru>, 2018.
#
#. extracted from /home/bear/work/guile/doc/guile/en/api-procedures.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-07 12:36+0300\n"
"PO-Revision-Date: 2018-07-19 08:51+0300\n"
"Last-Translator: Gagin <mikhail-gagin@yandex.ru>\n"
"Language-Team: Russian <mikhail-gagin@yandex.ru>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2009, 2010,\n"
"@c   2011, 2012, 2013  Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:9
msgid ""
"@node Procedures\n"
"@section Procedures"
msgstr ""
"@node Procedures\n"
"@section Процедуры"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:21
msgid ""
"@menu\n"
"* Lambda::                      Basic procedure creation using lambda.\n"
"* Primitive Procedures::        Procedures defined in C.\n"
"* Compiled Procedures::         Scheme procedures can be compiled.\n"
"* Optional Arguments::          Handling keyword, optional and rest "
"arguments.\n"
"* Case-lambda::                 One function, multiple arities.\n"
"* Higher-Order Functions::      Function that take or return functions.\n"
"* Procedure Properties::        Procedure properties and meta-information.\n"
"* Procedures with Setters::     Procedures with setters.\n"
"* Inlinable Procedures::        Procedures that can be inlined.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:26
msgid ""
"@node Lambda\n"
"@subsection Lambda: Basic Procedure Creation\n"
"@cindex lambda"
msgstr ""
"@node Lambda\n"
"@subsection Lambda: Базовое создание Процедуры\n"
"@cindex lambda"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:31
msgid ""
"A @code{lambda} expression evaluates to a procedure.  The environment\n"
"which is in effect when a @code{lambda} expression is evaluated is\n"
"enclosed in the newly created procedure, this is referred to as a\n"
"@dfn{closure} (@pxref{About Closure})."
msgstr ""
"Выражение @code{lambda} вычисляется создавая процедуру.  Окружение, которое\n"
"действует когда  вычисляется @code{lambda} выражение, привязывается к "
"недавно\n"
"созданной процедуре, это отсылка к замыканию(@dfn{closure}) (@pxref{About "
"Closure})."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:39
msgid ""
"When a procedure created by @code{lambda} is called with some actual\n"
"arguments, the environment enclosed in the procedure is extended by\n"
"binding the variables named in the formal argument list to new locations\n"
"and storing the actual arguments into these locations.  Then the body of\n"
"the @code{lambda} expression is evaluated sequentially.  The result of\n"
"the last expression in the procedure body is then the result of the\n"
"procedure invocation."
msgstr ""
"Когда процедура, созданная @code{lambda} вызывается с некоторыми "
"фактическими\n"
"аргументами, окружение заключенное в процедуру(привязанное к ней), "
"рассширяется\n"
"связыванием переменных, названных в списке формальных аргументов, "
"дополнительным\n"
"пространством, где и сохраняются фактические аргументы. Затем тело "
"@code{lambda} \n"
"выражения последовательно вычисляется. Результат последнего выражения в "
"теле\n"
"процедуры является результатом вызова процедуры."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:42
msgid ""
"The following examples will show how procedures can be created using\n"
"@code{lambda}, and what you can do with these procedures."
msgstr ""
"В следующих примерах показано, как процедуры могут быть созданы с "
"использованием\n"
"@code{lambda}, и что вы можете сделать с этими процедурами."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:47
msgid ""
"@lisp\n"
"(lambda (x) (+ x x))       @result{} @r{a procedure}\n"
"((lambda (x) (+ x x)) 4)   @result{} 8\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:50
msgid ""
"The fact that the environment in effect when creating a procedure is\n"
"enclosed in the procedure is shown with this example:"
msgstr ""
"Тот факт, что среда, действующая при создании процедуры заключена в "
"процедуре\n"
"показан в следующем примере:"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:57
msgid ""
"@lisp\n"
"(define add4\n"
"  (let ((x 4))\n"
"    (lambda (y) (+ x y))))\n"
"(add4 6)                   @result{} 10\n"
"@end lisp"
msgstr ""
"@lisp\n"
"(define add4\n"
"  (let ((x 4))\n"
"    (lambda (y) (+ x y))))\n"
"(define x 5)\n"
"(add4 6)                   @result{} 10\n"
"@end lisp"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:62
msgid ""
"@deffn syntax lambda formals body\n"
"@var{formals} should be a formal argument list as described in the\n"
"following table."
msgstr ""
"@deffn syntax lambda formals body\n"
"@var{formals} должен быть формальным списком аргументов, как описано в "
"следующей\n"
"таблице."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:83
msgid ""
"@table @code\n"
"@item (@var{variable1} @dots{})\n"
"The procedure takes a fixed number of arguments; when the procedure is\n"
"called, the arguments will be stored into the newly created location for\n"
"the formal variables.\n"
"@item @var{variable}\n"
"The procedure takes any number of arguments; when the procedure is\n"
"called, the sequence of actual arguments will converted into a list and\n"
"stored into the newly created location for the formal variable.\n"
"@item (@var{variable1} @dots{} @var{variablen} . @var{variablen+1})\n"
"If a space-delimited period precedes the last variable, then the\n"
"procedure takes @var{n} or more variables where @var{n} is the number\n"
"of formal arguments before the period.  There must be at least one\n"
"argument before the period.  The first @var{n} actual arguments will be\n"
"stored into the newly allocated locations for the first @var{n} formal\n"
"arguments and the sequence of the remaining actual arguments is\n"
"converted into a list and the stored into the location for the last\n"
"formal argument.  If there are exactly @var{n} actual arguments, the\n"
"empty list is stored into the location of the last formal argument.\n"
"@end table"
msgstr ""
"@table @code\n"
"@item (@var{variable1} @dots{})\n"
"Процедура принимает фиксированное количество аргументов; когда процерура\n"
"вызвается, аргументы будут сохранены во вновь созданном месте для "
"формальных\n"
"переменных.\n"
"@item @var{variable}\n"
"Процедура принимает любое количество аргументов; когда вызывается процедура\n"
"последовательность фактических аргументов преобразуется в список и хранится\n"
"во вновь созданном месте для формальной переменной.\n"
"@item (@var{variable1} @dots{} @var{variablen} . @var{variablen+1})\n"
"Если точка предшествует последней переменной, про процедура принимает\n"
"@var{n} или более переменных, где @var{n} это число формальных аргументов\n"
"до точки.  До точки должен быть хотя бы один аргумент. Первые @var{n}\n"
"фактических аргументов будут сохранены в недавно выделенных местах для\n"
"первых  @var{n} формальных аргументов и последовательность оставшихся\n"
"фактических аргументов преобразуется в список и сохраняется в месте для\n"
"последнего формального аргумента. Если имеется ровно @var{n} фактических\n"
"аргументов, в месте последнего формального аргумента храниться пустой\n"
"список.\n"
"@end table"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:89
msgid ""
"The list in @var{variable} or @var{variablen+1} is always newly\n"
"created and the procedure can modify it if desired.  This is the case\n"
"even when the procedure is invoked via @code{apply}, the required part\n"
"of the list argument there will be copied (@pxref{Fly Evaluation,,\n"
"Procedures for On the Fly Evaluation})."
msgstr ""
"Спимок @var{variable} или @var{variablen+1} всегда создается и процедура\n"
"при необходимости может изменить его.  Это так, даже если процедура\n"
"применяется с помощью @code{apply}, необходимая часть аргумента спика\n"
"будет скопирована. См. (@pxref{Fly Evaluation,,\n"
"Procedures for On the Fly Evaluation})."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:93
msgid ""
"@var{body} is a sequence of Scheme expressions which are evaluated in\n"
"order when the procedure is invoked.\n"
"@end deffn"
msgstr ""
"@var{body} --- это последовательность выражений Scheme, которые вычисляются\n"
"по порядку когда процедура вызывается.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:98
msgid ""
"@node Primitive Procedures\n"
"@subsection Primitive Procedures\n"
"@cindex primitives\n"
"@cindex primitive procedures"
msgstr ""
"@node Primitive Procedures\n"
"@subsection Примитивные Процедуры\n"
"@cindex primitives\n"
"@cindex primitive procedures"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:104
msgid ""
"Procedures written in C can be registered for use from Scheme,\n"
"provided they take only arguments of type @code{SCM} and return\n"
"@code{SCM} values.  @code{scm_c_define_gsubr} is likely to be the most\n"
"useful mechanism, combining the process of registration\n"
"(@code{scm_c_make_gsubr}) and definition (@code{scm_define})."
msgstr ""
"Процедуры написанные на Си могут быть зарегистрированы для использования\n"
"из Scheme, если они принимают только аргументы типа @code{SCM} и возвращают\n"
"значения @code{SCM}.  @code{scm_c_define_gsubr}, вероятно, будет самым "
"полезным\n"
"механизмом, объединяющим процесс регистрации\n"
"(@code{scm_c_make_gsubr}) и определения (@code{scm_define})."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:116
msgid ""
"@deftypefun SCM scm_c_make_gsubr (const char *name, int req, int opt, int "
"rst, fcn)\n"
"Register a C procedure @var{fcn} as a ``subr'' --- a primitive\n"
"subroutine that can be called from Scheme.  It will be associated with\n"
"the given @var{name} but no environment binding will be created.  The\n"
"arguments @var{req}, @var{opt} and @var{rst} specify the number of\n"
"required, optional and ``rest'' arguments respectively.  The total\n"
"number of these arguments should match the actual number of arguments\n"
"to @var{fcn}, but may not exceed 10.  The number of rest arguments should be "
"0 or 1.\n"
"@code{scm_c_make_gsubr} returns a value of type @code{SCM} which is a\n"
"``handle'' for the procedure.\n"
"@end deftypefun"
msgstr ""
"@deftypefun SCM scm_c_make_gsubr (const char *name, int req, int opt, int "
"rst, fcn)\n"
"Регистрирует процедуру Си @var{fcn} как ``subr'' --- примитивную "
"подпрограмму,\n"
"которая может быть вызвана из Scheme.  Она будет связана с  данным именем "
"@var{name},\n"
"но без привязки к окружению в котором она создается. Аргументы @var{req}, "
"@var{opt} и\n"
"@var{rst} укзазывают количество требуемых, необязательных и  "
"``последний(rest)'' \n"
"аргументов соответственно.  Общее количество этих аргумегнтов дожно "
"соответствовать\n"
"фактическому числу аргументов в @var{fcn}, но не может превышать 10.  "
"Количсество\n"
"аргументов rest должно быть 0 или 1.\n"
"@code{scm_c_make_gsubr} возвращает значение типа @code{SCM}, который "
"является\n"
"``дескриптором(handle)'' процедуры.\n"
"@end deftypefun"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:125
msgid ""
"@deftypefun SCM scm_c_define_gsubr (const char *name, int req, int opt, int "
"rst, fcn)\n"
"Register a C procedure @var{fcn}, as for @code{scm_c_make_gsubr}\n"
"above, and additionally create a top-level Scheme binding for the\n"
"procedure in the ``current environment'' using @code{scm_define}.\n"
"@code{scm_c_define_gsubr} returns a handle for the procedure in the\n"
"same way as @code{scm_c_make_gsubr}, which is usually not further\n"
"required.\n"
"@end deftypefun"
msgstr ""
"@deftypefun SCM scm_c_define_gsubr (const char *name, int req, int opt, int "
"rst, fcn)\n"
"Регистрирует процедуру Си @var{fcn}, как и для @code{scm_c_make_gsubr}\n"
"выше, и дополнительно создает привязку верхенго уровня Scheme для процедуры "
"в \n"
"``текущем окружении(current environment)'' используя @code{scm_define}.\n"
"@code{scm_c_define_gsubr} возвращает дескриптор процедуры так же, как и\n"
"@code{scm_c_make_gsubr}, который обычно не требуется.\n"
"@end deftypefun"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:128
msgid ""
"@node Compiled Procedures\n"
"@subsection Compiled Procedures"
msgstr ""
"@node Compiled Procedures\n"
"@subsection Скомпилированные Процедуры"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:133
msgid ""
"The evaluation strategy given in @ref{Lambda} describes how procedures\n"
"are @dfn{interpreted}. Interpretation operates directly on expanded\n"
"Scheme source code, recursively calling the evaluator to obtain the\n"
"value of nested expressions."
msgstr ""
"Стратегия вычисления, приведенная в @ref{Lambda} описывает как процедуры\n"
"интерпретируются(@dfn{interpreted}). Интерпретация работает непосредственно\n"
"на расширенном исходном коде Scheme, рекурсивно вызывая вычислитель для "
"получения\n"
"значения вложенных выражений."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:138
msgid ""
"Most procedures are compiled, however. This means that Guile has done\n"
"some pre-computation on the procedure, to determine what it will need to\n"
"do each time the procedure runs. Compiled procedures run faster than\n"
"interpreted procedures."
msgstr ""
"Однако большинство процедур скомпилировано. Это означает, что Guile сделал\n"
"некоторую преварительную работу с процедурой, чтобы определить, что ей "
"нужно\n"
"будет делать каждй раз, когда процедура запускается. Скомпилированные "
"процедуры\n"
"выполняются быстрее, чем интерпретируемые процедуры."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:145
msgid ""
"Loading files is the normal way that compiled procedures come to\n"
"being. If Guile sees that a file is uncompiled, or that its compiled\n"
"file is out of date, it will attempt to compile the file when it is\n"
"loaded, and save the result to disk. Procedures can be compiled at\n"
"runtime as well. @xref{Read/Load/Eval/Compile}, for more information\n"
"on runtime compilation."
msgstr ""
"Загрузка файлов - это нормальный способ создания скомпилированных процедур.\n"
"Если Guile видит, что файл не скомпилирован, или что его скомпилированный\n"
"файл устарел, он попытается скомпилировать файл когда он загружен, и "
"сохранить\n"
"результат на диск. Процедуры также могут быть скомпилированы во время "
"выполнения.\n"
"@xref{Read/Load/Eval/Compile}, для получения дополнительной информации о "
"компиляции\n"
"во время выполнения."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:149
msgid ""
"Compiled procedures, also known as @dfn{programs}, respond all\n"
"procedures that operate on procedures. In addition, there are a few\n"
"more accessors for low-level details on programs."
msgstr ""
"Скомпилированные процедуры, также известные как программы(@dfn{programs}),\n"
"отвечают всем процедурам, котоыре оперируют процедурами. Кроме того, есть\n"
"несколько дополнительных процедур доступа(accessors) низкоуровневых \n"
"подробностей о программах."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:153
msgid ""
"Most people won't need to use the routines described in this section,\n"
"but it's good to have them documented. You'll have to include the\n"
"appropriate module first, though:"
msgstr ""
"Большинство людей не должны использовать процедуры, описанные в этом\n"
"разделе, но это хорошо для их документирования. Сначала вам нужно\n"
"включить соответствующий модуль:"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:157
msgid ""
"@example\n"
"(use-modules (system vm program))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:163
msgid ""
"@deffn {Scheme Procedure} program? obj\n"
"@deffnx {C Function} scm_program_p (obj)\n"
"Returns @code{#t} if @var{obj} is a compiled procedure, or @code{#f}\n"
"otherwise.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} program? obj\n"
"@deffnx {C Function} scm_program_p (obj)\n"
"Возвращает @code{#t} если @var{obj} скомпилированная процедура, или "
"@code{#f}\n"
"если нет.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:169
msgid ""
"@deffn {Scheme Procedure} program-code program\n"
"@deffnx {C Function} scm_program_code (program)\n"
"Returns the address of the program's entry, as an integer.  This address\n"
"is mostly useful to procedures in @code{(system vm debug)}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} program-code program\n"
"@deffnx {C Function} scm_program_code (program)\n"
"Возвращает адрес точки входа в программу, как целое число. Этот адрес в \n"
"основном полезен для процедур отладчика: @code{(system vm debug)}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:174
msgid ""
"@deffn {Scheme Procedure} program-num-free-variable program\n"
"@deffnx {C Function} scm_program_num_free_variables (program)\n"
"Return the number of free variables captured by this program.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} program-num-free-variable program\n"
"@deffnx {C Function} scm_program_num_free_variables (program)\n"
"Возвращает количество свободных переменных, захваченых этой\n"
"программой.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:182
msgid ""
"@deffn {Scheme Procedure} program-free-variable-ref program n\n"
"@deffnx {C Function} scm_program_free_variable-ref (program, n)\n"
"@deffnx {Scheme Procedure} program-free-variable-set! program n val\n"
"@deffnx {C Function} scm_program_free_variable_set_x (program, n, val)\n"
"Accessors for a program's free variables.  Some of the values captured\n"
"are actually in variable ``boxes''.  @xref{Variables and the VM}, for\n"
"more information."
msgstr ""
"@deffn {Scheme Procedure} program-free-variable-ref program n\n"
"@deffnx {C Function} scm_program_free_variable-ref (program, n)\n"
"@deffnx {Scheme Procedure} program-free-variable-set! program n val\n"
"@deffnx {C Function} scm_program_free_variable_set_x (program, n, val)\n"
"Аксессоры для свободных переменных программы. Некоторые из захваченных\n"
"значений фактически в переменных ``boxes''.  @xref{Variables and the VM}, \n"
"для получения дополнительной информации."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:186
msgid ""
"Users must not modify the returned value unless they think they're\n"
"really clever.\n"
"@end deffn"
msgstr ""
"Пользователи не должны изменять возвращаемое значение, если не считаю,\n"
"что они действительно умны.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:188
msgid "@c FIXME"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:197
msgid ""
"@deffn {Scheme Procedure} program-bindings program\n"
"@deffnx {Scheme Procedure} make-binding name boxed? index start end\n"
"@deffnx {Scheme Procedure} binding:name binding\n"
"@deffnx {Scheme Procedure} binding:boxed? binding\n"
"@deffnx {Scheme Procedure} binding:index binding\n"
"@deffnx {Scheme Procedure} binding:start binding\n"
"@deffnx {Scheme Procedure} binding:end binding\n"
"Bindings annotations for programs, along with their accessors."
msgstr ""
"@deffn {Scheme Procedure} program-bindings program\n"
"@deffnx {Scheme Procedure} make-binding name boxed? index start end\n"
"@deffnx {Scheme Procedure} binding:name binding\n"
"@deffnx {Scheme Procedure} binding:boxed? binding\n"
"@deffnx {Scheme Procedure} binding:index binding\n"
"@deffnx {Scheme Procedure} binding:start binding\n"
"@deffnx {Scheme Procedure} binding:end binding\n"
"Анотация связанных переменных для программ, вместе со своими аксессорами."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:201
msgid ""
"Bindings declare names and liveness extents for block-local variables.\n"
"The best way to see what these are is to play around with them at a\n"
"REPL. @xref{VM Concepts}, for more information."
msgstr ""
"Связанные перменные объявляют именами и расширяют блок локальных "
"переменных.\n"
"Лучший путь, чтобы посмотреть, что это такое, поиграть с ними в REPL. \n"
"@xref{VM Concepts}, для получения дополнительной информации."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:206
msgid ""
"Note that bindings information is stored in a program as part of its\n"
"metadata thunk, so including it in the generated object code does not\n"
"impose a runtime performance penalty.\n"
"@end deffn"
msgstr ""
"Обратите внимание, что информация о связанных переменных храниться в "
"программе\n"
"как часть(thunk) метаданных, поэтому включение его в генерируемый объектный "
"код\n"
"не налагает штрафа на производительность во время выполнения.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:213
msgid ""
"@deffn {Scheme Procedure} program-sources program\n"
"@deffnx {Scheme Procedure} source:addr source\n"
"@deffnx {Scheme Procedure} source:line source\n"
"@deffnx {Scheme Procedure} source:column source\n"
"@deffnx {Scheme Procedure} source:file source\n"
"Source location annotations for programs, along with their accessors."
msgstr ""
"@deffn {Scheme Procedure} program-sources program\n"
"@deffnx {Scheme Procedure} source:addr source\n"
"@deffnx {Scheme Procedure} source:line source\n"
"@deffnx {Scheme Procedure} source:column source\n"
"@deffnx {Scheme Procedure} source:file source\n"
"Анотация местоположения исходного кода, вместе со своими аксессорами."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:221
msgid ""
"Source location information propagates through the compiler and ends\n"
"up being serialized to the program's metadata. This information is\n"
"keyed by the offset of the instruction pointer within the object code\n"
"of the program. Specifically, it is keyed on the @code{ip} @emph{just\n"
"following} an instruction, so that backtraces can find the source\n"
"location of a call that is in progress.\n"
"@end deffn"
msgstr ""
"Информация о расположении исходного кода распространяется через компилятор\n"
"и заканчивается сериализацией в метаданные программы. Эта информация\n"
"подкрепляется указателем смещения инструкции внутри объектного кода "
"программы.\n"
"В частности, это @code{ip} @emph{just following} последующих инструкций, так "
"что\n"
"обратная трассировка может найти местоположение источника кода, который "
"выполняется.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:233
msgid ""
"@deffn {Scheme Procedure} program-arities program\n"
"@deffnx {C Function} scm_program_arities (program)\n"
"@deffnx {Scheme Procedure} program-arity program ip\n"
"@deffnx {Scheme Procedure} arity:start arity\n"
"@deffnx {Scheme Procedure} arity:end arity\n"
"@deffnx {Scheme Procedure} arity:nreq arity\n"
"@deffnx {Scheme Procedure} arity:nopt arity\n"
"@deffnx {Scheme Procedure} arity:rest? arity\n"
"@deffnx {Scheme Procedure} arity:kw arity\n"
"@deffnx {Scheme Procedure} arity:allow-other-keys? arity\n"
"Accessors for a representation of the ``arity'' of a program."
msgstr ""
"@deffn {Scheme Procedure} program-arities program\n"
"@deffnx {C Function} scm_program_arities (program)\n"
"@deffnx {Scheme Procedure} program-arity program ip\n"
"@deffnx {Scheme Procedure} arity:start arity\n"
"@deffnx {Scheme Procedure} arity:end arity\n"
"@deffnx {Scheme Procedure} arity:nreq arity\n"
"@deffnx {Scheme Procedure} arity:nopt arity\n"
"@deffnx {Scheme Procedure} arity:rest? arity\n"
"@deffnx {Scheme Procedure} arity:kw arity\n"
"@deffnx {Scheme Procedure} arity:allow-other-keys? arity\n"
"Аксессоры для представления``арности(arity)'' программы."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:240
msgid ""
"The normal case is that a procedure has one arity. For example,\n"
"@code{(lambda (x) x)}, takes one required argument, and that's it. One\n"
"could access that number of required arguments via @code{(arity:nreq\n"
"(program-arities (lambda (x) x)))}. Similarly, @code{arity:nopt} gets\n"
"the number of optional arguments, and @code{arity:rest?} returns a true\n"
"value if the procedure has a rest arg."
msgstr ""
"Обычный случай состоит в том, что процедура имеет одну арность. Например,\n"
"@code{(lambda (x) x)}, принимает один требуемый аргумент, и все. Можно\n"
"получить доступ к этому числу требуемых аргументов через @code{(arity:nreq\n"
"(program-arities (lambda (x) x)))}. По аналогии, @code{arity:nopt} получает\n"
"количество необязательных аргументов, и @code{arity:rest?} возвращает "
"истиное\n"
"значение, если процедура имеет аргумент rest."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:247
msgid ""
"@code{arity:kw} returns a list of @code{(@var{kw} . @var{idx})} pairs,\n"
"if the procedure has keyword arguments. The @var{idx} refers to the\n"
"@var{idx}th local variable; @xref{Variables and the VM}, for more\n"
"information. Finally @code{arity:allow-other-keys?} returns a true\n"
"value if other keys are allowed. @xref{Optional Arguments}, for more\n"
"information."
msgstr ""
"@code{arity:kw} возвращает список пар @code{(@var{kw} . @var{idx})},\n"
"если в процедуре есть аргументы ключевые слова. @var{idx} ссылается\n"
"на локальную переменную @var{idx}th; @xref{Variables and the VM}, для\n"
"получения дополнительной информации. Наконец @code{arity:allow-other-keys?}\n"
"возвращает истинное значение если разрешены другие ключи. \n"
"@xref{Optional Arguments}, для получения дополнительной информации."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:255
msgid ""
"So what about @code{arity:start} and @code{arity:end}, then? They\n"
"return the range of bytes in the program's bytecode for which a given\n"
"arity is valid. You see, a procedure can actually have more than one\n"
"arity. The question, ``what is a procedure's arity'' only really makes\n"
"sense at certain points in the program, delimited by these\n"
"@code{arity:start} and @code{arity:end} values.\n"
"@end deffn"
msgstr ""
"Так что насчет  @code{arity:start} и @code{arity:end}? Они возвращают\n"
"диапазон байтов в байт-коде программы для которого арность действительна.\n"
"Понимаете, процедура может на самом деле может импть больше чем одну\n"
"арность. Вопрос только в том ``что такое арность процедуры'' действительно\n"
"имеет смысл в определенных точках в программе, ограниченных этими "
"значениями\n"
"@code{arity:start} и @code{arity:end}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:259
msgid ""
"@deffn {Scheme Procedure} program-arguments-alist program [ip]\n"
"Return an association list describing the arguments that @var{program} "
"accepts, or\n"
"@code{#f} if the information cannot be obtained."
msgstr ""
"@deffn {Scheme Procedure} program-arguments-alist program [ip]\n"
"Возвращает ассоциативный список, описывающий аргументы которые принимает\n"
"программа(@var{program}) или @code{#f} если информация не может быть "
"получена."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:262
msgid ""
"The alist keys that are currently defined are `required', `optional',\n"
"`keyword', `allow-other-keys?', and `rest'.  For example:"
msgstr ""
"Ключами alist которые в настоящий момент определены являются: `required', "
"`optional',\n"
"`keyword', `allow-other-keys?', и `rest'.  Например:"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:274
msgid ""
"@example\n"
"(program-arguments-alist\n"
" (lambda* (a b #:optional c #:key (d 1) #:rest e)\n"
"   #t)) @result{}\n"
"((required . (a b))\n"
" (optional . (c))\n"
" (keyword . ((#:d . 4)))\n"
" (allow-other-keys? . #f)\n"
" (rest . d))\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:278
msgid ""
"@deffn {Scheme Procedure} program-lambda-list program [ip]\n"
"Return a representation of the arguments of @var{program} as a lambda\n"
"list, or @code{#f} if this information is not available."
msgstr ""
"@deffn {Scheme Procedure} program-lambda-list program [ip]\n"
"Возвращает представление аргументов программы(@var{program}) как лямбда\n"
"список, или  @code{#f} если эта информация не доступна."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:280
msgctxt "/home/bear/work/guile/doc/guile/en/api-procedures.texi:280"
msgid "For example:"
msgstr "Например:"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:287
msgid ""
"@example\n"
"(program-lambda-list\n"
" (lambda* (a b #:optional c #:key (d 1) #:rest e)\n"
"   #t)) @result{}\n"
"@end example\n"
"@end deffn"
msgstr ""
"@example\n"
"(program-lambda-list\n"
" (lambda* (a b #:optional c #:key (d 1) #:rest e)\n"
"   #t)) @result{}\n"
"@end example\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:290
msgid ""
"@node Optional Arguments\n"
"@subsection Optional Arguments"
msgstr ""
"@node Optional Arguments\n"
"@subsection Необязательные Аргументы"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:299
msgid ""
"Scheme procedures, as defined in R5RS, can either handle a fixed number\n"
"of actual arguments, or a fixed number of actual arguments followed by\n"
"arbitrarily many additional arguments.  Writing procedures of variable\n"
"arity can be useful, but unfortunately, the syntactic means for handling\n"
"argument lists of varying length is a bit inconvenient.  It is possible\n"
"to give names to the fixed number of arguments, but the remaining\n"
"(optional) arguments can be only referenced as a list of values\n"
"(@pxref{Lambda})."
msgstr ""
"Процедуры Scheme, определенные в R5RS, могут обрабатывать фиксированное\n"
"количество фактических аргументов, или фиксированное количество фактических\n"
"аргументов, за которыми следует произвольно много дополнительных "
"аргументов.\n"
"Написание процедур переменной арности(arity) может быть полезным, но, к \n"
"сожалению, синтаксические средства для обработки списков аргументов "
"различной\n"
"длины немного не удобны. Возможно присвоение имен фиксированному числу \n"
"аргументов, но остальные(не обязательные) аргументы могут упоминаться "
"только\n"
"как список значений. см.(@pxref{Lambda})."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:306
msgid ""
"For this reason, Guile provides an extension to @code{lambda},\n"
"@code{lambda*}, which allows the user to define procedures with\n"
"optional and keyword arguments. In addition, Guile's virtual machine\n"
"has low-level support for optional and keyword argument dispatch.\n"
"Calls to procedures with optional and keyword arguments can be made\n"
"cheaply, without allocating a rest list."
msgstr ""
"По этой причине, Guile предоставляет расширение @code{lambda},\n"
"@code{lambda*}, которое позволяет пользователю определять процедуры\n"
"с необзательными аргументами и ключевыми словами. Кроме того, виртуальная\n"
"машина Guile имеет низкоуровневую поддержку для передачи необязательных \n"
"аргументов и ключевых слов. Вызов процедур с необязательными аргументами\n"
"и ключевыми словами можно сделать дешевым, без выделения списка (rest)\n"
"остаточных аргументов."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:311
msgid ""
"@menu\n"
"* lambda* and define*::         Creating advanced argument handling "
"procedures.\n"
"* ice-9 optargs::               (ice-9 optargs) provides some utilities.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:315
msgid ""
"@node lambda* and define*\n"
"@subsubsection lambda* and define*."
msgstr ""
"@node lambda* and define*\n"
"@subsubsection lambda* и define*."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:318
msgid ""
"@code{lambda*} is like @code{lambda}, except with some extensions to\n"
"allow optional and keyword arguments."
msgstr ""
"@code{lambda*} подобен @code{lambda}, за исключением некоторых расширений\n"
"допускающих необязательные аргументы и ключевые слова."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:327
msgid ""
"@deffn {library syntax} lambda* ([var@dots{}] @* @\n"
"                        [#:optional vardef@dots{}] @* @\n"
"                        [#:key  vardef@dots{} [#:allow-other-keys]] @* @\n"
"                        [#:rest var | . var]) @* @\n"
"                        body1 body2 @dots{}\n"
"@sp 1\n"
"Create a procedure which takes optional and/or keyword arguments\n"
"specified with @code{#:optional} and @code{#:key}.  For example,"
msgstr ""
"@deffn {library syntax} lambda* ([var@dots{}] @* @\n"
"                        [#:optional vardef@dots{}] @* @\n"
"                        [#:key  vardef@dots{} [#:allow-other-keys]] @* @\n"
"                        [#:rest var | . var]) @* @\n"
"                        body1 body2 @dots{}\n"
"@sp 1\n"
"Создает процедуру, которая принимает необзательные аргументы и/или ключевые "
"слова\n"
"указанные в @code{#:optional} и @code{#:key}.  Например,"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:331
msgid ""
"@lisp\n"
"(lambda* (a b #:optional c d . e) '())\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:336
msgid ""
"is a procedure with fixed arguments @var{a} and @var{b}, optional\n"
"arguments @var{c} and @var{d}, and rest argument @var{e}.  If the\n"
"optional arguments are omitted in a call, the variables for them are\n"
"bound to @code{#f}."
msgstr ""
"это процедура с фиксированными аргументами @var{a} и @var{b}, "
"необязательными\n"
"аргументами @var{c} и @var{d}, и остальными аргументами доступными через "
"@var{e}.\n"
"Если необязательные аргументы опущены в вызове, их переменные связаны с "
"занчением\n"
"@code{#f}."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:340
msgid ""
"@fnindex define*\n"
"Likewise, @code{define*} is syntactic sugar for defining procedures\n"
"using @code{lambda*}."
msgstr ""
"@fnindex define*\n"
"Аналогично, @code{define*} это синтаксический сахар для определения "
"процедур\n"
"с использованием @code{lambda*}."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:343
msgid ""
"@code{lambda*} can also make procedures with keyword arguments. For\n"
"example, a procedure defined like this:"
msgstr ""
"@code{lambda*}так же может выполнять процедуры с аргументами ключевыми "
"словами.\n"
"Например, процедура определяется следующим образом:"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:348
msgid ""
"@lisp\n"
"(define* (sir-yes-sir #:key action how-high)\n"
"  (list action how-high))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:354
msgid ""
"can be called as @code{(sir-yes-sir #:action 'jump)},\n"
"@code{(sir-yes-sir #:how-high 13)}, @code{(sir-yes-sir #:action\n"
"'lay-down #:how-high 0)}, or just @code{(sir-yes-sir)}. Whichever\n"
"arguments are given as keywords are bound to values (and those not\n"
"given are @code{#f})."
msgstr ""
"может быть вызвана как @code{(sir-yes-sir #:action 'jump)},\n"
"@code{(sir-yes-sir #:how-high 13)}, @code{(sir-yes-sir #:action\n"
"'lay-down #:how-high 0)}, или просто just @code{(sir-yes-sir)}. Какие бы\n"
"аргументы не указывались, ключевые слова привязаны к значениям(если не\n"
"заданы то к значению @code{#f})."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:358
msgid ""
"Optional and keyword arguments can also have default values to take\n"
"when not present in a call, by giving a two-element list of variable\n"
"name and expression.  For example in"
msgstr ""
"Необязательные аргументы и ключевые слова могут также иметь значение по\n"
"уполчанию, если их нет в вызове, предоставив дву-элементный список "
"переменных\n"
"и выражений. Например в"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:363
msgid ""
"@lisp\n"
"(define* (frob foo #:optional (bar 42) #:key (baz 73))\n"
"  (list foo bar baz))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:368
msgid ""
"@var{foo} is a fixed argument, @var{bar} is an optional argument with\n"
"default value 42, and baz is a keyword argument with default value 73.\n"
"Default value expressions are not evaluated unless they are needed,\n"
"and until the procedure is called."
msgstr ""
"@var{foo} это фиксированный аргумент, @var{bar} это не обязательный "
"аргумент\n"
"с значением по умолчанию 42, и baz это аргумент ключевое слово со значением\n"
"по умолчанию 73. Выражения по умолчанию не вычисляются, если они не нужны, "
"и\n"
"до тех пор пока процедура не будет вызвана."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:373
msgid ""
"Normally it's an error if a call has keywords other than those\n"
"specified by @code{#:key}, but adding @code{#:allow-other-keys} to the\n"
"definition (after the keyword argument declarations) will ignore\n"
"unknown keywords."
msgstr ""
"Обычно это ошибка, если в вызове есть ключевые слова, отличные от тех,\n"
"которые указаны в  @code{#:key}, но добавление @code{#:allow-other-keys}\n"
"к определению(после объявлений аргументов ключевых слов) будут \n"
"игнорироваться неизвестные ключевые слова."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:376
msgid ""
"If a call has a keyword given twice, the last value is used.  For\n"
"example,"
msgstr ""
"Если вызов имеет ключевое слово, заданное дважды, используется последнее\n"
"значение. Например,"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:380
msgid ""
"@lisp\n"
"(define* (flips #:key (heads 0) (tails 0))\n"
"  (display (list heads tails)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:384
msgid ""
"(flips #:heads 37 #:tails 42 #:heads 99)\n"
"@print{} (99 42)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:390
msgid ""
"@code{#:rest} is a synonym for the dotted syntax rest argument.  The\n"
"argument lists @code{(a . b)} and @code{(a #:rest b)} are equivalent\n"
"in all respects.  This is provided for more similarity to DSSSL,\n"
"MIT-Scheme and Kawa among others, as well as for refugees from other\n"
"Lisp dialects."
msgstr ""
"@code{#:rest} являтся синонимом для синтаксиса точечного аргумента "
"останова.\n"
"Списки аргументов @code{(a . b)} и @code{(a #:rest b)} эквивалентны во всех\n"
"отношениях. Это предусмотрено для большего сходства с DSSSL, MIT-Scheme и \n"
"Kawa в числе других, а также для переходящих из других диалектов Lisp."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:394
msgid ""
"When @code{#:key} is used together with a rest argument, the keyword\n"
"parameters in a call all remain in the rest list.  This is the same as\n"
"Common Lisp.  For example,"
msgstr ""
"Когда @code{#:key} используется вместе с аргументом rest, параметры "
"ключевые\n"
"слова в вызове все они остаются в списке rest.  Это тоже самое, что и\n"
"Common Lisp.  Например,"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:401
msgid ""
"@lisp\n"
"((lambda* (#:key (x 0) #:allow-other-keys #:rest r)\n"
"   (display r))\n"
" #:x 123 #:y 456)\n"
"@print{} (#:x 123 #:y 456)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:405
msgid ""
"@code{#:optional} and @code{#:key} establish their bindings\n"
"successively, from left to right. This means default expressions can\n"
"refer back to prior parameters, for example"
msgstr ""
"@code{#:optional} и @code{#:key} последовательно устанавливает свои "
"привязки\n"
"слева на право. Это означает, что выражения по умолчанию могут ссылаться на\n"
"предыдущие параметры, например."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:412
msgid ""
"@lisp\n"
"(lambda* (start #:optional (end (+ 10 start)))\n"
"  (do ((i start (1+ i)))\n"
"      ((> i end))\n"
"    (display i)))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:417
msgid ""
"The exception to this left-to-right scoping rule is the rest argument.\n"
"If there is a rest argument, it is bound after the optional arguments,\n"
"but before the keyword arguments.\n"
"@end deffn"
msgstr ""
"Исключением является правило останова слева на право. Если есть rest\n"
"аргумент, он связывается после необязательных аргументов, но до аргументов\n"
"ключевых слов.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:421
msgid ""
"@node ice-9 optargs\n"
"@subsubsection (ice-9 optargs)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:428
msgid ""
"Before Guile 2.0, @code{lambda*} and @code{define*} were implemented\n"
"using macros that processed rest list arguments. This was not optimal,\n"
"as calling procedures with optional arguments had to allocate rest\n"
"lists at every procedure invocation. Guile 2.0 improved this\n"
"situation by bringing optional and keyword arguments into Guile's\n"
"core."
msgstr ""
"До Guile 2.0, @code{lambda*} и @code{define*} были реализованы с \n"
"использованием макросов, которые обрабатывали список остальных аргументов.\n"
"Это не было оптимальным, поскольку вызов процедуры с дополнительными\n"
"аргументами при каждом вызове размещал список rest. Guile 2.0 улучшил эту\n"
"ситуацию привнеся дополнительные аргументы и ключевые слова в ядро Guile."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:432
msgid ""
"However there are occasions in which you have a list and want to parse\n"
"it for optional or keyword arguments. Guile's @code{(ice-9 optargs)}\n"
"provides some macros to help with that task."
msgstr ""
"Однако есть случаи. когда у вас есть список и вы хотите его разобрать для\n"
"выделения необязательных аргументов и ключевых слов. Guile предоставляет\n"
"в модуле @code{(ice-9 optargs)} некоторые макросы, чтобы помочь в решении\n"
"этой задачи."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:438
msgid ""
"The syntax @code{let-optional} and @code{let-optional*} are for\n"
"destructuring rest argument lists and giving names to the various list\n"
"elements.  @code{let-optional} binds all variables simultaneously, while\n"
"@code{let-optional*} binds them sequentially, consistent with @code{let}\n"
"and @code{let*} (@pxref{Local Bindings})."
msgstr ""
"Синтаксис @code{let-optional} и @code{let-optional*} предназначен для\n"
"разбора списка аргументов rest и присвоения имен различным элементам\n"
"списка.  @code{let-optional} связывает все переменные одновременно, а\n"
"@code{let-optional*} связывает их последовательно, согласуясь с \n"
"@code{let} и @code{let*} (@pxref{Local Bindings})."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:451
msgid ""
"@deffn {library syntax} let-optional rest-arg (binding @dots{}) body1 body2 "
"@dots{}\n"
"@deffnx {library syntax} let-optional* rest-arg (binding @dots{}) body1 "
"body2 @dots{}\n"
"These two macros give you an optional argument interface that is very\n"
"@dfn{Schemey} and introduces no fancy syntax. They are compatible with\n"
"the scsh macros of the same name, but are slightly extended. Each of\n"
"@var{binding} may be of one of the forms @var{var} or @code{(@var{var}\n"
"@var{default-value})}. @var{rest-arg} should be the rest-argument of the\n"
"procedures these are used from.  The items in @var{rest-arg} are\n"
"sequentially bound to the variable names are given. When @var{rest-arg}\n"
"runs out, the remaining vars are bound either to the default values or\n"
"@code{#f} if no default value was specified. @var{rest-arg} remains\n"
"bound to whatever may have been left of @var{rest-arg}."
msgstr ""
"@deffn {library syntax} let-optional rest-arg (binding @dots{}) body1 body2 "
"@dots{}\n"
"@deffnx {library syntax} let-optional* rest-arg (binding @dots{}) body1 "
"body2 @dots{}\n"
"Эти два макроса предоставляют вам интерфейс необязательных аргументов "
"который является\n"
"очень Схемным(@dfn{Schemey}) и не вводит никакого синтаксиса. Они совместимы "
"с макросами\n"
"scsh с теми же именами, но немного расширенне. Каждая из (@var{binding}) "
"может быть одной\n"
"из форм @var{var} или  @code{(@var{var} @var{default-value})}. @var{rest-"
"arg} должен быть\n"
"последним аргументом процедуры которая использует эту форму. Элементы в "
"@var{rest-arg} \n"
"последовательно связываются к данным именам переменных. Когда @var{rest-arg} "
"заканчивается,\n"
"остальные переменные связываются либо со значением по умолчанию или с "
"@code{#f}, если \n"
"значение по умолчанию не указано. @var{rest-arg} остается связанным "
"связанным с тем,\n"
"что останется от @var{rest-arg}."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:455
msgid ""
"After binding the variables, the expressions @var{body1} @var{body2} "
"@dots{}\n"
"are evaluated in order.\n"
"@end deffn"
msgstr ""
"после привязки переменных вычисляются выражения @var{body1} @var{body2} "
"@dots{}\n"
"в порядке их следования.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:459
msgid ""
"Similarly, @code{let-keywords} and @code{let-keywords*} extract values\n"
"from keyword style argument lists, binding local variables to those\n"
"values or to defaults."
msgstr ""
"Аналогично, @code{let-keywords} и @code{let-keywords*} извлекают значения\n"
"из списка аргументов ключевых слов, привязывая локальные переменные к этим\n"
"значениям или значениям по умолчанию."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:468
msgid ""
"@deffn {library syntax} let-keywords args allow-other-keys? (binding "
"@dots{}) body1 body2 @dots{}\n"
"@deffnx {library syntax} let-keywords* args allow-other-keys? (binding "
"@dots{}) body1 body2 @dots{}\n"
"@var{args} is evaluated and should give a list of the form\n"
"@code{(#:keyword1 value1 #:keyword2 value2 @dots{})}.  The\n"
"@var{binding}s are variables and default expressions, with the variables\n"
"to be set (by name) from the keyword values.  The @var{body1}\n"
"@var{body2} @dots{}  forms are then evaluated and the last is the\n"
"result.  An example will make the syntax clearest,"
msgstr ""
"@deffn {library syntax} let-keywords args allow-other-keys? (binding "
"@dots{}) body1 body2 @dots{}\n"
"@deffnx {library syntax} let-keywords* args allow-other-keys? (binding "
"@dots{}) body1 body2 @dots{}\n"
"@var{args} вычисляется и должен быть доступен как список формы\n"
"@code{(#:keyword1 value1 #:keyword2 value2 @dots{})}. \n"
"@var{binding} переменные и выражения по умолчанию, с переменными\n"
"устанавливаемыми(по именам) из значений ключевых слов. \n"
"@var{body1} @var{body2} @dots{}  формы вычисляемые и значение последнего\n"
"выражения является результатом.  An example will make the syntax clearest,"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:471
msgid ""
"@example\n"
"(define args '(#:xyzzy \"hello\" #:foo \"world\"))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:480
msgid ""
"(let-keywords args #t\n"
"      ((foo  \"default for foo\")\n"
"       (bar  (string-append \"default\" \"for\" \"bar\")))\n"
"  (display foo)\n"
"  (display \", \")\n"
"  (display bar))\n"
"@print{} world, defaultforbar\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:484
msgid ""
"The binding for @code{foo} comes from the @code{#:foo} keyword in\n"
"@code{args}.  But the binding for @code{bar} is the default in the\n"
"@code{let-keywords}, since there's no @code{#:bar} in the args."
msgstr ""
"Связываение для @code{foo} приходит от ключевого слова @code{#:foo} в\n"
"@code{args}.  Но связваение для @code{bar} является значение по умолчанию\n"
"в @code{let-keywords}, поскольку в args нет ключа @code{#:bar}."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:490
msgid ""
"@var{allow-other-keys?} is evaluated and controls whether unknown\n"
"keywords are allowed in the @var{args} list.  When true other keys are\n"
"ignored (such as @code{#:xyzzy} in the example), when @code{#f} an\n"
"error is thrown for anything unknown.\n"
"@end deffn"
msgstr ""
"@var{allow-other-keys?} вычисляет и управляет разрешением на использование\n"
"неизвестных ключевых слов в списке аргументов @var{args}.  Когда она "
"истинно\n"
"неизветные ключи игнорируются (такие как, {#:xyzzy} в примере), когда "
"@code{#f}\n"
"генерируется ошибка для неизвестного ключевого слова.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:498
msgid ""
"@code{(ice-9 optargs)} also provides some more @code{define*} sugar,\n"
"which is not so useful with modern Guile coding, but still supported:\n"
"@code{define*-public} is the @code{lambda*} version of\n"
"@code{define-public}; @code{defmacro*} and @code{defmacro*-public}\n"
"exist for defining macros with the improved argument list handling\n"
"possibilities. The @code{-public} versions not only define the\n"
"procedures/macros, but also export them from the current module."
msgstr ""
"@code{(ice-9 optargs)} также предоставляет еще несколько синтксического\n"
"сахара @code{define*},  которые не так полезны с современным кодированием\n"
"Guile, но все же поддерживаются: @code{define*-public} это @code{lambda*}\n"
"версия @code{define-public}; @code{defmacro*} и @code{defmacro*-public}\n"
"используются для определения макросов с улучшеной возможностью обработки\n"
"списка аргументов. @code{-public} версии не только определяют процедуры и\n"
"макросы, но также экспортировать их из текущего модуля."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:502
msgid ""
"@deffn {library syntax} define*-public formals body1 body2 @dots{}\n"
"Like a mix of @code{define*} and @code{define-public}.\n"
"@end deffn"
msgstr ""
"@deffn {library syntax} define*-public formals body1 body2 @dots{}\n"
"это смесь @code{define*} и @code{define-public}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:509
msgid ""
"@deffn {library syntax} defmacro* name formals body1 body2 @dots{}\n"
"@deffnx {library syntax} defmacro*-public name formals body1 body2 @dots{}\n"
"These are just like @code{defmacro} and @code{defmacro-public} except that "
"they\n"
"take @code{lambda*}-style extended parameter lists, where @code{#:"
"optional},\n"
"@code{#:key}, @code{#:allow-other-keys} and @code{#:rest} are allowed with "
"the usual\n"
"semantics. Here is an example of a macro with an optional argument:"
msgstr ""
"@deffn {library syntax} defmacro* name formals body1 body2 @dots{}\n"
"@deffnx {library syntax} defmacro*-public name formals body1 body2 @dots{}\n"
"Это тоже , как  @code{defmacro} и @code{defmacro-public} за исключением "
"того,\n"
"что они берут @code{lambda*}-стиль расширения списка параметров, где, "
"@code{#:optional},\n"
"@code{#:key}, @code{#:allow-other-keys} и @code{#:rest} разрешены с "
"использованием\n"
"обычной семантики. Вот пример макроса с необязательным аргументом:"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:515
msgid ""
"@lisp\n"
"(defmacro* transmogrify (a #:optional b)\n"
"  (a 1))\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:521
msgid ""
"@node Case-lambda\n"
"@subsection Case-lambda\n"
"@cindex SRFI-16\n"
"@cindex variable arity\n"
"@cindex arity, variable"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:526
msgid ""
"R5RS's rest arguments are indeed useful and very general, but they\n"
"often aren't the most appropriate or efficient means to get the job\n"
"done. For example, @code{lambda*} is a much better solution to the\n"
"optional argument problem than @code{lambda} with rest arguments."
msgstr ""
"R5RS определяет rest аргументы как действительно полезные и очень общие,\n"
"но они часть не самые подходящие или эффективные средства для выполнения\n"
"работы. Например, @code{lambda*} намного лучшее решение проблемы с \n"
"необязательными аргументами, чем @code{lambda} с аргументами rest."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:531
msgid ""
"@fnindex case-lambda\n"
"Likewise, @code{case-lambda} works well for when you want one\n"
"procedure to do double duty (or triple, or ...), without the penalty\n"
"of consing a rest list."
msgstr ""
"@fnindex case-lambda\n"
"Аналогично, @code{case-lambda} хорошо работает, когда вы хотите, чтобы\n"
"одна процедура выполняла двойную(или тройную, или ...) нагрузку, без\n"
"штрафа на создание списка остаточных(rest) аргументов."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:533
msgctxt "/home/bear/work/guile/doc/guile/en/api-procedures.texi:533"
msgid "For example:"
msgstr "Например:"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:539
msgid ""
"@lisp\n"
"(define (make-accum n)\n"
"  (case-lambda\n"
"    (() n)\n"
"    ((m) (set! n (+ n m)) n)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:545
msgid ""
"(define a (make-accum 20))\n"
"(a) @result{} 20\n"
"(a 10) @result{} 30\n"
"(a) @result{} 30\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:552
msgid ""
"The value returned by a @code{case-lambda} form is a procedure which\n"
"matches the number of actual arguments against the formals in the\n"
"various clauses, in order. The first matching clause is selected, the\n"
"corresponding values from the actual parameter list are bound to the\n"
"variable names in the clauses and the body of the clause is evaluated.\n"
"If no clause matches, an error is signalled."
msgstr ""
"Значение, возвращаемое формой @code{case-lambda}, это процедура, которая\n"
"соответствует числу фактических аргументов, а не формальных, в различных\n"
"вариантах испольования вызова. Первое совпадение, соответствующего значения\n"
"из фактического списка параметров связывается с именем переменной в "
"предложениях\n"
"и теле вычисляемого предложения. Если никакая позиция не соответствует, "
"выдается\n"
"сообщение об ошибке."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:556
msgid ""
"The syntax of the @code{case-lambda} form is defined in the following\n"
"EBNF grammar. @dfn{Formals} means a formal argument list just like\n"
"with @code{lambda} (@pxref{Lambda})."
msgstr ""
"Синткасис формы @code{case-lambda} определяется следующей EBNF граматикой.\n"
"Формальные(@dfn{Formals}) означает формальный список аргументов подобный\n"
"используемому с @code{lambda} (@pxref{Lambda})."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:570
msgid ""
"@example\n"
"@group\n"
"<case-lambda>\n"
"   --> (case-lambda <case-lambda-clause>*)\n"
"   --> (case-lambda <docstring> <case-lambda-clause>*)\n"
"<case-lambda-clause>\n"
"   --> (<formals> <definition-or-command>*)\n"
"<formals>\n"
"   --> (<identifier>*)\n"
"     | (<identifier>* . <identifier>)\n"
"     | <identifier>\n"
"@end group\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:572
msgid "Rest lists can be useful with @code{case-lambda}:"
msgstr ""
"Остаточный(Rest) список может быть полезен дла использования с @code{case-"
"lambda}:"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:583
msgid ""
"@lisp\n"
"(define plus\n"
"  (case-lambda\n"
"    \"Return the sum of all arguments.\"\n"
"    (() 0)\n"
"    ((a) a)\n"
"    ((a b) (+ a b))\n"
"    ((a b . rest) (apply plus (+ a b) rest))))\n"
"(plus 1 2 3) @result{} 6\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:590
msgid ""
"@fnindex case-lambda*\n"
"Also, for completeness. Guile defines @code{case-lambda*} as well,\n"
"which is like @code{case-lambda}, except with @code{lambda*} clauses.\n"
"A @code{case-lambda*} clause matches if the arguments fill the\n"
"required arguments, but are not too many for the optional and/or rest\n"
"arguments."
msgstr ""
"@fnindex case-lambda*\n"
"Кроме того, для полноты. Guile определяет @code{case-lambda*} также\n"
"как @code{case-lambda}, за исключением предложения @code{lambda*}.\n"
"Предложение @code{case-lambda*} соответствует если аргументы заполняют\n"
"требуемые аргументы, но не более необязательный и/или остаточных\n"
"аргументов."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:595
msgid ""
"Keyword arguments are possible with @code{case-lambda*} as well, but\n"
"they do not contribute to the ``matching'' behavior, and their\n"
"interactions with required, optional, and rest arguments can be\n"
"surprising."
msgstr ""
"Аргументы ключевые слова возможно использовать с @code{case-lambda*} также,\n"
"но оне не вносят вклад в поведение вычисляющее ``совпадение'', и их "
"взаимодействие\n"
"с требуемыми, необязательными и остаточными аргументами может быть "
"удивительным."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:602
msgid ""
"For the purposes of @code{case-lambda*} (and of @code{case-lambda}, as a\n"
"special case), a clause @dfn{matches} if it has enough required\n"
"arguments, and not too many positional arguments.  The required\n"
"arguments are any arguments before the @code{#:optional}, @code{#:key},\n"
"and @code{#:rest} arguments.  @dfn{Positional} arguments are the\n"
"required arguments, together with the optional arguments."
msgstr ""
"Для целей @code{case-lambda*} (и @code{case-lambda}, в качестве особого\n"
"случая), предложение соответствует(@dfn{matches}) если у него достаточно\n"
"требуемых аргументов, и не слишком много позиционных аргументов. \n"
"Необходимыми аргументами являются любые аргументы перед аргументами \n"
"@code{#:optional}, @code{#:key}, и @code{#:rest}.  "
"Позиционными(@dfn{Positional})\n"
"аргументами являются необходимые аргументы, а также необязательные аргументы."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:610
msgid ""
"In the absence of @code{#:key} or @code{#:rest} arguments, it's easy to\n"
"see how there could be too many positional arguments: you pass 5\n"
"arguments to a function that only takes 4 arguments, including optional\n"
"arguments.  If there is a @code{#:rest} argument, there can never be too\n"
"many positional arguments: any application with enough required\n"
"arguments for a clause will match that clause, even if there are also\n"
"@code{#:key} arguments."
msgstr ""
"В отсутствии аргументов @code{#:key} или @code{#:rest}, легко увидеть,\n"
"как может быть слишком моного позиционных аргументов: вы передаете 5\n"
"аргументов функции, которая принимает только 4 аргумента, включая "
"необязательные\n"
"аргументы. Если есть аргумент @code{#:rest}, никогда не может быть слишком\n"
"много позиционных аргументов: любое приложение с достаточным числом "
"необходимых\n"
"аргументов для предложения будет соответствовать этому предложению, даже "
"если есть\n"
"аргументы @code{#:key}."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:619
msgid ""
"Otherwise, for applications to a clause with @code{#:key} arguments (and\n"
"without a @code{#:rest} argument), a clause will match there only if\n"
"there are enough required arguments and if the next argument after\n"
"binding required and optional arguments, if any, is a keyword.  For\n"
"efficiency reasons, Guile is currently unable to include keyword\n"
"arguments in the matching algorithm.  Clauses match on positional\n"
"arguments only, not by comparing a given keyword to the available set of\n"
"keyword arguments that a function has."
msgstr ""
"В противном случае для приложений к предложению с аргументами @code{#:key}\n"
"(и без аргумента @code{#:rest}), предложение будет соответствовать\n"
"только там, где достаточно аргументов, и если следующий аргумент после\n"
"связывание требуемых и необзяательных аргументов, если они есть, является\n"
"ключевым словом. Для соображения эффективности, Guile в настоящее время\n"
"не может включать аргументы ключевые слова в алгоритм поиска соответствия.\n"
"Предложения проверяют совпадения только с позиционными аргументами, и не\n"
"сравнивают доступные ключевые слова с доступным набором аргументов ключевых\n"
"слов, который имеет функция."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:621
msgid "Some examples follow."
msgstr "Ниже приводятся некоторые примеры."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:629
msgid ""
"@example\n"
"(define f\n"
"  (case-lambda*\n"
"    ((a #:optional b) 'clause-1)\n"
"    ((a #:optional b #:key c) 'clause-2)\n"
"    ((a #:key d) 'clause-3)\n"
"    ((#:key e #:rest f) 'clause-4)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:637
msgid ""
"(f) @result{} clause-4\n"
"(f 1) @result{} clause-1\n"
"(f) @result{} clause-4\n"
"(f #:e 10) clause-1\n"
"(f 1 #:foo) clause-1\n"
"(f 1 #:c 2) clause-2\n"
"(f #:a #:b #:c #:d #:e) clause-4"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:641
msgid ""
";; clause-2 will match anything that clause-3 would match.\n"
"(f 1 #:d 2) @result{} error: bad keyword args in clause 2\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:645
msgid ""
"Don't forget that the clauses are matched in order, and the first\n"
"matching clause will be taken.  This can result in a keyword being bound\n"
"to a required argument, as in the case of @code{f #:e 10}."
msgstr ""
"Не забывайте, что предложения сопоставляются по порядку, и первое "
"предложение\n"
"соответствия будет принято. Это может привести к тому, что кючевое слово\n"
"привязывается к требуемому аргументу, как в случае @code{f #:e 10}."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:649
msgid ""
"@node Higher-Order Functions\n"
"@subsection Higher-Order Functions"
msgstr ""
"@node Higher-Order Functions\n"
"@subsection Функции более высокого порядка"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:651
msgid "@cindex higher-order functions"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:656
msgid ""
"As a functional programming language, Scheme allows the definition of\n"
"@dfn{higher-order functions}, i.e., functions that take functions as\n"
"arguments and/or return functions.  Utilities to derive procedures from\n"
"other procedures are provided and described below."
msgstr ""
"В качестве функционального языка программирования, Scheme позволяет "
"определять\n"
"функции более высокого порядка(@dfn{higher-order functions}), т.е. функции,\n"
"которые принимают функци как аргументы и/или возвращают функции. Утилиты "
"для\n"
"получения процедур из других процедур и приводятся ниже."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:660
msgid ""
"@deffn {Scheme Procedure} const value\n"
"Return a procedure that accepts any number of arguments and returns\n"
"@var{value}."
msgstr ""
"@deffn {Scheme Procedure} const value\n"
"Возвращает процедуру, которая принимает любое количество аргументов и\n"
"возвращает @var{value}."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:667
msgid ""
"@lisp\n"
"(procedure? (const 3))        @result{} #t\n"
"((const 'hello))              @result{} hello\n"
"((const 'hello) 'world)       @result{} hello\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:671
msgid ""
"@deffn {Scheme Procedure} negate proc\n"
"Return a procedure with the same arity as @var{proc} that returns the\n"
"@code{not} of @var{proc}'s result."
msgstr ""
"@deffn {Scheme Procedure} negate proc\n"
"Возвращает процедуру с той же арностью, что и @var{proc}, которая "
"возвращает\n"
"отритцание результата @var{proc}, т.е @code{not} @var{proc}."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:682
msgid ""
"@lisp\n"
"(procedure? (negate number?)) @result{} #t\n"
"((negate odd?) 2)             @result{} #t\n"
"((negate real?) 'dream)       @result{} #t\n"
"((negate string-prefix?) \"GNU\" \"GNU Guile\")\n"
"                              @result{} #f\n"
"(filter (negate number?) '(a 2 \"b\"))\n"
"                              @result{} (a \"b\")\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:688
msgid ""
"@deffn {Scheme Procedure} compose proc1 proc2 @dots{}\n"
"Compose @var{proc1} with the procedures @var{proc2} @dots{}  such that\n"
"the last @var{proc} argument is applied first and @var{proc1} last, and\n"
"return the resulting procedure.  The given procedures must have\n"
"compatible arity."
msgstr ""
"@deffn {Scheme Procedure} compose proc1 proc2 @dots{}\n"
"Составляет @var{proc1} с процедурами @var{proc2} @dots{} , так что\n"
"аргумент @var{proc} применяется сначала последней процедурой, затем\n"
"результат передается в предшестующю процедуру и последней обрабатывает "
"результат\n"
"@var{proc1}, и возвращает полученную процедуру. Данные процедуры должны "
"быть \n"
"совместимой арности."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:694
msgid ""
"@lisp\n"
"(procedure? (compose 1+ 1-)) @result{} #t\n"
"((compose sqrt 1+ 1+) 2)     @result{} 2.0\n"
"((compose 1+ sqrt) 3)        @result{} 2.73205080756888\n"
"(eq? (compose 1+) 1+)        @result{} #t"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:699
msgid ""
"((compose zip unzip2) '((1 2) (a b)))\n"
"                             @result{} ((1 2) (a b))\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:703
msgid ""
"@deffn {Scheme Procedure} identity x\n"
"Return X.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} identity x\n"
"Возвращает X.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:708
msgid ""
"@deffn {Scheme Procedure} and=> value proc\n"
"When @var{value} is @code{#f}, return @code{#f}.  Otherwise, return\n"
"@code{(@var{proc} @var{value})}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} and=> value proc\n"
"Когда @var{value} это @code{#f}, возвращается @code{#f}.  Иначе, "
"возвращается\n"
"@code{(@var{proc} @var{value})}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:711
msgid ""
"@node Procedure Properties\n"
"@subsection Procedure Properties and Meta-information"
msgstr ""
"@node Procedure Properties\n"
"@subsection Свойства Процедур и Мета-Информация"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:717
msgid ""
"In addition to the information that is strictly necessary to run,\n"
"procedures may have other associated information. For example, the\n"
"name of a procedure is information not for the procedure, but about\n"
"the procedure. This meta-information can be accessed via the procedure\n"
"properties interface."
msgstr ""
"В дополнение к информации, которая строго необходима для запуска,\n"
"процедуры могут иметь другую связанню с ними информацию. Например,\n"
"имя процедуры - это информация не для процедуры, а о процедуре. Эту\n"
"мета-информацию можно получить доступ через интерфейс свойств\n"
"процедур."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:722
msgid ""
"The first group of procedures in this meta-interface are predicates to\n"
"test whether a Scheme object is a procedure, or a special procedure,\n"
"respectively.  @code{procedure?} is the most general predicates, it\n"
"returns @code{#t} for any kind of procedure."
msgstr ""
"Первая группа процедур в этом мета-интерфейсе является предикатом\n"
"для проверки того, является ли объект Scheme процедурой или специальной\n"
"процедурой, соответственно.  @code{procedure?} наиболее общий предикат, \n"
"который возвращает @code{#t} для любой процедуры."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:728
msgid ""
"@rnindex procedure?\n"
"@deffn {Scheme Procedure} procedure? obj\n"
"@deffnx {C Function} scm_procedure_p (obj)\n"
"Return @code{#t} if @var{obj} is a procedure.\n"
"@end deffn"
msgstr ""
"@rnindex procedure?\n"
"@deffn {Scheme Procedure} procedure? obj\n"
"@deffnx {C Function} scm_procedure_p (obj)\n"
"Возвращает @code{#t} если @var{obj} это процедура.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:734
msgid ""
"@deffn {Scheme Procedure} thunk? obj\n"
"@deffnx {C Function} scm_thunk_p (obj)\n"
"Return @code{#t} if @var{obj} is a thunk---a procedure that does\n"
"not accept arguments.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} thunk? obj\n"
"@deffnx {C Function} scm_thunk_p (obj)\n"
"Возвращает @code{#t} если @var{obj} это thunk---процедура, которая не \n"
"принимает аргументов.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:739
msgid ""
"@cindex procedure properties\n"
"Procedure properties are general properties associated with\n"
"procedures. These can be the name of a procedure or other relevant\n"
"information, such as debug hints."
msgstr ""
"@cindex procedure properties\n"
"Свойства процедуры --- это общие свойства, связанные с процедурами. Это\n"
"могут быть название процедуры или другая соответствующая информация, "
"например\n"
"подсказки отладки."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:744
msgid ""
"@deffn {Scheme Procedure} procedure-name proc\n"
"@deffnx {C Function} scm_procedure_name (proc)\n"
"Return the name of the procedure @var{proc}\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} procedure-name proc\n"
"@deffnx {C Function} scm_procedure_name (proc)\n"
"Возвращает имя процедуры @var{proc}\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:750
msgid ""
"@deffn {Scheme Procedure} procedure-source proc\n"
"@deffnx {C Function} scm_procedure_source (proc)\n"
"Return the source of the procedure @var{proc}. Returns @code{#f} if\n"
"the source code is not available.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} procedure-source proc\n"
"@deffnx {C Function} scm_procedure_source (proc)\n"
"Возвращает исходный код процедуры @var{proc}. Возвращает  @code{#f} если\n"
"исходный код недоступен.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:756
msgid ""
"@deffn {Scheme Procedure} procedure-properties proc\n"
"@deffnx {C Function} scm_procedure_properties (proc)\n"
"Return the properties associated with @var{proc}, as an association\n"
"list.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} procedure-properties proc\n"
"@deffnx {C Function} scm_procedure_properties (proc)\n"
"Возвращает свойства связанные с процедурой @var{proc}, как ассоциативный\n"
"список.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:761
msgid ""
"@deffn {Scheme Procedure} procedure-property proc key\n"
"@deffnx {C Function} scm_procedure_property (proc, key)\n"
"Return the property of @var{proc} with name @var{key}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} procedure-property proc key\n"
"@deffnx {C Function} scm_procedure_property (proc, key)\n"
"Возвращает свойство процедуры @var{proc} с именем @var{key}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:766
msgid ""
"@deffn {Scheme Procedure} set-procedure-properties! proc alist\n"
"@deffnx {C Function} scm_set_procedure_properties_x (proc, alist)\n"
"Set @var{proc}'s property list to @var{alist}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} set-procedure-properties! proc alist\n"
"@deffnx {C Function} scm_set_procedure_properties_x (proc, alist)\n"
"Устанавливает список свойств @var{proc} указанным ассоциативным\n"
"списком @var{alist}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:772
msgid ""
"@deffn {Scheme Procedure} set-procedure-property! proc key value\n"
"@deffnx {C Function} scm_set_procedure_property_x (proc, key, value)\n"
"In @var{proc}'s property list, set the property named @var{key} to\n"
"@var{value}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} set-procedure-property! proc key value\n"
"@deffnx {C Function} scm_set_procedure_property_x (proc, key, value)\n"
"В списке свойств @var{proc}, устанавливает свойство с именем @var{key} в\n"
"значение @var{value}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:776
msgid ""
"@cindex procedure documentation\n"
"Documentation for a procedure can be accessed with the procedure\n"
"@code{procedure-documentation}."
msgstr ""
"@cindex procedure documentation\n"
"Документацию для процедуры можно получить с помощью процедуры\n"
"@code{procedure-documentation}."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:784
msgid ""
"@deffn {Scheme Procedure} procedure-documentation proc\n"
"@deffnx {C Function} scm_procedure_documentation (proc)\n"
"Return the documentation string associated with @code{proc}.  By\n"
"convention, if a procedure contains more than one expression and the\n"
"first expression is a string constant, that string is assumed to contain\n"
"documentation for that procedure.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} procedure-documentation proc\n"
"@deffnx {C Function} scm_procedure_documentation (proc)\n"
"Возвращает строку документации, связанную с @code{proc}.  По соглашению,\n"
"если процедура содержит более одного выражения, а первое выражение является\n"
"строковой константой, предполагается, что эта строка содержит документацию\n"
"для этой процедуры.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:788
msgid ""
"@node Procedures with Setters\n"
"@subsection Procedures with Setters"
msgstr ""
"@node Procedures with Setters\n"
"@subsection Процедуры с установщиками"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:790
msgid "@c FIXME::martin: Review me!"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:792
msgid "@c FIXME::martin: Document `operator struct'."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:800
msgid ""
"@cindex procedure with setter\n"
"@cindex setter\n"
"A @dfn{procedure with setter} is a special kind of procedure which\n"
"normally behaves like any accessor procedure, that is a procedure which\n"
"accesses a data structure.  The difference is that this kind of\n"
"procedure has a so-called @dfn{setter} attached, which is a procedure\n"
"for storing something into a data structure."
msgstr ""
"@cindex procedure with setter\n"
"@cindex setter\n"
"Процедура с установщиком(@dfn{procedure with setter}) это особый вид "
"процедуры,\n"
"которая обычно ведет себя как любая процедура доступа, которая является "
"процедурой\n"
"обращающейся к структуре данных. Разница состоит в том, что эта процедура "
"имеет\n"
"так называемый установщик(@dfn{setter}), который является процедурой для "
"сохранения\n"
"чего-либо в структуру данных."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:804
msgid ""
"Procedures with setters are treated specially when the procedure appears\n"
"in the special form @code{set!} (REFFIXME).  How it works is best shown\n"
"by example."
msgstr ""
"Процедуры с установщиком обрабатываются специально, когда процедура "
"появляется\n"
"в специальной форме @code{set!} (REFFIXME).  Как это работает, лучше всего "
"показано\n"
"на примере."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:816
msgid ""
"Suppose we have a procedure called @code{foo-ref}, which accepts two\n"
"arguments, a value of type @code{foo} and an integer.  The procedure\n"
"returns the value stored at the given index in the @code{foo} object.\n"
"Let @code{f} be a variable containing such a @code{foo} data\n"
"structure.@footnote{Working definitions would be:\n"
"@lisp\n"
"(define foo-ref vector-ref)\n"
"(define foo-set! vector-set!)\n"
"(define f (make-vector 2 #f))\n"
"@end lisp\n"
"}"
msgstr ""
"Предположим, что у нас есть процедура, называемая @code{foo-ref}, которая\n"
"принимает два аргумента, значение типа @code{foo} и целое число. Процедура\n"
"возвращает значение сохраненное в указанном индексе объекта @code{foo}.\n"
"Пусть @code{f} переменная содержащая такую структуру данных @code{foo}.\n"
"@footnote{Рабочее определение должно быть таким:\n"
"@lisp\n"
"(define foo-ref vector-ref)\n"
"(define foo-set! vector-set!)\n"
"(define f (make-vector 2 #f))\n"
"@end lisp\n"
"}"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:821
msgid ""
"@lisp\n"
"(foo-ref f 0)       @result{} bar\n"
"(foo-ref f 1)       @result{} braz\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:824
msgid ""
"Also suppose that a corresponding setter procedure called\n"
"@code{foo-set!} does exist."
msgstr ""
"Также предположим, что соответствующая процедура установщик\n"
"@code{foo-set!} существует."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:829
msgid ""
"@lisp\n"
"(foo-set! f 0 'bla)\n"
"(foo-ref f 0)       @result{} bla\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:834
msgid ""
"Now we could create a new procedure called @code{foo}, which is a\n"
"procedure with setter, by calling @code{make-procedure-with-setter} with\n"
"the accessor and setter procedures @code{foo-ref} and @code{foo-set!}.\n"
"Let us call this new procedure @code{foo}."
msgstr ""
"Теперь мы можем создать новую процедуру, называемую @code{foo}, которая\n"
"является процедурой с установщиком, вызывав @code{make-procedure-with-"
"setter}\n"
"с процедурами доступа и устновки @code{foo-ref} и @code{foo-set!}.\n"
"Назовем эту новую процедуру @code{foo}."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:838
msgid ""
"@lisp\n"
"(define foo (make-procedure-with-setter foo-ref foo-set!))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:841
msgid ""
"@code{foo} can from now on be used to either read from the data\n"
"structure stored in @code{f}, or to write into the structure."
msgstr ""
"Теперь @code{foo} может использоваться для чтения из структуры данных,\n"
"хранящейся в @code{f}, или для записи в эту структуру."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:846
msgid ""
"@lisp\n"
"(set! (foo f 0) 'dum)\n"
"(foo f 0)          @result{} dum\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:852
msgid ""
"@deffn {Scheme Procedure} make-procedure-with-setter procedure setter\n"
"@deffnx {C Function} scm_make_procedure_with_setter (procedure, setter)\n"
"Create a new procedure which behaves like @var{procedure}, but\n"
"with the associated setter @var{setter}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} make-procedure-with-setter procedure setter\n"
"@deffnx {C Function} scm_make_procedure_with_setter (procedure, setter)\n"
"Создает новую процедуру, которая ведет себя как процедура(@var{procedure}),\n"
"но с соответствующим установщиком @var{setter}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:858
msgid ""
"@deffn {Scheme Procedure} procedure-with-setter? obj\n"
"@deffnx {C Function} scm_procedure_with_setter_p (obj)\n"
"Return @code{#t} if @var{obj} is a procedure with an\n"
"associated setter procedure.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} procedure-with-setter? obj\n"
"@deffnx {C Function} scm_procedure_with_setter_p (obj)\n"
"Возвращает @code{#t} если @var{obj} это процедура связана с\n"
"процедурой устнановщика.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:864
msgid ""
"@deffn {Scheme Procedure} procedure proc\n"
"@deffnx {C Function} scm_procedure (proc)\n"
"Return the procedure of @var{proc}, which must be an\n"
"applicable struct.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} procedure proc\n"
"@deffnx {C Function} scm_procedure (proc)\n"
"Возвращает процедуру @var{proc}, которая должна быть применяемой\n"
"структурой.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:869
msgid ""
"@deffn {Scheme Procedure} setter proc\n"
"Return the setter of @var{proc}, which must be either a procedure with\n"
"setter or an operator struct.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} setter proc\n"
"Возвращает установщик @var{proc}, который должне быть либо процедурой с \n"
"установщиком, либо оператором структуры.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:872
msgid ""
"@node Inlinable Procedures\n"
"@subsection Inlinable Procedures"
msgstr ""
"@node Inlinable Procedures\n"
"@subsection Встраиваемые Процедуры"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:879
msgid ""
"@cindex inlining\n"
"@cindex procedure inlining\n"
"You can define an @dfn{inlinable procedure} by using\n"
"@code{define-inlinable} instead of @code{define}.  An inlinable\n"
"procedure behaves the same as a regular procedure, but direct calls will\n"
"result in the procedure body being inlined into the caller."
msgstr ""
"@cindex inlining\n"
"@cindex procedure inlining\n"
"Вы можете определить Встраиваемую Процедуру(@dfn{inlinable procedure})\n"
"используя @code{define-inlinable}, а не @code{define}.  Встраиваемая\n"
"процедура ведет себя так же, как и в обычная процедура, но прямые вызовы\n"
"приводят к тому что тело процедуры вставляется в вызывающую процедуру."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:884
msgid ""
"@cindex partial evaluator\n"
"Bear in mind that starting from version 2.0.3, Guile has a partial\n"
"evaluator that can inline the body of inner procedures when deemed\n"
"appropriate:"
msgstr ""
"@cindex partial evaluator\n"
"Имейте в виду, что начиная с версии 2.0.3 у Guile есть частичный\n"
"оценщик, который может вставить тело внутренних процедур, если \n"
"сочтет это целесообразным."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:892
msgid ""
"@example\n"
"scheme@@(guile-user)> ,optimize (define (foo x)\n"
"                                 (define (bar) (+ x 3))\n"
"                                 (* (bar) 2))\n"
"$1 = (define foo\n"
"       (lambda (#@{x 94@}#) (* (+ #@{x 94@}# 3) 2)))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:897
msgid ""
"@noindent\n"
"The partial evaluator does not inline top-level bindings, though, so\n"
"this is a situation where you may find it interesting to use\n"
"@code{define-inlinable}."
msgstr ""
"@noindent\n"
"Частичный оценщик не устанавиливает привязки верхнего уровня, однако, "
"бывают\n"
"ситуации в которых вам может быть интересно будет использовать\n"
"@code{define-inlinable}."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:906
msgid ""
"Procedures defined with @code{define-inlinable} are @emph{always}\n"
"inlined, at all direct call sites.  This eliminates function call\n"
"overhead at the expense of an increase in code size.  Additionally, the\n"
"caller will not transparently use the new definition if the inline\n"
"procedure is redefined.  It is not possible to trace an inlined\n"
"procedures or install a breakpoint in it (@pxref{Traps}).  For these\n"
"reasons, you should not make a procedure inlinable unless it\n"
"demonstrably improves performance in a crucial way."
msgstr ""
"Процедуры, определяемые с помощью @code{define-inlinable} всегда\n"
"@emph{всегда} встраиваются, во всех местах где они вызываются на прямую.\n"
"Это устраняет накладные расходы функций за счет увеличения расзмера\n"
"кода. Дополнительно, вызывающий не будет использовать новое определение,\n"
"если встроенная процедура переопределяется. Невозможно трассировать\n"
"встроенные процедуры или установить в них точку останова (@pxref{Traps}).\n"
"По этим причинам, вы должны делать встроенную процедуру, когда это явно\n"
"улучшает производительность в критических местах."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:911
msgid ""
"In general, only small procedures should be considered for inlining, as\n"
"making large procedures inlinable will probably result in an increase in\n"
"code size.  Additionally, the elimination of the call overhead rarely\n"
"matters for large procedures."
msgstr ""
"В целом, только небольшие процедуры следует рассматривать для встраивания,\n"
"поскольку большие встраиваемые процедуры приведут к увеличению размера "
"кода.\n"
"Кроме того, устранение издержек вызова редко имеет значение для крупных \n"
"процедур."

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:916
msgid ""
"@deffn {Scheme Syntax} define-inlinable (name parameter @dots{}) body1 body2 "
"@dots{}\n"
"Define @var{name} as a procedure with parameters @var{parameter}s and\n"
"bodies @var{body1}, @var{body2}, @enddots{}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Syntax} define-inlinable (name parameter @dots{}) body1 body2 "
"@dots{}\n"
"Определяет процедуру с именем @var{name} с параметрами @var{parameter} и "
"телами\n"
"@var{body1}, @var{body2}, @enddots{}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-procedures.texi:919
msgid ""
"@c Local Variables:\n"
"@c TeX-master: \"guile.texi\"\n"
"@c End:"
msgstr ""
