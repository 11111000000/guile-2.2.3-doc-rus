@c -*-texinfo-*-
@c This is part of the GNU Guile Reference Manual.
@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2011, 2012, 2013, 2014
@c   Free Software Foundation, Inc.
@c See the file guile.texi for copying conditions.

@node Utility Functions
@section Общие Утилиты(Служебные Функции)

@c FIXME::martin: Review me!

Эта глава содержит информацию о процедурах, которые н привязаны к конкретному
типу данных. Из-за широкого спектра их приложений, они собраны в главу Утилиты
(@dfn{utility}).

@menu
* Equality::                    When are two values `the same'?
* Object Properties::           A modern interface to object properties.
* Sorting::                     Sort utility procedures.
* Copying::                     Copying deep structures.
* General Conversion::          Converting objects to strings.
* Hooks::                       User-customizable event lists.
@end menu

@node Equality
@subsection Равенство
@cindex sameness
@cindex equality

В Scheme есть три типа основных предикатов равенства, описанных ниже.
Такие же виды сравнений возникают в других функциях, таких как
@code{memq} и ее друзьях (@pxref{List Searching}).

Для всех трех проверок, объекты разных типов никогда не бывают равными.
Так, например экземпляр списка и вектора не равны (not @code{equal?}),
даже если их содержимое одинаково. Точные и не точные числа также
рассмотриваются как различные типы, и следовательно они не равны, даже
если их значения одинаковы.

@code{eq?} просто проверяет является ли объект тем же самым (по сути, это
сравнение указателей).  Это быстро, и может использоваться при поиске
определенного объекта или при работе с символами или ключевыми словами
(которые всегда являются уникальными объектами).

@code{eqv?} расширеят @code{eq?} и смотрит на значение чисел и символьных
знаков.  Это может быть использовано для экземплякров подобно @code{=}
(@pxref{Comparison}) но без ошибки, если операнд не является числом.

@code{equal?} идет дальше, он просматривает (рекурсивно) содержимое
списков, векторов и т.д.  Это хорошо, например, для экземпляров списков,
которые были прочитаны или вычислены в разных местах и являются теми же
самыми, только не состоят из одних и тех же пар.  Такие списки выглядят
одинаково(когда их печатают) и @code{equal?} будет считать их равными.

@sp 1
@deffn {Scheme Procedure} eq? x y
@deffnx {C Function} scm_eq_p (x, y)
@rnindex eq?
Возвращает @code{#t} если @var{x} и @var{y} один и тот же объект, за
исключением цифр и символьных знаков. Например,

@example
(define x (vector 1 2 3))
(define y (vector 1 2 3))

(eq? x x)  @result{} #t
(eq? x y)  @result{} #f
@end example

Числа и символьные знаки не равны никаким другим объектам, но проблема в том,
что они не обязательно равны @code{eq?} самим себе.
Это так, даже когда приходит число прямо из переменной.

@example
(let ((n (+ 2 3)))
  (eq? n n))       @result{} *unspecified*
@end example

Вообще @code{eqv?} описанное ниже, следует использовать при сравнении чисел
или символьных знаков.  @code{=} (@pxref{Comparison}) or @code{char=?}
(@pxref{Characters}) тоже может быть спользовано.

Стоит отметить, что конец списка @code{()}, @code{#t}, @code{#f}, символ
данного имени, и ключевое слово данного имени, являются уникальными
объектами.  Для каждого экземпляра это один и тот же объект. Не зависимо от
того, как @code{()} возникает в программе, это один и тот же объект и его 
можно сравнивать используя @code{eq?},

@example
(define x (cdr '(123)))
(define y (cdr '(456)))
(eq? x y) @result{} #t

(define x (string->symbol "foo"))
(eq? x 'foo) @result{} #t
@end example
@end deffn

@deftypefn {C Function} int scm_is_eq (SCM x, SCM y)
Возвращает @code{1} когда @var{x} и @var{y} являются эквивалентными в
смысле @code{eq?}, иначе возвращает @code{0}.

@findex ==
Оператор @code{==} не должен использоваться для значений @code{SCM},
@code{SCM} это тип данных си который нельзя непосредственно сравнивать
исползуя @code{==} (@pxref{The SCM Type}).
@end deftypefn

@sp 1
@deffn {Scheme Procedure} eqv? x y
@deffnx {C Function} scm_eqv_p (x, y)
@rnindex eqv?
Возвращает @code{#t} если @var{x} и @var{y} это один и тот же объект или
для символьных знаков и чисел имеющих одно и тоже значение.

На объекты, за исключением символьных знаков и чисел, @code{eqv?} 
действует так же как @code{eq?} выше, сравнение даст истину если 
@var{x} и @var{y} являются одним и темже объектом.

Если @var{x} и @var{y} являются числами или символьными знаками, @code{eqv?} 
сравнивает их тип и значение. Точные числа не будут равны @code{eqv?} не точным
числам(даже если их значения одинаковы).

@example
(eqv? 3 (+ 1 2)) @result{} #t
(eqv? 1 1.0)     @result{} #f
@end example
@end deffn

@sp 1
@deffn {Scheme Procedure} equal? x y
@deffnx {C Function} scm_equal_p (x, y)
@rnindex equal?
возвращает @code{#t} если @var{x} и @var{y} одинакового типа и их содержимое
или значение являются равным.

Для пар, строк, векторов, массивов или структур, @code{equal?} сравнивает их
содержимое, и делает так используя  @code{equal?} рекурсивно,
поэтому может быть пройдена структура произвольной глубины.

@example
(equal? (list 1 2 3) (list 1 2 3))   @result{} #t
(equal? (list 1 2 3) (vector 1 2 3)) @result{} #f
@end example

Для других объектов, @code{equal?} сравнивает как @code{eqv?} выше,
что означает что символьные знакии числа сравниваются по типу и значению
(как в @code{eqv?}, точные и неточные числа не равны - not @code{equal?},
даже если их значения одинаковы).

@example
(equal? 3 (+ 1 2)) @result{} #t
(equal? 1 1.0)     @result{} #f
@end example

Хеш-таблицы в настоящее время сравниваются только в соответствии с @code{eq?},
поэтому длв разные таблицы не равны(not @code{equal?}), даже если их содержимое
одно и тоже.

@code{equal?} не поддерживает циклические структуры данных, он может
зациклиться, если попросить сравинить два циклическвих списка или
аналогичные структуры.

Типы объектов GOOPS (@pxref{GOOPS}), влючая типы внешних объектов
(@pxref{Defining New Foreign Object Types}), могут иметь специальную
реализацию @code{equal?} для сравнения двух значений одного типа.
Если @code{equal?} вызван для двух объектов GOOPS одинакового типа,
@code{equal?} отправит вызов на обобщенную функцию.  Это позволяет
приложению просматривать содержимое или контролировать то, что считается
равным @code{equal?} для двух объектов одинакового типа. Если такого
обработчика нет, по умолчанию просто сравнивается как @code{eq?}.
@end deffn

@node Object Properties
@subsection Object Properties

IЧасто полезно связать часть дополнительной информации с объектом 
Scheme даже когда объект не имеет выделенного слота, в котором
дополнительная информация может быть сохранена.  Свойства объекта
позволяют вам сделать это.

В Guile представлении свойства объекта является процедурой с установщиком
(@pxref{Procedures with Setters}) которую можно использовать  с обобщенной
формой @code{set!} (REFFIXME) чтобы установить и получить свойство для
любого объекта Scheme.  Итак, установка свойств выглядит так:

@lisp
(set! (my-property obj1) value-for-obj1)
(set! (my-property obj2) value-for-obj2)
@end lisp

@noindent
и получение значения одного и того же свойства выглядит следующим
образом:

@lisp
(my-property obj1)
@result{}
value-for-obj1

(my-property obj2)
@result{}
value-for-obj2
@end lisp

Чтобы создать свойство объекта в первую очередь используйте
процедуру @code{make-object-property}:

@lisp
(define my-property (make-object-property))
@end lisp

@deffn {Scheme Procedure} make-object-property
Создает и возвращает свойство объекта.  Свойство объекта является
процедурой с установщиком(procedure-with-setter) котороую можно вызвать
двумя способами.  @code{(set! (@var{property} @var{obj}) @var{val})} 
устанавлилвает свойство  @var{property} объекта @var{obj} в значение  
@var{val}.  @code{(@var{property} @var{obj})} возвращает текущее
значение свойства @var{property} объекта @var{obj} .
@end deffn

Одно свойство объекта созданное с помощью @code{make-object-property}
может связать отдельное свойство значения со всеми значениями Scheme
которые различаются по @code{eq?} (исключая числовые значения).

Внутренне, свойства объекта реализуются с использованием хеш-таблицы слабых
ключей.  Это означает, что пока значение Scheme связанное со значениями свойств
защищены от сборки мусора, значение его свойства также защищены.
Когда значение Scheme собирается сборщиком мусора, его запись в таблице
свойств удаляется и поэтому значение экс-свойства больше не защищено
таблицей.

Guile также реализует более традиционный списковый интерфейс поддерживающий
свойства, в котором каждый объект имеет список пар ключ - значение, связанный
с ним. Свойства в этом списке обозначены символами. Это устаревший интерфейс;
Вы должны использовать слабые хеш-таблицы или свойства объектов вместо него.

@deffn {Scheme Procedure} object-properties obj
@deffnx {C Function} scm_object_properties (obj)
Возвращает список свойств @var{obj}.
@end deffn

@deffn {Scheme Procedure} set-object-properties! obj alist
@deffnx {C Function} scm_set_object_properties_x (obj, alist)
Устанавливает список свойств объекта @var{obj} в @var{alist}.
@end deffn

@deffn {Scheme Procedure} object-property obj key
@deffnx {C Function} scm_object_property (obj, key)
Возвращает свойство объекта @var{obj} с именем @var{key}.
@end deffn

@deffn {Scheme Procedure} set-object-property! obj key value
@deffnx {C Function} scm_set_object_property_x (obj, key, value)
В списке свойств объекта @var{obj} устанавливает свойство с именем @var{key}
в значение @var{value}.
@end deffn

@node Sorting
@subsection Сортировка

@c FIXME::martin: Review me!

@cindex sorting
@cindex sorting lists
@cindex sorting vectors

Сортировка очень важна в компьютерных программах.  Таким образом, Guile 
поставляется с несколькими встроенными процедурами сортировки. Как всегда,
процедуры заканчивающиеся знаком @code{!} имеют побочные эффекты, это означает
что они могут изменять свои параметры для получения результатов.

Первая группа процедур может использоваться для объединения двух списков
(которые должны быть уже отсортированы самостоятельно) и создает
отсортированные списки содержащие все элементы входных списков.

@deffn {Scheme Procedure} merge alist blist less
@deffnx {C Function} scm_merge (alist, blist, less)
Объединяет два уже отсортированных списка в один.
Предоставляются два списка @var{alist} и @var{blist}, такие как
@code{(sorted? alist less?)} и @code{(sorted? blist less?)},
возвращается новый список состоящий из элементов @var{alist} и 
@var{blist} чередующихся так чтобы остаться отсортированными
@code{(sorted? (merge alist blist less?) less?)}.
Примечание:  функция не принимает векторы!
@end deffn

@deffn {Scheme Procedure} merge! alist blist less
@deffnx {C Function} scm_merge_x (alist, blist, less)
Принимает два уже отсортированных списка @var{alist} и @var{blist},
такие как @code{(sorted? alist less?)} и @code{(sorted? blist less?)},
возвращается новый список состоящий из элементов @var{alist} и 
@var{blist} чередующихся так чтобы остаться отсортированными
@code{(sorted? (merge alist blist less?) less?)}. Это деструктивный
вариант слияния.
Примечание:  функция не принимает векторы!
@end deffn

Следующие процедуры могут работать с последовательностями, которые являются
векторами или списками. Согласно предоставленным аргументам, онги возвращают
отсортированные вектора или списки, соответственно. Первая из следующих процедур
определяет, отсортирована ли последовательность, другая сортирует заданную
последовательность. Варианты с именами, начинающимися с @code{stable-}, отличаются
тем, что они поддерживают специальное свойство входных последовательностей: если два
или более элемента являются уже соответствующими предикату сравнения,  они остаются
в том же порядке, в котором они появились на входе.

@deffn {Scheme Procedure} sorted? items less
@deffnx {C Function} scm_sorted_p (items, less)
Возвращает @code{#t} если @var{items} является списком или вектором
таким, что для каждого элемента @var{x} и следующего элемента @var{y}
из @var{items}, функция @code{(@var{less} @var{y} @var{x})} возвращает
@code{#f}.  В противном случае возвращает @code{#f}.
@end deffn

@deffn {Scheme Procedure} sort items less
@deffnx {C Function} scm_sort (items, less)
Сортирует элементы последовательности @var{items}, которые могут
быть списком или вектором. Процедура @var{less} исползуется для
сравнения элементов последовательности. Это не стабильная сортировка.
@end deffn

@deffn {Scheme Procedure} sort! items less
@deffnx {C Function} scm_sort_x (items, less)
Сортирует элементы последовательности @var{items}, которые могут
быть списком или вектором. Процедура @var{less} исползуется для
сравнения элементов последовательности. Это деструктивная сортировка,
это означает, что входная последовательность модифицируется для 
получения отсортированного результата.
Это не стабильная сортировка.
@end deffn

@deffn {Scheme Procedure} stable-sort items less
@deffnx {C Function} scm_stable_sort (items, less)
Сортирует последовательность @var{items}, которая может быть списком
или вектором. @var{less} используется для сравнения элементов 
последовательности. Это стабильная сортировка.
@end deffn

@deffn {Scheme Procedure} stable-sort! items less
@deffnx {C Function} scm_stable_sort_x (items, less)
Сортирует последовательность @var{items}, которая может быть списком
или вектором. @var{less} используется для сравнения элементов 
последовательности. Это деструктивная сортировка, это означает, 
что входная последовательность модифицируется для 
получения отсортированного результата.
Это стабильная сортировка.
@end deffn

Процедуры в последней группе принимают в качестве входных данных только списки
или векторы, на что укзаывают их имена.

@deffn {Scheme Procedure} sort-list items less
@deffnx {C Function} scm_sort_list (items, less)
Сортирует список @var{items}, используя @var{less} для сравнения
элементов списка. Это стабильная сортировка.
@end deffn

@deffn {Scheme Procedure} sort-list! items less
@deffnx {C Function} scm_sort_list_x (items, less)
Сортирует список @var{items}, используя @var{less} для сравнения
элементов списка. Это деструктивная сортировка, это означает, 
что входной список модифицируется для получения отсортированного 
результата. Это стабильная сортировка.
@end deffn

@deffn {Scheme Procedure} restricted-vector-sort! vec less startpos endpos
@deffnx {C Function} scm_restricted_vector_sort_x (vec, less, startpos, endpos)
Сортирует вектор @var{vec}, исползуя @var{less} для сравнения элементов
вектора.  @var{startpos} (включая) и @var{endpos} (исключая) разграничивают
диапазон вектора, который сортируется. Возвращаемое значение не определено.
@end deffn

@node Copying
@subsection Копирования Глубоких Структур

@c FIXME::martin: Review me!

Процедуры копирования списков (@pxref{Lists}) дают только поверхнустную
копию входного списка, и в настоящее время Guile даже не содержит процедур
для копирования векторов.  @code{copy-tree} может быть использована для
глубинного копирования, так как она не только копирует верхнуюю структуру 
списка, но также копирует любые пары во входных списках.

@deffn {Scheme Procedure} copy-tree obj
@deffnx {C Function} scm_copy_tree (obj)
Рекурсивно копирует дерево данных, которое связано с @var{obj}, и возвращает
новую структуру данных.  @code{copy-tree} рекурсивно просматривает содержимое
как пар, таки векторов (так как обе ячейки cons и векторные ячейки могут
указывать на произвольные объекты), и останавливает повторение при попадании
в любой другой объект.
@end deffn

@node General Conversion
@subsection Общее преобразование в Строки

@c FIXME::martin: Review me!

При отладке программ Scheme, а также для обеспечения удобного для пользователя
интерфейса, процедура препобразования произвольного объекта Scheme в формат 
строки очень полезна.  Преобразование из/в строки конечно может быть выполнено
с помощью специальных процедур, когда тип данных объекта предназначенного для
преобразования известен, но этой процедурой очень часто гораздо удобнее пользоваться.

@code{object->string} преобразует объект, используя процедуру печати для
записи строки в порт, и возвращает результирующую строку.
Преобразование в объект обратно из строки возможно только в том случае, если
тип объекта имеет синтаксис чтения, и синтаксис чтения сохраняется процедурой
печати.

@deffn {Scheme Procedure} object->string obj [printer]
@deffnx {C Function} scm_object_to_string (obj, printer)
Возвращает строку Scheme, полученную при печати @var{obj}.
Функция печати может быть указана необязательным вторым
аргументом @var{printer} (по умолчанию: @code{write}).
@end deffn

@node Hooks
@subsection Хуки(К(Х)рюки, ;-) Крючки, Зацепки)
@tpindex Hooks

Хук это список процедур, которые должны вызваться в четко определенные
моменты времени. Как правило, приложение предоставляет хук @var{h} и
обещате своим пользователям, что оно вызвовет все процедуры из @var{h} 
в определенный момент времени при выполнении приложения.  Добавляя свою
сообственную процедуру к @var{h}, пользователь приложения может подключиться
или даже повлиять на ход выполнения приложения.

Сам Guile предоставляет несколько таких хуков для отладки и настройки:
они перечислены в подразделе ниже.

Когда приложение впервые создает хук, оно должно знать, сколько аргументов
будет передаваться процедурам из хука, когда хук будет запускаться.
Выбранное количество аргументов (которых может и не быть) объявляется при
создании хука, и все процедуры, которые добавляются к этому хуку должны быть
способны принимать такое количество аргументов.

Хук создается с помощью @code{make-hook}.  Процедура может быть добавлена
или удалена из хука использованием @code{add-hook!} или @code{remove-hook!},
и все процедуры хука можно удалить используя @code{reset-hook!}.  Когда 
приложению необходимо запустить хук, оно делает это используя @code{run-hook}.

@menu
* Hook Example::                Hook usage by example.
* Hook Reference::              Reference of all hook procedures.
* C Hooks::                     Hooks for use from C code.
* GC Hooks::                    Garbage collection hooks.
* REPL Hooks::                  Hooks into the Guile REPL.
@end menu

@node Hook Example
@subsubsection Пример Использования Хука

Использование хуков показано на нескольких примерах в этом разделе. Сначала
мы определяем хук арности(размерности) 2 --- т.е. процедуры хранящиеся в хуке
должны будут принимать два аргумента.

@lisp
(define hook (make-hook 2))
hook
@result{} #<hook 2 40286c90>
@end lisp

Теперь мы готовы добавить несколько процедур к вновь созданному хуку с 
помощью @code{add-hook!}.  В следующем примере добавлены две процедуры,
которые печатают разные сообщения и делают разные вещи со своими 
аргументами.

@lisp
(add-hook! hook (lambda (x y)
                    (display "Foo: ")
                    (display (+ x y))
                    (newline)))
(add-hook! hook (lambda (x y)
                    (display "Bar: ")
                    (display (* x y))
                    (newline)))
@end lisp

Как только процедуры были добавлены, мы можем вызвать хук используя
@code{run-hook}.

@lisp
(run-hook hook 3 4)
@print{} Bar: 12
@print{} Foo: 7
@end lisp

Обратите внимание, что процедуры вызываются в обратном порядке, в котором
они были добавлены.  Это потому, что стандартным поведением функции
@code{add-hook!} является добавление процедуры в начало(@emph{front})
списка процедур хука.  Вы можете заставить @code{add-hook!} добавить вашу
процедуру в конец (@emph{end}) списка, предоставив третий аргумент равный
@code{#t} во втором вызове @code{add-hook!}.

@lisp
(add-hook! hook (lambda (x y)
                    (display "Foo: ")
                    (display (+ x y))
                    (newline)))
(add-hook! hook (lambda (x y)
                    (display "Bar: ")
                    (display (* x y))
                    (newline))
                    #t)             ; @r{<- Change here!}

(run-hook hook 3 4)
@print{} Foo: 7
@print{} Bar: 12
@end lisp

@node Hook Reference
@subsubsection Ссылка на Хук

Когда вы создаете хук с помощью @code{make-hook}, вы можете указать арность
(размерность) процедур, которые можно добавить к хуку. Если арность не указана
в качестве аргумента @code{make-hook}, по умолчанию она будет равно нулю.
Все процедуры данного хука должны быть одинаковой арности, и когда процедуры
вызываются с использованием @code{run-hook}, количество передаваемых аргументов
должно соответствовать арности указанной во время создания хука.

Порядок в котором процедуры добавляются к хуку имеет значение.  Если третий
параметр @code{add-hook!} пропущен или равен @code{#f}, процедура добавляется
перед процедурами которые уже были  добавлены к хуку, в противном случае
процедура добавляется в конец. Процедуры всегда вызываются с начала и до конца
списка, когда они вызываются через @code{run-hook}.

Порядок процедур в списке, возвращаемый @code{hook->list} соответствует
порядку в котором эти процедуры будут вызваны, если хук будет запущен
с использованием @code{run-hook}.

Обратите внимание, что функции Си в следующих записях предназначены для
обработки хуков уровня схемы(@dfn{Scheme-level}) на Си.  Существуют также 
хуки уровня Си(@dfn{C-level}) которые имеют собственный интерфейс (@pxref{C Hooks}).

@deffn {Scheme Procedure} make-hook [n_args]
@deffnx {C Function} scm_make_hook (n_args)
Создает хук для хранения процедур размерности(арности) @var{n_args}.
@var{n_args} по умолчанию равен нулю.  Возвращаемое значение является
объектом хуком, который будет использоваться с другими процедурами
хука.
@end deffn

@deffn {Scheme Procedure} hook? x
@deffnx {C Function} scm_hook_p (x)
Возвращает @code{#t} если @var{x} это хук, @code{#f} иначе.
@end deffn

@deffn {Scheme Procedure} hook-empty? hook
@deffnx {C Function} scm_hook_empty_p (hook)
Возвращает @code{#t} если @var{hook} это пустой хук, @code{#f}
иначе.
@end deffn

@deffn {Scheme Procedure} add-hook! hook proc [append_p]
@deffnx {C Function} scm_add_hook_x (hook, proc, append_p)
Добавляет процедуру @var{proc} к хуку @var{hook}. Процедура
добавляется в конец если @var{append_p} равен истине,
иначе она добавляется в начало. Возвращаемое значение этой
процедурой не указано.
@end deffn

@deffn {Scheme Procedure} remove-hook! hook proc
@deffnx {C Function} scm_remove_hook_x (hook, proc)
Удаляет процедуру @var{proc} из хука @var{hook}.  Возвращаемое
значение этой процедурой не указано.
@end deffn

@deffn {Scheme Procedure} reset-hook! hook
@deffnx {C Function} scm_reset_hook_x (hook)
Удаляет все процедуры из хука @var{hook}.  Возвращаемое
этой процедурой значение не указано.
@end deffn

@deffn {Scheme Procedure} hook->list hook
@deffnx {C Function} scm_hook_to_list (hook)
Преобразует список процедур хука @var{hook} в список.
@end deffn

@deffn {Scheme Procedure} run-hook hook arg @dots{}
@deffnx {C Function} scm_run_hook (hook, args)
Применяет все процедуры из хука @var{hook} к аргументам @var{arg}
@enddots{}.  Порядок применения процедур от первого к последнему.
Возвращаемое этой процедурой значение не указано.
@end deffn

Если , в коде Сиe, вы уверены что есть объект хук и правильно сформированный
список аргументов для хука, вы можете также использовать
@code{scm_c_run_hook}, который идентичен to @code{scm_run_hook} но не 
проверяет типы.

@deftypefn {C Function} void scm_c_run_hook (SCM hook, SCM args)
То же, что и @code{scm_run_hook} но без проверки типа для подтверждения
того что @var{hook} на самом деле является хук объектом и  этот @var{args}
представляет собой правильно сформированный список соответствующей арности
хука.
@end deftypefn

Для Си кода @code{SCM_HOOKP} более быстрая альтернатива
@code{scm_hook_p}:

@deftypefn {C Macro} int SCM_HOOKP (x)
Возвращает 1 если @var{x} это хук уровня Схемы(Scheme-level), иначе 0.
@end deftypefn

@node C Hooks
@subsubsection Хуки для Си кода.

Уже описанные хуки предназначены для исполнения процедур на уровне Схемы
(Scheme-level). В дополнении к ним, библиотека Guile предоставляет назависимый
набор интерфейсов для создания и манипулирования хуками, которые предназначены
для заполнения функциями, реализоованными на Си.

Первоначальная мотивация здесь заключается в том, чтобы обеспечить совего
рода хук, который можно было бы безопасно использовать в разные моменты
во время сборки мусора. Хуки уровня Схемы(Scheme-level) для этого не 
подходят, цель их запуска сама по себе может потребовать выделения памяти,
что приведет к вызову сборщика мусора рекурсивно @dots{}  Тем не менее,
это также тот случай, когда эти хуки легче работают с уровнем Схемы
(Scheme-level), если вы хотите зарегистрировать только функции Си.
Так что если это в основном то, что должен делать ваш код,
вы можете предпочесть использовать этот интерфейс.

Для создания Си хука, вы должны выделить хранилище для структуры типа
@code{scm_t_c_hook} и инициализировать ее используя @code{scm_c_hook_init}.

@deftp {C Type} scm_t_c_hook
Тип данных для Си хука. Внутреннее устройство этого типа должно рассматриваться
кака не прозрачное, не видимое.
@end deftp

@deftp {C Enum} scm_t_c_hook_type
Перечисление возможных типов хуков, как то:

@table @code
@item SCM_C_HOOK_NORMAL
@vindex SCM_C_HOOK_NORMAL
Тип хука, для которого всегда будут вызываться все зарегистрированные функции.
@item SCM_C_HOOK_OR
@vindex SCM_C_HOOK_OR
Тип хука, для которого будет вызываться последовательность зарегистрированных 
функций только до тех пор, пока одна из них не вернет Си истину(т.е не нулевое
значение).
@item SCM_C_HOOK_AND
@vindex SCM_C_HOOK_AND
Тип хука, для которого будет вызываться последовательность зарегистрированных
функций только до тех пор, пока одна из них не вернет Си ложь(т.е ноль)
@end table
@end deftp

@deftypefn {C Function} void scm_c_hook_init (scm_t_c_hook *hook, void *hook_data, scm_t_c_hook_type type)
Инициализирует Си хук  в памяти указываемой @var{hook}.  @var{type}
должен быть одним из значений перечисления @code{scm_t_c_hook_type},
и управляет тем как функции хука будут вызываться.  @var{hook_data} это
параметр замыкания который будет передан всем зарегистрированным функциям
хука, когда они вызываются.
@end deftypefn

Чтобы добавить или удалить Си функцию из Си хука, используйте @code{scm_c_hook_add}
или @code{scm_c_hook_remove}.  Функция хука должна ожидать три параметра
@code{void *}, соответственно:

@table @var
@item hook_data
Данные замыкания хука, которые были указаны во время инициализации хука
@code{scm_c_hook_init}.

@item func_data
Данные замыкания функции, которые были указаны, когда эта функция была
зарегистрирована с хуком с помощью @code{scm_c_hook_add}.

@item data
Данные замыкания вызова указанные в вызове @code{scm_c_hook_run}, который
запускает хук.
@end table

@deftp {C Type} scm_t_c_hook_function
Тип функции для Си функций хук: получает три параметра @code{void *}
и возвращает результат @code{void *}.
@end deftp

@deftypefn {C Function} void scm_c_hook_add (scm_t_c_hook *hook, scm_t_c_hook_function func, void *func_data, int appendp)
Добавляет функцию @var{func}, с данными замыкания функции @var{func_data}, в
Си хук @var{hook}.  Новая функция добавляется в список функций хука если
@var{appendp} не равен нулю, в противном случае предваряется списком.
@end deftypefn

@deftypefn {C Function} void scm_c_hook_remove (scm_t_c_hook *hook, scm_t_c_hook_function func, void *func_data)
Удаляет функцию @var{func}, с данными замыкания функции @var{func_data},
из Си хука @var{hook}.  @code{scm_c_hook_remove} проверяет оба
@var{func} и @var{func_data} что позволяет для одной и той же функции @var{func}
быть зарегистрированной во множестве мест с различными данными замыкания.
@end deftypefn

Наконец, чтобы вызвать Си хук. вызовите функцию @code{scm_c_hook_run} указав
хук и данные замыкания вызова для его работы:

@deftypefn {C Function} {void *} scm_c_hook_run (scm_t_c_hook *hook, void *data)
Запуск Си хука @var{hook} вызовет замыкание данных @var{data}.  С учетом
вариантов для типа хука @code{SCM_C_HOOK_OR} и
@code{SCM_C_HOOK_AND}, @code{scm_c_hook_run} вызывая зарегистрированные в
хуке @var{hook} функции, передавая им данные замыкания хука, данные замыкания
каждой функции, и данные замыкания вызова.

@code{scm_c_hook_run} возвращаемое значени является возвращенным значением
последней вызванной функции.
@end deftypefn

@node GC Hooks
@subsubsection Хуки для Сборщика Мусора (GC)

Всякий раз, когда Guile выполняет сборку мусора, он вызывает следующие хуки
в указанном порядке.

@defvr {C Hook} scm_before_gc_c_hook
Вызывает Си хук в самом начале сборки мусора, после установки
@code{scm_gc_running_p} в 1, но перед входом GC в критическую секцию.

Если сборка мусора заблокирована, потому что @code{scm_block_gc} не
равен нулю, GC завершает работу раньше, вскоре после вызова этого хука,
больше никаких хуков не будет вызвано.
@end defvr

@defvr {C Hook} scm_before_mark_c_hook
Хук Си вызывается перед началом фазы пометки сборщика мусора,
после тогок как поток GC вошел в критическую секцию.
@end defvr

@defvr {C Hook} scm_before_sweep_c_hook
Си хук вызывается перед началом фазы оочистки сборщиком мусора.
Это тоже же, что и конец фазы маркировки, так что ничего не происходит
между фазой маркировки и очистки.
@end defvr

@defvr {C Hook} scm_after_sweep_c_hook
Си хук вызывается после завершения фазы очистки сборщиком мусора,
но пока поток GC все еще находиться в критической секции.
@end defvr

@defvr {C Hook} scm_after_gc_c_hook
Хук Си вызывается в самом конце сборки мусора, после того как поток
GC покинул свою критическую секцию.
@end defvr

@defvr {Scheme Hook} after-gc-hook
@vindex scm_after_gc_hook
Хук Scheme с арностью 0.  Этот хук запускается асинхронно (@pxref{Asyncs})
вскоре после завершения GC и любых других событий, которые были отложены во
время процесса сборки мусора.  (Также доступно из Си
с именем @code{scm_after_gc_hook}.)
@end defvr

Все перечисленные здесь хуки имеют тип @code{SCM_C_HOOK_NORMAL}, и 
инициализируются с данными замыкания хука NULL, и вызываются 
@code{scm_c_hook_run} с данными замыкания вызова NULL.

@cindex guardians, testing for GC'd objects
Хук Scheme @code{after-gc-hook} особенно полезен в сочетании с защитниками
(guardians) (@pxref{Guardians}).  Как правило, если вы используете защитника,
вы хотите вызвать хранителя после сборки мусора, что бы увидеть есть ли
какие либо объекты, добавленные в защитника были собраны.
Добавляя чанк(thunk), который выполняет вызов к @code{after-gc-hook}, вы можете
убедиться, что ваш защитникy проверяется после каждого цикла сборки мусора.

@node REPL Hooks
@subsubsection Хуки в  Guile REPL
Документации по ним нет, но выполнив  @code{grep hook *} 
в директории guile/2.2/system/repl можно обнаружить следующие
хуки:
@lisp
command.scm:                (run-hook before-print-hook x)
debug.scm:                  (run-hook before-print-hook val)
describe.scm:               (cons <hook>      "a hook")
error-handling.scm:         (run-hook before-error-hook)
error-handling.scm:         (run-hook after-error-hook)
repl.scm:                   (run-hook before-eval-hook exp)
@end lisp
 которые можно попытаться использовать.

@c Local Variables:
@c TeX-master: "guile.texi"
@c End: