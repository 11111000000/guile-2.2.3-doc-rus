@c -*-texinfo-*-
@c This is part of the GNU Guile Reference Manual.
@c Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2009, 2010, 2011,
@c   2014 Free Software Foundation, Inc.
@c See the file guile.texi for copying conditions.

@node Binding Constructs
@section Definitions and Variable Bindings

Scheme поддерживает определение переменных в разных контекстах. 
Переменные могут быть определены на верхнем уровне, чтобы они были
видны во всей программе и переменные могут быть определены локально
в процедурах и выражениях. Это важно для модульности и абстракции
данных.

@menu
* Top Level::                   Top level variable definitions.
* Local Bindings::              Local variable bindings.
* Internal Definitions::        Internal definitions.
* Binding Reflection::          Querying variable bindings.
* Binding Multiple Values::     Binding multiple return values.
@end menu

@node Top Level
@subsection Top Level Variable Definitions

@cindex variable definition

На верхнем уровне программы (т.е не вложенной в другое выражене),
определение имеет форму:

@lisp
(define a @var{value})
@end lisp

@noindent
определение переменной вызывает @code{a} и устанавливает значение @var{value}.

Если переменная уже существует в текущем модуле, поскольку она уже создана
в предыдущем выражении с тем же именем, ее значение просто изменяется на
новое значение. В этом случае указанная выше форма полностью эквивалентна

@lisp
(set! a @var{value})
@end lisp

@noindent
Эта эквивалентность означает, что @code{define} может использоваться 
взаимозаменяемо с @code{set!} для изменения значений переменных на верхнем
уровне REPL или исходном файле Scheme.  Это полезно во время интерактивной
разработки при перезагрузке файла Scheme который вы изменили, поскольку это
позволяет определить выражения в этом файле, так что бы они корректно
работали как при загрузке файла в первый, так и при последующих загрузках

Заметьте однако, что @code{define} и @code{set!} не всегда эквивалентны.
На пример, @code{set!} не доступна если именнованная переменная еще не
существует.И эти два выражения могут вести себя иначе, в случае когда
импортируемые переменные видны из другого модуля.

@deffn {Scheme Syntax} define name value
Создадим переменную верхнего уровня с именем @var{name} и значением @var{value}.
Если имя переменной уже существует, то значение переменной просто изменится.  
ВозвращаемоеThe  значекние выражения @code{define} не определено.
@end deffn

В C API эквивалентом @code{define} выступают @code{scm_define} и
@code{scm_c_define}, которые отличаются друг от друга определением
имени переменной, в первом это @code{SCM} символ, а во втором Си строка
оканчивающаяся нулем.


@deffn {C Function} scm_define (sym, value)
@deffnx {C Function} scm_c_define (const char *name, value)
Си эквивалент @code{define}, с именем переменной определенным как
@var{sym} символ, или как @var{name}, заканчивающаяся нулем Си строка.  
Оба варианта возвращают новый или существующий объект переменной.
@end deffn


@code{define} (когда это происходит на верхнем уровне), @code{scm_define} и
@code{scm_c_define} все создают или устанавливают значение переменной
среды верхнего уровня текущего модуля.  Если еще не было переменной с
узазанным именем, принадлежащей к текущему модулю, но аналогично именованная
переменная из другого модуля была видна через импорт, то недавно созданная
переменная в текущем модуле перекроет импортированную переменную, так
что импортированная переменная больше не будет видна.

Внимание: Определения в Scheme связываний внутри локальных конструкций
(@pxref{Local Bindings}) действуют по разному см. (@pxref{Internal Definitions}).

Многие люди используют стиль разработки добавляя и изменяя определения
во время выполнения программы. Встраивая их в свою программу, но не презапуская
ее. (Вы можете сделать это используя команду @code{reload-module}, команду 
@code{reload} REPL, процедуру @code{load}, или просто вставляя код в REPL.)
Если вы один из этих людей, вы обранужите что иногда есть некоторые переменные,
которые вы не хотите переопределять все время. 
Для этого используется @code{define-once}.

@fnindex defvar
@deffn {Scheme Syntax} define-once name value
Создает переменную верхнего уровня с именем @var{name} и значением @var{value}, 
но только если имя @var{name} еще не используется в текущем модуле.
@end deffn

Старые лисперы, вероятно знают @code{define-once} под лисп именем,
@code{defvar}.

@node Local Bindings
@subsection Связывание Локальных Переменных(Local Variable Bindings)

@cindex local bindings
@cindex local variables

В отличии от определений на верхнем уровне, которые создают привзяки,
которые видны всему коду в модуле, также можно определять переменные,
которые видны только в четко определенной части программы. Обычно эта
часть программы будет процедурой или подвыражением процедуры.

С помощью конструкций для локального связывания (@code{let}, @code{let*},
@code{letrec}, и @code{letrec*}), язык Scheme имеет получает блочную
структуру, как и большинство других языков программирования со времен
@sc{Algol 60}.  Читатели, знакомые с такими языками как C или Java уже
должны быть знакомы с этой концепцией, но у семейства выражений @code{let}
есть несколько свойств, которые стоит знать.

Самой базовой конструкцией создания локальных привязок является @code{let}.

@deffn syntax let bindings body
@var{bindings} has the form

@lisp
((@var{variable1} @var{init1}) @dots{})
@end lisp

это ноль или больше двух-элементных списков, каждый из которых состоит из
 переменной и произвольного выражения. Все имена переменных @var{variable}
должны быть разными.

Все выражения @code{let} вычисляются следующим образом.

@itemize @bullet
@item
Вычисляются все выражения  @var{init}.

@item
Выделяется новое хранилище для переменных  @var{variables}.

@item
Значения выражений @var{init} сохраняюся в переменных.

@item
Выражения в теле(@var{body}) вычислляются по порядку, и значение последнего
выражения возвращается как значение выражения @code{let}.
@end itemize

Выражения @var{init} не могут ссылаться ни на одну из локальных переменных
@var{variables}.
@end deffn

Другие конструкции создания привязок - это вариации на одну и туже тему:
создания новых значений, связывания их с переменными и вычисления тела в
этом новом расширенном лексическом контексте.

@deffn syntax let* bindings body
Аналогично @code{let}, но привязка переменных выполняется последовательно,
так что все выражения @var{init} могут использовать переменные определенные
левее в списке определения привязок.

Выражение @code{let*} всегда может быть выражено вложенными выражениями
@code{let}.

@lisp
(let* ((a 1) (b a))
   b)
@equiv{}
(let ((a 1))
  (let ((b a))
    b))
@end lisp
@end deffn

@deffn syntax letrec bindings body
Подобно @code{let}, но можно ссылаться на переменные @var{variable}
из лямбда выражений созданных в любом из @var{inits}.  То есть, 
процедуры созданные в выражении @var{init} могут рекурсивно ссылаться на
определенные переменные.

@lisp
(letrec ((even? (lambda (n)
                  (if (zero? n)
                      #t
                      (odd? (- n 1)))))
         (odd? (lambda (n)
                  (if (zero? n)
                      #f
                      (even? (- n 1))))))
  (even? 88))
@result{}
#t
@end lisp

Обратите внимание, что хотя выражения @var{init} могут ссылаться на 
новвые переменные, они не могут получить доступ к их значениям.
Например, созданная выше функция @code{even?} создает замыкание (@pxref{About Closure})
ссылающеся на переменную @code{odd?}.  Но @code{odd?} не может быть
вызвана(а значит и вызвана @code{even?})  до тех пор пока выполнение не 
перейдет в тело(body).
@end deffn

@deffn syntax letrec* bindings body
Аналогично @code{letrec}, за исключением того, что выражения @var{init} 
связываются со своими переменными по порядку.

Таким образом  @code{letrec*} ослабляет ограничения letrec, так как
более поздние выражения @var{init} могут ссылаться на значения ранее
связанных переменных.
variables.

@lisp
(letrec ((a 42)
         (b (+ a 10)))  ;; Illegal access
  (* a b))
;; The behavior of the expression above is unspecified

(letrec* ((a 42)
          (b (+ a 10)))
  (* a b))
@result{} 2184
@end lisp
@end deffn

Существует так же альтернативная форма формы @code{let}, которая исползуется
для выражения итерации.  Из-за использования в качестве циклической конструкции,
эта форма именованного let ((the @dfn{named let})) задокументирована в
разделе рассказывающем об итерациях (@pxref{while do, Iteration})

@node Internal Definitions
@subsection Внтуренние определения

@c FIXME::martin: Review me!

Форма @code{define}, которая появляется внутри тела @code{lambda},
@code{let}, @code{let*}, @code{letrec}, @code{letrec*} или эквивалентного
выражения называется внутренним определением(@dfn{internal definition}).
Внутреннее определение отличается от определения верхнего уровня (@pxref{Top Level}),
поскольку это определение видно только внутри тела вмещающей формы.
Давайте рассмотрим следующий пример.

@lisp
(let ((frumble "froz"))
   (define banana (lambda () (apple 'peach)))
   (define apple (lambda (x) x))
   (banana))
@result{}
peach
@end lisp

Здесь вмещающая форма - это @code{let}, поэтому @code{define} в теле
@code{let} являются внутренними определениями.  Поскольку область действия
внутренних определений является ВСЕ(@strong{complete}) тело выражения
@code{let}, @code{lambda}-выражение, котолрое связывается с переменной
@code{banana} может ссылаться на переменную @code{apple}, хотя его определение
появляется лексически после(@emph{after}) определения @code{banana}.  
Это происходит потому, что последовательность внутреннего определения действует
так, как будто это выражение @code{letrec*}.

@lisp
(let ()
  (define a 1)
  (define b 2)
  (+ a b))
@end lisp

@noindent
этквивалентно

@lisp
(let ()
  (letrec* ((a 1) (b 2))
    (+ a b)))
@end lisp

Внутренние определения допускаются только в начале тела включающего выражения.
Они не могут быть смешаны с другими выражениями.

Другое примечательное отличие от определений верхнего уровня состоит в том, что
в пределах одной группы внутренних определений определения всех имен переменных
должны быть разными. Это означает, что на верхнем уровне второе определение для
данной переменной действует как @code{set!}, а для внутренних определений с
повторной привязкой выбрасывается исключение.

Историческое замечание, раньше внутренние привязки расширялись в терминах
@code{letrec}, а не @code{letrec*}. Такая ситуация была для отчета R5RS
и более ранних. Тем не менее в R6RS, было признано, что последовательное
определение является интуитивным расширением, как в следующем случае:

@lisp
(let ()
  (define a 1)
  (define b (+ a a))
  (+ a b))
@end lisp

@noindent
Guile решил следовать R6RS в этом отношении, и теперь расширяет внутренние
определения используя @code{letrec*}.

@node Binding Reflection
@subsection Запрос о связанных переменных

Guile предоставляет процедуру для проверки того, связан ли символ в среде
верхнего уровня.

@deffn {Scheme Procedure} defined? sym [module]
@deffnx {C Function} scm_defined_p (sym, module)
Возвращает @code{#t} если @var{sym} определен в модуле @var{module} или
текущем модуле, когда @var{module} не указан; в противном случае возвращается
@code{#f}.
@end deffn

@node Binding Multiple Values
@subsection Связываение нескольких возвращаемых значений.

@deffn {Syntax} define-values formals expression
Выражение @var{expression} вычисляется, и переменные @var{formals} связываются
с возвращаемыми значениями , также как formals в @code{lambda} выражении, сопоставляются
с аргументами при вызове процедуры.
@end deffn

@example
(define-values (q r) (floor/ 10 3))
(list q r) @result{} (3 1)

(define-values (x . y) (values 1 2 3))
x @result{} 1
y @result{} (2 3)

(define-values x (values 1 2 3))
x @result{} (1 2 3)
@end example

@c Local Variables:
@c TeX-master: "guile.texi"
@c End: