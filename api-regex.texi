@c -*-texinfo-*-
@c This is part of the GNU Guile Reference Manual.
@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2007, 2009, 2010, 2012
@c   Free Software Foundation, Inc.
@c See the file guile.texi for copying conditions.

@node Regular Expressions
@section Regular Expressions
@tpindex Regular expressions

@cindex regular expressions
@cindex regex
@cindex emacs regexp

@dfn{Регулярное выражение} (или @dfn{regexp}) представляет собой
шаблон, который описывает целый класс строкч.  Полное описание
регулярных выражений и их синтаксис выодит за рамки настоящего
руководства.

Если ваша система не содержит библиотеки регулярных выражений POSIX,
и у вас нет связанной с Guile независимой библиотеки регулярных выражений,
такой как Rx, эти функции будут вам не доступны. Вы можете узнать,
включает ли ваша Guile поддержку регулярных выражений проверяя,
возвращает ли @code{(provided? 'regex)} значение true.


Следующие функции регулярных выражений и соответствия строк предоставляются
модулем @code{(ice-9 regex)}.  Перед использованием описанных функций вы
должны загрузить этот модуль, выполнив @code{(use-modules (ice-9 regex))}.

@menu
* Regexp Functions::            Functions that create and match regexps.
* Match Structures::            Finding what was matched by a regexp.
* Backslash Escapes::           Removing the special meaning of regexp
                                meta-characters.
@end menu

@node Regexp Functions
@subsection Regexp Functions

По умолчанию, Guile поддерживает расширенные регулярные выражения POSIX.
Это означает, что символы @samp{(}, @samp{)}, @samp{+} и @samp{?} являются
специальными, и должны быть экранированы, если вы хотите использовать эти
символы буквально и нет поддержки ``нежелательных'' вариантов @samp{*},
@samp{+} или @samp{?}.


Этот интерфейс регулярных выражений был смоделирован после того,
как реализован SCSH(Scheme shell). Он должен быть совместим с
регулярными выражениями SCSH.

Нулевой байт (@code{#\nul}) не может использоваться в шаблонах
регулярных выражений или входных строках, поскольку базовые
функции Си рассматривают его как конец стороки. Если есть
нулевой байт, возникнет ошибка.

Внутренние шаблоны и входные строки преобразуются в кодировку текущего 
языка и затем передаются в подпрограммы регулярных выражений библиотеки
Си (@pxref{Regular Expressions,,, libc, The GNU C Library
Reference Manual}). Возвращенные структуры соответствия всегда указывают
на символы в строках, а не на отдельные байты, даже в случае многобайтовых
кодировок.

@deffn {Scheme Procedure} string-match pattern str [start]
Компилирует строку @var{pattern} в регулярное выражение и сравнивает его
со строкой @var{str}.  Опционально аргумент @var{start} указывает
с какой позиции в строке @var{str} начинать сопоставление.

@code{string-match} возвращает @dfn{match structure} которая
описывает что было сопоставлено с регулярным выражением.  
@xref{Match Structures}.  Если @var{str} не соответствует
шаблону @var{pattern} вообще, @code{string-match} возвращается @code{#f}.
@end deffn


Ниже приводятся два примера поиска соотвествий. В первом примере шаблон
сопоставляется четырем цифрам в проверяемой строке. Во втором случае
шаблону ничего не сопоставляется.

@example
(string-match "[0-9][0-9][0-9][0-9]" "blah2002")
@result{} #("blah2002" (4 . 8))

(string-match "[A-Za-z]" "123456")
@result{} #f
@end example

Каждый раз когда вызывается @code{string-match}, функция должна скомпилировать
свой аргумент @var{pattern} во внутреннюю структуру регулярного выражения.
Это операция занимает много времени, что делает  @code{string-match} не 
эффективной, если одно и тоже регулярное выражение используется несколько раз
(например в цикле). Для лучшей производительности, вы можете скомпилировать
регулярное выражение заранее, а затем сопоставлять входные строки с уже
скопилированным регулярным выражением.

@deffn {Scheme Procedure} make-regexp pat flag@dots{}
@deffnx {C Function} scm_make_regexp (pat, flaglst)
Компилирует регулярное выражение описанное  в @var{pat}, и
возвращает скопилированную regexp структуру.  Если @var{pat} не 
описывает корректное регулярное выражение, @code{make-regexp} 
вызывает ошибку с кодом @code{regular-expression-syntax}.

Аргумент @var{flag} изменяет поведение компилируемого регулярного
выражения. Поддерживаются следующие значения флага:

@defvar regexp/icase
Считать прописные и строчные буквы одинаковыми при сравнении.
@end defvar

@defvar regexp/newline
Если в целевой строке появляется значение новой стоки, то операторы
@samp{^} и @samp{$} соотвествуют ей сразу после или непосредственно
перед ней, соответственно.  Также , операторы @samp{.} и @samp{[^...]} 
никогда не будут соответствовать символу новой строки.
Цель этого флага в обработке целевой строки в виде буфера, содержащего
много строк текста и регулярное выражение как шаблон, который может
соответствовать одной из этих строк
@end defvar

@defvar regexp/basic
Компилировать как базовое (``устаревшее'') вместо расширенных
(``современных'') регулярных выражений, синтаксис которых принимается
по умолчанию .  Базовые регулярные выражения не считают символы
@samp{|}, @samp{+} или @samp{?} специальными и требуют, чтобы
метасимволы @samp{@{...@}} и @samp{(...)}
экранировались обратным слешем. (@pxref{Backslash
Escapes}).  Есть несколько других отличий между базовыми и расширенными
регулярными выражениями, но эти самые значительные.
@end defvar

@defvar regexp/extended
Компилировать регуляроное выражение как расширенное, а не 
базовое регулярное выражение.  Данное поведение происходит
по умолчанию, этот флаг обычно не требуется.  Если вызов
@code{make-regexp} включает в себя оба флага 
@code{regexp/basic} и @code{regexp/extended}, тот который
стоит последним будет отменять предыдущий.
@end defvar
@end deffn

@deffn {Scheme Procedure} regexp-exec rx str [start [flags]]
@deffnx {C Function} scm_regexp_exec (rx, str, start, flags)
Сопоставляет скомпилированое регулярное выражение @var{rx} 
с входной строкой @code{str}.  Если есть необязательный
целый аргумент @var{start} сопоставление начинается с указанной
позиции в строке.
Возвращается структура, описывающая результа поиска
соответсвия или @code{#f} если совпадение не может быть
найдено.

Аргумент @var{flags} изменяет поведение поиска соответствия.  Последовательность
значений флага можеть быть объединена операцией @code{logior} (@pxref{Bitwise
Operations}),

@defvar regexp/notbol
Считает что начальное смещение @var{start} в строке @var{str} не
является началом строки и не соответствует оператору @samp{^}.

Если @var{rx} был создан с испльзованием параметра @code{regexp/newline} из опций
указанных выше, @samp{^} будет по прежнему соответствовать после новой стороки
в буфере @var{str}.
@end defvar

@defvar regexp/noteol
Считает что конец @var{str} не является концом стороки и не должен 
совпадать с оператором @samp{$}.

Если @var{rx} был создан с опцией @code{regexp/newline} указаных выше,
@samp{$} по прежнему будет соответствовать перед новой строкой в буфере
@var{str}.
@end defvar
@end deffn

@lisp
;; Regexp to match uppercase letters
(define r (make-regexp "[A-Z]*"))

;; Regexp to match letters, ignoring case
(define ri (make-regexp "[A-Z]*" regexp/icase))

;; Search for bob using regexp r
(match:substring (regexp-exec r "bob"))
@result{} ""                  ; no match

;; Search for bob using regexp ri
(match:substring (regexp-exec ri "Bob"))
@result{} "Bob"               ; matched case insensitive
@end lisp

@deffn {Scheme Procedure} regexp? obj
@deffnx {C Function} scm_regexp_p (obj)
Возвращает @code{#t} если @var{obj} является скомпилированным регулярным
выражением или @code{#f} если это не так.
@end deffn

@sp 1
@deffn {Scheme Procedure} list-matches regexp str [flags]
Возвращает список структур соответствия, которые являются не
перекрывающимися совпадениями регулярного выражения @var{regexp} с
 @var{str}.  @var{regexp} может быть либо строкой шаблона, либо
скомпилированным регулярным выражением.  Аргумент @var{flags} 
аналогичен рассказанному выше  @code{regexp-exec} .

@example
(map match:substring (list-matches "[a-z]+" "abc 42 def 78"))
@result{} ("abc" "def")
@end  example
@end deffn

@deffn {Scheme Procedure} fold-matches regexp str init proc [flags]
Применяет @var{proc} к неперекрывающимся совпадениям @var{regexp} с
@var{str}, и выдает результат.  @var{regexp} может быть строкой 
шаблона или скомпилированным регулярным выражением.  Аргумент @var{flags} 
соответствует выше описанному @code{regexp-exec}.

@var{proc} вызывается как: @code{(@var{proc} match prev)} где
@var{match} это структура соответствия и @var{prev} это предыдущие
возвраты из @var{proc}.  Для первого вызова @var{prev} используется
параметр @var{init}.  @code{fold-matches} возвращает окончательное
значение из @var{proc}.

Для примера посчитаем количество совпадений

@example
(fold-matches "[a-z][0-9]" "abc x1 def y2" 0
              (lambda (match count)
                (1+ count)))
@result{} 2
@end example
@end deffn

@sp 1
Регулярные выражения обычно используются для поиска шаблонов в одной
строке и их замены содержимым другой строки. Для этого удобны 
следующие функции:

@c begin (scm-doc-string "regex.scm" "regexp-substitute")
@deffn {Scheme Procedure} regexp-substitute port match item @dots{}
Пишет в @var{port} выделенную часть совпадения структуры соответсвтия.
@var{match}.
Или если  @var{port} равен @code{#f} формирует строку из эти частей и
возвращает ее.

Каждый элемент @var{item} указывает часть, которая должна быть записана,
и может быть одним из следующих:

@itemize @bullet
@item
Строка. Строковые аргументы вписываются дословно.

@item
Целое число.  Будет записано найденное соответствие с этим номером
(@code{match:substring}).  Если Ноль то это все соотвествие.

@item
Символ @samp{pre}.  Будт вписана часть совпадающей строки, преджествующая 
регулярному выражению (@code{match:prefix}).

@item
Символ @samp{post}.  Будет вписана часть совпадающей строки стоящая после 
соответствия регулярному выражению (@code{match:suffix}).
@end itemize

Для примера, изменяем найденное соответствие и сохраняем текст до и после
совпадения.

@example
(regexp-substitute #f (string-match "[0-9]+" "number 25 is good")
                   'pre "37" 'post)
@result{} "number 37 is good"
@end example

Или сопоставление даты формата @sc{yyyymmdd} такой как @samp{20020828} и
реорганизация и перенос полей.

@lisp
(define date-regex
   "([0-9][0-9][0-9][0-9])([0-9][0-9])([0-9][0-9])")
(define s "Date 20020429 12am.")
(regexp-substitute #f (string-match date-regex s)
                   'pre 2 "-" 3 "-" 1 'post " (" 0 ")")
@result{} "Date 04-29-2002 12am. (20020429)"
@end lisp
@end deffn

@c begin (scm-doc-string "regex.scm" "regexp-substitute")
@deffn {Scheme Procedure} regexp-substitute/global port regexp target item@dots{}
@cindex search and replace
Пишет в @var{port} выбранные части совпадений регулярного
выражения @var{regexp} с @var{target}.  Если @var{port} равен @code{#f} 
тогда формируется строка из этих частей и возвращается.  @var{regexp} может быть
строкой или скомпилированным регулярным выражением.

Работает похоже на @code{regexp-substitute}, но позволяет
проводить глобальные подстановки в целевой строке @var{target}.
Каждый элемент @var{item} ведет себя так же как в функции
@code{regexp-substitute}, со следующими отличиями:

@itemize @bullet
@item
Функция.  Вызывается как @code{(@var{item} match)} с параметром
структурой соответствия регулярному выражению @var{regexp}, 
она должна вернуть строку которая и будет записана в порт @var{port}.


@item
Символ @samp{post}.  Здесь он ничего не выводит, а вместо этого
вызывает рекурсивно @code{regexp-substitute/global} для оставшейся
части @var{target}.

Это необходимо для выполнения глобального поиска и замены на входной
строке @var{target}; без этого @code{regexp-substitute/global} делает
возврат после одного совпадения и вывода.
@end itemize

Например, чтобы свернуть все последовательности табуляций и пробелов
в один дефис(для каждой последовательности)

@example
(regexp-substitute/global #f "[ \t]+"  "this   is   the text"
                          'pre "-" 'post)
@result{} "this-is-the-text"
@end example

Или что бы использовать функцию reverse, что бы переставить буквы
в каждом слове.

@example
(regexp-substitute/global #f "[a-z]+"  "to do and not-do"
  'pre (lambda (m) (string-reverse (match:substring m))) 'post)
@result{} "ot od dna ton-od"
@end example

Без символа @code{post}, выполняется только одно регулярное совпадение.
Например, следующее: для даты из указанного выше @code{regexp-substitute},
отдельного строкового вызова @code{string-match}.

@lisp
(define date-regex 
   "([0-9][0-9][0-9][0-9])([0-9][0-9])([0-9][0-9])")
(define s "Date 20020429 12am.")
(regexp-substitute/global #f date-regex s
                          'pre 2 "-" 3 "-" 1 'post " (" 0 ")")

@result{} "Date 04-29-2002 12am. (20020429)"
@end lisp
@end deffn

@node Match Structures
@subsection Match Structures

@cindex match structures

Структура соответствия (@dfn{match structure}) это объек, возвращаемый
@code{string-match} и @code{regexp-exec}.  Он описывает какая часть строки,
если таковая имеется, соответствует данному регулярному выражению.
Структура соответствия включает: ссылку на строку, которая была проверена 
на сответствие, начальную и конечную позицию совпадения с регулярным 
выражением, и если регулярное выражение содержит любые подвыражения в 
скобках, начальную и конечную позицию каждого совпадения с этими 
подвыражениями.

В каждой из функций соответствия регулярному выражению, описанных ниже,
аргумент соответствия должен быть структурой сопоставления, возвращенной
предыдущим вызовом @code{string-match} или @code{regexp-exec}. Большинство
этих функций возвращают некоторую информацию об исходной строке, которая
была сопоставлена с регулярным выражением; мы будем называть эту строку
целевой (@var{target}) для простоты обращения.

@c begin (scm-doc-string "regex.scm" "regexp-match?")
@deffn {Scheme Procedure} regexp-match? obj
Возвращает @code{#t} если @var{obj} является структурой соответствия
возвращенной предыдущим вызовом @code{regexp-exec}, если нет @code{#f}.
@end deffn

@c begin (scm-doc-string "regex.scm" "match:substring")
@deffn {Scheme Procedure} match:substring match [n]
Возвращает часть целевой строки@var{target} соответствующую номеру
подвыражения @var{n}.  Подвыражение 0 (по умолчанию) представляет
полное совпадение регулярного выражения. Если регулярное выражение
в целом сопоставлено, но число подвыражений не @var{n} не совпало,
возвращается @code{#f}.
@end deffn

@lisp
(define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
(match:substring s)
@result{} "2002"

;; match starting at offset 6 in the string
(match:substring
  (string-match "[0-9][0-9][0-9][0-9]" "blah987654" 6))
@result{} "7654"
@end lisp

@c begin (scm-doc-string "regex.scm" "match:start")
@deffn {Scheme Procedure} match:start match [n]
Возвращает начальную позицию совпадения с подвыражением
@var{n}.
@end deffn

В последующем примере результат равен 4, так как совпадение начинается
с символа с численным индексом 4:

@lisp
(define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
(match:start s)
@result{} 4
@end lisp

@c begin (scm-doc-string "regex.scm" "match:end")
@deffn {Scheme Procedure} match:end match [n]
Возвращает конечную позицию совпадения с подвыражением @var{n}.
@end deffn

In the following example, the result is 8, since the match runs between
characters 4 and 8 (т.е.@: ``2002'')

@lisp
(define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
(match:end s)
@result{} 8
@end lisp

@c begin (scm-doc-string "regex.scm" "match:prefix")
@deffn {Scheme Procedure} match:prefix match
Возвращет не совпавшую часть целевой строки @var{target} предшествующую
совпадению с регулярным выражением.

@lisp
(define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
(match:prefix s)
@result{} "blah"
@end lisp
@end deffn

@c begin (scm-doc-string "regex.scm" "match:suffix")
@deffn {Scheme Procedure} match:suffix match
Возвращает несовпавшую часть целевой строки @var{target} следующую
за совпадением с регулярным выражением.
@end deffn

@lisp
(define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
(match:suffix s)
@result{} "foo"
@end lisp

@c begin (scm-doc-string "regex.scm" "match:count")
@deffn {Scheme Procedure} match:count match
Возвращает количество совпавших подвыражений в скобках из @var{match}.
Обратите внимание, что полное совпадение с регулярным выражением считается
также совпавшим подвыражением, а неудачные подвыражения также включены
в счет.
@end deffn

@c begin (scm-doc-string "regex.scm" "match:string")
@deffn {Scheme Procedure} match:string match
Возвращает исходную целевую строку @var{target}.
@end deffn

@lisp
(define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
(match:string s)
@result{} "blah2002foo"
@end lisp

@node Backslash Escapes
@subsection Backslash Escapes

Иногда вам нужно, что бы регулярное выражение соответствовало символам
типа @samp{*} или @samp{$}.  Например, чтобы проверить, указывает ли
конкретная строка на запись меню из узла Info, ее нужно будет сопоставить
с регулярным выражением, например:  @samp{^* [^:]*::}.  Однако это не 
сработает, так как звездочка является метасимволом, она не будет 
соответствовать симовлу @samp{*} в начале строки.  В нашем случае
мы хотим чтобы первая звездочка была обычным символом.

Вы можете сделать это указав метасимвол с символом обратной косой черты
@samp{\}.  (Это так называемое цитирование метасимвола @dfn{quoting}, 
и известное как @dfn{backslash escape}.)  Когда Guile видит обратную
косую черту в регулярном выражении, он считает, что следующий символ
является обычным, не зависимо от того какой особый смысл он обычно имеет.
Поэтому мы можем выполнить описанный выше пример, изменив регулярное 
выражение на @samp{^\* [^:]*::}.  Последовательность @samp{\*} сообщает
движку регулярных выражений что соответствие должно быть одной звездочке
в обрабатываемой стоке.

Поскольку обратная косая черта сама по себе является метасимволом,
вы можете заставить регулярное выражение соответствовать обратной
косой черте в обрабатываемой строке, предваряя обратную косую черту
самой собой(обратной косой чертой).  Например, чтобы найти переменную
ссылки в программе @TeX{}, вам может потребоваться найти вхождения
строки @samp{\let\} следующим за ним любым количеством символов.
Регулярное выражение @samp{\\let\\[A-Za-z]*} будет делать это: 
двойная обратная косая черта в регулярном выражении соответствует
обычной одиночной косой черте в обрабатываемой строке.

@c begin (scm-doc-string "regex.scm" "regexp-quote")
@deffn {Scheme Procedure} regexp-quote str
Предваряет каждый специальный символ в  @var{str} обратной косой чертой
и возвращает строковый результат.
@end deffn

@strong{Очень важно:} Использование обратной косой черты в исходном коде
Guile source (как в Emacs Lisp или C) может быть сложным, потому что
символ обратной косой черты имеет особое значение для Guile.
Например, если Guile встречает последовательность символов @samp{\n}
в середине строки, в то время как обрабатывается код Scheme, он заменяет
эти символы символом новой строки.  Аналогичным образом, последовательность
символов @samp{\t} заменяется символом табуляции.  Некоторые из этих
@dfn{escape последовательностей} обрабатываются Guile до того как ваш
код будет выполнен. Неопознанные управляющие последовательности игнорируются:
если символ @samp{\*} появляется в строке он будет переведен в одиночный
символ @samp{*}.

Эта трансляция явно нежелательна для регулярных выражений, поскольку
мы хотим включать обратную косую черту в строку, чтобы экранировать
метасимволы в регулярном выражении. Следовательно, чтобы убедиться,
что обратная косая черта сохраняется в вашей программе Guile, вы
должны использовать две последовательные обратные косые черты.

@lisp
(define Info-menu-entry-pattern (make-regexp "^\\* [^:]*"))
@end lisp

Строка в этом примере предварительно обрабатывается клиентом Guile
перед выполнением любого кода.  Результирующим аргументом
@code{make-regexp} будет строка @samp{^\* [^:]*}, что нам и надо.

Это также означает, что для того, чтобы написать регулярное выражение,
которое соответствует одному символу обратной косой черты, строка
регулярного выражения должна включать в себя ЧЕТЫРЕ!!!! обратных
косых черты. Каждая последовательная пара обратных косых черт
переводиться Guile на одиночную обратную косую черту, и полученая
двойная обратная косая черта интерпретируется движком regexp как
сопоставление с одним символом обратной косой черты. Следовательно:

@lisp
(define tex-variable-pattern (make-regexp "\\\\let\\\\=[A-Za-z]*"))
@end lisp

Причина громоздкости этого синтаксиса является исторической. Обе системы:
построения шаблонов регулярных выражений и система обработки строк Unix
традиционно использовали обратную косую черту со специальными назначением,
описанным выше. Спецификация регулярного выражения POSIX и стандарт ANSI C
требуют этой семантики. Попытка отказаться от любой конвенции может вызвать
другие проблемы совместимости, возможно более серьезные. Следовательно,
без расширения программы Scheme для поддержки различными соглашениями
о квотировании(экранировании) (неуправляемое и запутанное расширение, когда
оно реализуется на других языках) мы должны придерживаться этого громоздкого
escape синтаксиса.