#
# Gagin <mikhail-gagin@yandex.ru>, 2018.
#
#. extracted from /home/bear/work/guile/doc/guile/en/scheme-ideas.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-07 12:37+0300\n"
"PO-Revision-Date: 2018-05-14 15:17+0300\n"
"Last-Translator: Gagin <mikhail-gagin@yandex.ru>\n"
"Language-Team: Russian <mikhail-gagin@yandex.ru>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2012\n"
"@c   Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:9
msgid ""
"@node Hello Scheme!\n"
"@chapter Hello Scheme!"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:12
msgid ""
"In this chapter, we introduce the basic concepts that underpin the\n"
"elegance and power of the Scheme language."
msgstr ""
"В этой главе мы введем основные понятия, лежащие в основе элегантности\n"
"и силы языка Scheme."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:18
msgid ""
"Readers who already possess a background knowledge of Scheme may happily\n"
"skip this chapter.  For the reader who is new to the language, however,\n"
"the following discussions on data, procedures, expressions and closure\n"
"are designed to provide a minimum level of Scheme understanding that is\n"
"more or less assumed by the chapters that follow."
msgstr ""
"Читатели, которые уже владеют базовым знанием Scheme, могут с радостью\n"
"поропустить данную главу. Однако для читателей, которые являются новичками\n"
"в этом языке, следующие обсуждения по данным, процедурам, выражениям и\n"
"замыканиям, предназначенны для обеспечения минимального уровня понимания\n"
"Scheme, которое более или менее подразумевается в последующих главах."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:23
msgid ""
"The style of this introductory material aims about halfway between the "
"terse\n"
"precision of R5RS and the discursiveness of existing Scheme tutorials.  For\n"
"pointers to useful Scheme resources on the web, please see @ref{Further\n"
"Reading}."
msgstr ""
"Стиль этого вводного материала стоит на полпути между точностью R5RS и\n"
"дискурсивностью существующих обучающих программ Scheme.  Мы укажем\n"
"на полезные ресурсы по Scheme в интернете, см @ref{Further Reading}.\n"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:31
msgid ""
"@menu\n"
"* About Data::                  Latent typing, types, values and variables.\n"
"* About Procedures::            The representation and use of procedures.\n"
"* About Expressions::           All kinds of expressions and their meaning.\n"
"* About Closure::               Closure, scoping and environments.\n"
"* Further Reading::             Where to find out more about Scheme.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:35
msgid ""
"@node About Data\n"
"@section Data Types, Values and Variables"
msgstr ""
"@node About Data\n"
"@section Типы данных, Значения и Переменные"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:41
msgid ""
"This section discusses the representation of data types and values, what\n"
"it means for Scheme to be a @dfn{latently typed} language, and the role\n"
"of variables.  We conclude by introducing the Scheme syntaxes for\n"
"defining a new variable, and for changing the value of an existing\n"
"variable."
msgstr ""
"В этом разделе обсуждается представление типо данных и значений, что "
"означает\n"
"для Scheme быть скрыто-типизированным языком, и роль переменных. В "
"заключении\n"
"Мы заключим введение в синтаксис Scheme определением новых переменных и \n"
"изменением значений существующей переменной."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:47
msgid ""
"@menu\n"
"* Latent Typing::               Scheme as a \"latently typed\" language.\n"
"* Values and Variables::        About data types, values and variables.\n"
"* Definition::                  Defining variables and setting their "
"values.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:51
msgid ""
"@node Latent Typing\n"
"@subsection Latent Typing"
msgstr ""
"@node Latent Typing\n"
"@subsection Скрытая типизация"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:57
msgid ""
"The term @dfn{latent typing} is used to describe a computer language,\n"
"such as Scheme, for which you cannot, @emph{in general}, simply look at\n"
"a program's source code and determine what type of data will be\n"
"associated with a particular variable, or with the result of a\n"
"particular expression."
msgstr ""
"Термин @dfn{скрытая типизация} используется для описания компьютерного "
"языка,\n"
"такого как Scheme, дл которого вы не можете, в общем случаее, просто "
"взглянув\n"
"на исходный код программы, определить, какой тип данных будет связан с \n"
"конкретной переменной или с результатом конкретного выражения."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:67
msgid ""
"Sometimes, of course, you @emph{can} tell from the code what the type of\n"
"an expression will be.  If you have a line in your program that sets the\n"
"variable @code{x} to the numeric value 1, you can be certain that,\n"
"immediately after that line has executed (and in the absence of multiple\n"
"threads), @code{x} has the numeric value 1.  Or if you write a procedure\n"
"that is designed to concatenate two strings, it is likely that the rest\n"
"of your application will always invoke this procedure with two string\n"
"parameters, and quite probable that the procedure would go wrong in some\n"
"way if it was ever invoked with parameters that were not both strings."
msgstr ""
"Иногда, конечно, вы @emph{можете} указать из кода, какой тип будет у\n"
"выражения. Если у  вас есть строка программы, в которой устанавливается\n"
"значение переменной @code{x} в числовое значение равное 1, вы можете быть\n"
"уверенными, что сразу после выполнения этой строки(при отсутствии\n"
"многопоточности), @code{x} примет числовое значение 1.  Или если вы пишите\n"
"процедуру, которая разработана чтобы объединить две строки, вполне "
"вероятно,\n"
"что остальная часть вашего приложения будет всегда ссылаться на эту "
"процедуру\n"
"с двумя строковыми параметрами, и вполне вероятно что эта процедура будет\n"
"работать не правильно, если ее вызывать с параметрами, которые не являются\n"
"одновременно оба строками."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:74
msgid ""
"Nevertheless, the point is that there is nothing in Scheme which\n"
"requires the procedure parameters always to be strings, or @code{x}\n"
"always to hold a numeric value, and there is no way of declaring in your\n"
"program that such constraints should always be obeyed.  In the same\n"
"vein, there is no way to declare the expected type of a procedure's\n"
"return value."
msgstr ""
"Тем не менее, дело в том, что в Scheme нет ниего, что регулирует\n"
"тип параметров процедур, что может потребовать, чтобы параметры\n"
"процедуры были строками, или чтобы  @code{x} всегда содержало числовое\n"
"значение, и нет способа объявить в вашей программе, что такие ограничения\n"
"всегда должны выполняться. В тоже время, нет способа объявить ожидаемый\n"
"тип возращаемого процедурой значения."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:81
msgid ""
"Instead, the types of variables and expressions are only known -- in\n"
"general -- at run time.  If you @emph{need} to check at some point that\n"
"a value has the expected type, Scheme provides run time procedures that\n"
"you can invoke to do so.  But equally, it can be perfectly valid for two\n"
"separate invocations of the same procedure to specify arguments with\n"
"different types, and to return values with different types."
msgstr ""
"Вместо этого типы переменных и выражений известны --- в общем --- только\n"
"во время выполнения. Если вам нужно в какой-то момент проверить, что\n"
"значение имеет ожидаемый тип, Scheme предоставляет процедуру времени \n"
"выполнения, которую вы можете использовать для этого. Но в равной степени,\n"
"это может быть справедливо для двух отдельных вызовов той же процедуры для\n"
"указания аргументов с разными типами и для возврата значений разных\n"
"типов."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:84
msgid ""
"The next subsection explains what this means in practice, for the ways\n"
"that Scheme programs use data types, values and variables."
msgstr ""
"В следующем подразделе объясняется, что это означает на практике, \n"
"способы для программ Scheme использовать типы данных, значения и\n"
"переменные."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:88
msgid ""
"@node Values and Variables\n"
"@subsection Values and Variables"
msgstr ""
"@node Values and Variables\n"
"@subsection Значения и Переменные"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:95
msgid ""
"Scheme provides many data types that you can use to represent your data.\n"
"Primitive types include characters, strings, numbers and procedures.\n"
"Compound types, which allow a group of primitive and compound values to\n"
"be stored together, include lists, pairs, vectors and multi-dimensional\n"
"arrays.  In addition, Guile allows applications to define their own data\n"
"types, with the same status as the built-in standard Scheme types."
msgstr ""
"Scheme предоставляет множество типов данных, которые можно использовать\n"
"для представления ваших данных. Примитивные типы, включают символы,\n"
"строки, числа и процедуры. Составные типы, которые позволяют сгруппировать\n"
"примитивные типы и составные значения, включают в себя списки, пары, "
"векторы\n"
"и многомерные массивы. Кроме того, Guile позволяет приложениям определять\n"
"свои собственные типы данных, имеющие тот же статус, что и встроенные\n"
"стандартные типы Scheme."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:100
msgid ""
"As a Scheme program runs, values of all types pop in and out of\n"
"existence.  Sometimes values are stored in variables, but more commonly\n"
"they pass seamlessly from being the result of one computation to being\n"
"one of the parameters for the next."
msgstr ""
"По мере запуска Scheme программ, значения всех типов появляются и исчезают.\n"
"Иногда значения хранятся в переменных, но чаще они легко передаются как \n"
"результат из одного вычисления, в качестве одного из параметров, для\n"
"следующего."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:108
msgid ""
"Consider an example.  A string value is created because the interpreter\n"
"reads in a literal string from your program's source code.  Then a\n"
"numeric value is created as the result of calculating the length of the\n"
"string.  A second numeric value is created by doubling the calculated\n"
"length.  Finally the program creates a list with two elements -- the\n"
"doubled length and the original string itself -- and stores this list in\n"
"a program variable."
msgstr ""
"Рассмотрим пример. Строковое значение создается, потому что интерпретатор\n"
"читает литералы строк из исходного кода вашей программы. Затем в результате\n"
"создается числовое значение вычисления длины строки. Второее числовое\n"
"значение создается путем удвоения рассчитанной длины. Наконец, программа\n"
"создает список с двумя элементами - удвоенной длиной и самой исходной\n"
"строкой - и сохраняет этот список в программной переменной."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:113
msgid ""
"All of the values involved here -- in fact, all values in Scheme --\n"
"carry their type with them.  In other words, every value ``knows,'' at\n"
"runtime, what kind of value it is.  A number, a string, a list,\n"
"whatever."
msgstr ""
"Все используемые здесь значения --- фактически, все значения в\n"
"Scheme -- имеют свой тип. Другими словами, каждое значение\n"
"``знает,'' во время выполнения, какое значение оно имеет.  \n"
"Число, строка, список или что угодно."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:121
msgid ""
"A variable, on the other hand, has no fixed type.  A variable --\n"
"@code{x}, say -- is simply the name of a location -- a box -- in which\n"
"you can store any kind of Scheme value.  So the same variable in a\n"
"program may hold a number at one moment, a list of procedures the next,\n"
"and later a pair of strings.  The ``type'' of a variable -- insofar as\n"
"the idea is meaningful at all -- is simply the type of whatever value\n"
"the variable happens to be storing at a particular moment."
msgstr ""
"С другой стороны, переменная не имеет фиксированного типа. Переменная\n"
"@code{x}, скажем -- это просто имя местоположения -- поле, в котором\n"
"вы можете сохранить любое значение Scheme. Та же самая переменная в \n"
"программе может содержать число в один момент, скисок процедур в \n"
"следующий момент, а затем пару строк. ``Тип'' переменной --- насколько\n"
"эта идея имеет смысл --- это просто тип любого значения, которое хранит\n"
"переменная в определенный момент времени."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:125
msgid ""
"@node Definition\n"
"@subsection Defining and Setting Variables"
msgstr ""
"@node Definition\n"
"@subsection Определение и Установка Переменных"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:128
msgid ""
"To define a new variable, you use Scheme's @code{define} syntax like\n"
"this:"
msgstr ""
"Чтобы определить новую переменную, используйте синтаксис @code{define} \n"
"Scheme следующим образом:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:132
msgid ""
"@lisp\n"
"(define @var{variable-name} @var{value})\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:135
msgid ""
"This makes a new variable called @var{variable-name} and stores\n"
"@var{value} in it as the variable's initial value.  For example:"
msgstr ""
"Оно создает новую переменную с именем @var{variable-name} и сохраняет\n"
"в ней значение @var{value} --- начальное значение переменной. Например:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:139
msgid ""
"@lisp\n"
";; Make a variable `x' with initial numeric value 1.\n"
"(define x 1)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:143
msgid ""
";; Make a variable `organization' with an initial string value.\n"
"(define organization \"Free Software Foundation\")\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:147
msgid ""
"(In Scheme, a semicolon marks the beginning of a comment that continues\n"
"until the end of the line.  So the lines beginning @code{;;} are\n"
"comments.)"
msgstr ""
"(В Scheme, точка с запятой означает начало коментария, который продолжается\n"
"до конца линии. Так начинающиеся строки с  @code{;;} являются коментариями.)"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:151
msgid ""
"Changing the value of an already existing variable is very similar,\n"
"except that @code{define} is replaced by the Scheme syntax @code{set!},\n"
"like this:"
msgstr ""
"Изменение значения уже существующей переменной очень похоже,\n"
"за исключением того что синтаксис @code{define} заменяется\n"
"в Scheme синтаксисом @code{set!}, вот так:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:155
msgid ""
"@lisp\n"
"(set! @var{variable-name} @var{new-value})\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:160
msgid ""
"Remember that variables do not have fixed types, so @var{new-value} may\n"
"have a completely different type from whatever was previously stored in\n"
"the location named by @var{variable-name}.  Both of the following\n"
"examples are therefore correct."
msgstr ""
"Помните, что переменные не имеют фиксиксированных типов, поэтому новое\n"
"значение @var{new-value} может иметь полностью другой тип, чем тот который "
"был ранее\n"
"сохранен в переменной названной @var{variable-name}. Поэтому оба следующих "
"примера\n"
"являются правильными."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:164
msgid ""
"@lisp\n"
";; Change the value of `x' to 5.\n"
"(set! x 5)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:168
msgid ""
";; Change the value of `organization' to the FSF's street number.\n"
"(set! organization 545)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:174
msgid ""
"In these examples, @var{value} and @var{new-value} are literal numeric\n"
"or string values.  In general, however, @var{value} and @var{new-value}\n"
"can be any Scheme expression.  Even though we have not yet covered the\n"
"forms that Scheme expressions can take (@pxref{About Expressions}), you\n"
"can probably guess what the following @code{set!} example does@dots{}"
msgstr ""
"В этих примерах, @var{value} и @var{new-value} являются буквально числовыми\n"
"и строковыми значениями. В целом, однако, @var{value} и @var{new-value}\n"
"могут быть любыми выражениями Scheme.  Хотя мы еще не рассматривали формы,\n"
"которые могут принимать выражения Scheme (@pxref{About Expressions}), вы\n"
"вероятно, можете догадаться, что делает следующий  @code{set!} например\n"
"does@dots{}"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:178
msgid ""
"@lisp\n"
"(set! x (+ x 1))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:185
msgid ""
"(Note: this is not a complete description of @code{define} and\n"
"@code{set!}, because we need to introduce some other aspects of Scheme\n"
"before the missing pieces can be filled in.  If, however, you are\n"
"already familiar with the structure of Scheme, you may like to read\n"
"about those missing pieces immediately by jumping ahead to the following\n"
"references."
msgstr ""
"(Примечание: это не полное описание @code{define} и @code{set!},\n"
"потому что нам нужно ввести некоторые другие аспекты Scheme\n"
"до того, как недостающие части могут быть заполнены. Если, однако\n"
"вы уже знакомы со структурой Scheme, вам может понравиться читать\n"
"эти недостающие части сразу, перескакивая вперед по следующим ссылкам."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:190
msgid ""
"@itemize @bullet\n"
"@item\n"
"@ref{Lambda Alternatives}, to read about an alternative form of the\n"
"@code{define} syntax that can be used when defining new procedures."
msgstr ""
"@itemize @bullet\n"
"@item\n"
"@ref{Lambda Alternatives}, что бы прочитать об альтернативной форме\n"
"синтаксиса @code{define}, который можно использовать при определении\n"
"новых процедур."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:195
msgid ""
"@item\n"
"@ref{Procedures with Setters}, to read about an alternative form of the\n"
"@code{set!} syntax that helps with changing a single value in the depths\n"
"of a compound data structure.)"
msgstr ""
"@item\n"
"@ref{Procedures with Setters}, чтобы прочитать об альтернативной форме\n"
"сиснтаксиса @code{set!}, который помогает с изменением единственного "
"значения\n"
"в глубине составной структуры данных.)"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:202
msgid ""
"@item\n"
"@xref{Internal Definitions}, to read about using @code{define} other\n"
"than at top level in a Scheme program, including a discussion of when it\n"
"works to use @code{define} rather than @code{set!} to change the value\n"
"of an existing variable.\n"
"@end itemize"
msgstr ""
"@item\n"
"@xref{Internal Definitions}, чтобы прочитать об использовании @code{define}\n"
"другого чем на высшем уровне программы Scheme, включая обсуждение того, как\n"
"оно работает, чтобы использовать @code{define} а не @code{set!} для "
"изменения\n"
"значения существующей переменной.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:206
msgid ""
"@node About Procedures\n"
"@section The Representation and Use of Procedures"
msgstr ""
"@node About Procedures\n"
"@section Представление и Использование Процедур"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:214
msgid ""
"This section introduces the basics of using and creating Scheme\n"
"procedures.  It discusses the representation of procedures as just\n"
"another kind of Scheme value, and shows how procedure invocation\n"
"expressions are constructed.  We then explain how @code{lambda} is used\n"
"to create new procedures, and conclude by presenting the various\n"
"shorthand forms of @code{define} that can be used instead of writing an\n"
"explicit @code{lambda} expression."
msgstr ""
"В этом разделе описываются основы использования и создания процедур Scheme.\n"
"В нем обсуждается предоставление процедур как еще один вид значения Scheme,\n"
"и показывает, как строиться вызов процедур. Затем мы объясняем, как\n"
"@code{лямбда(lambda)} используется для создания новых процедур и в "
"заключении\n"
"представляем различные сокращенные формы @code{define}, которые можно \n"
"использовать, вместо того, чтобы писать явное @code{lambda} выражение."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:221
msgid ""
"@menu\n"
"* Procedures as Values::        Procedures are values like everything else.\n"
"* Simple Invocation::           How to write a simple procedure invocation.\n"
"* Creating a Procedure::        How to create your own procedures.\n"
"* Lambda Alternatives::         Other ways of writing procedure "
"definitions.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:225
msgid ""
"@node Procedures as Values\n"
"@subsection Procedures as Values"
msgstr ""
"@node Procedures as Values\n"
"@subsection Процедуры как Значения"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:234
msgid ""
"One of the great simplifications of Scheme is that a procedure is just\n"
"another type of value, and that procedure values can be passed around\n"
"and stored in variables in exactly the same way as, for example, strings\n"
"and lists.  When we talk about a built-in standard Scheme procedure such\n"
"as @code{open-input-file}, what we actually mean is that there is a\n"
"pre-defined top level variable called @code{open-input-file}, whose\n"
"value is a procedure that implements what R5RS says that\n"
"@code{open-input-file} should do."
msgstr ""
"Одно из великих упрощений Scheme заключается в том, что процедура ---\n"
"это еще один тип значения,  и эти значения---процедуры могут быть\n"
"переданы и сохранены в переменных точно также как, например строики и\n"
"списки. Когда мы говорим о встроенной стандартной процедуре Scheme,\n"
"такой как @code{open-input-file}, на самом деле мы имеем в виду, что\n"
"существует предопределенная переменная верхнего уровня, называемая\n"
"@code{open-input-file}, значением которой является процедура, которая\n"
"реализует то что говорит  R5RS о том что должна делать функция\n"
"@code{open-input-file}."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:242
msgid ""
"Note that this is quite different from many dialects of Lisp ---\n"
"including Emacs Lisp --- in which a program can use the same name with\n"
"two quite separate meanings: one meaning identifies a Lisp function,\n"
"while the other meaning identifies a Lisp variable, whose value need\n"
"have nothing to do with the function that is associated with the first\n"
"meaning.  In these dialects, functions and variables are said to live in\n"
"different @dfn{namespaces}."
msgstr ""
"Обратите внимание, что это сильно отличается от многих диалектов Lisp ---\n"
"включая Emacs Lisp --- в котором программа может использовать одно и тоже\n"
"имя с двумя совершенно отдельными значениями: одно значение идентифицирует\n"
"функцию Lisp, другое значение идентифицирует переменную Lisp, значение \n"
"которой не имеет ничего общего с с функцией, которая связана с первой\n"
"переменной. В этих диалектах, функции и переменные, как гворят, живут\n"
"в разных пространствах имен(@dfn{namespaces})."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:246
msgid ""
"In Scheme, on the other hand, all names belong to a single unified\n"
"namespace, and the variables that these names identify can hold any kind\n"
"of Scheme value, including procedure values."
msgstr ""
"С другой стороны, в Scheme, все имена принадлежат единому пространству\n"
"имен, а переменные которые идентифицируют эти имена, могут содержать\n"
"любое значение Scheme, включая процедурные значения."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:250
msgid ""
"One consequence of the ``procedures as values'' idea is that, if you\n"
"don't happen to like the standard name for a Scheme procedure, you can\n"
"change it."
msgstr ""
"Одним из последствий идеи ``процедуры как значения'' является то, что\n"
"если вам не нравиться стандартное имя процедуры Scheme, вы можете \n"
"изменить его."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:255
msgid ""
"For example, @code{call-with-current-continuation} is a very important\n"
"standard Scheme procedure, but it also has a very long name!  So, many\n"
"programmers use the following definition to assign the same procedure\n"
"value to the more convenient name @code{call/cc}."
msgstr ""
"Например, @code{call-with-current-continuation} является очень важной\n"
"стандартной процедурой Scheme, но она также имеет очень длинное имя!\n"
"Таким образом, многие программисты используют следующий прием, назначить\n"
"значение процедуры переменной с более удобным именем, например \n"
"@code{call/cc}."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:259
msgid ""
"@lisp\n"
"(define call/cc call-with-current-continuation)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:266
msgid ""
"Let's understand exactly how this works.  The definition creates a new\n"
"variable @code{call/cc}, and then sets its value to the value of the\n"
"variable @code{call-with-current-continuation}; the latter value is a\n"
"procedure that implements the behaviour that R5RS specifies under the\n"
"name ``call-with-current-continuation''.  So @code{call/cc} ends up\n"
"holding this value as well."
msgstr ""
"Понятно, как это работает. Определение создает новую перменную @code{call/"
"cc},\n"
"и затем устанавливает ее значение в значение переменной \n"
"@code{call-with-current-continuation}; значение последней --- это "
"процедура, \n"
"которая реализует поведение, которое R5RS определеяет в соответствии с\n"
"именем ``call-with-current-continuation''.  Таким образом @code{call/cc} \n"
"сохраняет это значение."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:272
msgid ""
"Now that @code{call/cc} holds the required procedure value, you could\n"
"choose to use @code{call-with-current-continuation} for a completely\n"
"different purpose, or just change its value so that you will get an\n"
"error if you accidentally use @code{call-with-current-continuation} as a\n"
"procedure in your program rather than @code{call/cc}.  For example:"
msgstr ""
"Теперь, когда @code{call/cc} содержит требуемое значение процедуры, вы\n"
"можете использовать переменную с именем @code{call-with-current-"
"continuation} \n"
"для совершенно другой цели или просто изменить ее значение, чтобы вы\n"
"получили сообщение об ошибке, если вы случайно используете \n"
"@code{call-with-current-continuation} как процедуру в вашей программе, не\n"
"вызов @code{call/cc}.  Например:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:276
msgid ""
"@lisp\n"
"(set! call-with-current-continuation \"Not a procedure any more!\")\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:280
msgid ""
"Or you could just leave @code{call-with-current-continuation} as it was.\n"
"It's perfectly fine for more than one variable to hold the same\n"
"procedure value."
msgstr ""
"Или вы могли бы просто оставить @code{call-with-current-continuation} как "
"было.\n"
"Это прекрасно для более чем одной переменной удерживать одно и тоже "
"значение\n"
"процедуры."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:284
msgid ""
"@node Simple Invocation\n"
"@subsection Simple Procedure Invocation"
msgstr ""
"@node Simple Invocation\n"
"@subsection Простой Вызов Процедур"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:286
msgid "A procedure invocation in Scheme is written like this:"
msgstr "Вызов процедур в Scheme записывается следующим образом:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:290
msgctxt "/home/bear/work/guile/doc/guile/en/scheme-ideas.texi:290"
msgid ""
"@lisp\n"
"(@var{procedure} [@var{arg1} [@var{arg2} @dots{}]])\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:294
msgid ""
"In this expression, @var{procedure} can be any Scheme expression whose\n"
"value is a procedure.  Most commonly, however, @var{procedure} is simply\n"
"the name of a variable whose value is a procedure."
msgstr ""
"В этом выражении, @var{procedure} может быть любым выражением Scheme, "
"значение\n"
"которого является процедурой.  Чаще всего, однако, процедура --- это просто "
"имя\n"
"переменной, значением которой является процедура."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:298
msgid ""
"For example, @code{string-append} is a standard Scheme procedure whose\n"
"behaviour is to concatenate together all the arguments, which are\n"
"expected to be strings, that it is given.  So the expression"
msgstr ""
"Например, @code{string-append} --- это стандартная процедура  Scheme,\n"
"задача которой объединить все аргументы, которые, как ожидается, будут\n"
"строками, в единую строку. Таким образом, выражение"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:302
msgctxt "/home/bear/work/guile/doc/guile/en/scheme-ideas.texi:302"
msgid ""
"@lisp\n"
"(string-append \"/home\" \"/\" \"andrew\")\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:306
msgid ""
"@noindent\n"
"is a procedure invocation whose result is the string value\n"
"@code{\"/home/andrew\"}."
msgstr ""
"@noindent\n"
"является вызовом процедуры, результатом действия которой будет строковое "
"значение\n"
"@code{\"/home/andrew\"}."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:309
msgid ""
"Similarly, @code{string-length} is a standard Scheme procedure that\n"
"returns the length of a single string argument, so"
msgstr ""
"Аналогично, @code{string-length} является стандартной процедурой Scheme "
"которая \n"
"возвращает длину передаваемого ей аргумента-строки, поэтому"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:313
msgid ""
"@lisp\n"
"(string-length \"abc\")\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:316
msgid ""
"@noindent\n"
"is a procedure invocation whose result is the numeric value 3."
msgstr ""
"@noindent\n"
"является вызовом процедуры, результатом которого является числовое\n"
"значение 3."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:320
msgid ""
"Each of the parameters in a procedure invocation can itself be any\n"
"Scheme expression.  Since a procedure invocation is itself a type of\n"
"expression, we can put these two examples together to get"
msgstr ""
"Каждый из параметров в вызове процедуры может быть любым выражением\n"
"Scheme. Поскольку вызов процедуры сам по себе является выражением,\n"
"мы можем свести эти два примера вместе, получив:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:324
msgctxt "/home/bear/work/guile/doc/guile/en/scheme-ideas.texi:324"
msgid ""
"@lisp\n"
"(string-length (string-append \"/home\" \"/\" \"andrew\"))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:327
msgid ""
"@noindent\n"
"--- a procedure invocation whose result is the numeric value 12."
msgstr ""
"@noindent\n"
"--- вызов процедуры, результатом которого является числовое значение 12."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:331
msgid ""
"(You may be wondering what happens if the two examples are combined the\n"
"other way round.  If we do this, we can make a procedure invocation\n"
"expression that is @emph{syntactically} correct:"
msgstr ""
"(Вам может быть интересно, что произойдет, если два примера будут "
"объединены\n"
"другим способом. Если мы это сделаем так, мы создадим синтаксически верное\n"
"выражение вызова:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:335
msgid ""
"@lisp\n"
"(string-append \"/home\" (string-length \"abc\"))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:341
msgid ""
"@noindent\n"
"but when this expression is executed, it will cause an error, because\n"
"the result of @code{(string-length \"abc\")} is a numeric value, and\n"
"@code{string-append} is not designed to accept a numeric value as one of\n"
"its arguments.)"
msgstr ""
"@noindent\n"
"но когда это выражение выполниться, оно вызовет ошибку, так как результат\n"
"@code{(string-length \"abc\")} это числовое значение, а @code{string-"
"append}\n"
"не предназанчена для приема числовых значений как одного из типов \n"
"аргументов.)"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:345
msgid ""
"@node Creating a Procedure\n"
"@subsection Creating and Using a New Procedure"
msgstr ""
"@node Creating a Procedure\n"
"@subsection Создание и использование новых Процедур"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:349
msgid ""
"Scheme has lots of standard procedures, and Guile provides all of these\n"
"via predefined top level variables.  All of these standard procedures\n"
"are documented in the later chapters of this reference manual."
msgstr ""
"Scheme имеет множество стандартных процедур, и Guile предоставляет все\n"
"эти возможности с помощью предопределений переменных верхнего уровняp.\n"
"Все эти стандартные процедуры описаны в следующих главах этого\n"
"справочного руководства."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:353
msgid ""
"Before very long, though, you will want to create new procedures that\n"
"encapsulate aspects of your own applications' functionality.  To do\n"
"this, you can use the famous @code{lambda} syntax."
msgstr ""
"Однако, очень скоро, вы захотите создать новые процедуры, которые\n"
"инкапсулируют функциональные аспекты ваших собственных приложений.\n"
"Для этого вы можете испльзовать знаменитый синтаксис - лямбда\n"
"@code{lambda}."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:355
msgid "For example, the value of the following Scheme expression"
msgstr "Например, значением следующего выражения Scheme"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:359
msgid ""
"@lisp\n"
"(lambda (name address) @var{expression} @dots{})\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:369
msgid ""
"@noindent\n"
"is a newly created procedure that takes two arguments:\n"
"@code{name} and @code{address}.  The behaviour of the\n"
"new procedure is determined by the sequence of @var{expression}s in the\n"
"@dfn{body} of the procedure definition.  (Typically, these\n"
"@var{expression}s would use the arguments in some way, or else there\n"
"wouldn't be any point in giving them to the procedure.)  When invoked,\n"
"the new procedure returns a value that is the value of the last\n"
"@var{expression} in the procedure body."
msgstr ""
"@noindent\n"
"является новой процедурой, которая принимает два аргумента\n"
"@code{name} и @code{address}.  Поведение новой процедуры определяется\n"
"последовательностью выражений@var{expression} в теле определения \n"
"процедуры. (Как правило, эти выражения @var{expression} каким-то \n"
"образом используют аргументы, иначе не было бы смысла передавать их\n"
"в процедуру)  При вызове новая процедура возвращает значение, которое\n"
"является значением последнего выражения в теле процедуры."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:374
msgid ""
"To make things more concrete, let's suppose that the two arguments are\n"
"both strings, and that the purpose of this procedure is to form a\n"
"combined string that includes these arguments.  Then the full lambda\n"
"expression might look like this:"
msgstr ""
"Чтобы сделать пример более конкретным, давайте предположим, что оба\n"
"аргумента -- это две строки, и что целью этой процедуры является\n"
"формирование объединенной строки, которая включает в себя эти\n"
"аргументы. Тогда полное лямбда выражение может выглядеть так:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:379
msgid ""
"@lisp\n"
"(lambda (name address)\n"
"  (string-append \"Name=\" name \":Address=\" address))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:385
msgid ""
"We noted in the previous subsection that the @var{procedure} part of a\n"
"procedure invocation expression can be any Scheme expression whose value\n"
"is a procedure.  But that's exactly what a lambda expression is!  So we\n"
"can use a lambda expression directly in a procedure invocation, like\n"
"this:"
msgstr ""
"В предыдущем разделе мы отметили, что процедурой при вызове процедуры\n"
"может быть любое выражени Scheme возвращающее значение типа процедуры.\n"
"Но это точно то, что возвращает лямбда выражение! Таким образом, мы\n"
"можем использовать лямбда-выражение непосредственно в месте вызова\n"
"процедуры, например:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:392
msgid ""
"@lisp\n"
"((lambda (name address)\n"
"   (string-append \"Name=\" name \":Address=\" address))\n"
" \"FSF\"\n"
" \"Cambridge\") \n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:396
msgid ""
"@noindent\n"
"This is a valid procedure invocation expression, and its result is the\n"
"string:"
msgstr ""
"@noindent\n"
"Это допустимое выражение вызова процедуры и его резальтатом является строка:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:400
msgid ""
"@lisp\n"
"\"Name=FSF:Address=Cambridge\"\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:402
msgid ""
"It is more common, though, to store the procedure value in a variable ---"
msgstr ""
"Однако более частым является сохранение значения процедуры в переменной ---"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:408
msgid ""
"@lisp\n"
"(define make-combined-string\n"
"  (lambda (name address)\n"
"    (string-append \"Name=\" name \":Address=\" address)))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:411
msgid ""
"@noindent\n"
"--- and then to use the variable name in the procedure invocation:"
msgstr ""
"@noindent\n"
"--- и затем использование имени переменной в вызове процедуры:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:415
msgid ""
"@lisp\n"
"(make-combined-string \"FSF\" \"Cambridge\") \n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:418
msgid ""
"@noindent\n"
"Which has exactly the same result."
msgstr ""
"@noindent\n"
"Что имеет точно такой же результат."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:423
msgid ""
"It's important to note that procedures created using @code{lambda} have\n"
"exactly the same status as the standard built in Scheme procedures, and\n"
"can be invoked, passed around, and stored in variables in exactly the\n"
"same ways."
msgstr ""
"Важно отметить, что процедуры, созданные с использванием @code{lambda}, "
"имеют\n"
"точно такой же статус как и стандартные встроенные процедуры Scheme и могут\n"
"быть вызваны, переданы и сохранены в переменные точно так же."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:427
msgid ""
"@node Lambda Alternatives\n"
"@subsection Lambda Alternatives"
msgstr ""
"@node Lambda Alternatives\n"
"@subsection Альтернативы лямбда(lambda)"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:431
msgid ""
"Since it is so common in Scheme programs to want to create a procedure\n"
"and then store it in a variable, there is an alternative form of the\n"
"@code{define} syntax that allows you to do just that."
msgstr ""
"Поскольку в программах Scheme так часто возникает необходимость\n"
"создать процедуру, а затем сохранить ее в переменной есть альтернативная\n"
"форма синтаксиса @code{define}, которая позволяет вам это сделать."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:433
msgid "A @code{define} expression of the form"
msgstr "Форма выражения @code{define}"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:438
msgid ""
"@lisp\n"
"(define (@var{name} [@var{arg1} [@var{arg2} @dots{}]])\n"
"  @var{expression} @dots{})\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:441
msgid ""
"@noindent\n"
"is exactly equivalent to the longer form"
msgstr ""
"@noindent\n"
"точно эквивалентна более длинной форме:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:447
msgid ""
"@lisp\n"
"(define @var{name}\n"
"  (lambda ([@var{arg1} [@var{arg2} @dots{}]])\n"
"    @var{expression} @dots{}))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:450
msgid ""
"So, for example, the definition of @code{make-combined-string} in the\n"
"previous subsection could equally be written:"
msgstr ""
"Так, например, определение @code{make-combined-string} в предыдущем "
"подразделе\n"
"может быть написано так:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:455
msgid ""
"@lisp\n"
"(define (make-combined-string name address)\n"
"  (string-append \"Name=\" name \":Address=\" address))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:460
msgid ""
"This kind of procedure definition creates a procedure that requires\n"
"exactly the expected number of arguments.  There are two further forms\n"
"of the @code{lambda} expression, which create a procedure that can\n"
"accept a variable number of arguments:"
msgstr ""
"Такое определение процедуры создает процедуру, котрая требует точно \n"
"ожидаемого количества аргументов. Существуют еще две формы лямбда-\n"
"выражений, которые создают процедуры, которые могут принимать \n"
"переменное количество аргументов:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:463
msgid ""
"@lisp\n"
"(lambda (@var{arg1} @dots{} . @var{args}) @var{expression} @dots{})"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:466
msgid ""
"(lambda @var{args} @var{expression} @dots{})\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:469
msgid ""
"@noindent\n"
"The corresponding forms of the alternative @code{define} syntax are:"
msgstr ""
"@noindent\n"
"Соотвествующие формы альтернативного синтаксиса @code{define} определяют:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:472
msgid ""
"@lisp\n"
"(define (@var{name} @var{arg1} @dots{} . @var{args}) @var{expression} "
"@dots{})"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:475
msgid ""
"(define (@var{name} . @var{args}) @var{expression} @dots{})\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:478
msgid ""
"@noindent\n"
"For details on how these forms work, see @xref{Lambda}."
msgstr ""
"@noindent\n"
"Подробнее о том, как работают эти формы, см. @xref{Lambda}."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:483
msgid ""
"Prior to Guile 2.0, Guile provided an extension to @code{define} syntax\n"
"that allowed you to nest the previous extension up to an arbitrary\n"
"depth. These are no longer provided by default, and instead have been\n"
"moved to @ref{Curried Definitions}"
msgstr ""
"Для Guile 2.0, Guile предоствляет расширение для определения синтксиса,\n"
"которое позволяет вам вставлять предыдущее расширение до произвольной\n"
"глубины. По умолчанию это расширение больше не предоставляется, и вместо\n"
"этого были перенесены в раздел: @ref{Curried Definitions}"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:492
msgid ""
"(It could be argued that the alternative @code{define} forms are rather\n"
"confusing, especially for newcomers to the Scheme language, as they hide\n"
"both the role of @code{lambda} and the fact that procedures are values\n"
"that are stored in variables in the same way as any other kind of value.\n"
"On the other hand, they are very convenient, and they are also a good\n"
"example of another of Scheme's powerful features: the ability to specify\n"
"arbitrary syntactic transformations at run time, which can be applied to\n"
"subsequently read input.)"
msgstr ""
"(Можно утверждать, что альтернативные формы @code{define} довольно\n"
"запутывают, осоебнно для новичков в языке Scheme, поскольку они\n"
"скрывают как роль @code{lambda}, так и тот факт, что процедуры - это\n"
"значения, которые храняться в переменных так же, как и любой другой\n"
"тип данных. С другой стороны, они очень удобны,  они также являются\n"
"хорошим примером других мощных возможностей Scheme: возможность\n"
"определить произвольные синтаксические преобразования во время работы,\n"
"которые могут быть применены для последующего чтения ввода."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:496
msgid ""
"@node About Expressions\n"
"@section Expressions and Evaluation"
msgstr ""
"@node About Expressions\n"
"@section Выражения и Вычисления"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:501
msgid ""
"So far, we have met expressions that @emph{do} things, such as the\n"
"@code{define} expressions that create and initialize new variables, and\n"
"we have also talked about expressions that have @emph{values}, for\n"
"example the value of the procedure invocation expression:"
msgstr ""
"До сих пор мы встречали выражения, которые выполняют такие вещи, как\n"
"выражения @code{define}, которые создают и инициализируют новые \n"
"переменные, и мы также говорили о выражениях, которые имеют значение\n"
"@emph{values}, например значение выражения выозова процедуры:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:505
msgctxt "/home/bear/work/guile/doc/guile/en/scheme-ideas.texi:505"
msgid ""
"@lisp\n"
"(string-append \"/home\" \"/\" \"andrew\")\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:511
msgid ""
"@noindent\n"
"but we haven't yet been precise about what causes an expression like\n"
"this procedure invocation to be reduced to its ``value'', or how the\n"
"processing of such expressions relates to the execution of a Scheme\n"
"program as a whole."
msgstr ""
"@noindent\n"
"но мы еще не уточнили, что вызывает выражение, подобное вызову этой\n"
"процедуры, сокращающееся до значения ``value'' возвращаемого после\n"
"вызова процедуры, или как обработка таких выражений относится к \n"
"выполнению программы Scheme в целом."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:519
msgid ""
"This section clarifies what we mean by an expression's value, by\n"
"introducing the idea of @dfn{evaluation}.  It discusses the side effects\n"
"that evaluation can have, explains how each of the various types of\n"
"Scheme expression is evaluated, and describes the behaviour and use of\n"
"the Guile REPL as a mechanism for exploring evaluation.  The section\n"
"concludes with a very brief summary of Scheme's common syntactic\n"
"expressions."
msgstr ""
"В этом разделе разъясняется, что мы подразумеваем под значением\n"
"выражения, вводя идею Вычисления@dfn{evaluation}.  В нем обсуждаются\n"
"побочные эффекты, которые могут быть при вычиселении, объясняется, \n"
"как вычисляются каждое из различных выражений Scheme и описываются\n"
"поведение и использование Guile REPL как механизма изучения\n"
"вычислений. Раздел завершается очень кратким изложением общих\n"
"синтаксических выражений Scheme."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:526
msgid ""
"@menu\n"
"* Evaluating::                  How a Scheme program is executed.\n"
"* Tail Calls::                  Space-safe recursion.\n"
"* The REPL::                    Interacting with the Guile interpreter.\n"
"* Syntax Summary::              Common syntactic expressions -- in brief.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:530
msgid ""
"@node Evaluating\n"
"@subsection Evaluating Expressions and Executing Programs"
msgstr ""
"@node Evaluating\n"
"@subsection Вычисление Выражений и Выполнение Программ"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:533
msgid ""
"In Scheme, the process of executing an expression is known as\n"
"@dfn{evaluation}.  Evaluation has two kinds of result:"
msgstr ""
"В Scheme, процесс выполнения выражения известен как Вычисление\n"
"(точный перевод Оценка)@dfn{evaluation}.  Вычисление имеет два\n"
"вида результата:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:537
msgid ""
"@itemize @bullet\n"
"@item\n"
"the @dfn{value} of the evaluated expression"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"Значение@dfn{value} вычисленного выражения"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:542
msgid ""
"@item\n"
"the @dfn{side effects} of the evaluation, which consist of any effects of\n"
"evaluating the expression that are not represented by the value.\n"
"@end itemize"
msgstr ""
"@item\n"
"побочные эффекты@dfn{side effects} вычисления, которые состоят из любых\n"
"эффектов вычисления выражения которые не представлены значением.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:549
msgid ""
"Of the expressions that we have met so far, @code{define} and\n"
"@code{set!} expressions have side effects --- the creation or\n"
"modification of a variable --- but no value; @code{lambda} expressions\n"
"have values --- the newly constructed procedures --- but no side\n"
"effects; and procedure invocation expressions, in general, have either\n"
"values, or side effects, or both."
msgstr ""
"Из выражений, которые мы встречали до сих пор, выражения @code{define} и\n"
"@code{set!} имеют сторонние эффекты --- создание или изменение переменной\n"
"--- не отражающиеся на значении выражения; выражение @code{lambda} имеет\n"
"значение --- новая построенная процедура --- но не имеет побочных эффектов;\n"
"процедура выражения вызова, как правило имеет либо значение, либо побочный\n"
"эффект, либо и то, и другое."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:557
msgid ""
"It is tempting to try to define more intuitively what we mean by\n"
"``value'' and ``side effects'', and what the difference between them is.\n"
"In general, though, this is extremely difficult.  It is also\n"
"unnecessary; instead, we can quite happily define the behaviour of a\n"
"Scheme program by specifying how Scheme executes a program as a whole,\n"
"and then by describing the value and side effects of evaluation for each\n"
"type of expression individually."
msgstr ""
"Заманчиво пытаться более интуитивно определить, что мы подразумеваем\n"
"под значением ``value'' и сторонним эффектом``side effects'', и какова\n"
"разница между ними. В целом, это чрезвычайно сложно. Это даже не нужно;\n"
"вместо этого мы с радостью можем определить поведение программы Scheme\n"
"указав, как Scheme выполняет программу в целом, а затем описать значения\n"
"и побочные эффекты вычилслений для каждого типа выражений индивидуально."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:563
msgid ""
"@noindent\n"
"So, some@footnote{These definitions are approximate.  For the whole\n"
"and detailed truth, see @ref{Formal syntax and semantics,R5RS\n"
"syntax,,r5rs,The Revised(5) Report on the Algorithmic Language\n"
"Scheme}.} definitions@dots{}"
msgstr ""
"@noindent\n"
"Итак, некоторые@footnote{Это определение является приблизительным.\n"
"Полную и детальную информацию, см. @ref{Formal syntax and semantics,R5RS\n"
"syntax,,r5rs,The Revised(5) Report on the Algorithmic Language\n"
"Scheme}.} определения @dots{}"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:565
msgid "@itemize @bullet"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:568
msgid ""
"@item\n"
"A Scheme program consists of a sequence of expressions."
msgstr ""
"@item\n"
"Программа Scheme состоит из последовательности выражений."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:572
msgid ""
"@item\n"
"A Scheme interpreter executes the program by evaluating these\n"
"expressions in order, one by one."
msgstr ""
"@item\n"
"Интерпретатор Scheme выполняет программу, вычисляя эти выражения по порядку\n"
"по одному."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:575
msgid ""
"@item\n"
"An expression can be"
msgstr ""
"@item\n"
"Выражение может быть"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:588
msgid ""
"@itemize @bullet\n"
"@item\n"
"a piece of literal data, such as a number @code{2.3} or a string\n"
"@code{\"Hello world!\"}\n"
"@item\n"
"a variable name\n"
"@item\n"
"a procedure invocation expression\n"
"@item\n"
"one of Scheme's special syntactic expressions.\n"
"@end itemize\n"
"@end itemize"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"частью литеральных данных, таких как число @code{2.3} или строка\n"
"@code{\"Hello world!\"}\n"
"@item\n"
"именем переменной\n"
"@item\n"
"выражением вызова процедуры\n"
"@item\n"
"одним из специальных синтаксических выражений Scheme.\n"
"@end itemize\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:592
msgid ""
"@noindent\n"
"The following subsections describe how each of these types of expression\n"
"is evaluated."
msgstr ""
"@noindent\n"
"В последующих разделах описывается, как вычисляется каждый из типов "
"выражений."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:599
msgid ""
"@menu\n"
"* Eval Literal::                Evaluating literal data.\n"
"* Eval Variable::               Evaluating variable references.\n"
"* Eval Procedure::              Evaluating procedure invocation "
"expressions.\n"
"* Eval Special::                Evaluating special syntactic expressions.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:602
msgid ""
"@node Eval Literal\n"
"@subsubsection Evaluating Literal Data"
msgstr ""
"@node Eval Literal\n"
"@subsubsection Вычисление Литеральных Данных"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:606
msgid ""
"When a literal data expression is evaluated, the value of the expression\n"
"is simply the value that the expression describes.  The evaluation of a\n"
"literal data expression has no side effects."
msgstr ""
"Когда вычисляется выражение состоящее из литеральных данных, значение "
"выражения\n"
"представляет собой просто значение того, что описывает это выражение. "
"Вычисление\n"
"литерального выражения данных не имеет побочных эффектов."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:609
msgid ""
"@noindent\n"
"So, for example, "
msgstr ""
"@noindent\n"
"Так, например, "

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:614
msgid ""
"@itemize @bullet\n"
"@item\n"
"the value of the expression @code{\"abc\"} is the string value\n"
"@code{\"abc\"}"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"значение выражения @code{\"abc\"} представляет собой строковое значение\n"
"@code{\"abc\"}"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:617
msgid ""
"@item\n"
"the value of the expression @code{3+4i} is the complex number 3 + 4i"
msgstr ""
"@item\n"
"вычисление выражения @code{3+4i} является значением комплексноым числом 3 + "
"4i"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:622
msgid ""
"@item\n"
"the value of the expression @code{#(1 2 3)} is a three-element vector\n"
"containing the numeric values 1, 2 and 3.\n"
"@end itemize"
msgstr ""
"@item\n"
"вычисление выражения @code{#(1 2 3)} представляет собой значение "
"трехэлементный\n"
"вектор, содержащий числовые значения 1, 2 и 3.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:629
msgid ""
"For any data type which can be expressed literally like this, the syntax\n"
"of the literal data expression for that data type --- in other words,\n"
"what you need to write in your code to indicate a literal value of that\n"
"type --- is known as the data type's @dfn{read syntax}.  This manual\n"
"specifies the read syntax for each such data type in the section that\n"
"describes that data type."
msgstr ""
"Для любого типа данных, который может быть выражен литералами подобно\n"
"указанным выше, существует синтаксис записи выражений литеральных данных.\n"
"Другими словами, то что вам нужно записать в свой код для указания\n"
"литерального значения этого типа --- известно как синтаксис чтения\n"
"типа данных@dfn{read syntax}.  Это руководство указывает синтаксис\n"
"чтения для каждого такого типа данных в разделе, который описывает\n"
"эти типы данных."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:634
msgid ""
"Some data types do not have a read syntax.  Procedures, for example,\n"
"cannot be expressed as literal data; they must be created using a\n"
"@code{lambda} expression (@pxref{Creating a Procedure}) or implicitly\n"
"using the shorthand form of @code{define} (@pxref{Lambda Alternatives})."
msgstr ""
"Некоторые типы данных не имеют синтаксиса чтения. Процедуры, например,\n"
"не могут быть выражены литеральными данными; они должны быть созданы\n"
"с использованием выражения лямбда @code{lambda}(@pxref{Creating a "
"Procedure}) \n"
"или неявного использования короткой формы @code{define} (@pxref{Lambda "
"Alternatives})."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:638
msgid ""
"@node Eval Variable\n"
"@subsubsection Evaluating a Variable Reference"
msgstr ""
"@node Eval Variable\n"
"@subsubsection Вычисление ссылок на переменные"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:642
msgid ""
"When an expression that consists simply of a variable name is evaluated,\n"
"the value of the expression is the value of the named variable.  The\n"
"evaluation of a variable reference expression has no side effects."
msgstr ""
"Когда вычисляется выражение, состоящее просто из имени переменной,\n"
"значение выражения представляет собой значение именованной\n"
"переменной. Вычисление выражения ссылки переменной не имеет\n"
"побочных эффектов."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:644
msgid "So, after"
msgstr "Так, после"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:648
msgid ""
"@lisp\n"
"(define key \"Paul Evans\")\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:652
msgid ""
"@noindent\n"
"the value of the expression @code{key} is the string value @code{\"Paul\n"
"Evans\"}.  If @var{key} is then modified by"
msgstr ""
"@noindent\n"
"значение выражения @code{key} это строковое значение  @code{\"Paul\n"
"Evans\"}.  Если @var{key} изменить, с помощью:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:656
msgid ""
"@lisp\n"
"(set! key 3.74)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:659
msgid ""
"@noindent\n"
"the value of the expression @code{key} is the numeric value 3.74."
msgstr ""
"@noindent\n"
"значение выражения @code{key} будет числовым значением 3.74."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:662
msgid ""
"If there is no variable with the specified name, evaluation of the\n"
"variable reference expression signals an error."
msgstr ""
"Если нет переменной с указанным именем, вычисление выражения ссылки\n"
"на переменную сообщит об ошибке."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:666
msgid ""
"@node Eval Procedure\n"
"@subsubsection Evaluating a Procedure Invocation Expression"
msgstr ""
"@node Eval Procedure\n"
"@subsubsection Вычисление выражения Вызова Процедуры"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:669
msgid ""
"This is where evaluation starts getting interesting!  As already noted,\n"
"a procedure invocation expression has the form"
msgstr ""
"Здесь начинаются интересные вычисления!  Как уже отмечалось, выражение \n"
"вызова процедуры имеет вид:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:673
msgctxt "/home/bear/work/guile/doc/guile/en/scheme-ideas.texi:673"
msgid ""
"@lisp\n"
"(@var{procedure} [@var{arg1} [@var{arg2} @dots{}]])\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:677
msgid ""
"@noindent\n"
"where @var{procedure} must be an expression whose value, when evaluated,\n"
"is a procedure."
msgstr ""
"@noindent\n"
"где @var{procedure} должна быть выражением, значением которого, когда\n"
"производиться вычисление, является процедурой."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:680
msgid ""
"The evaluation of a procedure invocation expression like this proceeds\n"
"by"
msgstr "Вычисление выражения вызова процедуры продолжается дальше:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:685
msgid ""
"@itemize @bullet\n"
"@item\n"
"evaluating individually the expressions @var{procedure}, @var{arg1},\n"
"@var{arg2}, and so on"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"вычисляются индивидуально выражения @var{procedure}, @var{arg1},\n"
"@var{arg2}, и т.д."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:691
msgid ""
"@item\n"
"calling the procedure that is the value of the @var{procedure}\n"
"expression with the list of values obtained from the evaluations of\n"
"@var{arg1}, @var{arg2} etc. as its parameters.\n"
"@end itemize"
msgstr ""
"@item\n"
"выполняется вызов процедуры, которая является значением вычисления\n"
"выражения @var{procedure} со списком значений полученных из вычисления\n"
"@var{arg1}, @var{arg2} и т.д. в качестве параметров.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:700
msgid ""
"For a procedure defined in Scheme, ``calling the procedure with the list\n"
"of values as its parameters'' means binding the values to the\n"
"procedure's formal parameters and then evaluating the sequence of\n"
"expressions that make up the body of the procedure definition.  The\n"
"value of the procedure invocation expression is the value of the last\n"
"evaluated expression in the procedure body.  The side effects of calling\n"
"the procedure are the combination of the side effects of the sequence of\n"
"evaluations of expressions in the procedure body."
msgstr ""
"Для процедуры, определенной в Scheme, ``вызов процедуры со списком значений\n"
"как ее параметров'' означает привязку значений к формальным параметрам\n"
"процедуры, а затем вычислением последовательности выражений составляющих\n"
"тело процедуры. Значение выражения вызова процедуры --- это значение\n"
"последнего вычисленного выражения в процедуре. Побочные эффекты вызова\n"
"процедуры -- это сочетание побочных эффектов последовательности вычислений\n"
"выражаний в теле процедуры."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:703
msgid ""
"For a built-in procedure, the value and side-effects of calling the\n"
"procedure are best described by that procedure's documentation."
msgstr ""
"Для встроенных процедур значение и побочные эффекты вызова процедуры\n"
"лучше всего описаны в документации по этой процедуре."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:708
msgid ""
"Note that the complete side effects of evaluating a procedure invocation\n"
"expression consist not only of the side effects of the procedure call,\n"
"but also of any side effects of the preceding evaluation of the\n"
"expressions @var{procedure}, @var{arg1}, @var{arg2}, and so on."
msgstr ""
"Обратите внимание, что побочные эффекты вычисления выражения вызова \n"
"процедуры заключаются не только в побочных эффектах вызова процедуры,\n"
"но и в любых побочных эффектах предшествующих вычислению выражений \n"
"@var{procedure}, @var{arg1}, @var{arg2}, и т.д."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:711
msgid ""
"To illustrate this, let's look again at the procedure invocation\n"
"expression:"
msgstr ""
"Чтобы проилюстрировать это, давайте снова посмотрим на выражение\n"
"вызова процедуры:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:715
msgctxt "/home/bear/work/guile/doc/guile/en/scheme-ideas.texi:715"
msgid ""
"@lisp\n"
"(string-length (string-append \"/home\" \"/\" \"andrew\"))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:718
msgid ""
"In the outermost expression, @var{procedure} is @code{string-length} and\n"
"@var{arg1} is @code{(string-append \"/home\" \"/\" \"andrew\")}."
msgstr ""
"В самом внешнем выражении, @var{procedure}  @code{string-length} и "
"аргументом\n"
"@var{arg1} равным @code{(string-append \"/home\" \"/\" \"andrew\")}."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:724
msgid ""
"@itemize @bullet\n"
"@item\n"
"Evaluation of @code{string-length}, which is a variable, gives a\n"
"procedure value that implements the expected behaviour for\n"
"``string-length''."
msgstr ""
"@itemize @bullet\n"
"@item\n"
"Вычисление @code{string-length}, с переданной в процедуру переменной,\n"
"позволяет процедуре реализовать поведение для ``string-length''."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:728
msgid ""
"@item\n"
"Evaluation of @code{(string-append \"/home\" \"/\" \"andrew\")}, which is\n"
"another procedure invocation expression, means evaluating each of"
msgstr ""
"@item\n"
"Вычисление @code{(string-append \"/home\" \"/\" \"andrew\")}, которая\n"
"является вызовом другой процедуры, означает вычисление каждого:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:733
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{string-append}, which gives a procedure value that implements the\n"
"expected behaviour for ``string-append''"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"@code{string-append}, выражение дает значение процедуры, которая реализует\n"
"поведение для ``string-append''"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:736
msgid ""
"@item\n"
"@code{\"/home\"}, which gives the string value @code{\"/home\"}"
msgstr ""
"@item\n"
"@code{\"/home\"}, выражение которое дает строковое значение @code{\"/home\"}"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:739
msgid ""
"@item\n"
"@code{\"/\"}, which gives the string value @code{\"/\"}"
msgstr ""
"@item\n"
"@code{\"/\"}, выражение дает строковое значение @code{\"/\"}"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:743
msgid ""
"@item\n"
"@code{\"andrew\"}, which gives the string value @code{\"andrew\"}\n"
"@end itemize"
msgstr ""
"@item\n"
"@code{\"andrew\"}, выражение которое дает строковое значениe @code{\"andrew"
"\"}\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:748
msgid ""
"and then invoking the procedure value with this list of string values as\n"
"its arguments.  The resulting value is a single string value that is the\n"
"concatenation of all the arguments, namely @code{\"/home/andrew\"}.\n"
"@end itemize"
msgstr ""
"и затем вызвает значение procedure со списком строковых значений в качестве\n"
"своих аргументов.  Результирующее значение предстваляет собой однострочное\n"
"значение, которое является конкатенацией всех аргументов, а именно\n"
"@code{\"/home/andrew\"}.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:753
msgid ""
"In the evaluation of the outermost expression, the interpreter can now\n"
"invoke the procedure value obtained from @var{procedure} with the value\n"
"obtained from @var{arg1} as its arguments.  The resulting value is a\n"
"numeric value that is the length of the argument string, which is 12."
msgstr ""
"При вычислении внешнего выражения интерпретатор теперь может вызвать\n"
"значение процедуры, полученное из  @var{procedure} со значением\n"
"полученным из @var{arg1} в качестве аргумента. Результирующее значение\n"
"представляет собой длину строки аргумента, которой является число 12."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:757
msgid ""
"@node Eval Special\n"
"@subsubsection Evaluating Special Syntactic Expressions"
msgstr ""
"@node Eval Special\n"
"@subsubsection Вычисление Специальных Синтаксических Выражений"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:764
msgid ""
"When a procedure invocation expression is evaluated, the procedure and\n"
"@emph{all} the argument expressions must be evaluated before the\n"
"procedure can be invoked.  Special syntactic expressions are special\n"
"because they are able to manipulate their arguments in an unevaluated\n"
"form, and can choose whether to evaluate any or all of the argument\n"
"expressions."
msgstr ""
"Когда вычисляется выражение вызова процедуры, процедура и все аргументы\n"
"выражения должны быть вычислены до до вызова процедуры. Специальные\n"
"синтаксические выражения являются особенными, поскольку они могут\n"
"манипулировать своими аргументами в невычисленной форме и могут выбирать,\n"
"следует ли вычислять некоторые или все аргументы выражения."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:768
msgid ""
"Why is this needed?  Consider a program fragment that asks the user\n"
"whether or not to delete a file, and then deletes the file if the user\n"
"answers yes."
msgstr ""
"Зачем это необходимо?  Рассмотрим фрагмент программы, который запрашивает\n"
"у пользователя, удаление файла; а затем удаляет его если пользователь\n"
"ответил да."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:774
msgid ""
"@lisp\n"
"(if (string=? (read-answer \"Should I delete this file?\")\n"
"              \"yes\")\n"
"    (delete-file file))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:782
msgid ""
"If the outermost @code{(if @dots{})} expression here was a procedure\n"
"invocation expression, the expression @code{(delete-file file)}, whose\n"
"side effect is to actually delete a file, would already have been\n"
"evaluated before the @code{if} procedure even got invoked!  Clearly this\n"
"is no use --- the whole point of an @code{if} expression is that the\n"
"@dfn{consequent} expression is only evaluated if the condition of the\n"
"@code{if} expression is ``true''."
msgstr ""
"Если внешнее выражение @code{(if @dots{})} здесь бы было выражением\n"
"вызова процедуры, выражение @code{(delete-file file)}, чей побочный\n"
"эффект состоит в том, чтобы фактически удалить файл, было бы\n"
"вычислено до вычисления процедуры @code{if}!  Ясно, что это бесполезно\n"
" --- целая позиция в выражении @code{if} называемая "
"следствием(@dfn{consequent})\n"
"вычисляется только только тогда, когда условие выражения @code{if} является\n"
"истинным(``true'')."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:793
msgid ""
"Therefore @code{if} must be special syntax, not a procedure.  Other\n"
"special syntaxes that we have already met are @code{define}, @code{set!}\n"
"and @code{lambda}.  @code{define} and @code{set!} are syntax because\n"
"they need to know the variable @emph{name} that is given as the first\n"
"argument in a @code{define} or @code{set!} expression, not that\n"
"variable's value.  @code{lambda} is syntax because it does not\n"
"immediately evaluate the expressions that define the procedure body;\n"
"instead it creates a procedure object that incorporates these\n"
"expressions so that they can be evaluated in the future, when that\n"
"procedure is invoked."
msgstr ""
"Поэтому @code{if} должен быть специальным синтаксисом, а не процедурой.\n"
"Другие специальные синтаксисы, с которыми мы уже встречались:\n"
" @code{define}, @code{set!} и @code{lambda}.  @code{define} и @code{set!}\n"
"являются синтаксисами поскольку им надо знать имя@emph{name} переменной, \n"
"которое задается в качестве первого аргумента в выражениях  @code{define}\n"
"или @code{set!}, а не значение этой переменной.  @code{lambda} это "
"синтаксис,\n"
"потому что не сразу оценивает выражения, определяющие тело процедуры;\n"
"вместо этого он создает процедуру объект, которая включает эти выражения,\n"
"чтобы их можно было вычислить в будущем, когда будет вызвана эта процедура."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:797
msgid ""
"The rules for evaluating each special syntactic expression are specified\n"
"individually for each special syntax.  For a summary of standard special\n"
"syntax, see @xref{Syntax Summary}."
msgstr ""
"Правила вычисления каждого специального синтаксического выражения "
"идивидуальны\n"
"для каждого специального синтаксиса. Для краткого описания стандартного\n"
"специального синтаксиса см. @xref{Syntax Summary}."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:803
msgid ""
"@node Tail Calls\n"
"@subsection Tail calls\n"
"@cindex tail calls\n"
"@cindex recursion"
msgstr ""
"@node Tail Calls\n"
"@subsection Хвостовые вызовы\n"
"@cindex tail calls\n"
"@cindex recursion"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:808
msgid ""
"Scheme is ``properly tail recursive'', meaning that tail calls or\n"
"recursions from certain contexts do not consume stack space or other\n"
"resources and can therefore be used on arbitrarily large data or for\n"
"an arbitrarily long calculation.  Consider for example,"
msgstr ""
"Scheme  ``оптимизирует хвостовую рекурсию'', что означает, что \n"
"хвостовые вызовы или рекурсии из определенных контекстов не потребляют\n"
"пространство стека или других ресурсов и поэтому могут использовать\n"
"произвольно большие данные или для произвольно больших вычислений.\n"
"Рассмотрим например,"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:814
msgid ""
"@example\n"
"(define (foo n)\n"
"  (display n)\n"
"  (newline)\n"
"  (foo (1+ n)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:822
msgid ""
"(foo 1)\n"
"@print{}\n"
"1\n"
"2\n"
"3\n"
"@dots{}\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:828
msgid ""
"@code{foo} prints numbers infinitely, starting from the given @var{n}.\n"
"It's implemented by printing @var{n} then recursing to itself to print\n"
"@math{@var{n}+1} and so on.  This recursion is a tail call, it's the\n"
"last thing done, and in Scheme such tail calls can be made without\n"
"limit."
msgstr ""
"@code{foo} печатает числа бесконечно, начиная с данного @var{n}.\n"
"Она реализуется путем печати @var{n} затем рекурсивно вызывает себя\n"
"для печати @math{@var{n}+1} и т.д.  Эта рекурсия содержит хвостовой\n"
"вызов, и в Scheme подобные хвостовые вызовы могут быть сделаны\n"
"без ограничений."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:832
msgid ""
"Or consider a case where a value is returned, a version of the SRFI-1\n"
"@code{last} function (@pxref{SRFI-1 Selectors}) returning the last\n"
"element of a list,"
msgstr ""
"Или рассмотрим случай когда возвращается значение, из SRFI-1 вариант \n"
"функции @code{last} (@pxref{SRFI-1 Selectors}) возвращающей последний \n"
"элемент списка,"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:838
msgid ""
"@example\n"
"(define (my-last lst)\n"
"  (if (null? (cdr lst))\n"
"      (car lst)\n"
"      (my-last (cdr lst))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:841
msgid ""
"(my-last '(1 2 3)) @result{} 3      \n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:846
msgid ""
"If the list has more than one element, @code{my-last} applies itself\n"
"to the @code{cdr}.  This recursion is a tail call, there's no code\n"
"after it, and the return value is the return value from that call.  In\n"
"Scheme this can be used on an arbitrarily long list argument."
msgstr ""
"Если список содержит более одного элемента, @code{my-last} применяется\n"
"к  @code{cdr}.  Эта рекурсия является хвостовым вызовом, после него нет\n"
"кода, а возвращаемое значение является возвращаемым значением этого\n"
"вызова. В Scheme эту функцию можно использовать для аргумента с произвольно\n"
"длинным списком."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:850
msgid ""
"@sp 1\n"
"A proper tail call is only available from certain contexts, namely the\n"
"following special form positions,"
msgstr ""
"@sp 1\n"
"Правильный хвостовой вызов доступен только из определенных контекстов, \n"
"а именно следующие специальные формы позиций,"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:854
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{and} --- last expression"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"@code{and} --- последнее выражение"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:857
msgid ""
"@item\n"
"@code{begin} --- last expression"
msgstr ""
"@item\n"
"@code{begin} --- последнее выражение"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:860
msgid ""
"@item\n"
"@code{case} --- last expression in each clause"
msgstr ""
"@item\n"
"@code{case} --- последнее выражение в каждом пункте"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:864
msgid ""
"@item\n"
"@code{cond} --- last expression in each clause, and the call to a\n"
"@code{=>} procedure is a tail call"
msgstr ""
"@item\n"
"@code{cond} --- последнее выражение в каждом пункте, а вызов процедуры\n"
"@code{=>} это хвостовой вызов"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:867
msgid ""
"@item\n"
"@code{do} --- last result expression"
msgstr ""
"@item\n"
"@code{do} --- последний результат выражения"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:870
msgid ""
"@item\n"
"@code{if} --- ``true'' and ``false'' leg expressions"
msgstr ""
"@item\n"
"@code{if} --- ``истина(true)'' и ``ложь(false)'' выражения \"ног\""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:873
msgid ""
"@item\n"
"@code{lambda} --- last expression in body"
msgstr ""
"@item\n"
"@code{lambda} --- последнее выражение в теле"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:877
msgid ""
"@item\n"
"@code{let}, @code{let*}, @code{letrec}, @code{let-syntax},\n"
"@code{letrec-syntax} --- last expression in body"
msgstr ""
"@item\n"
"@code{let}, @code{let*}, @code{letrec}, @code{let-syntax},\n"
"@code{letrec-syntax} --- последнее выражение в теле"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:881
msgid ""
"@item\n"
"@code{or} --- last expression\n"
"@end itemize"
msgstr ""
"@item\n"
"@code{or} --- последнее выражение\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:884
msgid ""
"@noindent\n"
"The following core functions make tail calls,"
msgstr ""
"@noindent\n"
"Следующие основные функции выполняют хвостовой вызов,"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:888
msgid ""
"@itemize @bullet\n"
"@item\n"
"@code{apply} --- tail call to given procedure"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"@code{apply} --- хвостовой вызов к данной процедуре"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:892
msgid ""
"@item\n"
"@code{call-with-current-continuation} --- tail call to the procedure\n"
"receiving the new continuation"
msgstr ""
"@item\n"
"@code{call-with-current-continuation} --- хвостовой вызов процедуры "
"принимающей \n"
"новое продолжение(continuation)"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:896
msgid ""
"@item\n"
"@code{call-with-values} --- tail call to the values-receiving\n"
"procedure"
msgstr ""
"@item\n"
"@code{call-with-values} --- хвостовой вызов процедуры получающей\n"
"значения"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:899
msgid ""
"@item\n"
"@code{eval} --- tail call to evaluate the form"
msgstr ""
"@item\n"
"@code{eval} --- хвостовой вызов вычисления формы"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:904
msgid ""
"@item\n"
"@code{string-any}, @code{string-every} --- tail call to predicate on\n"
"the last character (if that point is reached)\n"
"@end itemize"
msgstr ""
"@item\n"
"@code{string-any}, @code{string-every} --- хвостовой вызов предиката\n"
"на последнем символе( если эта точка достижима)\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:909
msgid ""
"@sp 1\n"
"The above are just core functions and special forms.  Tail calls in\n"
"other modules are described with the relevant documentation, for\n"
"example SRFI-1 @code{any} and @code{every} (@pxref{SRFI-1 Searching})."
msgstr ""
"@sp 1\n"
"Выше приведенны основные функции и специальные формы.  Хвостовой вызов\n"
"в других модулях описан в соответствующей документации, например SRFI-1\n"
"@code{any} и @code{every} (@pxref{SRFI-1 Searching})."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:913
msgid ""
"It will be noted there are a lot of places which could potentially be\n"
"tail calls, for instance the last call in a @code{for-each}, but only\n"
"those explicitly described are guaranteed."
msgstr ""
"Следует отметить, что существует много мест, которые потенциально могут\n"
"быть хвостовыми вызовами, например последний вызов в @code{for-each}, но\n"
"только те из них гарантированы которые имеют явное описание."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:917
msgid ""
"@node The REPL\n"
"@subsection Using the Guile REPL"
msgstr ""
"@node The REPL\n"
"@subsection Использование Guile REPL"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:923
msgid ""
"If you start Guile without specifying a particular program for it to\n"
"execute, Guile enters its standard Read Evaluate Print Loop --- or\n"
"@dfn{REPL} for short.  In this mode, Guile repeatedly reads in the next\n"
"Scheme expression that the user types, evaluates it, and prints the\n"
"resulting value."
msgstr ""
"Если вы запустите Guile без указания конкретной программы для выполнения,\n"
"Guile входит в стандартный цикл Чтение-Выполнение-Печать(Read Evaluate \n"
"Print Loop или коротко @dfn{REPL}). В этом режиме, Guile неоднократно \n"
"читает выражения Scheme, которые вводит пользователь, вычисляет их\n"
"и печатает результирующие значения."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:929
msgid ""
"The REPL is a useful mechanism for exploring the evaluation behaviour\n"
"described in the previous subsection.  If you type @code{string-append},\n"
"for example, the REPL replies @code{#<primitive-procedure\n"
"string-append>}, illustrating the relationship between the variable\n"
"@code{string-append} and the procedure value stored in that variable."
msgstr ""
"REPL --- полезный механизм для изучения описанного поведения вычислений\n"
"описанного в предыдущем разделе. Если вы набираете @code{string-append},\n"
"например, REPL отвечает @code{#<primitive-procedure string-append>}, \n"
"илюстрирующая взаимосвязь между переменными @code{string-append} и\n"
"процедурой, хранящейся в этой переменной.\n"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:932
msgid ""
"In this manual, the notation @result{} is used to mean ``evaluates\n"
"to''.  Wherever you see an example of the form"
msgstr ""
"В этом руководстве, обозначение @result{} используется для обозначения\n"
"результа вычисления ``evaluates to''.  Где бы вы не увидели пример\n"
"формы:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:938
msgid ""
"@lisp\n"
"@var{expression}\n"
"@result{}\n"
"@var{result}\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:942
msgid ""
"@noindent\n"
"feel free to try it out yourself by typing @var{expression} into the\n"
"REPL and checking that it gives the expected @var{result}."
msgstr ""
"@noindent\n"
"не стесняйтесь попробовать себя, набрав выражение в REPL\n"
"и проверить, что он выдает ожидаемый результат."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:946
msgid ""
"@node Syntax Summary\n"
"@subsection Summary of Common Syntax"
msgstr ""
"@node Syntax Summary\n"
"@subsection Итоги о Общем Синтаксисе"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:951
msgid ""
"This subsection lists the most commonly used Scheme syntactic\n"
"expressions, simply so that you will recognize common special syntax\n"
"when you see it.  For a full description of each of these syntaxes,\n"
"follow the appropriate reference."
msgstr ""
"В этом подразделе перечислены наиболее часто используемые синтаксические \n"
"выражения Scheme, настолько простые, что как только вы их увидите\n"
"вы сможете разпознать общий специальный синтакс. Для полного описания\n"
"каждого из этих синтаксисов дана соответствующая гиперссылка."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:953
msgid "@code{lambda} (@pxref{Lambda}) is used to construct procedure objects."
msgstr ""
"@code{lambda} (@pxref{Lambda}) используется для создания объектов процедур."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:956
msgid ""
"@code{define} (@pxref{Top Level}) is used to create a new variable and\n"
"set its initial value."
msgstr ""
"@code{define} (@pxref{Top Level}) используется для создания новой "
"переменной\n"
"и установки ее первоначального значения."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:959
msgid ""
"@code{set!} (@pxref{Top Level}) is used to modify an existing variable's\n"
"value."
msgstr ""
"@code{set!} (@pxref{Top Level}) используется для изменения значения "
"существующей\n"
"переменной."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:965
msgid ""
"@code{let}, @code{let*} and @code{letrec} (@pxref{Local Bindings})\n"
"create an inner lexical environment for the evaluation of a sequence of\n"
"expressions, in which a specified set of local variables is bound to the\n"
"values of a corresponding set of expressions.  For an introduction to\n"
"environments, see @xref{About Closure}."
msgstr ""
"@code{let}, @code{let*} и @code{letrec} (@pxref{Local Bindings})\n"
"создают внутреннюю лексическую среду для вычисления последовательности\n"
"выражений, в которой задано множество локальных переменных связываемых\n"
"со множеством значений соответствующего набора выражений.  Для введения\n"
"в окружение(среду), см. @xref{About Closure}."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:971
msgid ""
"@code{begin} (@pxref{begin}) executes a sequence of expressions in order\n"
"and returns the value of the last expression.  Note that this is not the\n"
"same as a procedure which returns its last argument, because the\n"
"evaluation of a procedure invocation expression does not guarantee to\n"
"evaluate the arguments in order."
msgstr ""
"@code{begin} (@pxref{begin}) выполняет последовательность вражений в "
"порядке\n"
"их следования и возвращаетж последнее выражение. Обратите внимание, что \n"
"это не тоже самое, что процедура которая возвращает совй последний "
"аргумент,\n"
"потому что оценка выражения вызова процедуры не гарантирует вычисления\n"
"аргументов в порядке их следования."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:975
msgid ""
"@code{if} and @code{cond} (@pxref{Conditionals}) provide conditional\n"
"evaluation of argument expressions depending on whether one or more\n"
"conditions evaluate to ``true'' or ``false''."
msgstr ""
"@code{if} and @code{cond} (@pxref{Conditionals}) обеспечивают условное "
"вычисление\n"
"выражений аргументов в зависимости от того, является ли результатом\n"
"вычисления условия истина или ложь."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:979
msgid ""
"@code{case} (@pxref{Conditionals}) provides conditional evaluation of\n"
"argument expressions depending on whether a variable has one of a\n"
"specified group of values."
msgstr ""
"@code{case} (@pxref{Conditionals}) обеспечивают условное вычисление\n"
"выражений аргументов в зависимости от того, совпадает ли переменная\n"
"условия с одной из заданных групп значений."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:983
msgid ""
"@code{and} (@pxref{and or}) executes a sequence of expressions in order\n"
"until either there are no expressions left, or one of them evaluates to\n"
"``false''."
msgstr ""
"@code{and} (@pxref{and or}) выполняет последовательность выраженей в "
"порядке\n"
"их следования, пока не останется никаких выражений, или в одном из них "
"результом \n"
"будет значение ``false''."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:987
msgid ""
"@code{or} (@pxref{and or}) executes a sequence of expressions in order\n"
"until either there are no expressions left, or one of them evaluates to\n"
"``true''."
msgstr ""
"@code{or} (@pxref{and or})выполняет последовательность выражений в \n"
"порядке их следования, пока не останется выражений или в одном из них\n"
"результатом не будет значение ``true''."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:991
msgid ""
"@node About Closure\n"
"@section The Concept of Closure"
msgstr ""
"@node About Closure\n"
"@section Концепция Замыкания"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:993
msgid "@cindex closure"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:999
msgid ""
"The concept of @dfn{closure} is the idea that a lambda expression\n"
"``captures'' the variable bindings that are in lexical scope at the\n"
"point where the lambda expression occurs.  The procedure created by the\n"
"lambda expression can refer to and mutate the captured bindings, and the\n"
"values of those bindings persist between procedure calls."
msgstr ""
"Концепция замыкания @dfn{closure} состоит в том, что выражение лямбда\n"
"захватывает``captures'' свяазнные переменные лексической области в точке,\n"
"где определяется лямбда выражение. Процедура создания лямбда выражений,\n"
"может ссылаться или изменять захваченные связанные переменные, но значение\n"
"этих связанных переменных будет сохраняться между вызовами процедур."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1002
msgid ""
"This section explains and explores the various parts of this idea in\n"
"more detail."
msgstr ""
"В этом разделе более подробно рассматриваются  и анализируются\n"
"различные аспекты этой идеи."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1014
msgid ""
"@menu\n"
"* About Environments::          Names, locations, values and environments.\n"
"* Local Variables::             Local variables and local environments.\n"
"* Chaining::                    Environment chaining.\n"
"* Lexical Scope::               The meaning of lexical scoping.\n"
"* Closure::                     Explaining the concept of closure.\n"
"* Serial Number::               Example 1: a serial number generator.\n"
"* Shared Variable::             Example 2: a shared persistent variable.\n"
"* Callback Closure::            Example 3: the callback closure problem.\n"
"* OO Closure::                  Example 4: object orientation.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1017
msgid ""
"@node About Environments\n"
"@subsection Names, Locations, Values and Environments"
msgstr ""
"@node About Environments\n"
"@subsection Имена, Местоположение, Значения и Среды"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1023
msgid ""
"@cindex location\n"
"@cindex environment\n"
"@cindex vcell\n"
"@cindex top level environment\n"
"@cindex environment, top level"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1033
msgid ""
"We said earlier that a variable name in a Scheme program is associated\n"
"with a location in which any kind of Scheme value may be stored.\n"
"(Incidentally, the term ``vcell'' is often used in Lisp and Scheme\n"
"circles as an alternative to ``location''.)  Thus part of what we mean\n"
"when we talk about ``creating a variable'' is in fact establishing an\n"
"association between a name, or identifier, that is used by the Scheme\n"
"program code, and the variable location to which that name refers.\n"
"Although the value that is stored in that location may change, the\n"
"location to which a given name refers is always the same."
msgstr ""
"Ранее мы говорили, что имя переменной в программе Scheme связано\n"
"с местоположением в котором может храниться любое значение Scheme.\n"
"(Кстати, термин ``vcell'' часто используется в кругах Lisp и Scheme\n"
"в качестве альтернативы местоположению``location''.)  Таким образом\n"
"когда мы говорим о ``создании переменной'', фактически мы устанавливаем\n"
"связь между именем или идентификатором, который используется программным\n"
"кодом Scheme, и местоположением переменной которое относиться к этому\n"
"имени. Хотя значение, которое храниться в этом местоположении,\n"
"может измениться, место,на которое ссылается данное имя,\n"
"всегда одно и тоже."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1036
msgid ""
"We can illustrate this by breaking down the operation of the\n"
"@code{define} syntax into three parts: @code{define}"
msgstr ""
"Мы можем проилюстрировать это, разбив синтаксис определения\n"
"@code{define} на три части: @code{define}"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1040
msgid ""
"@itemize @bullet\n"
"@item\n"
"creates a new location"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"создает новое местоположение"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1044
msgid ""
"@item\n"
"establishes an association between that location and the name specified\n"
"as the first argument of the @code{define} expression"
msgstr ""
"@item\n"
"устанавливает связь между этим местоположением и именем, обозначенным\n"
"как первый аргумент выражения @code{define}"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1049
msgid ""
"@item\n"
"stores in that location the value obtained by evaluating the second\n"
"argument of the @code{define} expression.\n"
"@end itemize"
msgstr ""
"@item\n"
"сохраняет в этом местоположении, значение, полученное путем вычисления\n"
"второго аргумента выражения @code{define}.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1056
msgid ""
"A collection of associations between names and locations is called an\n"
"@dfn{environment}.  When you create a top level variable in a program\n"
"using @code{define}, the name-location association for that variable is\n"
"added to the ``top level'' environment.  The ``top level'' environment\n"
"also includes name-location associations for all the procedures that are\n"
"supplied by standard Scheme."
msgstr ""
"Набор ассоциаций между именами и местоположениями называется окружением\n"
"(средой)@dfn{environment}.  Когда вы создаете переменную верхнего уровня\n"
"в программе, используя @code{define}, ассоциация имя-местоположение для\n"
"этой переменной добавляется в окружение ``верхнего уровня''.  Кроме того,\n"
"окружение ``верхнего уровня'' включает ассоциации имя-местоположение для\n"
"всех процедур предоставляемых стандартной Scheme."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1061
msgid ""
"It is also possible to create environments other than the top level one,\n"
"and to create variable bindings, or name-location associations, in those\n"
"environments.  This ability is a key ingredient in the concept of\n"
"closure; the next subsection shows how it is done."
msgstr ""
"Также возможно создавать среды, отличные от верхнего уровня, и создавать\n"
"связанные переменные или ассоциации имя-местоположение в этих средах. Эта\n"
"способность является ключевым инградиентом в концепции замыкания; В "
"следующем\n"
"подразделе показывается как это делается."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1065
msgid ""
"@node Local Variables\n"
"@subsection Local Variables and Environments"
msgstr ""
"@node Local Variables\n"
"@subsection Локальные Переменные и Окружающая Среда"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1070
msgid ""
"@cindex local variable\n"
"@cindex variable, local\n"
"@cindex local environment\n"
"@cindex environment, local"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1079
msgid ""
"We have seen how to create top level variables using the @code{define}\n"
"syntax (@pxref{Definition}).  It is often useful to create variables\n"
"that are more limited in their scope, typically as part of a procedure\n"
"body.  In Scheme, this is done using the @code{let} syntax, or one of\n"
"its modified forms @code{let*} and @code{letrec}.  These syntaxes are\n"
"described in full later in the manual (@pxref{Local Bindings}).  Here\n"
"our purpose is to illustrate their use just enough that we can see how\n"
"local variables work."
msgstr ""
"Мы видели, как создавать переменные верхнего уровня с помощью синтаксиса\n"
"@code{define} см. (@pxref{Definition}).  Часто бывает полезно создавать\n"
"переменные, которые были бы ограничены в своем конексте, как правило,\n"
"частью тела процедуры. В Scheme это делается с использованием синтаксиса\n"
"@code{let}, или его модифицированной формы @code{let*} или @code{letrec}.\n"
"Эти синтаксисы описаны полностью дальше в руководстве см. (@pxref{Local "
"Bindings}).\n"
"Здесь наша цель - проилюстрировать их использование, чтобы мы могли видеть,\n"
"как работают локальные переменные."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1083
msgid ""
"For example, the following code uses a local variable @code{s} to\n"
"simplify the computation of the area of a triangle given the lengths of\n"
"its three sides."
msgstr ""
"Например, следующий код использует локальную перменную @code{s}, чтобы\n"
"упростить вычисление площади треугоальника по трем сторонам."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1088
msgid ""
"@lisp\n"
"(define a 5.3)\n"
"(define b 4.7)\n"
"(define c 2.8)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1093
msgid ""
"(define area\n"
"  (let ((s (/ (+ a b c) 2)))\n"
"    (sqrt (* s (- s a) (- s b) (- s c)))))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1102
msgid ""
"The effect of the @code{let} expression is to create a new environment\n"
"and, within this environment, an association between the name @code{s}\n"
"and a new location whose initial value is obtained by evaluating\n"
"@code{(/ (+ a b c) 2)}.  The expressions in the body of the @code{let},\n"
"namely @code{(sqrt (* s (- s a) (- s b) (- s c)))}, are then evaluated\n"
"in the context of the new environment, and the value of the last\n"
"expression evaluated becomes the value of the whole @code{let}\n"
"expression, and therefore the value of the variable @code{area}."
msgstr ""
"Эфектом от выражения @code{let} является создание новой окружающей среды и\n"
"в рамках этой среды устанавливается связь межуд именем @code{s}\n"
"и новым местоположением, начальное значение которого получено вычислением\n"
"@code{(/ (+ a b c) 2)}.  Выражения в теле @code{let}, а именно \n"
"@code{(sqrt (* s (- s a) (- s b) (- s c)))}, затем вычисляются в \n"
"контексте новой окружающей среды и значение последнего вычисленного\n"
"выражения становяться значением всего выражения @code{let}, и "
"следовательно,\n"
"значением всей вычисленной переменной  @code{area}."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1106
msgid ""
"@node Chaining\n"
"@subsection Environment Chaining"
msgstr ""
"@node Chaining\n"
"@subsection Цепочка Окружений"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1109
msgid ""
"@cindex shadowing an imported variable binding\n"
"@cindex chaining environments"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1118
msgid ""
"In the example of the previous subsection, we glossed over an important\n"
"point.  The body of the @code{let} expression in that example refers not\n"
"only to the local variable @code{s}, but also to the top level variables\n"
"@code{a}, @code{b}, @code{c} and @code{sqrt}.  (@code{sqrt} is the\n"
"standard Scheme procedure for calculating a square root.)  If the body\n"
"of the @code{let} expression is evaluated in the context of the\n"
"@emph{local} @code{let} environment, how does the evaluation get at the\n"
"values of these top level variables?"
msgstr ""
"В примере предыдущего подраздела мы скрыли важный момент. Тело выражения\n"
"@code{let} в этом примере, относится не только к локальной переменной "
"@code{s},\n"
"но также к переменным верхнего уровня @code{a}, @code{b}, @code{c} и "
"@code{sqrt}.\n"
"(@code{sqrt} стандартная процедура Scheme для вычисления квадратного "
"корня.)\n"
"Если тело выражения @code{let} вычислятеся в контексте локальной среды "
"@code{let},\n"
"как  вычислитель получает значения этих переменных верхнего уровня?"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1129
msgid ""
"The answer is that the local environment created by a @code{let}\n"
"expression automatically has a reference to its containing environment\n"
"--- in this case the top level environment --- and that the Scheme\n"
"interpreter automatically looks for a variable binding in the containing\n"
"environment if it doesn't find one in the local environment.  More\n"
"generally, every environment except for the top level one has a\n"
"reference to its containing environment, and the interpreter keeps\n"
"searching back up the chain of environments --- from most local to top\n"
"level --- until it either finds a variable binding for the required\n"
"identifier or exhausts the chain."
msgstr ""
"Ответ заключается в том. что локальная среда, созданная автоматически\n"
"выражением @code{let} содержит ссылку на среду его содержащую - \n"
"в данном случае, среду верхнего уровня --- и интерпрететор Scheme\n"
"автоматически ищет связанные переменные в среде верхнего уровня, \n"
"если он не находит их в локальном окружении.  В более общем\n"
"плане, каждая среда, за исключением верхнего уровня, имеет ссылку на\n"
"содержащую ее среду, а интерпретатор осущетствляет обратный поиск\n"
"по цепочке окружений из локального уровня до верхнего уровня, пока\n"
"не найдет связанную переменную для требуемого идентификатора или\n"
"не пройдет всю цепь."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1134
msgid ""
"This description also determines what happens when there is more than\n"
"one variable binding with the same name.  Suppose, continuing the\n"
"example of the previous subsection, that there was also a pre-existing\n"
"top level variable @code{s} created by the expression:"
msgstr ""
"Это описание также определяет, что происходит, когда имеется более\n"
"одной переменной связанных с одинаковым имеменем. предположим, что\n"
"(продолжая пример предыдущего подраздела) уже существовала пермеменная\n"
"верхнего уровня @code{s} созданная выражением:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1138
msgid ""
"@lisp\n"
"(define s \"Some beans, my lord!\")\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1149
msgid ""
"Then both the top level environment and the local @code{let} environment\n"
"would contain bindings for the name @code{s}.  When evaluating code\n"
"within the @code{let} body, the interpreter looks first in the local\n"
"@code{let} environment, and so finds the binding for @code{s} created by\n"
"the @code{let} syntax.  Even though this environment has a reference to\n"
"the top level environment, which also has a binding for @code{s}, the\n"
"interpreter doesn't get as far as looking there.  When evaluating code\n"
"outside the @code{let} body, the interpreter looks up variable names in\n"
"the top level environment, so the name @code{s} refers to the top level\n"
"variable."
msgstr ""
"Тогда и среда верхнего уровня, и среда локального @code{let} будут "
"содержать\n"
"связанные значения с именем @code{s}.  При вычислении кода внутри тела\n"
"@code{let}, интерпретатор смотрит сначала локальную среду @code{let}, и\n"
"поэтому находит привязку для @code{s} созданную синтаксисом @code{let}\n"
"Несмотря на то, что среда имеет ссылку на среду верхнего уровня, которая\n"
"также имеет связанную переменную с именем @code{s}, интерпретатор не\n"
"доходт до того чтобы искать ее там. При вычислении кода вне тела "
"@code{let},\n"
"интерпретатор ищет имена переменных в среде верхнего уровня, поэтому\n"
"имя переменной @code{s} относится к переменной верхнего уровня."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1153
msgid ""
"Within the @code{let} body, the binding for @code{s} in the local\n"
"environment is said to @dfn{shadow} the binding for @code{s} in the top\n"
"level environment."
msgstr ""
"Говорят, что внутри тела @code{let}, связывание для переменной @code{s} в\n"
"локальной среде скрывает @dfn{shadow} связанную переменную @code{s} в\n"
"среде верхнего уровня."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1157
msgid ""
"@node Lexical Scope\n"
"@subsection Lexical Scope"
msgstr ""
"@node Lexical Scope\n"
"@subsection Лексическая Область видимости"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1162
msgid ""
"The rules that we have just been describing are the details of how\n"
"Scheme implements ``lexical scoping''.  This subsection takes a brief\n"
"diversion to explain what lexical scope means in general and to present\n"
"an example of non-lexical scoping."
msgstr ""
"Правила, которые мы только что описали --- это детали того, как Scheme \n"
"реализует ``лексическую область видимости''.  В этом подразделе делается\n"
"краткое введение, чтобы объяснить, что означает лексическая область\n"
"видимости вообще и представляется пример не лексической области видимости."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1164
msgid "``Lexical scope'' in general is the idea that"
msgstr "``Лексическая область видимости'' в целом --- это идея о том, что"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1170
msgid ""
"@itemize @bullet\n"
"@item\n"
"an identifier at a particular place in a program always refers to the\n"
"same variable location --- where ``always'' means ``every time that the\n"
"containing expression is executed'', and that"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"идентификатор в определенном месте в программе ``всегда'' ссылается на одно "
"и\n"
"тоже местоположение переменной --- где ``всегда'' означает ``каждый раз, "
"когда\n"
"выполняется содержащее его выражение'', и что"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1177
msgid ""
"@item\n"
"the variable location to which it refers can be determined by static\n"
"examination of the source code context in which that identifier appears,\n"
"without having to consider the flow of execution through the program as\n"
"a whole.\n"
"@end itemize"
msgstr ""
"@item\n"
"местоположение переменной, на которое она ссылается, может быть определено\n"
"статическим исследованием контекста исходного кода, в котором отображается\n"
"этот идентификатор, без необходимости рассматривать поток исполнения\n"
"программы в целом.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1186
msgid ""
"In practice, lexical scoping is the norm for most programming languages,\n"
"and probably corresponds to what you would intuitively consider to be\n"
"``normal''.  You may even be wondering how the situation could possibly\n"
"--- and usefully --- be otherwise.  To demonstrate that another kind of\n"
"scoping is possible, therefore, and to compare it against lexical\n"
"scoping, the following subsection presents an example of non-lexical\n"
"scoping and examines in detail how its behavior differs from the\n"
"corresponding lexically scoped code."
msgstr ""
"На практике лексическая область видимости является нормой для большинства\n"
"языков программирования и, вероятно, соответствует тому, что вы интуитивно\n"
"считаете ``нормальным''.  Вы даже может быть задаться вопросмо, как может\n"
"возникнуть иная ситуация и чем она может быть полезна.  Поэтому мы \n"
"продемонстрируем возможную ситуацию иной области видимости и сравним\n"
"ее с лексической областью видимости. В следующем разделе представлен\n"
"пример нелексической области видимости и подробно рассматривается как\n"
"его поведение отличается от соответствующего кода с лексической областью\n"
"видимости."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1190
msgid ""
"@menu\n"
"* Scoping Example::             An example of non-lexical scoping.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1194
msgid ""
"@node Scoping Example\n"
"@subsubsection An Example of Non-Lexical Scoping"
msgstr ""
"@node Scoping Example\n"
"@subsubsection Пример не Лексической области видимости"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1198
msgid ""
"To demonstrate that non-lexical scoping does exist and can be useful, we\n"
"present the following example from Emacs Lisp, which is a ``dynamically\n"
"scoped'' language."
msgstr ""
"Чтобы продемонстрировать, что нелексическая область видимости существует\n"
"и может быть полезна, мы приводим следующий пример из языка Emacs Lisp, \n"
"который является языком с ``динамической областью видмости''."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1201
msgid ""
"@lisp\n"
"(defvar currency-abbreviation \"USD\")"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1207
msgid ""
"(defun currency-string (units hundredths)\n"
"  (concat currency-abbreviation\n"
"          (number-to-string units)\n"
"          \".\"\n"
"          (number-to-string hundredths)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1212
msgid ""
"(defun french-currency-string (units hundredths)\n"
"  (let ((currency-abbreviation \"FRF\"))\n"
"    (currency-string units hundredths)))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1222
msgid ""
"The question to focus on here is: what does the identifier\n"
"@code{currency-abbreviation} refer to in the @code{currency-string}\n"
"function?  The answer, in Emacs Lisp, is that all variable bindings go\n"
"onto a single stack, and that @code{currency-abbreviation} refers to the\n"
"topmost binding from that stack which has the name\n"
"``currency-abbreviation''.  The binding that is created by the\n"
"@code{defvar} form, to the value @code{\"USD\"}, is only relevant if none\n"
"of the code that calls @code{currency-string} rebinds the name\n"
"``currency-abbreviation'' in the meanwhile."
msgstr ""
"Здесь нужно сосредоточиться на вопросе: что означает идентификатор\n"
"@code{currency-abbreviation} в функции @code{currency-string}?\n"
"Ответ в Emacs Lisp заключается в том, что все связанные переменные\n"
"переходят в единый стек, и @code{currency-abbreviation} означается \n"
"как верхняя привязка из этого стека, которая имеет название \n"
"``currency-abbreviation''.  Связывание, которое создается формой \n"
"@code{defvar} с значением @code{\"USD\"}, имеет значение только в том\n"
"случае, если ни один операто из кода, который вызвал @code{currency-string}\n"
"не переопределит ``currency-abbreviation''."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1227
msgid ""
"The second function @code{french-currency-string} works precisely by\n"
"taking advantage of this behaviour.  It creates a new binding for the\n"
"name ``currency-abbreviation'' which overrides the one established by\n"
"the @code{defvar} form."
msgstr ""
"Вторая функция @code{french-currency-string} работает точно так используя\n"
"это поведение.  Она создает новую привязку для имени ``currency-"
"abbreviation''\n"
"которая переопределяет ту, которая была установлена формой @code{defvar}."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1234
msgid ""
"@lisp\n"
";; Note!  This is Emacs Lisp evaluation, not Scheme!\n"
"(french-currency-string 33 44)\n"
"@result{}\n"
"\"FRF33.44\"\n"
"@end lisp"
msgstr ""
"@lisp\n"
";; Замечание!!! Выполнение Emacs Lisp, а не Scheme!\n"
"(french-currency-string 33 44)\n"
"@result{}\n"
"\"FRF33.44\"\n"
"@end lisp"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1237
msgid ""
"Now let's look at the corresponding, @emph{lexically scoped} Scheme\n"
"code:"
msgstr ""
"Теперь давайте посмотрим на соотвествующий код, выполняющийся\n"
"в соответствии с лекической областью видимостью в Scheme:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1240
msgid ""
"@lisp\n"
"(define currency-abbreviation \"USD\")"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1246
msgid ""
"(define (currency-string units hundredths)\n"
"  (string-append currency-abbreviation\n"
"                 (number->string units)\n"
"                 \".\"\n"
"                 (number->string hundredths)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1251
msgid ""
"(define (french-currency-string units hundredths)\n"
"  (let ((currency-abbreviation \"FRF\"))\n"
"    (currency-string units hundredths)))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1258
msgid ""
"According to the rules of lexical scoping, the\n"
"@code{currency-abbreviation} in @code{currency-string} refers to the\n"
"variable location in the innermost environment at that point in the code\n"
"which has a binding for @code{currency-abbreviation}, which is the\n"
"variable location in the top level environment created by the preceding\n"
"@code{(define currency-abbreviation @dots{})} expression."
msgstr ""
"Согласно правилам лексической области видимости, имя \n"
"@code{currency-abbreviation} в @code{currency-string} ссылается на\n"
"местоположение переменной в самом ближайшем окружении к точке кода,\n"
"который выполняет связываение для @code{currency-abbreviation}, данное\n"
"расположение переменной задано на верхнем уровне окружения выражением:\n"
"@code{(define currency-abbreviation @dots{})}."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1264
msgid ""
"In Scheme, therefore, the @code{french-currency-string} procedure does\n"
"not work as intended.  The variable binding that it creates for\n"
"``currency-abbreviation'' is purely local to the code that forms the\n"
"body of the @code{let} expression.  Since this code doesn't directly use\n"
"the name ``currency-abbreviation'' at all, the binding is pointless."
msgstr ""
"Поэтому в Scheme, процедура @code{french-currency-string} не будет\n"
"работать должным образом.  Связываение переменных создаваемое для\n"
"``currency-abbreviation'' является чисто локальным кодом, который\n"
"формирует тело выражения @code{let}.  Поскольку этот код напрямую\n"
"не использует имя ``currency-abbreviation'' нигде, это связывание\n"
"бессмысленно."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1270
msgid ""
"@lisp\n"
"(french-currency-string 33 44)\n"
"@result{}\n"
"\"USD33.44\"\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1278
msgid ""
"This begs the question of how the Emacs Lisp behaviour can be\n"
"implemented in Scheme.  In general, this is a design question whose\n"
"answer depends upon the problem that is being addressed.  In this case,\n"
"the best answer may be that @code{currency-string} should be\n"
"redesigned so that it can take an optional third argument.  This third\n"
"argument, if supplied, is interpreted as a currency abbreviation that\n"
"overrides the default."
msgstr ""
"Это ставит вопрос, как поведение Emacs Lisp может быть реализовано на\n"
"Scheme.  В общем, это вопрос дизайна, ответ на которй зависит от адресата.\n"
"В даном случае, лучшим ответом могбы быть тот, что  @code{currency-string} \n"
"должна принимать необязательный третий аргумент.  Этот третий аргумент,\n"
"если он представлен, интерпретируется как абревиатура валюты, которая "
"отменяет\n"
"значение по умолчанию."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1283
msgid ""
"It is possible to change @code{french-currency-string} so that it mostly\n"
"works without changing @code{currency-string}, but the fix is inelegant,\n"
"and susceptible to interrupts that could leave the\n"
"@code{currency-abbreviation} variable in the wrong state:"
msgstr ""
"Можно изменить @code{french-currency-string} чтобы она изменяла основную\n"
"@code{currency-string}, но эти изменения не будут элегантными и \n"
"устойчивыми к прерываниям, которые могут преревести \n"
"@code{currency-abbreviation} в некорректное состояние:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1291
msgid ""
"@lisp\n"
"(define (french-currency-string units hundredths)\n"
"  (set! currency-abbreviation \"FRF\")\n"
"  (let ((result (currency-string units hundredths)))\n"
"    (set! currency-abbreviation \"USD\")\n"
"    result))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1295
msgid ""
"The key point here is that the code does not create any local binding\n"
"for the identifier @code{currency-abbreviation}, so all occurrences of\n"
"this identifier refer to the top level variable."
msgstr ""
"Ключевым моментом здесь является то, что код не создает никакой локальной\n"
"привязки для идентификатора @code{currency-abbreviation}, так что все "
"изменения\n"
"относятся к пермеменной верхнего уровня."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1299
msgid ""
"@node Closure\n"
"@subsection Closure"
msgstr ""
"@node Closure\n"
"@subsection Замыкания"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1302
msgid ""
"Consider a @code{let} expression that doesn't contain any\n"
"@code{lambda}s:"
msgstr ""
"Рассмотрим выражение a @code{let}, которое не содержит никаких\n"
"@code{lambda}s:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1307
msgid ""
"@lisp\n"
"(let ((s (/ (+ a b c) 2)))\n"
"  (sqrt (* s (- s a) (- s b) (- s c))))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1310
msgid ""
"@noindent\n"
"When the Scheme interpreter evaluates this, it"
msgstr ""
"@noindent\n"
"Когда интерпретатор Scheme вычисляет это, он"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1315
msgid ""
"@itemize @bullet\n"
"@item\n"
"creates a new environment with a reference to the environment that was\n"
"current when it encountered the @code{let}"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"создает новую окружающую среду со ссылкой на среду, которая была до\n"
"того как ему встретилось выражение @code{let}"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1319
msgid ""
"@item\n"
"creates a variable binding for @code{s} in the new environment, with\n"
"value given by @code{(/ (+ a b c) 2)}"
msgstr ""
"@item\n"
"создает связанную пермеменную для @code{s} в новом окружении, со значением\n"
"задаваемым выражением @code{(/ (+ a b c) 2)}"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1323
msgid ""
"@item\n"
"evaluates the expression in the body of the @code{let} in the context of\n"
"the new local environment, and remembers the value @code{V}"
msgstr ""
"@item\n"
"вычисляет выражение в теле @code{let} в контексте нового локального\n"
"окружения и запоминает значение  @code{V}, последнего выполненого выражения."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1326
msgid ""
"@item\n"
"forgets the local environment"
msgstr "забывает локальное окружение."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1332
msgid ""
"@item\n"
"continues evaluating the expression that contained the @code{let}, using\n"
"the value @code{V} as the value of the @code{let} expression, in the\n"
"context of the containing environment.\n"
"@end itemize"
msgstr ""
"@item\n"
"продолжает выполнять выражения, содержащее @code{let}, используя\n"
"значение @code{V} как значение выражения @code{let}, в контексте\n"
"содержащей его среды.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1339
msgid ""
"After the @code{let} expression has been evaluated, the local\n"
"environment that was created is simply forgotten, and there is no longer\n"
"any way to access the binding that was created in this environment.  If\n"
"the same code is evaluated again, it will follow the same steps again,\n"
"creating a second new local environment that has no connection with the\n"
"first, and then forgetting this one as well."
msgstr ""
"После того, как выражение @code{let} было вычислено, созданная локальная\n"
"среда просто забывается, и пропадает доступ ко всем связанным в нем "
"переменным.\n"
"Если один и тот же код будет снова выполнен, он будет повторять те же шаги,\n"
"создавая вторую новую локальную среду, не с связанную с первой, а затем\n"
"снова забывая о ней."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1345
msgid ""
"If the @code{let} body contains a @code{lambda} expression, however, the\n"
"local environment is @emph{not} forgotten.  Instead, it becomes\n"
"associated with the procedure that is created by the @code{lambda}\n"
"expression, and is reinstated every time that that procedure is called.\n"
"In detail, this works as follows."
msgstr ""
"Однако, если тело @code{let} содержит  @code{lambda} выражение, то "
"локальная\n"
"среда не является забытой.  Вместо этого, она становиться связанной с \n"
"процедурой, созданной @code{lambda} выражением, и востанавливается каждый\n"
"раз, когда вызывается эта процедура. В деталях это работает следующим "
"образом..."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1351
msgid ""
"@itemize @bullet\n"
"@item\n"
"When the Scheme interpreter evaluates a @code{lambda} expression, to\n"
"create a procedure object, it stores the current environment as part of\n"
"the procedure definition."
msgstr ""
"@itemize @bullet\n"
"@item\n"
"Когда интерпретатор Scheme вычисляет @code{lambda} выражение, чтобы\n"
"создать процедурный объект, он сохраняет текущую среду как часть\n"
"определения процедуры."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1357
msgid ""
"@item\n"
"Then, whenever that procedure is called, the interpreter reinstates the\n"
"environment that is stored in the procedure definition and evaluates the\n"
"procedure body within the context of that environment.\n"
"@end itemize"
msgstr ""
"@item\n"
"Затем, всякий раз, когда процедура вызывается, интерпретатор "
"восстанавливает \n"
"среду которая храниться в определении процедуры и вычисляет тело процедуры\n"
"в пределах контекста этой среды.\n"
"@end itemize"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1360
msgid ""
"The result is that the procedure body is always evaluated in the context\n"
"of the environment that was current when the procedure was created."
msgstr ""
"В результате тело процедуры вычисляется в контексте среды которая\n"
"была актуальна, когда эта процедура создавалась."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1363
msgid ""
"This is what is meant by @dfn{closure}.  The next few subsections\n"
"present examples that explore the usefulness of this concept."
msgstr ""
"Это и есть то что мы называем замыкание @dfn{closure}.  В следущих\n"
"нескольких подразделах представлены примеры, которые исследуют\n"
"полезность этой концепции."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1367
msgid ""
"@node Serial Number\n"
"@subsection Example 1: A Serial Number Generator"
msgstr ""
"@node Serial Number\n"
"@subsection Пример 1: Генератор последовательности чисел"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1371
msgid ""
"This example uses closure to create a procedure with a variable binding\n"
"that is private to the procedure, like a local variable, but whose value\n"
"persists between procedure calls."
msgstr ""
"В этом примере используется замыкание для создания процедуры которая\n"
"является внутренней для данной процедуры, как локальная переменная, но\n"
"значение которой сохраняется между вызовами процедур."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1378
msgid ""
"@lisp\n"
"(define (make-serial-number-generator)\n"
"  (let ((current-serial-number 0))\n"
"    (lambda ()\n"
"      (set! current-serial-number (+ current-serial-number 1))\n"
"      current-serial-number)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1380
msgid "(define entry-sn-generator (make-serial-number-generator))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1384
msgid ""
"(entry-sn-generator)\n"
"@result{}\n"
"1"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1389
msgid ""
"(entry-sn-generator)\n"
"@result{}\n"
"2\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1395
msgid ""
"When @code{make-serial-number-generator} is called, it creates a local\n"
"environment with a binding for @code{current-serial-number} whose\n"
"initial value is 0, then, within this environment, creates a procedure.\n"
"The local environment is stored within the created procedure object and\n"
"so persists for the lifetime of the created procedure."
msgstr ""
"Когда вызывается @code{make-serial-number-generator}, он создает локальную\n"
"среду со связанной переменной с именем @code{current-serial-number} "
"начальное\n"
"значение которой равно 0, в этой среде создается процедура. Локальная среда\n"
"храниться в созданном объекте процедуры и поэтому сохраняется на протяжении\n"
"жизни созданной процедуры."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1399
msgid ""
"Every time the created procedure is invoked, it increments the value of\n"
"the @code{current-serial-number} binding in the captured environment and\n"
"then returns the current value."
msgstr ""
"Каждый раз, когда вызывается созданная процедура, она увеличивает значение\n"
"связанной переменной @code{current-serial-number} в захваченной среде,\n"
"а затем возвращает текущее значение."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1405
msgid ""
"Note that @code{make-serial-number-generator} can be called again to\n"
"create a second serial number generator that is independent of the\n"
"first.  Every new invocation of @code{make-serial-number-generator}\n"
"creates a new local @code{let} environment and returns a new procedure\n"
"object with an association to this environment."
msgstr ""
"Обратите внимание, что @code{make-serial-number-generator} можно вызвать\n"
"снова, чтобы создать второй генератор последовательных чисел, который\n"
"независит от первого. Каждый новый вызов @code{make-serial-number-"
"generator}\n"
"создает новую локальную среду @code{let} и возвращает новый объект "
"процедуры\n"
"ассоциированный с этой средой."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1409
msgid ""
"@node Shared Variable\n"
"@subsection Example 2: A Shared Persistent Variable"
msgstr ""
"@node Shared Variable\n"
"@subsection Пример 2: Общая статическая переменная."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1415
msgid ""
"This example uses closure to create two procedures, @code{get-balance}\n"
"and @code{deposit}, that both refer to the same captured local\n"
"environment so that they can both access the @code{balance} variable\n"
"binding inside that environment.  The value of this variable binding\n"
"persists between calls to either procedure."
msgstr ""
"В этом примере используется замыкание, чтобы создать две процедуры\n"
"@code{get-balance} и @code{deposit}, которые обращаются к одной\n"
"и той же локальной среде, чтобы обеспечить доступ к связанной\n"
"перменной @code{balance} определенной внутри это локальной среды.\n"
"Значение этой связанной переменной сохраняется между вызовами\n"
"этих процедур."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1420
msgid ""
"Note that the captured @code{balance} variable binding is private to\n"
"these two procedures: it is not directly accessible to any other code.\n"
"It can only be accessed indirectly via @code{get-balance} or\n"
"@code{deposit}, as illustrated by the @code{withdraw} procedure."
msgstr ""
"Обратите внимание, что связанная перемеменная @code{balance} является\n"
"частной для этих двух процедур: она на прямую не доступна для любого\n"
"другого кода. Доступ к ней можно получить косвенно только через\n"
"@code{get-balance} или @code{deposit}, как это показано\n"
"в процедуре @code{withdraw}."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1424
msgid ""
"@lisp\n"
"(define get-balance #f)\n"
"(define deposit #f)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1433
msgid ""
"(let ((balance 0))\n"
"  (set! get-balance\n"
"        (lambda ()\n"
"          balance))\n"
"  (set! deposit\n"
"        (lambda (amount)\n"
"          (set! balance (+ balance amount))\n"
"          balance)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1436
msgid ""
"(define (withdraw amount)\n"
"  (deposit (- amount)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1440
msgid ""
"(get-balance)\n"
"@result{}\n"
"0"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1444
msgid ""
"(deposit 50)\n"
"@result{}\n"
"50"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1449
msgid ""
"(withdraw 75)\n"
"@result{}\n"
"-25\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1456
msgid ""
"An important detail here is that the @code{get-balance} and\n"
"@code{deposit} variables must be set up by @code{define}ing them at top\n"
"level and then @code{set!}ing their values inside the @code{let} body.\n"
"Using @code{define} within the @code{let} body would not work: this\n"
"would create variable bindings within the local @code{let} environment\n"
"that would not be accessible at top level."
msgstr ""
"Важная деталь здесь заключается в том, что должны быть установлены\n"
"переменные @code{get-balance} и  @code{deposit} определенные \n"
"на верхнем уровне с помощью @code{define}, а затем установлены\n"
"с помощью @code{set!} внутри тела @code{let}. Использование \n"
"@code{define} внутри тела  @code{let} работать не будет: это\n"
"создало бы связанные переменные внутри локальной среды @code{let}, \n"
"которая будет недоступной на верхнем уровне."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1460
msgid ""
"@node Callback Closure\n"
"@subsection Example 3: The Callback Closure Problem"
msgstr ""
"@node Callback Closure\n"
"@subsection Пример 3: Проблема замыкания обратного вызова"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1469
msgid ""
"A frequently used programming model for library code is to allow an\n"
"application to register a callback function for the library to call when\n"
"some particular event occurs.  It is often useful for the application to\n"
"make several such registrations using the same callback function, for\n"
"example if several similar library events can be handled using the same\n"
"application code, but the need then arises to distinguish the callback\n"
"function calls that are associated with one callback registration from\n"
"those that are associated with different callback registrations."
msgstr ""
"Часто используемая модель программирования для библиотечного кода ---\n"
"позволить приложению регистрировать функции обратного вызова для библиотеки\n"
"вызываемые при возникновении определенного события. Для приложения\n"
"зачастую полезно выполнить несколько таких регистраций, используя одну\n"
"и туже функцию обратного вызова, для например если несколько похожих\n"
"событий библиотеки могут обрабатываться с использованием одного и того\n"
"же кода приложения, но тогда возникает необходимость различать вызовы\n"
"функций обратного вызова, которые связаны  с одной регистрацией\n"
"обратного вызова, от тех которые связаны с другой регистрацией\n"
"обратного вызова."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1475
msgid ""
"In languages without the ability to create functions dynamically, this\n"
"problem is usually solved by passing a @code{user_data} parameter on the\n"
"registration call, and including the value of this parameter as one of\n"
"the parameters on the callback function.  Here is an example of\n"
"declarations using this solution in C:"
msgstr ""
"В языках, не имеющих возможности динамически создавать функции, эта\n"
"проблема обычно решается путем передачи параметра @code{user_data}\n"
"при регистрации вызова и включения значения этого параметра в качестве\n"
"одного из параметров функции обратного вызова. Вот пример объявления\n"
"с использованием этого решения на Си:"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1479
msgid ""
"@example\n"
"typedef void (event_handler_t) (int event_type,\n"
"                                void *user_data);"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1484
msgid ""
"void register_callback (int event_type,\n"
"                        event_handler_t *handler,\n"
"                        void *user_data);\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1488
msgid ""
"In Scheme, closure can be used to achieve the same functionality without\n"
"requiring the library code to store a @code{user-data} for each callback\n"
"registration."
msgstr ""
"В Scheme, замыкание может использоваться для достижения такой же "
"функциональности,\n"
"не используя библиотечный код для хранения пользовательских данных "
"@code{user-data}\n"
"для регистрации обратного вызова."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1491
msgid ""
"@lisp\n"
";; In the library:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1494
msgid ""
"(define (register-callback event-type handler-proc)\n"
"  @dots{})"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1496
msgid ";; In the application:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1502
msgid ""
"(define (make-handler event-type user-data)\n"
"  (lambda ()\n"
"    @dots{}\n"
"    <code referencing event-type and user-data>\n"
"    @dots{}))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1506
msgid ""
"(register-callback event-type\n"
"                   (make-handler event-type @dots{}))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1514
msgid ""
"As far as the library is concerned, @code{handler-proc} is a procedure\n"
"with no arguments, and all the library has to do is call it when the\n"
"appropriate event occurs.  From the application's point of view, though,\n"
"the handler procedure has used closure to capture an environment that\n"
"includes all the context that the handler code needs ---\n"
"@code{event-type} and @code{user-data} --- to handle the event\n"
"correctly."
msgstr ""
"Что касается библиотеки, @code{handler-proc} это процедура без аргументов,\n"
"и все что нужно сделать библиотеке, это вызвать его когда произойдет\n"
"соответствующее событие. В приложения однако, однако процедура обработчика\n"
"использует замыкание для захвата среды, которая включает в себя весь \n"
"контекст, который требуется коду обработчика ---\n"
"@code{event-type} и @code{user-data} --- для правильной обработки\n"
"события."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1518
msgid ""
"@node OO Closure\n"
"@subsection Example 4: Object Orientation"
msgstr ""
"@node OO Closure\n"
"@subsection Пример 4: Объектная Ориентация"

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1526
msgid ""
"Closure is the capture of an environment, containing persistent variable\n"
"bindings, within the definition of a procedure or a set of related\n"
"procedures.  This is rather similar to the idea in some object oriented\n"
"languages of encapsulating a set of related data variables inside an\n"
"``object'', together with a set of ``methods'' that operate on the\n"
"encapsulated data.  The following example shows how closure can be used\n"
"to emulate the ideas of objects, methods and encapsulation in Scheme."
msgstr ""
"Замыкание --- это захыват среды, содержащей постоянные связанные \n"
"переменные, внутри определения процедуры или набора связанных процедур.\n"
"Это довольно похоже на идею в некоторых объектно-ориентированных языках,\n"
"инкапсуляции набора связанных переменных внутри ``объекта'', вместе с\n"
"набором ``методов'' которые работают с инкапсулированными данными.\n"
"Следующий пример показывает, как замыкание можно использовать для\n"
"эмуляции идеи объектов, методов и инкапусуляции в Scheme."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1537
msgid ""
"@lisp\n"
"(define (make-account)\n"
"  (let ((balance 0))\n"
"    (define (get-balance)\n"
"      balance)\n"
"    (define (deposit amount)\n"
"      (set! balance (+ balance amount))\n"
"      balance)\n"
"    (define (withdraw amount)\n"
"      (deposit (- amount)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1547
msgid ""
"    (lambda args\n"
"      (apply\n"
"        (case (car args)\n"
"          ((get-balance) get-balance)\n"
"          ((deposit) deposit)\n"
"          ((withdraw) withdraw)\n"
"          (else (error \"Invalid method!\")))\n"
"        (cdr args)))))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1551
msgid ""
"Each call to @code{make-account} creates and returns a new procedure,\n"
"created by the expression in the example code that begins ``(lambda\n"
"args''."
msgstr ""
"Каждый вызов @code{make-account} создает и возвращает новую процедуру,\n"
"созданную выражением в коде примера, который начинается с: ``(lambda\n"
"args''."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1554
msgid ""
"@lisp\n"
"(define my-account (make-account))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1559
msgid ""
"my-account\n"
"@result{}\n"
"#<procedure args>\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1565
msgid ""
"This procedure acts as an account object with methods\n"
"@code{get-balance}, @code{deposit} and @code{withdraw}.  To apply one of\n"
"the methods to the account, you call the procedure with a symbol\n"
"indicating the required method as the first parameter, followed by any\n"
"other parameters that are required by that method."
msgstr ""
"Эта процедура действует как объект учетная запись(СЧЕТ) с методами\n"
"@code{get-balance}, @code{deposit} и @code{withdraw}.  Чтобы применить\n"
"один из методов к текущему СЧЕТу, вы вызываете процедуру с помощью\n"
"символа указывая требуемый метод в качестве первого параметра, за которым\n"
"следуют любые другие параметры, которые требуются этому методу."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1570
msgid ""
"@lisp\n"
"(my-account 'get-balance)\n"
"@result{}\n"
"0"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1574
msgid ""
"(my-account 'withdraw 5)\n"
"@result{}\n"
"-5"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1578
msgid ""
"(my-account 'deposit 396)\n"
"@result{}\n"
"391"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1583
msgid ""
"(my-account 'get-balance)\n"
"@result{}\n"
"391\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1589
msgid ""
"Note how, in this example, both the current balance and the helper\n"
"procedures @code{get-balance}, @code{deposit} and @code{withdraw}, used\n"
"to implement the guts of the account object's methods, are all stored in\n"
"variable bindings within the private local environment captured by the\n"
"@code{lambda} expression that creates the account object procedure."
msgstr ""
"Обратите внимание, в этом примере, как текущий баланс, так и "
"вспомогательные\n"
"процедуры @code{get-balance}, @code{deposit} и @code{withdraw}, "
"используемые\n"
"для реализации методов работающих с внутренним балансом, храняться в "
"переменных\n"
"связанных в закрытой локальной среде, захваченной выражением @code{lambda},\n"
"которе создает процедуру-объект --- СЧЕТ."

#: /home/bear/work/guile/doc/guile/en/scheme-ideas.texi:1593
msgid ""
"@c Local Variables:\n"
"@c TeX-master: \"guile.texi\"\n"
"@c End:"
msgstr ""
