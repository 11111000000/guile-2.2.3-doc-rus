@c -*-texinfo-*-
@c This is part of the GNU Guile Reference Manual.
@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2009, 2010,
@c   2011, 2012, 2013, 2014 Free Software Foundation, Inc.
@c See the file guile.texi for copying conditions.

@node Control Mechanisms
@section Управление потоком выполнения Программы

См. @ref{Control Flow} для обсуждения того, как более общий контроль потока
управления Scheme влияет на Си код.

@menu
* begin::                       Sequencing and splicing.
* Conditionals::                If, when, unless, case, and cond.
* and or::                      Conditional evaluation of a sequence.
* while do::                    Iteration mechanisms.
* Prompts::                     Composable, delimited continuations.
* Continuations::               Non-composable continuations.
* Multiple Values::             Returning and accepting multiple values.
* Exceptions::                  Throwing and catching exceptions.
* Error Reporting::             Procedures for signaling errors.
* Dynamic Wind::                Dealing with non-local entrance/exit.
* Fluids and Dynamic States::   Dynamic scope building blocks.
* Parameters::                  A dynamic scope facility.
* Handling Errors::             How to handle errors in C code.
* Continuation Barriers::       Protection from non-local control flow.
@end menu

@node begin
@subsection Последовательности(Sequencing) и Соедениения(Splicing)

@cindex begin
@cindex sequencing
@cindex expression sequencing

В качестве выражения, синтаксис @code{begin} исползуется для вычисления 
последовательности подвыражений в установленном порядке. Ниже рассмотрим
условное выражение:

@lisp
(if (> x 0)
    (begin (display "greater") (newline)))
@end lisp

Если test истинен, мы отобразим ``greater'' для текущего порта вывода,
а затем отобразим новую строку.  Мы используем @code{begin} для формирования
составного выражения из этой последовательности подвыражений.

@deffn syntax begin expr @dots{}
Выражение(я) вычисляются в порядке слева на право и значение последнего
выражения возвращается как значение выражения @code{begin}.  Этот тип
выражения используется когда выражения перед последним выражением выражением
вычисляются из за их "сторонних эффектов".
@end deffn

@cindex splicing
@cindex definition splicing

Синтаксис @code{begin} играет другую роль в контектсе определений
(@pxref{Internal Definitions}).  Форма @code{begin} в контексте
определений объединяет(@dfn{splices}) свои подчиненные формы в одном
месте. Например, рассмотрим следующую процедуру.:

@lisp
(define (make-seal)
  (define-sealant seal open)
  (values seal open))
@end lisp

Давайте предположим, что существует макрос @code{define-sealant} который
расширяется до некоторого определения обернутого в @code{begin}, подобно
этому:

@lisp
(define (make-seal)
  (begin
    (define seal-tag
      (list 'seal))
    (define (seal x)
      (cons seal-tag x))
    (define (sealed? x)
      (and (pair? x) (eq? (car x) seal-tag)))
    (define (open x)
      (if (sealed? x)
          (cdr x)
          (error "Expected a sealed value:" x))))
  (values seal open))
@end lisp

Здесь, посокльку @code{begin} находиться в контексте определения, его
подчиненные формы объединены(@dfn{spliced}) внутри @code{begin}.  Это
позволяет определениям, созданным макросом быть видимыми для последующих
выражений, формы @code{values}.

Это прекрасный момент, но соединение(splicing) и последовательность
(sequencing) отличаются. Может иметь смысл соединять нулевые формы,
потому что может иметь смысл иметь ноль внутренних определений перед
выражениями в процедуре или лексической форме связывания.  Однако не 
имеет смысла иметь последовательность нулевых выражений, потому что
в этом случае не было бы понятно, какое значение должна иметь 
последовательность, поскольку в последовательности нулевых выражений
не может быть последнего значения.  Последовательность нулевых
выражений является ошибкой.

В некотором смысле было бы более элегантно устранить объединение(splicing)
из языка Scheme, и без макросов (@pxref{Macros}), это было бы хорошей идеей.
Но полезно иметь возможность писать макросы, которые расширяются до множественных
определений, как в @code{define-sealant} выше, поэтому Scheme
злоупотребляет формой @code{begin} для этих двух задач.

@node Conditionals
@subsection Простое Условное Вычисление

@cindex conditional evaluation
@cindex if
@cindex when
@cindex unless
@cindex case
@cindex cond

Guile предоставляет три синтаксические конструкции для условных вычислений.
@code{if} это обычное выражение if-then-else (с необязательной ветвью else),
@code{cond} является условным выражением с множеством ветвей и 
@code{case} выбирающее ветвь, если ключевое выражение имеет значение из набора 
константных значений в ветвях.

@deffn syntax if test consequent [alternate]
Все аргументы могут быть произвольными выражениями.  Сначала,
вычисляется @var{test}.  Если он возвращает истинное значение, вычисляется
выражение @var{consequent}, а @var{alternate} игнорируется.  Если @var{test}
вычисляется в значение @code{#f}, вычисляется только @var{alternate}.  Значения
вычисляемой ветви (@var{consequent} или @var{alternate}) возвращаются как значения
выражения @code{if}.

Когда @var{alternate} пропущена и @var{test} вычисляется в @code{#f},
значение выражения не определено.
@end deffn

Когда вы идете на написание @code{if} без альтернативы (однорукое условие
@dfn{one-armed @code{if}}), вас не волнует, возвращаемое значение(значения)
возвращаемые этим выражением. Таким образом, вас больше интересует
эффект(@emph{effect}) от вычисления последующего(consequent) выражения.
(По соглашени, мы используем слово оператор(@dfn{statement}) для ссылки на выражение
которое вычисляется ради эффекта, а не ради значения).

В таком случае, считается более ясным выразить эти намерения с помощью
специальных форм @code{when} и @code{unless}.  В качестве дополнительного
бонуса, эти формы принимают множественные операторы(statements) для вычисления,
которые неявно обернуты в форму @code{begin}.

@deffn {Scheme Syntax} when test statement1 statement2 ...
@deffnx {Scheme Syntax} unless test statement1 statement2 ...
Фактическое определение этих форм во многом является их наиболее
ясной документацией:

@example
(define-syntax-rule (when test stmt stmt* ...)
  (if test (begin stmt stmt* ...)))

(define-syntax-rule (unless test stmt stmt* ...)
  (if (not test) (begin stmt stmt* ...)))
@end example

Можно сказать, @code{when} вычисляет последующие операторы по порядку,если
значение @var{test} истинно.  @code{unless} наоборот: вычисляет операторы если
занчение @var{test} ложно.
@end deffn

@deffn syntax cond clause1 clause2 @dots{}
Каждое предложение @code{cond}-clause должно выглядеть так:

@lisp
(@var{test} @var{expression} @dots{})
@end lisp

где  @var{test} и @var{expression} произвольные вывражения, или так

@lisp
(@var{test} => @var{expression})
@end lisp

где @var{expression} должно вычислять как процедуру.

@var{test} предложений вычисляются по порядку, и как только один из них
вычислит значение истина, вычисляется соответствующие выражения 
@var{expression} по порядку, а значение последнего выражения возвращается
как значение всего выражения @code{cond}.  Для передложения типа @code{=>},
вычисляется выражение @var{expression} и результирующая процедура применяется
к значению @var{test}.  Результат этого приенения процедуры явлляется 
результатом всего выражения @code{cond}.

@cindex SRFI-61
@cindex general cond clause
@cindex multiple values and cond
Одно дополнительное предложение @code{cond}-clause доступно как расширение
стандартной Scheme:

@lisp
(@var{test} @var{guard} => @var{expression})
@end lisp

где @var{guard} и @var{expression} должны вычисляться как процедуры.
Для предложения этого типа, @var{test} может возвращать множественные
значекния и @code{cond} игнорирует его логическое состояни; вместо
этого, @code{cond} вычисляет @var{guard} применяя его к результирующим
значение(я) @var{test}, как если бы @var{guard} была потребителем
(@var{consumer}) аргументов в @code{call-with-values}.  Если результат
вызова процедуры возвратит истинное значение, вычисляется выражение
@var{expression} и результирующая процедура пременяется к значению(ям)
выражения @var{test}, также как вызывалась процедура @var{guard}.

Тестом @var{test} последнего предложения @var{clause} может быть символ @code{else}.
Затем, если ни один из предшествующих тестов @var{test} не равен истине, 
вычисляются выражения @var{expression} следующие за @code{else} и получаемый
результат будет результатом выражения @code{cond}.
@end deffn

@deffn syntax case key clause1 clause2 @dots{}
@var{key} может быть выражением, а @var{clause} должны иметь вид

@lisp
((@var{datum1} @dots{}) @var{expr1} @var{expr2} @dots{})
@end lisp

или

@lisp
((@var{datum1} @dots{}) => @var{expression})
@end lisp

и последнее @var{clause} может иметь форму

@lisp
(else @var{expr1} @var{expr2} @dots{})
@end lisp

или

@lisp
(else => @var{expression})
@end lisp

Все @var{datum} должны быть разными.  Сначала вычисляется @var{key}.  
Результат этого вычисления сравнивается со всеми @var{datum} значениями
используя @code{eqv?}.  Когда сравнение заканчивается успехом, выражения
следующее за @var{datum} вычисляются слева на право, результирующее значение
последнего выражения является результатом всего выражения @code{case}.

Если @var{key} не соответствует ни одному @var{datum} и существует
предложение @code{else}, вычисляются следующие за @code{else} выражения.
Если такого предложения нет, результат выражения не определен.

Для типа предложений @code{=>}, вычисляется @var{expression} и результирующая
процедура применяется к занчению @var{key}.  Результат применения этой процедуры
является результатом всего выражения @code{case}.
@end deffn

@node and or
@subsection Условное вычисление последовательности выражений

@code{and} и @code{or} вычисляют все свои аргументы в порядке аналогичном
@code{begin}, но вычисление останавливается как только одно из выражений
вычисляется как ложное или истинное, соответственно.

@deffn syntax and expr @dots{}
Вычисляет выражения формы @var{expr} слева на право и останавливает вычисления
как только одно из выражений вычисляется в @code{#f} остальные выражения не 
вычисляются; Значение последнего вычисленного выражения возвращается
Если никакое выражение не вычисляется как @code{#f}, возвращается значение
последнего выражения.

Если используется без выражений, возвращает @code{#t}.
@end deffn

@deffn syntax or expr @dots{}
Вычисляет вывражения формы @var{expr}s слева на право и останавливает
вычисления как только выражение возвращает истинное значение (т.е. значение
отличное от @code{#f}); остальные выражения не вычисляются.  Значение
последнего вычисленного выражения возвращается. Если все выражения вычисляются
в @code{#f}, возвращается @code{#f}.

Если используется без выражений, возвращает @code{#f}.
@end deffn

@node while do
@subsection Механизмы Итерации

@cindex iteration
@cindex looping
@cindex named let

Scheme имеет несколько механизмов итерации, главным образом потому, что
итерация в программах  Scheme обычно выражается с помощью рекурсии.
Тем не менее,  R5RS определяет конструкцию для программирования циклов,
называемый @code{do}.  Кроме того, Guile имеет явный синтаксис цикла,
называемый @code{while}.

@deffn syntax do ((variable init [step]) @dots{}) (test expr @dots{}) body @dots{}
Связывает переменные @var{variable}s и вычисляет тело @var{body} до тех пор пока
@var{test} не вернет истину.
Возвращает значение выполнения последнего выражения @var{expr} следующих после @var{test}, 
если они есть.  Простой пример проилюстрирует основную форму,

@example
(do ((i 1 (1+ i)))
    ((> i 4))
  (display i))
@print{} 1234
@end example

@noindent
Или с двумя переменными и возвращаемым окончательным значением,

@example
(do ((i 1 (1+ i))
     (p 3 (* 3 p)))
    ((> i 4)
     p)
  (format #t "3**~s is ~s\n" i p))
@print{}
3**1 is 3
3**2 is 9
3**3 is 27
3**4 is 81
@result{}
243
@end example

Привязки переменных @var{variable} устанавливаются так же как @code{let}, 
в котором все выражения вычисляются и все привязки выполяются.  При итерации,
необязательные выражения @var{step} выполняются с предыдущими привязками в
области видимости, при этом создаются новые привязки.

Выражение @var{test} является условием завершения. Цикл останавливается
когда значение выражения @var{test} становиться равным истине.  Оно
вычисляется каждый раз перед выполнением @var{body}, если в первый раз
оно вычисляется как истинное, @var{body} не вычисляется вообще.

Не обязательные выражения @var{expr} после @var{test} выполняются в конце
цикла, с последними достпуными привязками переменных @var{variable}.  
Последнее @var{expr} дает возвращаемое значение, или если нет выражений @var{expr}
возвращаемое значение неопределено.

Каждая итерация устанавливает привязки к новым местам для переменных
@var{variable}, подобно новому @code{let} для каждой итереации.  это
делается и для  переменных @var{variable} не имеющих выражений @var{step}.
Следующий пример это илюстрирует, показывая как новыая @code{i} захыватывается
 @code{lambda} на каждой итерации (@pxref{About Closure,, The
Concept of Closure}).

@example
(define lst '())
(do ((i 1 (1+ i)))
    ((> i 4))
  (set! lst (cons (lambda () i) lst)))
(map (lambda (proc) (proc)) lst)
@result{}
(4 3 2 1)
@end example
@end deffn

@deffn syntax while cond body @dots{}
Запускает цикл выполнения форм @var{body} пока выражение @var{cond} 
равно истине. @var{cond} проверяется в начале каждой итерации, так что 
если оно станет @code{#f} в самом начале, то @var{body} не будет 
выполняться вообще.

С @code{while}, предоставляются две дополнительные привязки, их можно использовать
как из @var{cond} так и из @var{body}.

@deffn {Scheme Procedure} break break-arg @dots{}
Производит выход из формы @code{while}.
@end deffn

@deffn {Scheme Procedure} continue
Отменяет текущую итерацию, возвращается в начало и снова выполняет
проверку @var{cond} и т.д.
@end deffn

Если цикл завершается нормально, когда @var{cond} вычисляется в
@code{#f}, тогда выражение the @code{while} в целом вычисляется как
@code{#f}.  Если оно завершается вызовом @code{break} с каким либо 
количеством аргументв, эти аргументы возвращаются из выражения @code{while},
как множественные значения.  В противном случае, если он завершается вызовом
@code{break} без аргументов, он возвращает значение @code{#t}.

@example
(while #f (error "not reached")) @result{} #f
(while #t (break)) @result{} #t
(while #t (break 1 2 3)) @result{} 1 2 3
@end example

Каждая форма @code{while} получает свои собственные процедуры @code{break} 
и @code{continue}, работающие на этом @code{while}.  Это означает, что когда
циклы вложены, внешний @code{break} может быть использован для выхода из 
всех внутренних циклов.
Например,

@example
(while (test1)
  (let ((outer-break break))
    (while (test2)
      (if (something)
        (outer-break #f))
      ...)))
@end example

Обратите внимание, что каждая процедура @code{break} и @code{continue} может
использоваться только в динамическом пространстве своего @code{while}. 
Вне @code{while} его поведение не определено.
@end deffn

@cindex named let
Другим очень распростарненным способом итерации в программах Scheme является
использование так называемого Именованного let(@dfn{named let}).

Именованный let это вариант @code{let}, который создает процедуру и
вызывает ее за один шаг.  Так как вновь создаваемая процедура, именованного
let более мощная процедура чем @code{do}-- она может быть использована не только
для итерации, но и для произвольной рекурсии.

@deffn syntax let variable bindings body
Для определения @var{bindings} смотри документацию по
@code{let} (@pxref{Local Bindings}).

Именованный @code{let} работает следующим образом:

@itemize @bullet
@item
Создается новая процедура, которая принимает столько аргументов, сколько
содержиться в @var{bindings} и связываются локально (используя @code{let}) 
к @var{variable}.  Имена формальных аргументов новой процедуры это
имена переменных @var{variables}.

@item
Выражения @var{body} вставляются во вновь созданную процедуру.

@item
Процедура вызывается с выражениями @var{init} в качестве формальных 
аргументов.
@end itemize

В следующем примере реализован цикл который повоторяется (рекурсивно) 1000
раз.

@lisp
(let lp ((x 1000))
  (if (positive? x)
      (lp (- x 1))
      x))
@result{}
0
@end lisp
@end deffn

@node Prompts
@subsection Запросы(Prompts)
@cindex prompts
@cindex delimited continuations
@cindex composable continuations
@cindex non-local exit

Запросы являются барьерами потока управления между различными частями программы. 
Таким же образом пользователь видит запрос(prompt) командной оболочки(shell) 
(например, приглашение/запрос Bash) как барьер между операционной системой и
его программой, запросы Scheme позволяют программисту Scheme обрабатывать
части программы, как если бы они работали в разных операционных системах.

Мы используем это окольное объяснение, потому что,  если вы не наркоман функционального
программирования, то наверное не слышали термин ``разграниченное, составное продолжение''.
Это ХОРОШО; это относительно новая тема, но очень полезная для понимания.

@menu
* Prompt Primitives::           Call-with-prompt and abort-to-prompt.
* Shift and Reset::             The zoo of delimited control operators.
@end menu

@node Prompt Primitives
@subsubsection Примитивы Запросов(Prompt)

Примитивы Guile разделяют управляющие операторы на
@code{call-with-prompt} и @code{abort-to-prompt}.

@deffn {Scheme Procedure} call-with-prompt tag thunk handler
Устанавливает запрос(prompt), и вызывает чанк(@var{thunk}) в этом запросе(prompt).

Во время динамического распространения вызова чанка @var{thunk}, в динамическом
контексте запроса(prompt) будет присутствовать метка с именем @var{tag}, такая что,
если пользователь вызовет @code{abort-to-prompt} (смотри ниже) с этой меткой(tag), 
управление перейдет обратно в запрос(prompt), и будет запущен обработчик
@var{handler}.

@var{handler} должен быть процедурой. Первым аргументом обработчика @var{handler} 
будет состояние вычислений начавшихся когда был вызван чанк @var{thunk} и закончившихся
когда был вызван @code{abort-to-prompt}. Остальные аргументы для обработчика @var{handler}
это аргументы передаваемые в @code{abort-to-prompt}.
@end deffn

@deffn {Scheme Procedure} make-prompt-tag [stem]
Создает новый тег запроса(prompt).  Тег запроса(prompt tag) это просто
уникальный объект. В настоящее время тег запроса это чистая пара. Это может
измениться в будущих версиях Guile.
@end deffn

@deffn {Scheme Procedure} default-prompt-tag
Возвращает тег запроса(prompt) по умолчанию.  Наличие отличительного тега
у запроса по умолчанию, позволяет создавать некоторые полезные запросы и
идиомы прерываний, обсуждаемые в следующем разделе.  Обратите внимание, что
@code{default-prompt-tag} на самом деле является параметром, и может быть
динамически перепривязан использованием @code{parameterize}.
@xref{Parameters}.
@end deffn

@deffn {Scheme Procedure} abort-to-prompt tag val1 val2 @dots{}
Раскручивает динамический и управляющий контекст ближайшего запроса
с именем @var{tag}, а также передает предоставляемые значения.
@end deffn

Си программисты могут увидеть в вызовах @code{call-with-prompt} и @code{abort-to-prompt}
причудливые на вид @code{setjmp} и @code{longjmp}, соответственно. Запросы действительно
весьма полезны в качестве не локального механизма выхода. Guile конструкции @code{catch} и
@code{throw} реализованы в терминах запросов(prompts). Запросы(Prompts) более удобны,
чем @code{longjmp}, так как они имеют возможность передавать несколько значений цели
перехода.

Кроме того, в отличии от @code{longjmp}, обработчик(handler) запроса(prompt) 
получает полное состояние процесса, который был прерван, как первый аргумент
обработчика(prompt handler). Это состояние является продолжением(@dfn{continuation})
вычисления, заключенного в запрос(prompt). Это и есть разделенное продолжение
(@dfn{delimited continuation}), потому что это не всё продолжение программы;
скорее , это просто вычисление начатое вызовом @code{call-with-prompt}.

Продолжение является процедурой, и его можно восстановить просто вызвав его,
с любым количеством значений. Здесь все становиться интересным и сложным. Кроме
того описываемые как разделенные, продолжения, ограниченные запросами(prompts),
также являются составными(@dfn{composable}), потому что вызов сохраненного запроса
(prompt-saved) продолжения составляет это продолжение с текущим.

Представьте что вы сохранили продолжение с помощью call-with-prompt:

@example
(define cont
  (call-with-prompt
   ;; tag
   'foo
   ;; thunk
   (lambda ()
     (+ 34 (abort-to-prompt 'foo)))
   ;; handler
   (lambda (k) k)))
@end example

В результате вы получает продолжение добавляющее 34. Это как если бы вы написали:

@example
(define cont
  (lambda (x)
    (+ 34 x)))
@end example

Итак, если мы вызовем @code{cont} с одним числовым значением, мы получим это
число увеличенное на 34:

@example
(cont 8)
@result{} 42
(* 2 (cont 8))
@result{} 84
@end example

Последний пример иллюстрирует то, что мы имеем в виду, когда говорим, 
составляется с текущим продолжением ("composes with the current continuation").
Мы имеем в виду, что есть текущее продолжение --- некоторое оставшееся 
вычисление, такое как @code{(lambda (x) (* x 2))} -- и что вызов сохраненного
продолжения не стирает текущее продолжение, он составляет сохраненное продолжение
с текущим.

Мы обсуждаем этот вопрос здесь, потому что традиционные продолжения Scheme, какие
обсуждаются в следующем разделе, не являются соединяемыми и на самом деле
менее выразительны, чем продолжения захваченные с помощью запросов(prompts).
Но тут есть место для них обоих.

Прежде чем двигаться дальше, мы должны упомянуть, что если обработчик запроса
является @code{lambda} выражением, и не ссылается на свой первый аргумент, прерывание
этого запроса(prompt) не вызовет создания продолжения.  Это может быть важным
фактором эффективности, который следует помнить.

@cindex continuation, escape
Одним из примеров, где эта оптимизация имеет значение являются escape
продолжения (@dfn{escape continuations}).  Escape-продолжения, являются
разделенными продолжениями, единственное использование которых -- создать
нелокальный выход, т.е убежать(escape) из текущего продолжения. 
Обычное использование escape-продолжений это выбрасывание исключений.
(@pxref{Exceptions}).

Приведенные ниже конструкции представляют собой синтаксический сахар над
запросами(propts), упрощающий использование escape-продолжений.

@deffn {Scheme Procedure} call-with-escape-continuation proc
@deffnx {Scheme Procedure} call/ec proc
Вызывает @var{proc} с escape-продолжением.

В приведенном ниже примере, возвращаемое @var{return} продолжение используется
для выхода(побега) из продолжения вызова @code{fold}.

@lisp
(use-modules (ice-9 control)
             (srfi srfi-1))

(define (prefix x lst)
  ;; Return all the elements before the first occurrence
  ;; of X in LST.
  (call/ec
    (lambda (return)
      (fold (lambda (element prefix)
              (if (equal? element x)
                  (return (reverse prefix))  ; escape `fold'
                  (cons element prefix)))
            '()
            lst))))

(prefix 'a '(0 1 2 a 3 4 5))
@result{} (0 1 2)
@end lisp
@end deffn

@deffn {Scheme Syntax} let-escape-continuation k body @dots{}
@deffnx {Scheme Syntax} let/ec k body @dots{}
Связывает @var{k} внутри @var{body} с escape-продолжением.

Это эквивалентно
@code{(call/ec (lambda (@var{k}) @var{body} @dots{}))}.
@end deffn

Кроме того, есть еще один вспомогательный примитив, экспортируемый  @code{(ice-9
control)}, поэтому загрузите этот модуль для использования
@code{suspendable-continuation?}:

@example
(use-modules (ice-9 control))
@end example

@deffn {Scheme Procedure} suspendable-continuation? tag
Возвращает @code{#t} если вызов @code{abort-to-prompt} с тегом запроса
(prompt tag) @var{tag} приведет к созданию разделенного продолжения, которое
может быть возобновлено позже.

Почти все продолжения имеют это свойство.  Исключением является случай,
когда между @code{call-with-prompt} и вызов @code{abort-to-prompt} 
повторяются через Си по нескольким причинам,
@code{abort-to-prompt} будет успешным, но любая попытка возобновить
продолжение( вызвав его) потерпит неудачу. Это потому, что составление
сохраненного продолжения с текущим продолжением сопряжено с перемещением
кадров стека, которые были сохранены из старого стека на (возможно) новую
позицию нового стека, и Guile может это сделать только для кадров стека
созданных для  кода Scheme, а не кадров стека созданных Си компилятором.
Это немного грубовато, но если вы будете придерживаться Scheme, у вас не
будет проблем.

Если запрос с данным тегом не найден, эта процедура просто возвращает
@code{#f}.
@end deffn

@node Shift and Reset
@subsubsection Сдвиг(Shift), Переустановка(Reset), и все такое.

Существует целый зоопарк операторов управления с разделителями, и как
представляется он не ограничивается этим набором, Guile реализует их 
поддержку в отдельном модуле:

@example
(use-modules (ice-9 control))
@end example

Во первых, у нас есть полезное сокращение для оператора @code{call-with-prompt}.

@deffn {Scheme Syntax} % expr
@deffnx {Scheme Syntax} % expr handler
@deffnx {Scheme Syntax} % tag expr handler
Вычисляет выражение @var{expr} в запросе(prompt), опционально указывается тег(tag)
и обработчик(handler).  Если тега нет, по умолчанию используется тег подсказки по
умолчанию.

Если обработчик не указан, устанавливается обработчик по умолчанию.  Обработчик
по умолчанию  принимает процедуру одного аргумента, которая будет 
вызываться на захваченном продолжении, в пределах запроса.

Иногда проще показать код, как в этом случае:

@example
(define (default-prompt-handler k proc)
  (% (default-prompt-tag)
     (proc k)
     default-prompt-handler))
@end example

Символьный знак @code{%} выбран потому, что он выглядит как запрос.
@end deffn

Аналогично, существует сокращение для @code{abort-to-prompt}, которое
принимает метку запоса по умолчанию(default prompt tag):

@deffn {Scheme Procedure} abort val1 val2 @dots{}
Прерывает запрос по умолчанию с меткой, передавая обработчику 
@var{val1} @var{val2} @dots{}.
@end deffn

Как упоминалось ранее, @code{(ice-9 control)} также предоставляет другие
операторы управления разделениями.  Этот раздел является немного техническим,
и начинающим пользователям работающим с разделенными продолжениями, вероятно
стоит вернуться к нему после некоторой практики работы с @code{%}.

Вы все еще здесь?  Итак, когда реализуется операто управления разделениями,
подобный @code{call-with-prompt}, нужно принять два решения.  Первое, работает
ли обработчик внутри или снаружи запроса?  Наличие обработчика запускаемого 
в запросе позволяет превать внутри и вернуться к тому же обработчику запроса,
что часто бывает полезно. Однако это предотвращает хвостовые вызовы от
обработчика, поэтому он менее общий.

Аналогично, вызывает ли захваченное продолжение восстановление запроса(prompt)?
Снова у нас есть компромисс между удобством и  правильными хвостовыми вызовами.

Эти решения фиксируются в операторе Феллайзена(Felleisen) @dfn{F}.  Если
ни одно продолжение не имеет обработчиков неявно добавляется запрос, оператор
известный как @dfn{--F--}.  Этот случай для Guile @code{call-with-prompt}
и @code{abort-to-prompt}.

Если оба, продолжение и обработчик неявно добавляют запрос, то оператор
будет @dfn{+F+}.  @code{shift} и @code{reset} являются такими операторами.

@deffn {Scheme Syntax} reset body1 body2 @dots{}
Устанавливают запрос, и вычисляют @var{body1} @var{body2} @dots{} в этом
запросе.

Обработчик запроса предназначенный для работы с @code{shift}, описан ниже.
@end deffn

@deffn {Scheme Syntax} shift cont body1 body2 @dots{}
Прерывает до ближайшего @code{reset}, и вычисляет @var{body1} @var{body2}
@dots{} в контексте, в котором захваченное продолжение связано с 
@var{cont}.

Как упоминалось выше, вместе взятые выражения the @var{body1} @var{body2} @dots{}
и вызовы @var{cont} неявно устанавливают запрос(prompt).
@end deffn

Заинтересованным читателям предлагается ознакомиться с замечательным сайтом
Олега Киселёва по адресу @uref{http://okmij.org/ftp/}, для получения дополнительной
информации об этих операторах.

@node Continuations
@subsection Продолжения
@cindex continuations

Продолжение(``continuation'') это код, который будет выполняться когда
функция или выражение завершиться(возвратит управление). Например, 
рассмотрим

@example
(define (foo)
  (display "hello\n")
  (display (bar)) (newline)
  (exit))
@end example

Продолжение из вызова @code{bar} содержит
@code{display} возвращенного значения, и вызовы функций @code{newline} и
@code{exit}.  Это может быть выражено как функция одного аргумента.

@example
(lambda (r)
  (display r) (newline)
  (exit))
@end example

В Scheme, продолжения представлены в виде специальных процедур, подобнгых
этой. Специальное свойство заключается в том, что когда вызывается продолжение,
оно оставляет текущее местоположение программы и переходит непосредственно к
тому, которое представлено продолжением.

Продолжение похоже на динамическую метку, фиксирующую во время выполнения
точку выполнения программы, включая все вложенные вызовы, которые привели к 
ней(или скорее код, который будет выполнен, когда эти вызовы завершаться).

Продолжения создаются следующими функциями.

@deffn {Scheme Procedure} call-with-current-continuation proc
@deffnx {Scheme Procedure} call/cc proc
@rnindex call-with-current-continuation
Захватывает текущее продолжение и вызывает процедуру @code{(@var{proc}
@var{cont})}  с ним.  Возвращаемое значение является значением возвращаемым
@var{proc}, или когда @code{(@var{cont} @var{value})} вызывается позже,
возвращается переданное значение @var{value}.

Обысно @var{cont} должен вызываться с одним аргументом, но когда местоположение
возобновляется ожидается множественное значение (@pxref{Multiple
Values}) затем они должны быть переданы в виде нескольких аргументов, для
экземпляра продолжения @code{(@var{cont} @var{x} @var{y} @var{z})}.

@var{cont} может использоваться только с той же стороны от барьера
продолжения, с какой оно было создано (@pxref{Continuation Barriers}), 
и в много-поточных программах, только из той же ветки, в которой оно
было создано.

Вызов @var{proc} не является частью захваченного продолжения, оно выполняется
только тогда, когда продолжение создается. Часто программа захочет хранить
продолжение @var{cont} где то, для использования в дальнейшем; это можно сделать
в процедуре @var{proc}.

Слово @code{call} в имени @code{call-with-current-continuation}
относиться к способу вызова процедуры @var{proc} передавая ей
вновь созданное продолжения. Это не связано с тем, как используется
вызов позже, чтобы вызывать продолжение.

@code{call/cc} это псевноним для @code{call-with-current-continuation}.
Он для общего использования, так как последнее имя довольно длинное.
@end deffn

@sp 1
@noindent
Вот простой пример,

@example
(define kont #f)
(format #t "the return is ~a\n"
        (call/cc (lambda (k)
                   (set! kont k)
                   1)))
@result{} the return is 1

(kont 2)
@result{} the return is 2
@end example

@code{call/cc} захватывает продолжение, в котором возвращаемое значение
будет отображаться с помощью @code{format}.  Функция @code{lambda} сохраняет
данное продолжение в @code{kont} и делает начальный возврат значения равного
@code{1} который и отображается. Более поздний вызов @code{kont} возобновляет
захваченную точку, но на этот раз возвращает @code{2}, которое и отображается.

Когда Guile запускается интерактивно, вызов такого @code{format} неявно
возвращается назад в цикл REPL(read-eval-print loop).  @code{call/cc}
перехватывает это как и любой другой возврат, вот почему интерактивно
@code{kont} выполнит возврат, чтобы читать ввод дальше.

@sp 1
Си программисты могут заметить, что @code{call/cc} подобен @code{setjmp}
в том, как он записывает во время выполнения точку выполнения программы.
А вызов продолжения подобен @code{longjmp} в том смысле, что он покидает
текущее местоположение и переходит к записанному. Как и @code{longjmp},
значение передаваемое в продолжение является значением возвращаемым
@code{call/cc} при возобновлении там.  Однако @code{longjmp} может идти
только вверх, по стеку программ, но механизм продолжений может идти куда
угодно.

Когда вызывается продолжение, @code{call/cc} и последующий код
эффективно  ``возвращаются(returns)'' повторно.  Может показаться
странным, что функция возвращается больше раз, чем она была вызвана.
Вместо этого может помочь мысль о том, что она тайно повторно
перевходит и затем поток программы следует как обычно.

@code{dynamic-wind} (@pxref{Dynamic Wind}) может использоваться для
обеспечения  кода установки и кода очистк, запускаемого когда локус
программы возобновляется или отменяется через механизм продолжения.

@sp 1
Продолжения являются мощным механизмом, и могут использоваться для реализации
практически любого вида структур управления, таких как циклы, сопрограммы или
обработка исключений.

Однако реализация продолжений в Guile не так эффективна, какой она могла
бы быть, поскольку Guile предназначен для взаимодействия с программами
написанными на других языках, таких как Си, которые не знают о продолжениях.
В основном продолжения захватываются копированием блока стека, и возобновляются
копированием блока обратно.

По этой причине, продолжения захваченные с помощью @code{call/cc} должны использоваться
только когда нет другого простого способа достижения желаемого результата, или когда
элегантность механизма продолжения перевешивает необходимость в быстродействии.

Побеги(Escapes) из всех циклов или вложенных функций обычно лучше всего
обрабатываются с помощью запросов(prompts) (@pxref{Prompts}).  Сопрограммы
(Coroutines) могут быть эффективно реализованы с помощью взаимодействующих
потоков(cooperating threads) (поток содержит полный программный стек, но
не копирует его, как это делает продолжение).

@node Multiple Values
@subsection Возврат и Прием Множества значений.

@cindex multiple values
@cindex receive

Scheme позволяет процедуре возвращать более одного значения вызывающему.
Это совсем не похоже на другие языки, которые позволяют возвращать
только одно значение.  Возврат нескольких значений отличается от
возврата списка (или пары, или вектора) значений вызывающей стороне,
поскольку концептуально возвращается не один(not @emph{one}) составной
объект, а несколько различных значений.

Примитивными процедурами для обработки нескольких значений являются 
@code{values} и @code{call-with-values}.  @code{values} используется 
для возврата нескольких значений из процедуры.  Просто поместите
вызов @code{values} с нулем или большим количеством аргументов в хвостовую
позицию тела процедуры.  @code{call-with-values} объединяет возврат процедуры
возвращающей множество значений с процедурой которая принимает эти значения
в качестве параметров.

@rnindex values
@deffn {Scheme Procedure} values arg @dots{}
@deffnx {C Function} scm_values (args)
Поставляет все свои аргументы в продолжение. За исключением
продолжений созданных процедурой @code{call-with-values},
все продолжения принимают одно значение.  Эффект от перадачи
нуля значений или более чем одного значения в продолжения которые
не были созданы @code{call-with-values} не определен.

Для @code{scm_values}, @var{args} это список аргументов, а возвращаемое
значение это объект множества значений, которые мог вернуть вызывающий.
В текущей реализаци этот объект разделяет структуру с 
@var{args}, поэтому @var{args} не должны быть изменены в последствии.
@end deffn

@deftypefn {C Function} SCM scm_c_values (SCM *base, size_t n)
@code{scm_c_values} яляется альтернативой @code{scm_values}.  Она создает
новый объект значений, и копирует в него  @var{n} значений начиная с
@var{base}.

В настоящее время он создает список и передает его в
 @code{scm_values}, но в будущем мы сможем использовать
более эффективное представление
@end deftypefn

@deftypefn {C Function} size_t scm_c_nvalues (SCM obj)
Если @var{obj} является объектом с несколькими значениями, возвращает
количество значений, которые он содержит. Иначе возвращает 1.
@end deftypefn

@deftypefn {C Function} SCM scm_c_value_ref (SCM obj, size_t idx)
Возвращает значение в позиции указанной @var{idx} объекта @var{obj}.
Обратите внимание, что объект @var{obj} обычно будет объектом с 
несколькими значениями, но это не обязательно.  Любой другой объект
представляет собой одиночной значение(он сам), и обрабатывается
соответствующим образом.
@end deftypefn

@rnindex call-with-values
@deffn {Scheme Procedure} call-with-values producer consumer
Вызывает аргумент @var{producer} без значений и продолжение,
которое при передаче нескольких значений, вызывает процедуру
@var{consumer} с этими значениями в качестве аргументов.
Продолжение для вызвова @var{consumer} является продолжением
вызвова @code{call-with-values}.

@example
(call-with-values (lambda () (values 4 5))
                  (lambda (a b) b))
@result{} 5

@end example
@example
(call-with-values * -)
@result{} -1
@end example
@end deffn

В дополнение к основным процедурам, описанным выше, в Guile есть модуль
который экспортирует синтаксис с именем @code{receive}, который
гораздо удобнее.  Он есть в @code{(ice-9 receive)} и соответствует
SRFI-8 (@pxref{SRFI-8}).

@lisp
(use-modules (ice-9 receive))
@end lisp

@deffn {library syntax} receive formals expr body @dots{}
Вычисляет выражение @var{expr}, и связывает результирующие значения
(ноль или больее) с результирующими значениями(ноль или больше)
в @var{formals}.  @var{formals} это список символов, такие как 
список аргументов в @code{lambda}
(@pxref{Lambda}).  После связывания переменных в @var{body} @dots{} 
вычисляются по порядку, возвращая значениев последнем
выражении.

Например, получение результатов из @code{partition} в SRFI-1
(@pxref{SRFI-1}),

@example
(receive (odds evens)
    (partition odd? '(7 4 2 8 3))
  (display odds)
  (display " and ")
  (display evens))
@print{} (7 3) and (4 2 8)
@end example

@end deffn

@node Exceptions
@subsection Исключения
@cindex error handling
@cindex exception handling

Общим требованием в приложениях является желание выпрыгивать не локально
(@dfn{non-locally}) из глубины вычислений обратно, скажем, в основной
цикл обработки(main processing loop).  Обычно, место, то есть цель перехода
находиться где то в стеке вызывающих процедур, которые вызвали процедуру, которая
хочет выпрыгнуть назад.  Например, типичная логика для обработки нажатий клавиш
приложения может выглядеть примерно так:

@example
main-loop:
  read the next key press and call dispatch-key

dispatch-key:
  lookup the key in a keymap and call an appropriate procedure,
  say find-file

find-file:
  interactively read the required file name, then call
  find-specified-file

find-specified-file:
  check whether file exists; if not, jump back to main-loop
  @dots{}
@end example

Переход к основному циклу to @code{main-loop} может быть достигнут путем
возврата через стек одной процедуры за раз, используя возвращаемое значение
каждой процедуры, чтобы указать состояние ошибки, но Guile (как и большинство
современных языков программирования) предоставляет дополнительный механизм,
называемый обработкой исключений(@dfn{exception handling}), который может быть
использован для реализации таких переходов гораздо удобнее.

@menu
* Exception Terminology::       Different ways to say the same thing.
* Catch::                       Setting up to catch exceptions.
* Throw Handlers::              Handling exceptions before unwinding the stack.
* Throw::                       Throwing an exception.
* Exception Implementation::    How Guile implements exceptions.
@end menu

@node Exception Terminology
@subsubsection Терминология Исключений

Существует несколько вариантов терминологии для работы с нелокальными
переходами(non-local jumps). Это полезно знать о них и понимать, что все они
относятся к одному и тому же основному механизму.

@itemize @bullet
@item
На самом деле совершение не локального перехода, можно называть вызовом
исключения(@dfn{raising an exception}), вызовом сигнала(@dfn{raising a signal}), 
выбросом исключения (@dfn{throwing an exception}) или выполнением длинного перехода
@dfn{doing a long jump}.  Когда переход указывает на состояние ошибки,
люди могут говорит о сигнале(@dfn{signalling}), вызове(@dfn{raising}) или
выбросе( @dfn{throwing})
@dfn{an error}.

@item
Обработка перехода(прыжка) к своей цели может упоминаться как ловля(@dfn{catching})
или обработка(@dfn{handling}) исключения( @dfn{exception}), сигнала(@dfn{signal}) или
в случае состояния ошибки, ошибкой(@dfn{error}).
@end itemize

Там где используется сигнал(@dfn{signal}) и сигнализация(@dfn{signalling}),
требуется особая осторожность, чтобы избежать риска путаницы с
сигналами POSIX.

Это руководство предпочитает говорить о создании и отлове исключений,
так как эта терминология соответствует соответствующим примитивам Guile.

Механизм исключений описанный в этом разделе, имеет связи с разделенными
продолжениями(@dfn{delimited continuations}) (@pxref{Prompts}).  В частности,
выбрасывание исключения сродни вызову выхода/побега из продолжения(@dfn{escape continuation})
(@pxref{Prompt Primitives, @code{call/ec}}).

@node Catch
@subsubsection Ловля/Перехват Исключений(Catching Exceptions)

@code{catch} используется для установки цели для возможного не локального
прыжка/перехода. Аргументами выражения @code{catch} являются ключ(@dfn{key}),
который ограничивает набор исключений, к которым применяется этот @code{catch},
чанк(thunk) который определяет исполняемый код и одина или две процедуры 
обработчики (@dfn{handler}), которые говорят, что делать, если при выполнении
кода возникает исключение. Если выполнение чанка(thunk) происходит нормально
(@dfn{normally}), что означает, без исключений, процедуры обработчики не вызываются
вовсе.

Когда исключение выбрасывается с использованием функции @code{throw}(бросать), 
первый аргумент @code{throw} является символом, указывающим на тип исключения.
Например, Guile выбрасывает исключения используя символ @code{numerical-overflow}
для указания ошибок числового переполнения, таких как деление на ноль:

@lisp
(/ 1 0)
@result{}
ABORT: (numerical-overflow)
@end lisp

Аргумент @var{key} в выражении @code{catch} соответствует этому символу.
@var{key} может быть конкретным символом, таким как @code{numerical-overflow},
в этом случае @code{catch} применяется к конкретным исключениям этого типа;
или это может быть @code{#t}, что означает, что @code{catch} применяется ко
всем исключениям, независимо от их типа.

Второй аргумент выражения @code{catch} должен быть чанком(thunk)
(т.е.@: процедурой которая не принимает ни одного аргумента), который
указывает обычнй исполняемый код.  @code{catch} активен когда
исполняется этот чанк(thunk), включая любой код вызываемый непосредственно
или косвенно из тела чанка. Вычисление выражения @code{catch} активирует
этот catch и затем вызывает этот чанк(thunk).

Третий аргумент выражения @code{catch} это процедура обработчик.
Если возникает исключение, вызывается эта процедура с точно теми же
аргументами, которые указываюстя в @code{throw}.  Следовательно, процедура
обработчика должна быть разработана, что бы принимать такое число аргументов,
которое соответствует всем выражениям @code{throw}, которые могут быть
перехвачены данным @code{catch}.

Четвертый, необязательный аргумент выражения @code{catch} это другая процедура
обработчик, называемая обработчик предварительной раскрутки(@dfn{pre-unwind}).
Он отличается от третьего аргумента тем, что если выбрасывается исключение,
он вызывается перед(@emph{before}) обработчиком из третьего аргумента, точно в
динамическом контексте выражения, которое выбросило исключение @code{throw}.
Это означает, что оно полезно для захвата или отображения стека в точке 
вызова @code{throw}, или для изучения других аспектов динамического контекста,
таких как значения флюидов(fluid values), до того, как контекст будет перемота
обратно, к контексту господствующего @code{catch}.

@deffn {Scheme Procedure} catch key thunk handler [pre-unwind-handler]
@deffnx {C Function} scm_catch_with_pre_unwind_handler (key, thunk, handler, pre_unwind_handler)
@deffnx {C Function} scm_catch (key, thunk, handler)
Вызывает чанк @var{thunk} в динамическом контексте обработчика @var{handler} 
исключения соответствующего ключу @var{key}.  Если чанк(thunk) выбросит исключение с
ключем @var{key}, вызовется обработчик @var{handler}, вот так:
@lisp
(handler key args ...)
@end lisp

@var{key} это символ или @code{#t}.

@var{thunk} не принимает аргументов.  Если @var{thunk} возвращается
нормально, его возвращаемое значене возвращается выражением @code{catch}.

Обработчик вызывается за пределами области охвата @code{catch}.
Если @var{handler} снова выбрасывает исключение с тем же ключем(key), 
далее вызывается новый обработчик стоящий по цепочке выше.

Если ключ это @code{#t}, тогда выбрасывание любого(@emph{any}) символа
будет соответствовать этому вызову для @code{catch}.

Если задан @var{pre-unwind-handler} и чанк(@var{thunk}) выбрасывает
исключение которое соответствует @var{key}, Guile вызывает
@var{pre-unwind-handler} до того, как произойдет разматывание(unwinding)
динамического состояния и вызов основного обработчика @var{handler}.  
@var{pre-unwind-handler} должен быть процедурой с той же сигнатурой
что и @var{handler}, который имеет сигнатуру @code{(lambda (key . args))}.
Он обычно используется для сохранения стека в точке, где произошло
исключение, но может также запрашивать другие части динамического состояния
в этой точке, такие как значения флюидов(fluid values).

@var{pre-unwind-handler} может выйти как нормально, так и не локально.
Если он выходит нормально, Guile раскручивает стек и динамический контекст
и затем вызывает обычный обработчк(третий аргумент).  Если он выходит не
локально, этот выход определяется продолжением.
@end deffn

Если процедура обработчика должна соответствовать различным выражениям @code{throw}
с различным числом аргументов, вы должны написать его так:

@lisp
(lambda (key . args)
  @dots{})
@end lisp

@noindent
Аргумент @var{key} гарантированно присутствует всегда, потому что
выбрасывание исключения(@code{throw}) без ключа @var{key} не действительна. 
Количество и интерпретация аргументов @var{args} варьируется от одного типа
исключений к другому, но должна быть указана к документации для каждого типа
исключений.

Обратите внимание, что после вызова обычного обработчика (после разматывания
стека(post-unwind)), перехват прерываний(catch), который вызвал процедуру
обработки исключений, больше не активен. Поэтому, если обработчик исключений
сам выбросит  исключение, это исключение может быть перехвачено только другими
активными выражениями catch находящимися в стеке выше, если они есть.

@sp 1
@deftypefn {C Function} SCM scm_c_catch (SCM tag, scm_t_catch_body body, void *body_data, scm_t_catch_handler handler, void *handler_data, scm_t_catch_handler pre_unwind_handler, void *pre_unwind_handler_data)
@deftypefnx {C Function} SCM scm_internal_catch (SCM tag, scm_t_catch_body body, void *body_data, scm_t_catch_handler handler, void *handler_data)
Вышеупомянутые @code{scm_catch_with_pre_unwind_handler} и @code{scm_catch}
принимают Scheme процеруды в качестве аргументов тела и обработчика исключений.
@code{scm_c_catch} и @code{scm_internal_catch} являются их эквивалентами, принимающими
Си функции.

@var{body} вызывается как @code{@var{body} (@var{body_data})} с перехватом
исключений соответствующего @var{tag} типа.  Если ислючение поймано,
вызываются @var{pre_unwind_handler} и @var{handler} как
@code{@var{handler} (@var{handler_data}, @var{key}, @var{args})}.
@var{key} и @var{args} являются @code{SCM} ключем(key) и списком аргументов из
@code{throw}.

@tpindex scm_t_catch_body
@tpindex scm_t_catch_handler
@var{body} и @var{handler} должны иметь следующие прототипы.
@code{scm_t_catch_body} и @code{scm_t_catch_handler} это указатель
определения типа для них.

@example
SCM body (void *data);
SCM handler (void *data, SCM key, SCM args);
@end example

параметры @var{body_data} и @var{handler_data} передаются в соответствующие
вызовы так что приложение может передавать дополнительную информацию для 
этих функций.

Если data состоит из объекта @code{SCM}, следует позаботиться о том, чтобы
он небыл собран сборщиком мусора, пока он еще требуется.  Если @code{SCM} это
локальная Си переменная, один из способов защитить ее - передать указатель на
эту переменную в качестве параметра data, поскольку Си компилятор будет знать
ее значение, оно будет храниться в стеке. Другой способ --- использовать
@code{scm_remember_upto_here_1} (@pxref{Foreign Object Memory
Management}).
@end deftypefn

@node Throw Handlers
@subsubsection Обработчики Исключений

Иногда полезно перехватить исключение, которое выдается перед разматыванием
стека. Это может быть необходимо, чтобы очистить некоторые связанные состояния,
распечатки трассы вызовов или например, передать информацию об исключении в
отладчик. Процедура @code{with-throw-handler} предоставляет способ сделать это.

@deffn {Scheme Procedure} with-throw-handler key thunk handler
@deffnx {C Function} scm_with_throw_handler (key, thunk, handler)
Добавляет обработчик @var{handler} в динамический контекст в качестве
обработчика исключения для ключа @var{key}, затем вызывает чанк(@var{thunk}).

Он ведет себя также как @code{catch}, за исключением того, что не разматывает
стек до того как вызовет обработчик @var{handler}. Если процедура @var{handler}
возвращается нормально, Guile повторно выбрасывает тоже самое исключение для
следующего ближайшего catch или throw обработчика. @var{handler} может выходить
не локально, конечно, выйти не локально можно через явный выброс исключения или
вызов продолжения.
@end deffn

Обычно обработчик @var{handler} используется для отображения трассы вызовов
стека, в точке где произошел соответствующий выброс исключения(@code{throw}),
или чтобы сохранить эту информацию для возможного отображения позже.

Не разматывать стек(Not unwinding) означает, что выбрасывается исключение,
которое обрабатывается с помощью обработчика throw, эквивалентно вызову
встроенного встроенного(inline) обработчика для каждого @code{throw}, и
затем пропуском окружающих @code{with-throw-handler}. Другими словами,

@lisp
(with-throw-handler 'key
  (lambda () @dots{} (throw 'key args @dots{}) @dots{})
  handler)
@end lisp

@noindent
в основом эквивалентно

@lisp
((lambda () @dots{} (handler 'key args @dots{}) @dots{}))
@end lisp

В частности, динамический контекст при вызове обработчика @var{handler} 
это это место где вызывается @code{throw}. Примеры, не совсем эквиваленты,
поскольку тело @code{with-throw-handler} не находиться в хвостовой позиции
по отношению к @code{with-throw-handler}, и если обработчик @var{handler}
завершиться нормально, Guile организует повторный выброс (rethrow) ошибки,
но надеюсь, цель этого ясна. (For an introduction to what is meant
by dynamic context, @xref{Dynamic Wind}.)

@deftypefn {C Function} SCM scm_c_with_throw_handler (SCM tag, scm_t_catch_body body, void *body_data, scm_t_catch_handler handler, void *handler_data, int lazy_catch_p)
Приведенные выше @code{scm_with_throw_handler} получают аргументами процедуры Scheme 
в качестве тела((thunk) и обработчика.  @code{scm_c_with_throw_handler} является
эквивалентом, принимающим Си функции. См. @code{scm_c_catch} (@pxref{Catch})
для описания параметров, однако поведение коенчно соответствует
@code{with-throw-handler}.
@end deftypefn

Если чанк(@var{thunk}) выбрасывает исключение, Guile обрабатывает это
исключение, вызывая самый внутренний обработчик @code{catch} или throw
ключ которого совпадает с ключем исключения. Когда самый внутренний
обработчик исключения найден, Guile вызывает указанную процедуру обработчика
используя @code{(apply @var{handler} key args)}.  Процедура обработчика может
вернуться нормально, либо выйти не локально. Если она завершается нормально,
Guile передает исключение следующему самому внутреннему обработчику @code{catch}
или throw.  Если он выходит не локально, этот выход определяется продолжением.

Поведение обработчика исключений throw очень похоже на поведение
необязательного обработчика pre-unwind  в выражении @code{catch}.
В частности, процедура обработчика  throw вызывается  в том же
динамическом конетесте, так же как и в выражении the @code{throw},
так и обработчике pre-unwind.
@code{with-throw-handler} можно рассматривать как половину -@code{catch}: он делает
все, что и @code{catch} до тех пор пока  @code{catch} не начинает разматывать
стек и динамический контекст, но затем он возвращается к следующему внутреннему
обработчику @code{catch} или throw.

Также обратите внимание, что поскольку динамический контекст не разматывается, 
если обработчик @code{with-throw-handler} выбрасывает исключение с ключем,
который не соответствует ключу @var{key} выражения @code{with-throw-handler},
новый бросок(исключение) может быть обработано обработчиком @code{catch} или
throw которые БЛИЖЕ(@emph{closer}) выбросившему исключение коду, чем первый
обработчик @code{with-throw-handler}.

Вот пример, демонстрирующий это поведение:

@lisp
(catch 'a
  (lambda ()
    (with-throw-handler 'b
      (lambda ()
        (catch 'a
          (lambda ()
            (throw 'b))
          inner-handler))
      (lambda (key . args)
        (throw 'a))))
  outer-handler)
@end lisp

@noindent
Этот код вызывает внутренний обработчик @code{inner-handler} и затем
продолжает с продолжения внутреннего @code{catch}.

@node Throw
@subsubsection Выброс/Генерация Исключений

Примитив @code{throw} используется для выброса исключения. Один аргумент
 @var{key}, является обязательным, и должен быть символом; он указывает
тип исключения которое выбрасывается.  Следующий аргумент @var{args},
@code{throw} принимает произвольное число дополнительных аргументов,
значение которых зависит от типа исключения. Документация для каждого
возможного типа исключения должна описывать дополнительные аргументы,
которые ожидаются для такого рода исключения.

@deffn {Scheme Procedure} throw key arg @dots{}
@deffnx {C Function} scm_throw (key, args)
Вызывает catch форму соответствующую ключу @var{key}, передавая аргументы @var{arg} @dots{}
в обработчик @var{handler}.

@var{key} это симовл.  Он будет соответствовать перехватывающим формам(catch)
с тем же самым символом или  @code{#t}.

Если обработчик вообще отсутствует, Guile напечатает ошибку и затем завершит работу.
@end deffn

Когда генерируется исключение, оно будет перехвачено самым внутренним
обработчиком @code{catch} или throw который применим к данному типу
исключения; другими словами, чей ключ @var{key} является @code{#t} или
тем же символом что и используемый в выражении @code{throw}.  Как только
Guile определил соответствующий обработчик @code{catch} или throw, он
обрабатывает исключение, применяя соответсвтующие процедуры обработчики
к аргументам из @code{throw}.

Если для сгенерированного ислючения нет подходящего обработчика @code{catch}
или throw, Guile печатает ошибку в текущий порт ошибки, указывающую на 
неперехваченное исключение, и затем завершается.  На практике, это довольно
трудно наблюдать, поскольку Guile при интерактивном использовании устанавливает
обработчик верхнего уровня @code{catch}, который перехватывает все исключения
и печатает соответствующее сообщение об ошибке без(@emph{without}) выхода. 
Например, это то, что происходит если вы пытаетесь выбросить не обрабатываемое
исключение в стандартном Guile REPL; обратите внимание, что цикл команд Guile
продолжается после сообщения об ошибке:

@lisp
guile> (throw 'badex)
<unnamed port>:3:1: In procedure gsubr-apply @dots{}
<unnamed port>:3:1: unhandled-exception: badex
ABORT: (misc-error)
guile> 
@end lisp

Поведение по умолчанию для необработанного исключения можно наблюдать, вычислив
выражение @code{throw} из командной строки shell:

@example
$ guile -c "(begin (throw 'badex) (display \"here\\n\"))"
guile: uncaught throw to badex: ()
$ 
@end example

@noindent
То что Guile выходит сразу после неизвестного исключения, демонстрируется
отсутствием любого вывода от выражения @code{display}, поскольку Guile 
никогда не достигает точки вычисления этого выражения.

@node Exception Implementation
@subsubsection Как Guile Реализует Исключения

В обычной Scheme система исключений реализуется использованием
@code{call-with-current-continuation}.  Продолжения
(@pxref{Continuations}) являются мощной концепцией, которую может использовать
любой другой механизм управления--- в том числе @code{catch} и @code{throw} --- 
могут быть реализованы в терминах продолжений.

Однако Guile не реализует функции @code{catch} и @code{throw} подобным образом.
Почему нет?  Потому что Guile специально разработан для легкой интеграции с 
приложениями написанными на Си.  В смешанной среде Scheme/Си, концепция
продолжений(@dfn{continuation}) должна логически включать
``что произойдет следующим(what happens next)'' в Си части приложения, а также
в части Scheme, и получается, что единственный разумный способ реализации таких
продолжений - это сохранять и восстанавливать полный Си стек.

Таким образом, реализация через @code{call-with-current-continuation} в Guile
является копированием стека. Это позволяет ей хорошо взаимодействовать с
обычным Си кодом, но означает, что создание и вызов продолжений замедляется 
на время которое нужно для копирования Си стека.

Более целенаправленный механизм, предоставляемый @code{catch} и @code{throw}
не требует сохранения и востановления Си стека, потому что @code{throw}
всегда прыгает в место ВЫШЕ по стеку, относительно кода выполнившего
@code{throw}.  Поэтому Guile реализует примитивы @code{catch} и
@code{throw} независимо от @code{call-with-current-continuation} способом,
который использует преимущества обычных исключений движущихся только вверх
(@emph{upwards only}).

@node Error Reporting
@subsection Процедуры для Сообщения об Ошибках

Guile предоставляет набор удобных процедур для сообщения об ошибках,
которые реализованы поверх только что описанных примитивов исключений.

@deffn {Scheme Procedure} error msg arg @dots{}
Выбрасывает ошибку с кодом @code{misc-error} и сообщением, созданным
с помощью отображения @var{msg} и записи @var{arg} @enddots{}.
@end deffn

@deffn {Scheme Procedure} scm-error key subr message args data
@deffnx {C Function} scm_error_scm (key, subr, message, args, data)
Выбрасывает ошибку с кодом @var{key}.  @var{subr} может быть строкой
с именем связанной с ошибкой процедуры, или @code{#f}.
@var{message} это строка сообщения об ошибке, возможно содержащая
эскейп-коды @code{~S} и @code{~A}.  Когда сообщается об ошибке, они 
заменяются форматированными соотвующими членами @var{args}: @code{~A} 
(был @code{%s} в более старых версиях Guile) форматом используемым для
@code{display} и @code{~S} (было @code{%S}) форматом используемым для
@code{write}.  @var{data} это список или @code{#f} в зависимости от
ключа @var{key}: если @var{key} это @code{system-error} тогда это должен
быть список, содержащий значение Unix @code{errno}; Если @var{key} это
@code{signal} тогда это должен быть список содержащий номер сигнала
Unix; Если @var{key} это @code{out-of-range}, @code{wrong-type-arg},
или @code{keyword-argument-error}, это список содержащий плохое значение; 
иначе это обычно @code{#f}.
@end deffn

@deffn {Scheme Procedure} strerror err
@deffnx {C Function} scm_strerror (err)
Возвращает сообщение об ошибке Unix соответствующее @var{err}, целочисленное
значение @code{errno}.

Когда вызывается  @code{setlocale} (@pxref{Locales}), сообщение будет
на языке и в кодировке(charset) соответсвующей @code{LC_MESSAGES}.  
(Это делается библиотекой Си.)
@end deffn

@c begin (scm-doc-string "boot-9.scm" "false-if-exception")
@deffn syntax false-if-exception expr
Возвращает результат вычисления своего аргумента; однако если возникает
исключение, то вместо него возвращается @code{#f}.
@end deffn
@c end

@node Dynamic Wind
@subsection Динамический Ветер(Dynamic Wind)

Для кода Scheme, основной процедурой реагирования на нелокальные входы и 
выходы в/из динамического контекста является @code{dynamic-wind}.  Си код
может использовать @code{scm_internal_dynamic_wind}, но так как Си код не 
позволяет удобно строить анонимные процедуры которые замыкаются относительно
лексических переменных, это будет, ну, неудобно.

Поэтому, Guile предлагает функции @code{scm_dynwind_begin} и
@code{scm_dynwind_end} для разделения динамического динамического
пространства(extent). В этом динамическом пространстве, который называется
динамический контекст(@dfn{dynwind context}), вы можете выполнять различные
действия(@dfn{dynwind actions}) которые управляют тем, что происходит
когда происходит вход в динамический контекс, или выход из него.
Например, вы можете зарегистрировать процедуру очистки с помощью 
@code{scm_dynwind_unwind_handler} которая будет выполняться, когда
управление покидает контекст.  Есть еще несколько других специалзированных
действий динамического ветра(dynwind), например, чтобы временно заблокировать
асинхронное выполнение или временно изменить текущий порт вывода.
Они описаны в другом месте этого руководтсва.

Вот пример, который показывает, как предотвратить утечки памяти.

@example

/* Suppose there is a function called FOO in some library that you
   would like to make available to Scheme code (or to C code that
   follows the Scheme conventions).

   FOO takes two C strings and returns a new string.  When an error has
   occurred in FOO, it returns NULL.
*/

char *foo (char *s1, char *s2);

/* SCM_FOO interfaces the C function FOO to the Scheme way of life.
   It takes care to free up all temporary strings in the case of
   non-local exits.
 */

SCM
scm_foo (SCM s1, SCM s2)
@{
  char *c_s1, *c_s2, *c_res;

  scm_dynwind_begin (0);

  c_s1 = scm_to_locale_string (s1);

  /* Call 'free (c_s1)' when the dynwind context is left. 
  */
  scm_dynwind_unwind_handler (free, c_s1, SCM_F_WIND_EXPLICITLY);

  c_s2 = scm_to_locale_string (s2);

  /* Same as above, but more concisely.
  */
  scm_dynwind_free (c_s2);

  c_res = foo (c_s1, c_s2);
  if (c_res == NULL)
    scm_memory_error ("foo");

  scm_dynwind_end ();

  return scm_take_locale_string (res);
@}
@end example

@rnindex dynamic-wind
@deffn {Scheme Procedure} dynamic-wind in_guard thunk out_guard
@deffnx {C Function} scm_dynamic_wind (in_guard, thunk, out_guard)
Все три аргумента должны быть процедурами без аргументов.
сначала вызывается @var{in_guard}, потом @var{thunk}, затем
@var{out_guard}.

Если в любое время, во время выполнения чанка @var{thunk}, в
динамическом пространства выражения @code{dynamic-wind} произойдет
нелокальный выход, вызывается @var{out_guard}.  Если произойдет
повторный вход в динамическое пространство описываемое динамическим
ветром(dynamic-wind) вызывается @var{in_guard}.  Таким образом
@var{in_guard} и @var{out_guard} могут быть вызваны любое количество
раз.

@lisp
(define x 'normal-binding)
@result{} x
(define a-cont
  (call-with-current-continuation
   (lambda (escape)
     (let ((old-x x))
       (dynamic-wind
           ;; in-guard:
           ;;
           (lambda () (set! x 'special-binding))

           ;; thunk
           ;;
           (lambda () (display x) (newline)
                      (call-with-current-continuation escape)
                      (display x) (newline)
                      x)

           ;; out-guard:
           ;;
           (lambda () (set! x old-x)))))))
;; Prints:
special-binding
;; Evaluates to:
@result{} a-cont
x
@result{} normal-binding
(a-cont #f)
;; Prints:
special-binding
;; Evaluates to:
@result{} a-cont  ;; the value of the (define a-cont...)
x
@result{} normal-binding
a-cont
@result{} special-binding
@end lisp
@end deffn

@deftp {C Type} scm_t_dynwind_flags
Это перечисление имеет несколько флагов, которые изменяют поведение
@code{scm_dynwind_begin}.  Флаги перечислены в следующей таблице.

@table @code
@item SCM_F_DYNWIND_REWINDABLE
Динамический контекст становиться "перематываемым"(@dfn{rewindable}). Это означает
что в него можно повторно войти нелокально(через вызов продолжения). По умолчанию
в этот контекст динамического ветра(dynwind) нельзя повторно войти не локально.
@end table

@end deftp

@deftypefn {C Function} void scm_dynwind_begin (scm_t_dynwind_flags flags)
Функция @code{scm_dynwind_begin} запускает новый динамический контекст и 
делает его  `текущим'.

Аргумент @var{flags} определяет поведение контекста по умолчанию.
Обычно используется 0.  Это приведет к созданию контекста, в который
нельзя повторно войти с захваченным продолжением. Когда вы будете готовы
обработать повторные входы, включите повторные входы 
@code{SCM_F_DYNWIND_REWINDABLE} в @var{flags}.

Быть готовым к повторному входу означает, что эффекты обработчика
unwind могут быть отменены при повторном входе. В приведенном выше 
примере мы хотели предотвратить утечку памяти при нелокальном выходе
и поэтому зарегистрировали обработчик раскрутки(unwind) которые освобождает
память.  Но как только память освобождена, мы не можем вернуться обратно,
т.е войти в продолжение. Таким образом возвращение не может быть разрешено.

Следствием этого является то, что продолжения становяться менее
полезными, нельзя войти в захваченные контексты, но вам не нужно
слишком сильно беспокоиться об этом.

Контекст завершается либо неявно, когда происходит нелокальный выход,
либо явно вызовом @code{scm_dynwind_end}.  Вы должны убедиться, что
контекст динамического ветра(dynwind) действительно закончен должным
образом. Если вам не удасться вызвать @code{scm_dynwind_end} для 
каждого @code{scm_dynwind_begin}, поведение будет неопеделенным.
@end deftypefn

@deftypefn {C Function} void scm_dynwind_end ()
Явно завершает текущий динамический контекст и делает текущим предыдущий.
@end deftypefn

@deftp {C Type} scm_t_wind_flags
Это перечисление нескольких флагов, которые изменяют поведение
@code{scm_dynwind_unwind_handler} и
@code{scm_dynwind_rewind_handler}.  Флаги перечислены в следующей
таблице.

@table @code
@item SCM_F_WIND_EXPLICITLY
@vindex SCM_F_WIND_EXPLICITLY
Зарегистрированное действие так же выполняется, когда в/из контекста динамического
ветра(dynwind) осуществляется локальный вход или выход.
@end table
@end deftp

@deftypefn {C Function} void scm_dynwind_unwind_handler (void (*func)(void *), void *data, scm_t_wind_flags flags)
@deftypefnx {C Function} void scm_dynwind_unwind_handler_with_scm (void (*func)(SCM), SCM data, scm_t_wind_flags flags)
Организация вызова для @var{func} с аргументами @var{data}, когда текущий
контекст завершается не явно.  Если @var{flags} содержит  @code{SCM_F_WIND_EXPLICITLY}, 
@var{func} также вызывается, когда контекст завершается явно с помощью  @code{scm_dynwind_end}.

Функция @code{scm_dynwind_unwind_handler_with_scm} обеспечивает
защиту @var{data} от сборщика мусора.
@end deftypefn

@deftypefn {C Function} void scm_dynwind_rewind_handler (void (*func)(void *), void *data, scm_t_wind_flags flags)
@deftypefnx {C Function} void scm_dynwind_rewind_handler_with_scm (void (*func)(SCM), SCM data, scm_t_wind_flags flags)
Организация вызова для функции @var{func} вызываемой с аргументом @var{data}, когда
текущий контекст стартует заново путем перемотки стека.  когда флаги @var{flags}
содержат @code{SCM_F_WIND_EXPLICITLY}, функция @var{func} также вызывается еще и немедленно.

Функция @code{scm_dynwind_rewind_handler_with_scm} обеспечивает защиту данных
@var{data} от сборщика мусора.
@end deftypefn

@deftypefn {C Function} void scm_dynwind_free (void *mem)
Организует автоматическое освобождение для @var{mem} при каждом выходе
из текущего контекста, нормального или не-локального.
@code{scm_dynwind_free (mem)} ялвяется эквивалентнцм сокращением для
@code{scm_dynwind_unwind_handler (free, mem, SCM_F_WIND_EXPLICITLY)}.
@end deftypefn

@node Fluids and Dynamic States
@subsection Флюиды/Жидкие и изменичивые(Fluids) и Динамические состояния(Dynamic States)

@cindex fluids

Флюид(@emph{fluid}) это переменная, значение которой связано с динамическим
пространством вызванной функции.  Так же как операционная система запускает
процесс с предоставлением ему установленных портов текущего ввода и вывода
(или файловых дискрипторов), в Guile вы можете организовать вызов функции
во время связывания флюида(fluid/переменно) с особым значением. Эта связь
между флюидом и значением будет существовать во время динамического пространства
вызова функции.

Поэтому флюиды являются строительными блоками для реализации переменных
с динамической сферой действия.  Переменные с динамической сферой действия
полезны, когда вы хотите установить значение переменной значением в течении
некоторого динамического пространства при исполнении вашей программы и заставить
ее вернуться к своему исходному значению, поток управления выходит за пределы
этого динамического пространствва.  Смотри описание к @code{with-fluids} 
ниже, для более детального ознакомления.  Эта связь между флюидами, значениями
и динамическим пространством устойчива к множественным входам( например,
когда захваченное продолжение вызывается более чем один раз) и ранним выходам
(например при выбрасывании/возникновении исключений).

Guile использует флюиды для реализации параметров (@pxref{Parameters}).  Обычно
вы просто хотите использовать параметры напрямую. Однако, может быть полезным узнать
что такое флюиды и как они работают, вот о чем этот раздел.

Текущий набор ассоциаций флюид-значение может быть зафиксирован в
объекте динамического состояния(@emph{dynamic state} object). 
Динамическое пространство(dynamic extent) это просто моментальный
снимок текущий ассоциаций флюид-значение(fluid-value).  Пользователи Guile
могут захватывать(фиксировать) текущее динамическое состояние с помощью
@code{current-dynamic-state} и восстанавливать его позже через 
@code{with-dynamic-state} или пдобных процедур.
Это средство особенно полезно, когда реализуются абстракции подобные 
легковесным потокам(lightweight thread).

Новые флюиды создаются с помощью @code{make-fluid} и @code{fluid?} 
используется для проверки, является ли объект на самом деле флюидом.
К значениям хранящися во флюиде можно получать доступ с помощью
@code{fluid-ref} и @code{fluid-set!}.

@xref{Thread Local Variables}, для получения дополнительных сведений о
флюидах, потоках и динамических состояниях.

@deffn {Scheme Procedure} make-fluid [dflt]
@deffnx {C Function} scm_make_fluid ()
@deffnx {C Function} scm_make_fluid_with_default (dflt)
Возвращает вновь созданный флюид, начальное значение которого равно @var{dflt}, 
или @code{#f} если @var{dflt} не задано.
Флюиды это объекты которые могут одно значение для одного динамического состояния.
То есть, изменения этого значения видны только коду, который выполняется с тем же
динамическим состоянием, что и модифицирующий код.  Когда создается новое 
динамическое состояние, оно наследует значения от своего родителя. Поскольку каждый
поток, обычно, выполняется со своим собственным динамическим состоянием, вы может
использовать флюиды, для хранения локальных значений потока.
@end deffn

@deffn {Scheme Procedure} make-unbound-fluid
@deffnx {C Function} scm_make_unbound_fluid ()
Возвращает новый флюид, который изначально не связан (вместо того,
чтобы быть связанным с каким то определенным значением).
@end deffn

@deffn {Scheme Procedure} fluid? obj
@deffnx {C Function} scm_fluid_p (obj)
Возвращает @code{#t} если @var{obj} это флюид, иначе возвращает
@code{#f}.
@end deffn

@deffn {Scheme Procedure} fluid-ref fluid
@deffnx {C Function} scm_fluid_ref (fluid)
Возвращает значение связанное с флюидом @var{fluid} в текущем 
динамическвом корне. Если @var{fluid} не был установлен, возвращается
значение по умолчанию. Вызов @code{fluid-ref} для несвязанного флюида
вызывает ошибку времени выполнения.
@end deffn

@deffn {Scheme Procedure} fluid-set! fluid value
@deffnx {C Function} scm_fluid_set_x (fluid, value)
Устанавливает значение связанное с флюидом @var{fluid} в текущем динамическом
корне.
@end deffn

@deffn {Scheme Procedure} fluid-ref* fluid depth
@deffnx {C Function} scm_fluid_ref_star (fluid, depth)
Возвращает старое значение присвоенное флюиду @var{fluid} имеющее глубину(@var{depth})
в текущем потоке. Если глубина(@var{depth}) равна или превышает
количество значений, которые были присвоены @var{fluid}, возвращает значение
по умолчанию для флюида.  @code{(fluid-ref* f 0)} эквивалентно коду @code{(fluid-ref f)}.

@code{fluid-ref*} полезен, когда вы хотите поддерживать стеко-подобную
структуру во флюиде, например, такую как стек текущих обработчиков исключений.
Использование @code{fluid-ref*} вместо явного стека позволяет любому
частичному продолжению захватывать используя @code{call-with-prompt} только
привязки созданные только в пределах запроса, вместо всего продолжения.
@xref{Prompts}, для получения дополнительной информации о разделенных продолжениях.
@end deffn

@deffn {Scheme Procedure} fluid-unset! fluid
@deffnx {C Function} scm_fluid_unset_x (fluid)
Отсоединяет данный флюид от любого значения, делая его несвязанным.
@end deffn

@deffn {Scheme Procedure} fluid-bound? fluid
@deffnx {C Function} scm_fluid_bound_p (fluid)
Возвращает @code{#t} если данный флюид связан со значением, иначе
@code{#f}.
@end deffn

@code{with-fluids*} временно изменяет значение одного или нескольких флюидов,
так что процедура и каждая вызванная ей процедура обращаются к заданным
значениям.  После возврата процедуры, старые значения восстанавливаются.

@deffn {Scheme Procedure} with-fluid* fluid value thunk
@deffnx {C Function} scm_with_fluid (fluid, value, thunk)
Устанавливает флюиду @var{fluid} временное значение @var{value} и вызывает чанк @var{thunk}.
@var{thunk} должен быть процедурой без аргументов.
@end deffn

@deffn {Scheme Procedure} with-fluids* fluids values thunk
@deffnx {C Function} scm_with_fluids (fluids, values, thunk)
Устанавливает флюидам @var{fluids} временные значения @var{values} и вызывает 
чанк @var{thunk}. @var{fluids} должен быть списком флюидов и @var{values} 
должен иметь тоже количество значений.  Каждая подстановка делается в указанном
порядке.  @var{thunk} должен быть процедурой без аргументов.
Он вызывается внутри динамического ветра( @code{dynamic-wind}) и флюиды
устанавливаются/восстанавиливаются когда управление входит или покидает 
динамическое пространство.
@end deffn

@deffn {Scheme Macro} with-fluids ((fluid value) @dots{}) body1 body2 @dots{}
Выполняет тело @var{body1} @var{body2} @dots{}  в то время как каждый флюид
@var{fluid} устанавиливается соответствующим значением @var{value}.  Как @var{fluid},
так и значение @var{value} вычисляются и @var{fluid} должен выдавать  флюид.  
Тело выполняется внутри динамического ветра(@code{dynamic-wind}) и флюиды 
устанавливаются/восстанавливаются когда управление входит или покидает установленный
динамическое пространство.
@end deffn

@deftypefn {C Function} SCM scm_c_with_fluids (SCM fluids, SCM vals, SCM (*cproc)(void *), void *data)
@deftypefnx {C Function} SCM scm_c_with_fluid (SCM fluid, SCM val, SCM (*cproc)(void *), void *data)
Функция @code{scm_c_with_fluids} похожа на @code{scm_with_fluids} за исключением
того, что она принимает Си функцию для вызова, вместо чанка Scheme.

Функция @code{scm_c_with_fluid} аналогична, но позволяет устанавливать
один флюид вместо списка.
@end deftypefn

@deftypefn {C Function} void scm_dynwind_fluid (SCM fluid, SCM val)
Эта функция должна использоваться внутри пары вызовов
@code{scm_dynwind_begin} и @code{scm_dynwind_end} (@pxref{Dynamic
Wind}).  Во время контекста динамического ветра(dynwind), флюид @var{fluid}
устанавливается значением @var{val}.

Точнее, значение флюида заменяется на `сохраненное/резервированное'
значение, всякий раз когда в контекст динамического ветра(dynwind) входит
поток управления и покидает его. Резервное значение инициализируется значением
аргумента @var{val}.
@end deftypefn

@deffn {Scheme Procedure} dynamic-state? obj
@deffnx {C Function} scm_dynamic_state_p (obj)
Возвращает @code{#t} если @var{obj} это объект динамического состояния(dynamic state object);
иначе @code{#f}.
@end deffn

@deftypefn {C Procedure} int scm_is_dynamic_state (SCM obj)
Возвращает не ноль, если @var{obj} это объект динамического состояния;
иначе возвращает 0.
@end deftypefn

@deffn {Scheme Procedure} current-dynamic-state
@deffnx {C Function} scm_current_dynamic_state ()
Возвращает снимок текущих связей флюид-значение(fluid-value) в виде
нового объекта динамического состояния.
@end deffn

@deffn {Scheme Procedure} set-current-dynamic-state state
@deffnx {C Function} scm_set_current_dynamic_state (state)
Восстанавливает сохранненые ассоциации флюид-значение(fluid-value), заменяя
текущие ассоциации флюид-значение(fluid-value).  Возвращает текущие ассоциации
fluid-value в виде объекта динамического состояния, как в
@code{current-dynamic-state}.
@end deffn

@deffn {Scheme Procedure} with-dynamic-state state proc
@deffnx {C Function} scm_with_dynamic_state (state, proc)
Вызывает @var{proc} делая привязки флюидов из @var{state} текущими,
запоминая текущие привязки флюидов.  Когда управление покидает вызов
 @var{proc}, восстанавливает сохраненные привязки, сохраняя вместо этого
привязки флюидов внутри вызова.  Если управление обратно входит в
@var{proc}, восстанавливает эти сохраненные привязки, запоминая текущие
привязки и так далее.
@end deffn

@deftypefn {C Procedure} void scm_dynwind_current_dynamic_state (SCM state)
Устанавливает текущим динамическое состояние @var{state} для текущего
контекста динамического ветра(dynwind).  Подобно @code{with-dynamic-state}, 
но в с точки зрения Си интерфейса API Guile ``dynwind''.
@end deftypefn

@deftypefn {C Procedure} {void *} scm_c_with_dynamic_state (SCM state, void *(*func)(void *), void *data)
Как @code{scm_with_dynamic_state}, но вызывая @var{func} с данными
@var{data}.
@end deftypefn

@node Parameters
@subsection Параметры(Parameters)

@cindex SRFI-39
@cindex parameter object
@tindex Parameter

Параметры являются средством Guile для динамически связанных переменных.

На самом нижнем уровне, объект параметр это процедура.  Вызывая ее без
аргументов возвращает свое значение.  Вызов ее с одним аргументом
устанавливает ее значение.

@example
(define my-param (make-parameter 123))
(my-param) @result{} 123
(my-param 456)
(my-param) @result{} 456
@end example

Специальная форма @code{parameterize} устанавливает новое местоположение для
параметров, т.е новые местоположения, имеющие эффект в пределах динамического
пространства параметризированного(@code{parameterize}) тела.  Выход востанавливает
предыдущие местположения. Повторный вход (через сохраненное продолжение) снова будет
использовать новые местопоолжения.

@example
(parameterize ((my-param 789))
  (my-param)) @result{} 789
(my-param) @result{} 456
@end example

Параметры похожи на динамически связанные переменные в других диалектах
Лиспа. Они позволяют приложениям устанавливать параметры( как следует
из названия) только для выполнения определенной части кода, восстанавливая
их когда он завершиться.  Примером таких параметров могут быть чувствительность
к регистру во время поиска, или подсказка для пользовательского ввода.

Глобальные переменные не так хороши, как объекты параметров для такого
рода вещей. Изменения в них видны всем потокам, но в  Guile
местоположение объекта параметра устанавливается для каждого потока,
тем самым действительно ограниичивая эффект от параметризации(@code{parameterize})
только его динамическим выполнением.

Передача аргументов в функции является потоко-защищенной, но это становиться
утомительным когда есть больше чем несколько, или когда они должны пройти
через несколько уровней вызова перед тем, как дойти до точки где они вызвать
эффект. Введение нового параметра в существующий код, часто гораздо проще
с использованием объекта параметра, чем добавлением аргументов.

@deffn {Scheme Procedure} make-parameter init [converter]
Возвращает новый объект параметр, с начальным значением @var{init}.

Если задан преобразователь @var{converter}, то для каждой установки
значения выполняется вызов @code{(@var{converter} val)}, возвращаемое им
значение сохраняется. Такой вызов также выполняется для начального
значения @var{init}.

@var{converter} позволяет проверять значения, или вводить их в каноническую
форму. Например,

@example
(define my-param (make-parameter 123
                   (lambda (val)
                     (if (not (number? val))
                         (error "must be a number"))
                     (inexact->exact val))))
(my-param 0.75)
(my-param) @result{} 3/4
@end example
@end deffn

@deffn {library syntax} parameterize ((param value) @dots{}) body1 body2 @dots{}
Устанавливает новую динамическую область с заданными параметрами @var{param}, привязанными
к новым местоположениям и установленными заданными значениями @var{value}s. 
Выражения @var{body1} @var{body2} @dots{} вычисляются в этой среде.  
Значение возвращаемое последним body формы возвращается.

Каждый параметр @var{param} является выражением, которое вычисляется для 
получения объекта параметра.  Часто это будет просто имя переменной, содержащей
объект, но это может быть что угодно что вычисляет параметр.

Выражения @var{param} и выражения @var{value} все вычисляются перед установкой
новой динамической привязки, и они вычисляются в неопределенном порядке.

Например,

@example
(define prompt (make-parameter "Type something: "))
(define (get-input)
  (display (prompt))
  ...)

(parameterize ((prompt "Type a number: "))
  (get-input)
  ...)
@end example
@end deffn

Объекты параметры реализуются с использованием флюидов (@pxref{Fluids and
Dynamic States}), поэтому каждое динамическое состояние имеет свои собственные
местоположения. Это включает отдельные местопоолжения за пределами любой
паораметризованной(@code{parameterize}) формы.  Когда параметр создан он получает
отдельное начальное местположение в каждом динамическом состоянии, все они
инициализируются заданным значением @var{init}.

Новый код, вероятно, должен просто использовать параметры вместо флюидов,
поскольку интерфейс работы с ними лучше. Но для переноса старого кода или
обеспечения иного взаимодействия, Guile предоставляет процедуру 
@code{fluid->parameter}:

@deffn {Scheme Procedure} fluid->parameter fluid [conv]
Создает параметр, который оборачивает флюид.

Значение параметра будет тем же самым, что и значение флюида.
Если параметр пересвязывается в некотором динамическом пространстве,
возможно через @code{parameterize}, новое значение будет выполнять
необязательную процедуру @var{conv}, как и для любого параметра.  
Обратите внимание, что в отличии от @code{make-parameter}, @var{conv} 
не применяется к начальному значению.
@end deffn

Как упоминалось выше, потому что каждый поток обычно имеет отдельное
динамическое состояние, каждый поток имеет имеет и свои собственные
местоположения для объектов параметров, и изменения в одном потоке не
видно никакому другому. Когда создается новое динамическое состояние или
поток, значения параметров в исходном контексте, копируются в новое
местоположение.

@cindex SRFI-39
Параметры Guile соответствуют SRFI-39 (@pxref{SRFI-39}).

@node Handling Errors
@subsection Как обрабатывать Ошибки

Обработка ошибок основана на @code{catch} и @code{throw}.  Ошибки всегда
выбрасываются с  ключем @var{key} и четырьмя аргументами:

@itemize @bullet
@item
@var{key}: символ, который указывает тип ошибки.  Символы используемые
в libguile перечислены ниже.

@item
@var{subr}: имя процедуры, из которой выдается ошибка, или
@code{#f}.

@item
@var{message}: это строка (возможно, зависящая от языка и системы)
описывающая ошибку.  Токены @code{~A} и @code{~S} могут быть
встроены в это сообщение: они будут заменены на элементы списка 
@var{args} когда сообщение будет распечатано.  @code{~A} указывает на
аргумент печатаемый с использованием @code{display}, тогда как @code{~S}
указывает на аргумент печатаемый с использованием @code{write}.  
@var{message} также может быть @code{#f}, чтобы его можно было извлечь из
@var{key} обработчиком ошибок (может быть полезно, если @var{key} может быть
выброшен как из Си, так и из Scheme).

@item
@var{args}: список аргументов, которые будут использоваться для расширения
токенов @code{~A} и @code{~S} в @var{message}.  Может также быть @code{#f} 
если аргументы не требуются.

@item
@var{rest}: список любых дополнительных необходимых объектов. например, когда
ключ key это @code{'system-error}, он содержит значение Си errno.  Также может
быть @code{#f} если никакие дополнительные объекты не требуется.
@end itemize

В дополнении к @code{catch} и @code{throw}, доступны следующие возмоности
Scheme:

@deffn {Scheme Procedure} display-error frame port subr message args rest
@deffnx {C Function} scm_display_error (frame, port, subr, message, args, rest)
Выводит сообщение об ошибке в порт вывода @var{port}.
@var{frame} это кадр в котором произошла ошибка, @var{subr} это
имя процедуры в которой произошла ошибка и @var{message} это фактическое
сообщение об ошибке, которое может содержать инструкции по форматированию.
Они позволяют форматированно выводить аргументы из списка @var{args}.  
@var{rest} игнорируется.
@end deffn

Ниже приведены ключи ошибок, определенные в libguile и ситуации, в которых они
используются:

@itemize @bullet
@item
@cindex @code{error-signal}
@code{error-signal}: выбрасывается после получение необработанного фатального
сигнала, такого как SIGSEGV, SIGBUS, SIGFPE и т.п.  Аргумент @var{rest} в функции
throw содержит код номера сигнала (в настоящее время это не тоже самое, что обычный
номер сигнала Unix).

@item
@cindex @code{system-error}
@code{system-error}: выбрасывается после того как операционная система
указала на состояние ошибки. Аргумент @var{rest} при вызове throw содержит
значение errno.

@item
@cindex @code{numerical-overflow}
@code{numerical-overflow}: числовое переполнение.

@item
@cindex @code{out-of-range}
@code{out-of-range}: аргументы процедуры не попадают в допустимую область.

@item
@cindex @code{wrong-type-arg}
@code{wrong-type-arg}: аргумент процедуры имеет неправильный тип.

@item
@cindex @code{wrong-number-of-args}
@code{wrong-number-of-args}: процедура была вызвана с неправильным числом аргументов.

@item
@cindex @code{memory-allocation-error}
@code{memory-allocation-error}: ошибка выделения памяти.

@item
@cindex @code{stack-overflow}
@code{stack-overflow}: ошибка переполнения стека.

@item
@cindex @code{regular-expression-syntax}
@code{regular-expression-syntax}: ошибки генерируемые библиотекой
регулярных выражений.

@item
@cindex @code{misc-error}
@code{misc-error}: другие ошибки.
@end itemize

@subsubsection Поддержка Си

В следующих Си функциях, параметры @var{SUBR} и @var{MESSAGE} могут
иметь значение @code{NULL}, что бы получить эффект как от @code{#f} 
описанный выше.

@deftypefn {C Function} SCM scm_error (SCM @var{key}, char *@var{subr}, char *@var{message}, SCM @var{args}, SCM @var{rest})
Выбрасывает(генерирует) ошибку, для каждого @code{scm-error} (@pxref{Error Reporting}).
@end deftypefn

@deftypefn {C Function} void scm_syserror (char *@var{subr})
@deftypefnx {C Function} void scm_syserror_msg (char *@var{subr}, char *@var{message}, SCM @var{args})
Генерирует ошибку с ключем @code{system-error} и указывает @code{errno} в
аргументе @var{rest}.  Для @code{scm_syserror} сообщение генерируется с
использованием @code{strerror}.

Следует позаботиться о том, чтобы любой код между ошибочной операцией и вызовом
этой процедуры не изменил @code{errno}.
@end deftypefn

@deftypefn {C Function} void scm_num_overflow (char *@var{subr})
@deftypefnx {C Function} void scm_out_of_range (char *@var{subr}, SCM @var{bad_value})
@deftypefnx {C Function} void scm_wrong_num_args (SCM @var{proc})
@deftypefnx {C Function} void scm_wrong_type_arg (char *@var{subr}, int @var{argnum}, SCM @var{bad_value})
@deftypefnx {C Function} void scm_wrong_type_arg_msg (char *@var{subr}, int @var{argnum}, SCM @var{bad_value}, const char *@var{expected})
@deftypefnx {C Function} void scm_memory_error (char *@var{subr})
@deftypefnx {C Function} void scm_misc_error (const char *@var{subr}, const char *@var{message}, SCM @var{args})
Выбрасывает ошибку с различными ключами описанными выше.

В @code{scm_wrong_num_args}, @var{proc} должен быть символом Scheme,
который является именем неправильно вызванной процедуры. Другие
подпрограммы принимают имя вызванной процедуры в виде Си строки.

В @code{scm_wrong_type_arg_msg}, @var{expected} ожидается Си строка
описывающая тип аргумента, который ожидался.

В @code{scm_misc_error}, @var{message} это строка сообщения об ошибке,
возможно, содержащая простой формат @code{simple-format} экранирования (@pxref{Simple
Output}), и соответствующие аргументы в списке @var{args}.
@end deftypefn

@subsubsection Сигнализация об Ошибках в Типе

Каждая функция, видимая на уровне Scheme должна активно проверять типы
своих аргументов, чтобы избежать неверной интерпретации значения, и
возможно выдавать ошибку сегментации.  Guile предоставляет некоторые макросы
чтобы делать это просто.

@deftypefn Macro void SCM_ASSERT (int @var{test}, SCM @var{obj}, unsigned int @var{position}, const char *@var{subr})
@deftypefnx Macro void SCM_ASSERT_TYPE (int @var{test}, SCM @var{obj}, unsigned int @var{position}, const char *@var{subr}, const char *@var{expected}) 
Если @var{test} равен нулю, сигнализирует об ошибке ``неверный тип аргумента(wrong type argument)'',
свяазнной с программой с именем @var{subr}, oработающей со значением
@var{obj}, котое является аргументом в позиции @var{position} @var{subr}.

В @code{SCM_ASSERT_TYPE}, @var{expected} это Си строка описывающая тип
аргумента, который ожидается.
@end deftypefn

@deftypefn Macro int SCM_ARG1
@deftypefnx Macro int SCM_ARG2
@deftypefnx Macro int SCM_ARG3
@deftypefnx Macro int SCM_ARG4
@deftypefnx Macro int SCM_ARG5
@deftypefnx Macro int SCM_ARG6
@deftypefnx Macro int SCM_ARG7
Одно из приведенных выше значений может использоваться для @var{position}, чтобы указать
номер аргумента в @var{subr} который проверяется.
Кроме того, положительное целое число может быть испольовано, что позволяет проверять
аргументы после семи.  Однако для параметра с номером выше семи, предпочтительно
использовать @code{SCM_ARGN} вместо соответствующего необработанного числа, поскольку
оно облегчает понимание кода.
@end deftypefn

@deftypefn Macro int SCM_ARGn
Передача нулевого значения  или @code{SCM_ARGn} для позиции @var{position} позволяет
оставить ее неопределенной, с неправильным типом аргумента. Опять же
@code{SCM_ARGn} должен быть предпочтительнее постаоянного необработанного нуля.
@end deftypefn

@node Continuation Barriers
@subsection Барьеры Продолжений

Не локальный поток управления, вызыванный продолжениями, иногда может быть
нежелательным. Вы можете использовать @code{with-continuation-barrier} для
возведения барьера, который не смогут проходить продолжения.

@deffn {Scheme Procedure} with-continuation-barrier proc
@deffnx {C Function} scm_with_continuation_barrier (proc)
Вызывает @var{proc} и возвращает его результат.  Не позволяйте вызываемым
продолжениям, которые покидают или входят в динамическое пространство(экстент)
вызывать @code{with-continuation-barrier}.  Такая попытка приведет к сообщению об
ошибке.

Выбросы/вызовы(Throws) (такие как ошибки), которые не перехвачены внутри
@var{proc} ловяться  @code{with-continuation-barrier}.  В этом случае, печатается
короткое сообщение в текущий порт ошибки и возвращается @code{#f}.

Таким образом, @code{with-continuation-barrier} возвращается ровноо один раз.
@end deffn

@deftypefn {C Function} {void *} scm_c_with_continuation_barrier (void *(*func) (void *), void *data)
Как @code{scm_with_continuation_barrier} но вызывает @var{func} для
@var{data}.  Когда ловит ошибку, возвращает @code{NULL}.
@end deftypefn

@c Local Variables:
@c TeX-master: "guile.texi"
@c End: