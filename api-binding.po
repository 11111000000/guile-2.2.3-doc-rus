#
# Gagin <mikhail-gagin@yandex.ru>, 2018.
# NuINu <don't@send.my>, 2019.
#
#. extracted from api-binding.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-04-18 08:03+0300\n"
"PO-Revision-Date: 2019-03-04 12:00+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: api-binding.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C) 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2009, 2010, "
"2011,\n"
"@c   2014 Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: api-binding.texi:9
msgid ""
"@node Binding Constructs\n"
"@section Definitions and Variable Bindings"
msgstr ""

#: api-binding.texi:14
msgid ""
"Scheme supports the definition of variables in different contexts.\n"
"Variables can be defined at the top level, so that they are visible in\n"
"the entire program, and variables can be defined locally to procedures\n"
"and expressions.  This is important for modularity and data abstraction."
msgstr ""
"Scheme поддерживает определение переменных в разных контекстах. \n"
"Переменные могут быть определены на верхнем уровне, чтобы они были\n"
"видны во всей программе и переменные могут быть определены локально\n"
"в процедурах и выражениях. Это важно для модульности и абстракции\n"
"данных."

#: api-binding.texi:22
msgid ""
"@menu\n"
"* Top Level::                   Top level variable definitions.\n"
"* Local Bindings::              Local variable bindings.\n"
"* Internal Definitions::        Internal definitions.\n"
"* Binding Reflection::          Querying variable bindings.\n"
"* Binding Multiple Values::     Binding multiple return values.\n"
"@end menu"
msgstr ""

#: api-binding.texi:26
msgid ""
"@node Top Level\n"
"@subsection Top Level Variable Definitions"
msgstr ""

#: api-binding.texi:28
msgid "@cindex variable definition"
msgstr ""

#: api-binding.texi:31
msgid ""
"At the top level of a program (i.e., not nested within any other\n"
"expression), a definition of the form"
msgstr ""
"На верхнем уровне программы (т.е не вложенной в другое выражене),\n"
"определение имеет форму:"

#: api-binding.texi:35
msgid ""
"@lisp\n"
"(define a @var{value})\n"
"@end lisp"
msgstr ""

#: api-binding.texi:38
msgid ""
"@noindent\n"
"defines a variable called @code{a} and sets it to the value @var{value}."
msgstr ""
"@noindent\n"
"определение переменной вызывает @code{a} и устанавливает значение "
"@var{value}."

#: api-binding.texi:43
msgid ""
"If the variable already exists in the current module, because it has\n"
"already been created by a previous @code{define} expression with the\n"
"same name, its value is simply changed to the new @var{value}.  In this\n"
"case, then, the above form is completely equivalent to"
msgstr ""
"Если переменная уже существует в текущем модуле, поскольку она уже создана\n"
"в предыдущем выражении с тем же именем, ее значение просто изменяется на\n"
"новое значение. В этом случае указанная выше форма полностью эквивалентна"

#: api-binding.texi:47
msgid ""
"@lisp\n"
"(set! a @var{value})\n"
"@end lisp"
msgstr ""

#: api-binding.texi:55
msgid ""
"@noindent\n"
"This equivalence means that @code{define} can be used interchangeably\n"
"with @code{set!} to change the value of variables at the top level of\n"
"the REPL or a Scheme source file.  It is useful during interactive\n"
"development when reloading a Scheme file that you have modified, because\n"
"it allows the @code{define} expressions in that file to work as expected\n"
"both the first time that the file is loaded and on subsequent occasions."
msgstr ""
"@noindent\n"
"Эта эквивалентность означает, что @code{define} может использоваться \n"
"взаимозаменяемо с @code{set!} для изменения значений переменных на верхнем\n"
"уровне REPL или исходном файле Scheme.  Это полезно во время интерактивной\n"
"разработки при перезагрузке файла Scheme который вы изменили, поскольку это\n"
"позволяет определить выражения в этом файле, так что бы они корректно\n"
"работали как при загрузке файла в первый, так и при последующих загрузках"

#: api-binding.texi:61
msgid ""
"Note, though, that @code{define} and @code{set!} are not always\n"
"equivalent.  For example, a @code{set!} is not allowed if the named\n"
"variable does not already exist, and the two expressions can behave\n"
"differently in the case where there are imported variables visible from\n"
"another module."
msgstr ""
"Заметьте однако, что @code{define} и @code{set!} не всегда эквивалентны.\n"
"На пример, @code{set!} не доступна если именнованная переменная еще не\n"
"существует.И эти два выражения могут вести себя иначе, в случае когда\n"
"импортируемые переменные видны из другого модуля."

#: api-binding.texi:67
msgid ""
"@deffn {Scheme Syntax} define name value\n"
"Create a top level variable named @var{name} with value @var{value}.\n"
"If the named variable already exists, just change its value.  The return\n"
"value of a @code{define} expression is unspecified.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Syntax} define name value\n"
"Создадим переменную верхнего уровня с именем @var{name} и значением "
"@var{value}.\n"
"Если имя переменной уже существует, то значение переменной просто "
"изменится.  \n"
"ВозвращаемоеThe  значекние выражения @code{define} не определено.\n"
"@end deffn"

#: api-binding.texi:72
msgid ""
"The C API equivalents of @code{define} are @code{scm_define} and\n"
"@code{scm_c_define}, which differ from each other in whether the\n"
"variable name is specified as a @code{SCM} symbol or as a\n"
"null-terminated C string."
msgstr ""
"В C API эквивалентом @code{define} выступают @code{scm_define} и\n"
"@code{scm_c_define}, которые отличаются друг от друга определением\n"
"имени переменной, в первом это @code{SCM} символ, а во втором Си строка\n"
"оканчивающаяся нулем.\n"

#: api-binding.texi:79
msgid ""
"@deffn {C Function} scm_define (sym, value)\n"
"@deffnx {C Function} scm_c_define (const char *name, value)\n"
"C equivalents of @code{define}, with variable name specified either by\n"
"@var{sym}, a symbol, or by @var{name}, a null-terminated C string.  Both\n"
"variants return the new or preexisting variable object.\n"
"@end deffn"
msgstr ""
"@deffn {C Function} scm_define (sym, value)\n"
"@deffnx {C Function} scm_c_define (const char *name, value)\n"
"Си эквивалент @code{define}, с именем переменной определенным как\n"
"@var{sym} символ, или как @var{name}, заканчивающаяся нулем Си строка.  \n"
"Оба варианта возвращают новый или существующий объект переменной.\n"
"@end deffn\n"

#: api-binding.texi:88
msgid ""
"@code{define} (when it occurs at top level), @code{scm_define} and\n"
"@code{scm_c_define} all create or set the value of a variable in the top\n"
"level environment of the current module.  If there was not already a\n"
"variable with the specified name belonging to the current module, but a\n"
"similarly named variable from another module was visible through having\n"
"been imported, the newly created variable in the current module will\n"
"shadow the imported variable, such that the imported variable is no\n"
"longer visible."
msgstr ""
"@code{define} (когда это происходит на верхнем уровне), @code{scm_define} и\n"
"@code{scm_c_define} все создают или устанавливают значение переменной\n"
"среды верхнего уровня текущего модуля.  Если еще не было переменной с\n"
"узазанным именем, принадлежащей к текущему модулю, но аналогично "
"именованная\n"
"переменная из другого модуля была видна через импорт, то недавно созданная\n"
"переменная в текущем модуле перекроет импортированную переменную, так\n"
"что импортированная переменная больше не будет видна."

#: api-binding.texi:91
msgid ""
"Attention: Scheme definitions inside local binding constructs\n"
"(@pxref{Local Bindings}) act differently (@pxref{Internal Definitions})."
msgstr ""
"Внимание: Определения в Scheme связываний внутри локальных конструкций\n"
"(@pxref{Local Bindings}) действуют по разному см. (@pxref{Internal "
"Definitions})."

#: api-binding.texi:99
msgid ""
"Many people end up in a development style of adding and changing\n"
"definitions at runtime, building out their program without restarting\n"
"it.  (You can do this using @code{reload-module}, the @code{reload} REPL\n"
"command, the @code{load} procedure, or even just pasting code into a\n"
"REPL.)  If you are one of these people, you will find that sometimes\n"
"there are some variables that you @emph{don't} want to redefine all the\n"
"time.  For these, use @code{define-once}."
msgstr ""
"Многие люди используют стиль разработки добавляя и изменяя определения\n"
"во время выполнения программы. Встраивая их в свою программу, но не "
"презапуская\n"
"ее. (Вы можете сделать это используя команду @code{reload-module}, команду \n"
"@code{reload} REPL, процедуру @code{load}, или просто вставляя код в REPL.)\n"
"Если вы один из этих людей, вы обранужите что иногда есть некоторые "
"переменные,\n"
"которые вы не хотите переопределять все время. \n"
"Для этого используется @code{define-once}."

#: api-binding.texi:105
msgid ""
"@fnindex defvar\n"
"@deffn {Scheme Syntax} define-once name value\n"
"Create a top level variable named @var{name} with value @var{value}, but\n"
"only if @var{name} is not already bound in the current module.\n"
"@end deffn"
msgstr ""
"@fnindex defvar\n"
"@deffn {Scheme Syntax} define-once name value\n"
"Создает переменную верхнего уровня с именем @var{name} и значением "
"@var{value}, \n"
"но только если имя @var{name} еще не используется в текущем модуле.\n"
"@end deffn"

#: api-binding.texi:108
msgid ""
"Old Lispers probably know @code{define-once} under its Lisp name,\n"
"@code{defvar}."
msgstr ""
"Старые лисперы, вероятно знают @code{define-once} под лисп именем,\n"
"@code{defvar}."

#: api-binding.texi:112
msgid ""
"@node Local Bindings\n"
"@subsection Local Variable Bindings"
msgstr ""
"@node Local Bindings\n"
"@subsection Связывание Локальных Переменных(Local Variable Bindings)"

#: api-binding.texi:115
msgid ""
"@cindex local bindings\n"
"@cindex local variables"
msgstr ""

#: api-binding.texi:121
msgid ""
"As opposed to definitions at the top level, which creates bindings that\n"
"are visible to all code in a module, it is also possible to define\n"
"variables which are only visible in a well-defined part of the program.\n"
"Normally, this part of a program will be a procedure or a subexpression\n"
"of a procedure."
msgstr ""
"В отличии от определений на верхнем уровне, которые создают привзяки,\n"
"которые видны всему коду в модуле, также можно определять переменные,\n"
"которые видны только в четко определенной части программы. Обычно эта\n"
"часть программы будет процедурой или подвыражением процедуры."

#: api-binding.texi:128
msgid ""
"With the constructs for local binding (@code{let}, @code{let*},\n"
"@code{letrec}, and @code{letrec*}), the Scheme language has a block\n"
"structure like most other programming languages since the days of\n"
"@sc{Algol 60}.  Readers familiar to languages like C or Java should\n"
"already be used to this concept, but the family of @code{let}\n"
"expressions has a few properties which are well worth knowing."
msgstr ""
"С помощью конструкций для локального связывания (@code{let}, @code{let*},\n"
"@code{letrec}, и @code{letrec*}), язык Scheme имеет получает блочную\n"
"структуру, как и большинство других языков программирования со времен\n"
"@sc{Algol 60}.  Читатели, знакомые с такими языками как C или Java уже\n"
"должны быть знакомы с этой концепцией, но у семейства выражений @code{let}\n"
"есть несколько свойств, которые стоит знать."

#: api-binding.texi:130
msgid "The most basic local binding construct is @code{let}."
msgstr ""
"Самой базовой конструкцией создания локальных привязок является @code{let}."

#: api-binding.texi:133
msgid ""
"@deffn syntax let bindings body\n"
"@var{bindings} has the form"
msgstr ""

#: api-binding.texi:137
msgid ""
"@lisp\n"
"((@var{variable1} @var{init1}) @dots{})\n"
"@end lisp"
msgstr ""

#: api-binding.texi:140
msgid ""
"that is zero or more two-element lists of a variable and an arbitrary\n"
"expression each.  All @var{variable} names must be distinct."
msgstr ""
"это ноль или больше двух-элементных списков, каждый из которых состоит из\n"
" переменной и произвольного выражения. Все имена переменных @var{variable}\n"
"должны быть разными."

#: api-binding.texi:142
msgid "A @code{let} expression is evaluated as follows."
msgstr "Все выражения @code{let} вычисляются следующим образом."

#: api-binding.texi:146
msgid ""
"@itemize @bullet\n"
"@item\n"
"All @var{init} expressions are evaluated."
msgstr ""
"@itemize @bullet\n"
"@item\n"
"Вычисляются все выражения  @var{init}."

#: api-binding.texi:149
msgid ""
"@item\n"
"New storage is allocated for the @var{variables}."
msgstr ""
"@item\n"
"Выделяется новое хранилище для переменных  @var{variables}."

#: api-binding.texi:152
msgid ""
"@item\n"
"The values of the @var{init} expressions are stored into the variables."
msgstr ""
"@item\n"
"Значения выражений @var{init} сохраняюся в переменных."

#: api-binding.texi:158
msgid ""
"@item\n"
"The expressions in @var{body} are evaluated in order, and the value of\n"
"the last expression is returned as the value of the @code{let}\n"
"expression.\n"
"@end itemize"
msgstr ""
"@item\n"
"Выражения в теле(@var{body}) вычислляются по порядку, и значение последнего\n"
"выражения возвращается как значение выражения @code{let}.\n"
"@end itemize"

#: api-binding.texi:162
msgid ""
"The @var{init} expressions are not allowed to refer to any of the\n"
"@var{variables}.\n"
"@end deffn"
msgstr ""
"Выражения @var{init} не могут ссылаться ни на одну из локальных переменных\n"
"@var{variables}.\n"
"@end deffn"

#: api-binding.texi:166
msgid ""
"The other binding constructs are variations on the same theme: making new\n"
"values, binding them to variables, and executing a body in that new,\n"
"extended lexical context."
msgstr ""
"Другие конструкции создания привязок - это вариации на одну и туже тему:\n"
"создания новых значений, связывания их с переменными и вычисления тела в\n"
"этом новом расширенном лексическом контексте."

#: api-binding.texi:171
msgid ""
"@deffn syntax let* bindings body\n"
"Similar to @code{let}, but the variable bindings are performed\n"
"sequentially, that means that all @var{init} expression are allowed to\n"
"use the variables defined on their left in the binding list."
msgstr ""
"@deffn syntax let* bindings body\n"
"Аналогично @code{let}, но привязка переменных выполняется последовательно,\n"
"так что все выражения @var{init} могут использовать переменные определенные\n"
"левее в списке определения привязок."

#: api-binding.texi:174
msgid ""
"A @code{let*} expression can always be expressed with nested @code{let}\n"
"expressions."
msgstr ""
"Выражение @code{let*} всегда может быть выражено вложенными выражениями\n"
"@code{let}."

#: api-binding.texi:184
msgid ""
"@lisp\n"
"(let* ((a 1) (b a))\n"
"   b)\n"
"@equiv{}\n"
"(let ((a 1))\n"
"  (let ((b a))\n"
"    b))\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-binding.texi:190
msgid ""
"@deffn syntax letrec bindings body\n"
"Similar to @code{let}, but it is possible to refer to the @var{variable}\n"
"from lambda expression created in any of the @var{inits}.  That is,\n"
"procedures created in the @var{init} expression can recursively refer to\n"
"the defined variables."
msgstr ""
"@deffn syntax letrec bindings body\n"
"Подобно @code{let}, но можно ссылаться на переменные @var{variable}\n"
"из лямбда выражений созданных в любом из @var{inits}.  То есть, \n"
"процедуры созданные в выражении @var{init} могут рекурсивно ссылаться на\n"
"определенные переменные."

#: api-binding.texi:204
msgid ""
"@lisp\n"
"(letrec ((even? (lambda (n)\n"
"                  (if (zero? n)\n"
"                      #t\n"
"                      (odd? (- n 1)))))\n"
"         (odd? (lambda (n)\n"
"                  (if (zero? n)\n"
"                      #f\n"
"                      (even? (- n 1))))))\n"
"  (even? 88))\n"
"@result{}\n"
"#t\n"
"@end lisp"
msgstr ""

#: api-binding.texi:211
msgid ""
"Note that while the @var{init} expressions may refer to the new\n"
"variables, they may not access their values.  For example, making the\n"
"@code{even?} function above creates a closure (@pxref{About Closure})\n"
"referencing the @code{odd?} variable.  But @code{odd?} can't be called\n"
"until after execution has entered the body.\n"
"@end deffn"
msgstr ""
"Обратите внимание, что хотя выражения @var{init} могут ссылаться на \n"
"новвые переменные, они не могут получить доступ к их значениям.\n"
"Например, созданная выше функция @code{even?} создает замыкание "
"(@pxref{About Closure})\n"
"ссылающеся на переменную @code{odd?}.  Но @code{odd?} не может быть\n"
"вызвана(а значит и вызвана @code{even?})  до тех пор пока выполнение не \n"
"перейдет в тело(body).\n"
"@end deffn"

#: api-binding.texi:215
msgid ""
"@deffn syntax letrec* bindings body\n"
"Similar to @code{letrec}, except the @var{init} expressions are bound to\n"
"their variables in order."
msgstr ""
"@deffn syntax letrec* bindings body\n"
"Аналогично @code{letrec}, за исключением того, что выражения @var{init} \n"
"связываются со своими переменными по порядку."

#: api-binding.texi:219
msgid ""
"@code{letrec*} thus relaxes the letrec restriction, in that later\n"
"@var{init} expressions may refer to the values of previously bound\n"
"variables."
msgstr ""
"Таким образом  @code{letrec*} ослабляет ограничения letrec, так как\n"
"более поздние выражения @var{init} могут ссылаться на значения ранее\n"
"связанных переменных.\n"
"variables."

#: api-binding.texi:225
msgid ""
"@lisp\n"
"(letrec ((a 42)\n"
"         (b (+ a 10)))  ;; Illegal access\n"
"  (* a b))\n"
";; The behavior of the expression above is unspecified"
msgstr ""

#: api-binding.texi:232
msgid ""
"(letrec* ((a 42)\n"
"          (b (+ a 10)))\n"
"  (* a b))\n"
"@result{} 2184\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-binding.texi:237
msgid ""
"There is also an alternative form of the @code{let} form, which is used\n"
"for expressing iteration.  Because of the use as a looping construct,\n"
"this form (the @dfn{named let}) is documented in the section about\n"
"iteration (@pxref{while do, Iteration})"
msgstr ""
"Существует так же альтернативная форма формы @code{let}, которая "
"исползуется\n"
"для выражения итерации.  Из-за использования в качестве циклической "
"конструкции,\n"
"эта форма именованного let ((the @dfn{named let})) задокументирована в\n"
"разделе рассказывающем об итерациях (@pxref{while do, Iteration})"

#: api-binding.texi:240
msgid ""
"@node Internal Definitions\n"
"@subsection Internal definitions"
msgstr ""
"@node Internal Definitions\n"
"@subsection Внтуренние определения"

#: api-binding.texi:242
msgid "@c FIXME::martin: Review me!"
msgstr ""

#: api-binding.texi:249
msgid ""
"A @code{define} form which appears inside the body of a @code{lambda},\n"
"@code{let}, @code{let*}, @code{letrec}, @code{letrec*} or equivalent\n"
"expression is called an @dfn{internal definition}.  An internal\n"
"definition differs from a top level definition (@pxref{Top Level}),\n"
"because the definition is only visible inside the complete body of the\n"
"enclosing form.  Let us examine the following example."
msgstr ""
"Форма @code{define}, которая появляется внутри тела @code{lambda},\n"
"@code{let}, @code{let*}, @code{letrec}, @code{letrec*} или эквивалентного\n"
"выражения называется внутренним определением(@dfn{internal definition}).\n"
"Внутреннее определение отличается от определения верхнего уровня (@pxref{Top "
"Level}),\n"
"поскольку это определение видно только внутри тела вмещающей формы.\n"
"Давайте рассмотрим следующий пример."

#: api-binding.texi:258
msgid ""
"@lisp\n"
"(let ((frumble \"froz\"))\n"
"   (define banana (lambda () (apple 'peach)))\n"
"   (define apple (lambda (x) x))\n"
"   (banana))\n"
"@result{}\n"
"peach\n"
"@end lisp"
msgstr ""

#: api-binding.texi:267
msgid ""
"Here the enclosing form is a @code{let}, so the @code{define}s in the\n"
"@code{let}-body are internal definitions.  Because the scope of the\n"
"internal definitions is the @strong{complete} body of the\n"
"@code{let}-expression, the @code{lambda}-expression which gets bound to\n"
"the variable @code{banana} may refer to the variable @code{apple}, even\n"
"though its definition appears lexically @emph{after} the definition of\n"
"@code{banana}.  This is because a sequence of internal definition acts\n"
"as if it were a @code{letrec*} expression."
msgstr ""
"Здесь вмещающая форма - это @code{let}, поэтому @code{define} в теле\n"
"@code{let} являются внутренними определениями.  Поскольку область действия\n"
"внутренних определений является ВСЕ(@strong{complete}) тело выражения\n"
"@code{let}, @code{lambda}-выражение, котолрое связывается с переменной\n"
"@code{banana} может ссылаться на переменную @code{apple}, хотя его "
"определение\n"
"появляется лексически после(@emph{after}) определения @code{banana}.  \n"
"Это происходит потому, что последовательность внутреннего определения "
"действует\n"
"так, как будто это выражение @code{letrec*}."

#: api-binding.texi:274
msgid ""
"@lisp\n"
"(let ()\n"
"  (define a 1)\n"
"  (define b 2)\n"
"  (+ a b))\n"
"@end lisp"
msgstr ""

#: api-binding.texi:277
msgid ""
"@noindent\n"
"is equivalent to"
msgstr ""
"@noindent\n"
"этквивалентно"

#: api-binding.texi:283
msgid ""
"@lisp\n"
"(let ()\n"
"  (letrec* ((a 1) (b 2))\n"
"    (+ a b)))\n"
"@end lisp"
msgstr ""

#: api-binding.texi:286
msgid ""
"Internal definitions are only allowed at the beginning of the body of an\n"
"enclosing expression.  They may not be mixed with other expressions."
msgstr ""
"Внутренние определения допускаются только в начале тела включающего "
"выражения.\n"
"Они не могут быть смешаны с другими выражениями."

#: api-binding.texi:292
msgid ""
"Another noteworthy difference to top level definitions is that within\n"
"one group of internal definitions all variable names must be distinct.\n"
"That means where on the top level a second define for a given variable\n"
"acts like a @code{set!}, an exception is thrown for internal definitions\n"
"with duplicate bindings."
msgstr ""
"Другое примечательное отличие от определений верхнего уровня состоит в том, "
"что\n"
"в пределах одной группы внутренних определений определения всех имен "
"переменных\n"
"должны быть разными. Это означает, что на верхнем уровне второе определение "
"для\n"
"данной переменной действует как @code{set!}, а для внутренних определений с\n"
"повторной привязкой выбрасывается исключение."

#: api-binding.texi:298
msgid ""
"As a historical note, it used to be that internal bindings were expanded\n"
"in terms of @code{letrec}, not @code{letrec*}. This was the situation\n"
"for the R5RS report and before. However with the R6RS, it was recognized\n"
"that sequential definition was a more intuitive expansion, as in the\n"
"following case:"
msgstr ""
"Историческое замечание, раньше внутренние привязки расширялись в терминах\n"
"@code{letrec}, а не @code{letrec*}. Такая ситуация была для отчета R5RS\n"
"и более ранних. Тем не менее в R6RS, было признано, что последовательное\n"
"определение является интуитивным расширением, как в следующем случае:"

#: api-binding.texi:305
msgid ""
"@lisp\n"
"(let ()\n"
"  (define a 1)\n"
"  (define b (+ a a))\n"
"  (+ a b))\n"
"@end lisp"
msgstr ""

#: api-binding.texi:309
msgid ""
"@noindent\n"
"Guile decided to follow the R6RS in this regard, and now expands\n"
"internal definitions using @code{letrec*}."
msgstr ""
"@noindent\n"
"Guile решил следовать R6RS в этом отношении, и теперь расширяет внутренние\n"
"определения используя @code{letrec*}."

#: api-binding.texi:313
msgid ""
"@node Binding Reflection\n"
"@subsection Querying variable bindings"
msgstr ""
"@node Binding Reflection\n"
"@subsection Запрос о связанных переменных"

#: api-binding.texi:316
msgid ""
"Guile provides a procedure for checking whether a symbol is bound in the\n"
"top level environment."
msgstr ""
"Guile предоставляет процедуру для проверки того, связан ли символ в среде\n"
"верхнего уровня."

#: api-binding.texi:323
msgid ""
"@deffn {Scheme Procedure} defined? sym [module]\n"
"@deffnx {C Function} scm_defined_p (sym, module)\n"
"Return @code{#t} if @var{sym} is defined in the module @var{module} or\n"
"the current module when @var{module} is not specified; otherwise return\n"
"@code{#f}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} defined? sym [module]\n"
"@deffnx {C Function} scm_defined_p (sym, module)\n"
"Возвращает @code{#t} если @var{sym} определен в модуле @var{module} или\n"
"текущем модуле, когда @var{module} не указан; в противном случае "
"возвращается\n"
"@code{#f}.\n"
"@end deffn"

#: api-binding.texi:327
msgid ""
"@node Binding Multiple Values\n"
"@subsection Binding multiple return values"
msgstr ""
"@node Binding Multiple Values\n"
"@subsection Связываение нескольких возвращаемых значений."

#: api-binding.texi:333
msgid ""
"@deffn {Syntax} define-values formals expression\n"
"The @var{expression} is evaluated, and the @var{formals} are bound to\n"
"the return values in the same way that the formals in a @code{lambda}\n"
"expression are matched to the arguments in a procedure call.\n"
"@end deffn"
msgstr ""
"@deffn {Syntax} define-values formals expression\n"
"Выражение @var{expression} вычисляется, и переменные @var{formals} "
"связываются\n"
"с возвращаемыми значениями , также как formals в @code{lambda} выражении, "
"сопоставляются\n"
"с аргументами при вызове процедуры.\n"
"@end deffn"

#: api-binding.texi:337
msgid ""
"@example\n"
"(define-values (q r) (floor/ 10 3))\n"
"(list q r) @result{} (3 1)"
msgstr ""

#: api-binding.texi:341
msgid ""
"(define-values (x . y) (values 1 2 3))\n"
"x @result{} 1\n"
"y @result{} (2 3)"
msgstr ""

#: api-binding.texi:345
msgid ""
"(define-values x (values 1 2 3))\n"
"x @result{} (1 2 3)\n"
"@end example"
msgstr ""

#: api-binding.texi:349
msgid ""
"@c Local Variables:\n"
"@c TeX-master: \"guile.texi\"\n"
"@c End:"
msgstr ""
