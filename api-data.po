#
# Gagin <mikhail-gagin@yandex.ru>, 2018.
#
#. extracted from api-data.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-04-20 07:48+0300\n"
"PO-Revision-Date: 2018-05-07 10:48+0300\n"
"Last-Translator: Gagin <mikhail-gagin@yandex.ru>\n"
"Language-Team: Russian <mikhail-gagin@yandex.ru>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: api-data.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C)  1996, 1997, 2000-2004, 2006-2017\n"
"@c   Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: api-data.texi:9
msgid ""
"@node Data Types\n"
"@section Data Types"
msgstr ""

#: api-data.texi:14
msgid ""
"Guile's data types form a powerful built-in library of representations\n"
"and functionality that you can apply to your problem domain.  This\n"
"chapter surveys the data types built-in to Guile, from the simple to the\n"
"complex."
msgstr ""
"Типы данных Guile образуют мощную встроенную библиотеку представлений\n"
"и функциональных возможностей, которые вы можете использовать в вашей\n"
"проблемной области. В этой главе рассматриваются типы данных, встроенные\n"
"в Guile, от простых до сложных."

#: api-data.texi:40
msgid ""
"@menu\n"
"* Booleans::                    True/false values.\n"
"* Numbers::                     Numerical data types.\n"
"* Characters::                  Single characters.\n"
"* Character Sets::              Sets of characters.\n"
"* Strings::                     Sequences of characters.\n"
"* Symbols::                     Symbols.\n"
"* Keywords::                    Self-quoting, customizable display "
"keywords.\n"
"* Pairs::                       Scheme's basic building block.\n"
"* Lists::                       Special list functions supported by Guile.\n"
"* Vectors::                     One-dimensional arrays of Scheme objects.\n"
"* Bit Vectors::                 Vectors of bits.\n"
"* Bytevectors::                 Sequences of bytes.\n"
"* Arrays::                      Multidimensional matrices.\n"
"* VLists::                      Vector-like lists.\n"
"* Record Overview::             Walking through the maze of record APIs.\n"
"* SRFI-9 Records::              The standard, recommended record API.\n"
"* Records::                     Guile's historical record API.\n"
"* Structures::                  Low-level record representation.\n"
"* Dictionary Types::            About dictionary types in general.\n"
"* Association Lists::           List-based dictionaries.\n"
"* VHashes::                     VList-based dictionaries.   \n"
"* Hash Tables::                 Table-based dictionaries.\n"
"* Other Types::                 Other sections describe data types too.\n"
"@end menu"
msgstr ""

#: api-data.texi:45
msgid ""
"@node Booleans\n"
"@subsection Booleans\n"
"@tpindex Booleans"
msgstr ""

#: api-data.texi:48
msgid ""
"The two boolean values are @code{#t} for true and @code{#f} for false.\n"
"They can also be written as @code{#true} and @code{#false}, as per R7RS."
msgstr ""
"Два логических значения @code{#t} истина и @code{#f} ложь.\n"
"Они также могут быть записаны как @code{#true} и @code{#false}, \n"
"согласно R7RS."

#: api-data.texi:54
msgid ""
"Boolean values are returned by predicate procedures, such as the general\n"
"equality predicates @code{eq?}, @code{eqv?} and @code{equal?}\n"
"(@pxref{Equality}) and numerical and string comparison operators like\n"
"@code{string=?} (@pxref{String Comparison}) and @code{<=}\n"
"(@pxref{Comparison})."
msgstr ""

#: api-data.texi:58
msgid ""
"@lisp\n"
"(<= 3 8)\n"
"@result{} #t"
msgstr ""

#: api-data.texi:61
msgid ""
"(<= 3 -3)\n"
"@result{} #f"
msgstr ""

#: api-data.texi:64
msgid ""
"(equal? \"house\" \"houses\")\n"
"@result{} #f"
msgstr ""

#: api-data.texi:69
msgid ""
"(eq? #f #f)\n"
"@result{}\n"
"#t\n"
"@end lisp"
msgstr ""

#: api-data.texi:74
msgid ""
"In test condition contexts like @code{if} and @code{cond}\n"
"(@pxref{Conditionals}), where a group of subexpressions will be\n"
"evaluated only if a @var{condition} expression evaluates to ``true'',\n"
"``true'' means any value at all except @code{#f}."
msgstr ""

#: api-data.texi:78
msgid ""
"@lisp\n"
"(if #t \"yes\" \"no\")\n"
"@result{} \"yes\""
msgstr ""

#: api-data.texi:81
msgid ""
"(if 0 \"yes\" \"no\")\n"
"@result{} \"yes\""
msgstr ""

#: api-data.texi:85
msgid ""
"(if #f \"yes\" \"no\")\n"
"@result{} \"no\"\n"
"@end lisp"
msgstr ""

#: api-data.texi:90
msgid ""
"A result of this asymmetry is that typical Scheme source code more often\n"
"uses @code{#f} explicitly than @code{#t}: @code{#f} is necessary to\n"
"represent an @code{if} or @code{cond} false value, whereas @code{#t} is\n"
"not necessary to represent an @code{if} or @code{cond} true value."
msgstr ""
"Результатом этой асимметрии является то, что типичный исходный код Scheme\n"
"чаще всего испльзует @code{#f} чем @code{#t}: @code{#f} необходима для\n"
"представления ложного значения @code{if} или @code{cond}, тогда как "
"@code{#t}\n"
"не является необходимым для того чтобы представлять истинное значение в \n"
"@code{if} или @code{cond}."

#: api-data.texi:95
msgid ""
"It is important to note that @code{#f} is @strong{not} equivalent to any\n"
"other Scheme value.  In particular, @code{#f} is not the same as the\n"
"number 0 (like in C and C++), and not the same as the ``empty list''\n"
"(like in some Lisp dialects)."
msgstr ""
"Важно отметить, что @code{#f} @strong{НЕ} эквивалентен никакому другому\n"
"значению Scheme.  В частности, @code{#f} это не тоже самое, что число 0 \n"
"(как в C и C++), и не тоже самое, что ``пустой список''\n"
"(как в некоторых диалектах Лиспа)."

#: api-data.texi:101
msgid ""
"In C, the two Scheme boolean values are available as the two constants\n"
"@code{SCM_BOOL_T} for @code{#t} and @code{SCM_BOOL_F} for @code{#f}.\n"
"Care must be taken with the false value @code{SCM_BOOL_F}: it is not\n"
"false when used in C conditionals.  In order to test for it, use\n"
"@code{scm_is_false} or @code{scm_is_true}."
msgstr ""
"В Си, два логических значения Scheme доступны как две константы \n"
"@code{SCM_BOOL_T} для @code{#t} и @code{SCM_BOOL_F} для @code{#f}.\n"
"Следует соблюдать осторожность с ложным значением @code{SCM_BOOL_F}: \n"
"это не false при использовании в условных выражениях Си.  Чтобы\n"
"проверить значение использйте @code{scm_is_false} или @code{scm_is_true}."

#: api-data.texi:107
msgid ""
"@rnindex not\n"
"@deffn {Scheme Procedure} not x\n"
"@deffnx {C Function} scm_not (x)\n"
"Return @code{#t} if @var{x} is @code{#f}, else return @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:114
msgid ""
"@rnindex boolean?\n"
"@deffn {Scheme Procedure} boolean? obj\n"
"@deffnx {C Function} scm_boolean_p (obj)\n"
"Return @code{#t} if @var{obj} is either @code{#t} or @code{#f}, else\n"
"return @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:118
msgid ""
"@deftypevr {C Macro} SCM SCM_BOOL_T\n"
"The @code{SCM} representation of the Scheme object @code{#t}.\n"
"@end deftypevr"
msgstr ""

#: api-data.texi:122
msgid ""
"@deftypevr {C Macro} SCM SCM_BOOL_F\n"
"The @code{SCM} representation of the Scheme object @code{#f}.\n"
"@end deftypevr"
msgstr ""

#: api-data.texi:126
msgid ""
"@deftypefn {C Function} int scm_is_true (SCM obj)\n"
"Return @code{0} if @var{obj} is @code{#f}, else return @code{1}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:130
msgid ""
"@deftypefn {C Function} int scm_is_false (SCM obj)\n"
"Return @code{1} if @var{obj} is @code{#f}, else return @code{0}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:135
msgid ""
"@deftypefn {C Function} int scm_is_bool (SCM obj)\n"
"Return @code{1} if @var{obj} is either @code{#t} or @code{#f}, else\n"
"return @code{0}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:139
msgid ""
"@deftypefn {C Function} SCM scm_from_bool (int val)\n"
"Return @code{#f} if @var{val} is @code{0}, else return @code{#t}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:143
msgid ""
"@deftypefn {C Function} int scm_to_bool (SCM val)\n"
"Return @code{1} if @var{val} is @code{SCM_BOOL_T}, return @code{0}\n"
"when @var{val} is @code{SCM_BOOL_F}, else signal a `wrong type' error."
msgstr ""
"@deftypefn {C Function} int scm_to_bool (SCM val)\n"
"Возвращает @code{1} если значение @var{val} равно @code{SCM_BOOL_T}, \n"
"возвращает @code{0} если значение @var{val} равно @code{SCM_BOOL_F},\n"
"иначе сигнал ошибки `wrong type'(неправильный тип)."

#: api-data.texi:147
msgid ""
"You should probably use @code{scm_is_true} instead of this function\n"
"when you just want to test a @code{SCM} value for trueness.\n"
"@end deftypefn"
msgstr ""
"Вы должны использовать @code{scm_is_true} вместо этой функции,\n"
"когда хотите просто проверить истинность значения @code{SCM}.\n"
"@end deftypefn"

#: api-data.texi:151
msgid ""
"@node Numbers\n"
"@subsection Numerical data types\n"
"@tpindex Numbers"
msgstr ""

#: api-data.texi:156
msgid ""
"Guile supports a rich ``tower'' of numerical types --- integer,\n"
"rational, real and complex --- and provides an extensive set of\n"
"mathematical and scientific functions for operating on numerical\n"
"data.  This section of the manual documents those types and functions."
msgstr ""
"Guile поддерживает богатую ``башню'' из числовых типов -\n"
"целые числа, рациональные, реальные и комплексные ---\n"
"и предоставляет обширный набор математических и научных\n"
"функций для работы с числовыми данными. В этом разделе\n"
"руководства указаны эти типы и функции."

#: api-data.texi:160
msgid ""
"You may also find it illuminating to read R5RS's presentation of numbers\n"
"in Scheme, which is particularly clear and accessible: see\n"
"@ref{Numbers,,,r5rs,R5RS}."
msgstr ""
"Вы также можете обнаружить что раздел освещает  R5RS's - представление\n"
"чисел в Scheme, для большей ясности: см\n"
"@ref{Numbers,,,r5rs,R5RS}."

#: api-data.texi:177
msgid ""
"@menu\n"
"* Numerical Tower::             Scheme's numerical \"tower\".\n"
"* Integers::                    Whole numbers.\n"
"* Reals and Rationals::         Real and rational numbers.\n"
"* Complex Numbers::             Complex numbers.\n"
"* Exactness::                   Exactness and inexactness.\n"
"* Number Syntax::               Read syntax for numerical data.\n"
"* Integer Operations::          Operations on integer values.\n"
"* Comparison::                  Comparison predicates.\n"
"* Conversion::                  Converting numbers to and from strings.\n"
"* Complex::                     Complex number operations.\n"
"* Arithmetic::                  Arithmetic functions.\n"
"* Scientific::                  Scientific functions.\n"
"* Bitwise Operations::          Logical AND, OR, NOT, and so on.\n"
"* Random::                      Random number generation.\n"
"@end menu"
msgstr ""

#: api-data.texi:182
msgid ""
"@node Numerical Tower\n"
"@subsubsection Scheme's Numerical ``Tower''\n"
"@rnindex number?"
msgstr ""

#: api-data.texi:185
msgid ""
"Scheme's numerical ``tower'' consists of the following categories of\n"
"numbers:"
msgstr "Числовая ``башня'' Scheme состоит из следующих числовых категорий:"

#: api-data.texi:189
msgid ""
"@table @dfn\n"
"@item integers\n"
"Whole numbers, positive or negative; e.g.@: --5, 0, 18."
msgstr ""
"@table @dfn\n"
"@item integers\n"
"Целые числа, положительные или отритцательные; например @: --5, 0, 18."

#: api-data.texi:195
msgid ""
"@item rationals\n"
"The set of numbers that can be expressed as @math{@var{p}/@var{q}}\n"
"where @var{p} and @var{q} are integers; e.g.@: @math{9/16} works, but\n"
"pi (an irrational number) doesn't. These include integers\n"
"(@math{@var{n}/1})."
msgstr ""
"@item rationals\n"
"Рациональные числа - набор чисел, который может быть выражен как \n"
"@math{@var{p}/@var{q}} где @var{p} и @var{q} целые; например@: \n"
"@math{9/16}, но pi (иррациональное число) нельзя так представить. \n"
"К ним относятся и целые числа, т.к (@math{@var{n}/1})."

#: api-data.texi:200
msgid ""
"@item real numbers\n"
"The set of numbers that describes all possible positions along a\n"
"one-dimensional line. This includes rationals as well as irrational\n"
"numbers."
msgstr ""
"@item real numbers\n"
"Реальные(Вещественные) числа - набор чисел, который описывает все возможные\n"
"положения вдоль одномерной линии. Он включает в себя и\n"
"рациональные и иррациональные числа."

#: api-data.texi:208
msgid ""
"@item complex numbers\n"
"The set of numbers that describes all possible positions in a two\n"
"dimensional space. This includes real as well as imaginary numbers\n"
"(@math{@var{a}+@var{b}i}, where @var{a} is the @dfn{real part},\n"
"@var{b} is the @dfn{imaginary part}, and @math{i} is the square root of\n"
"@minus{}1.)\n"
"@end table"
msgstr ""
"@item complex numbers\n"
"Комплексные числа, набор чисел, который описывает все возможные положения\n"
"в двумерном пространстве. Он включает как реальные так и мнимые числа\n"
"(@math{@var{a}+@var{b}i}, где @var{a} это @dfn{real part(реальная часть)},\n"
"@var{b} это @dfn{imaginary part(мнимая часть)}, и @math{i} это квадратный\n"
"корень из @minus{}1.)\n"
"@end table"

#: api-data.texi:213
msgid ""
"It is called a tower because each category ``sits on'' the one that\n"
"follows it, in the sense that every integer is also a rational, every\n"
"rational is also real, and every real number is also a complex number\n"
"(but with zero imaginary part)."
msgstr ""
"Это называется башней, потому что каждая категория ``сидит'' над той,\n"
"которая следует за ней, в том смысле, что целое число, также является\n"
"рациональным, а все рациональные числа, также вещественны и каждое \n"
"вещественное число одновременно и комплексное(но с нулевой мнимой частью)"

#: api-data.texi:221
msgid ""
"In addition to the classification into integers, rationals, reals and\n"
"complex numbers, Scheme also distinguishes between whether a number is\n"
"represented exactly or not.  For example, the result of\n"
"@m{2\\sin(\\pi/4),2*sin(pi/4)} is exactly @m{\\sqrt{2},2^(1/2)}, but Guile\n"
"can represent neither @m{\\pi/4,pi/4} nor @m{\\sqrt{2},2^(1/2)} exactly.\n"
"Instead, it stores an inexact approximation, using the C type\n"
"@code{double}."
msgstr ""
"В добавление к классификации в целые числа, рациональные, вещественные\n"
"и комплексные числа, Scheme также различает, представлено ли число точно\n"
"или нет.  Например, результат @m{2\\sin(\\pi/4),2*sin(pi/4)} точно \n"
"@m{\\sqrt{2},2^(1/2)}, но Guile неможет представлять ни @m{\\pi/4,pi/4}\n"
"ни @m{\\sqrt{2},2^(1/2)} точно.\n"
"Вместо этого он хранит неточное приближение, используя Си тип\n"
"@code{double}."

#: api-data.texi:225
msgid ""
"Guile can represent exact rationals of any magnitude, inexact\n"
"rationals that fit into a C @code{double}, and inexact complex numbers\n"
"with @code{double} real and imaginary parts."
msgstr ""
"Guile может представлять точные рациональности любой величины,\n"
"неточные рациональности которые описываеются в Си @code{double},\n"
"и неточные комплексные числа с типом Си @code{double} реальной\n"
"и мнимой частью."

#: api-data.texi:228
msgid ""
"The @code{number?} predicate may be applied to any Scheme value to\n"
"discover whether the value is any of the supported numerical types."
msgstr ""
"Предикат @code{number?} может быть применен к любому значению Scheme,\n"
"чтобы выяснить является ли значение числом для любого из поддерживаемых\n"
"числовых типов."

#: api-data.texi:233
msgid ""
"@deffn {Scheme Procedure} number? obj\n"
"@deffnx {C Function} scm_number_p (obj)\n"
"Return @code{#t} if @var{obj} is any kind of number, else @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:235
msgctxt "api-data.texi:235"
msgid "For example:"
msgstr ""

#: api-data.texi:239
msgid ""
"@lisp\n"
"(number? 3)\n"
"@result{} #t"
msgstr ""

#: api-data.texi:242
msgid ""
"(number? \"hello there!\")\n"
"@result{} #f"
msgstr ""

#: api-data.texi:247
msgid ""
"(define pi 3.141592654)\n"
"(number? pi)\n"
"@result{} #t\n"
"@end lisp"
msgstr ""

#: api-data.texi:251
msgid ""
"@deftypefn {C Function} int scm_is_number (SCM obj)\n"
"This is equivalent to @code{scm_is_true (scm_number_p (obj))}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:254
msgid ""
"The next few subsections document each of Guile's numerical data types\n"
"in detail."
msgstr ""
"Следующие несколько подразделов подробно описывают каждый из численных\n"
"типов данных Guile."

#: api-data.texi:257
msgid ""
"@node Integers\n"
"@subsubsection Integers"
msgstr ""

#: api-data.texi:259
msgid "@tpindex Integer numbers"
msgstr ""

#: api-data.texi:261
msgid "@rnindex integer?"
msgstr ""

#: api-data.texi:264
msgid ""
"Integers are whole numbers, that is numbers with no fractional part,\n"
"such as 2, 83, and @minus{}3789."
msgstr ""

#: api-data.texi:267
msgid ""
"Integers in Guile can be arbitrarily big, as shown by the following\n"
"example."
msgstr ""
"Целые числа в Guile могут быть сколь угодно большими, как\n"
"показано в следующем примере."

#: api-data.texi:274
msgid ""
"@lisp\n"
"(define (factorial n)\n"
"  (let loop ((n n) (product 1))\n"
"    (if (= n 0)\n"
"        product\n"
"        (loop (- n 1) (* product n)))))"
msgstr ""

#: api-data.texi:277
msgid ""
"(factorial 3)\n"
"@result{} 6"
msgstr ""

#: api-data.texi:280
msgid ""
"(factorial 20)\n"
"@result{} 2432902008176640000"
msgstr ""

#: api-data.texi:284
msgid ""
"(- (factorial 45))\n"
"@result{} -119622220865480194561963161495657715064383733760000000000\n"
"@end lisp"
msgstr ""

#: api-data.texi:294
msgid ""
"Readers whose background is in programming languages where integers are\n"
"limited by the need to fit into just 4 or 8 bytes of memory may find\n"
"this surprising, or suspect that Guile's representation of integers is\n"
"inefficient.  In fact, Guile achieves a near optimal balance of\n"
"convenience and efficiency by using the host computer's native\n"
"representation of integers where possible, and a more general\n"
"representation where the required number does not fit in the native\n"
"form.  Conversion between these two representations is automatic and\n"
"completely invisible to the Scheme level programmer."
msgstr ""
"Читатели, чьи имеющие знания в языках программирования низкого уровня\n"
"(типа Си), где целые числа ограничены необходимостью умещаться в\n"
"4 или 8 байт памяти, могут найти это удивительным и подозревать, что\n"
"представление целых чисел Guile неэффективно. Фактически, Guile \n"
"достигает почти оптимального баланса удобства и эффективности,\n"
"используя представление целых чисел, где это возможно, в виде\n"
"удобном для работы компьютера(т.е в Си типах), и более общее\n"
"представление, где требуемое число не соответсвует ограничениям\n"
"используемого компьютера. Преобразованием между этими двумя \n"
"представлениями происходит автоматически и полностью невидимо\n"
"для программиста Scheme."

#: api-data.texi:300
msgid ""
"C has a host of different integer types, and Guile offers a host of\n"
"functions to convert between them and the @code{SCM} representation.\n"
"For example, a C @code{int} can be handled with @code{scm_to_int} and\n"
"@code{scm_from_int}.  Guile also defines a few C integer types of its\n"
"own, to help with differences between systems."
msgstr ""
"Си имеет множество разных целых типов, а Guile предлагает множество\n"
"функций для преобразования между ними и представлением @code{SCM}.\n"
"Например, Си @code{int} можно обрабатывать с помощью @code{scm_to_int}\n"
"и @code{scm_from_int}.  Guile также определяет несколько собственных\n"
"целочисленных Си типов, чтобы помочь преодолевать различия\n"
"между различными компьютерными системами."

#: api-data.texi:305
msgid ""
"C integer types that are not covered can be handled with the generic\n"
"@code{scm_to_signed_integer} and @code{scm_from_signed_integer} for\n"
"signed types, or with @code{scm_to_unsigned_integer} and\n"
"@code{scm_from_unsigned_integer} for unsigned types."
msgstr ""

#: api-data.texi:315
msgid ""
"Scheme integers can be exact and inexact.  For example, a number\n"
"written as @code{3.0} with an explicit decimal-point is inexact, but\n"
"it is also an integer.  The functions @code{integer?} and\n"
"@code{scm_is_integer} report true for such a number, but the functions\n"
"@code{exact-integer?}, @code{scm_is_exact_integer},\n"
"@code{scm_is_signed_integer}, and @code{scm_is_unsigned_integer} only\n"
"allow exact integers and thus report false.  Likewise, the conversion\n"
"functions like @code{scm_to_signed_integer} only accept exact\n"
"integers."
msgstr ""
"Целые числа в Scheme могут быть точными и не точными. Например, число\n"
"записываемое как @code{3.0} с явной десятичной точкой является неточным,\n"
"но оно также является целым числом. Функции @code{integer?} и\n"
"@code{scm_is_integer} сообщают истина для такого чилса, но функции\n"
"@code{exact-integer?}, @code{scm_is_exact_integer},\n"
"@code{scm_is_signed_integer}, и @code{scm_is_unsigned_integer} разрешают\n"
"работу только с точными числами и сообщают об ошибке.  Аналогично,\n"
"функции преобразования, такие как @code{scm_to_signed_integer} принимают\n"
"только точные целые числа."

#: api-data.texi:322
msgid ""
"The motivation for this behavior is that the inexactness of a number\n"
"should not be lost silently.  If you want to allow inexact integers,\n"
"you can explicitly insert a call to @code{inexact->exact} or to its C\n"
"equivalent @code{scm_inexact_to_exact}.  (Only inexact integers will\n"
"be converted by this call into exact integers; inexact non-integers\n"
"will become exact fractions.)"
msgstr ""
"Обоснование такого поведения заключается в том. что неточность числа\n"
"не должна быть устранена молча.  Если вы хотите работать с неточным\n"
"числом, вы можете явно вставить вызов @code{inexact->exact} или его\n"
"эквилвалент в Си @code{scm_inexact_to_exact}. (Только неточные\n"
"целые числа будут преобразованы этим вызовом в точные; нецелые числа\n"
"надо преобразовывать почастям.)"

#: api-data.texi:327
msgid ""
"@deffn {Scheme Procedure} integer? x\n"
"@deffnx {C Function} scm_integer_p (x)\n"
"Return @code{#t} if @var{x} is an exact or inexact integer number, else\n"
"return @code{#f}."
msgstr ""

#: api-data.texi:331
msgid ""
"@lisp\n"
"(integer? 487)\n"
"@result{} #t"
msgstr ""

#: api-data.texi:334
msgid ""
"(integer? 3.0)\n"
"@result{} #t"
msgstr ""

#: api-data.texi:337
msgid ""
"(integer? -3.4)\n"
"@result{} #f"
msgstr ""

#: api-data.texi:342
msgid ""
"(integer? +inf.0)\n"
"@result{} #f\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:346
msgid ""
"@deftypefn {C Function} int scm_is_integer (SCM x)\n"
"This is equivalent to @code{scm_is_true (scm_integer_p (x))}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:351
msgid ""
"@deffn {Scheme Procedure} exact-integer? x\n"
"@deffnx {C Function} scm_exact_integer_p (x)\n"
"Return @code{#t} if @var{x} is an exact integer number, else\n"
"return @code{#f}."
msgstr ""

#: api-data.texi:355
msgid ""
"@lisp\n"
"(exact-integer? 37)\n"
"@result{} #t"
msgstr ""

#: api-data.texi:360
msgid ""
"(exact-integer? 3.0)\n"
"@result{} #f\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:364
msgid ""
"@deftypefn {C Function} int scm_is_exact_integer (SCM x)\n"
"This is equivalent to @code{scm_is_true (scm_exact_integer_p (x))}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:380
msgid ""
"@defvr  {C Type} scm_t_int8\n"
"@defvrx {C Type} scm_t_uint8\n"
"@defvrx {C Type} scm_t_int16\n"
"@defvrx {C Type} scm_t_uint16\n"
"@defvrx {C Type} scm_t_int32\n"
"@defvrx {C Type} scm_t_uint32\n"
"@defvrx {C Type} scm_t_int64\n"
"@defvrx {C Type} scm_t_uint64\n"
"@defvrx {C Type} scm_t_intmax\n"
"@defvrx {C Type} scm_t_uintmax\n"
"The C types are equivalent to the corresponding ISO C types but are\n"
"defined on all platforms, with the exception of @code{scm_t_int64} and\n"
"@code{scm_t_uint64}, which are only defined when a 64-bit type is\n"
"available.  For example, @code{scm_t_int8} is equivalent to\n"
"@code{int8_t}."
msgstr ""

#: api-data.texi:386
msgid ""
"You can regard these definitions as a stop-gap measure until all\n"
"platforms provide these types.  If you know that all the platforms\n"
"that you are interested in already provide these types, it is better\n"
"to use them directly instead of the types provided by Guile.\n"
"@end defvr"
msgstr ""

#: api-data.texi:391
msgid ""
"@deftypefn  {C Function} int scm_is_signed_integer (SCM x, scm_t_intmax min, "
"scm_t_intmax max)\n"
"@deftypefnx {C Function} int scm_is_unsigned_integer (SCM x, scm_t_uintmax "
"min, scm_t_uintmax max)\n"
"Return @code{1} when @var{x} represents an exact integer that is\n"
"between @var{min} and @var{max}, inclusive."
msgstr ""

#: api-data.texi:397
msgid ""
"These functions can be used to check whether a @code{SCM} value will\n"
"fit into a given range, such as the range of a given C integer type.\n"
"If you just want to convert a @code{SCM} value to a given C integer\n"
"type, use one of the conversion functions directly.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:405
msgid ""
"@deftypefn  {C Function} scm_t_intmax scm_to_signed_integer (SCM x, "
"scm_t_intmax min, scm_t_intmax max)\n"
"@deftypefnx {C Function} scm_t_uintmax scm_to_unsigned_integer (SCM x, "
"scm_t_uintmax min, scm_t_uintmax max)\n"
"When @var{x} represents an exact integer that is between @var{min} and\n"
"@var{max} inclusive, return that integer.  Else signal an error,\n"
"either a `wrong-type' error when @var{x} is not an exact integer, or\n"
"an `out-of-range' error when it doesn't fit the given range.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:411
msgid ""
"@deftypefn  {C Function} SCM scm_from_signed_integer (scm_t_intmax x)\n"
"@deftypefnx {C Function} SCM scm_from_unsigned_integer (scm_t_uintmax x)\n"
"Return the @code{SCM} value that represents the integer @var{x}.  This\n"
"function will always succeed and will always return an exact number.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:443
msgid ""
"@deftypefn  {C Function} char scm_to_char (SCM x)\n"
"@deftypefnx {C Function} {signed char} scm_to_schar (SCM x)\n"
"@deftypefnx {C Function} {unsigned char} scm_to_uchar (SCM x)\n"
"@deftypefnx {C Function} short scm_to_short (SCM x)\n"
"@deftypefnx {C Function} {unsigned short} scm_to_ushort (SCM x)\n"
"@deftypefnx {C Function} int scm_to_int (SCM x)\n"
"@deftypefnx {C Function} {unsigned int} scm_to_uint (SCM x)\n"
"@deftypefnx {C Function} long scm_to_long (SCM x)\n"
"@deftypefnx {C Function} {unsigned long} scm_to_ulong (SCM x)\n"
"@deftypefnx {C Function} {long long} scm_to_long_long (SCM x)\n"
"@deftypefnx {C Function} {unsigned long long} scm_to_ulong_long (SCM x)\n"
"@deftypefnx {C Function} size_t scm_to_size_t (SCM x)\n"
"@deftypefnx {C Function} ssize_t scm_to_ssize_t (SCM x)\n"
"@deftypefnx {C Function} scm_t_uintptr scm_to_uintptr_t (SCM x)\n"
"@deftypefnx {C Function} scm_t_ptrdiff scm_to_ptrdiff_t (SCM x)\n"
"@deftypefnx {C Function} scm_t_int8 scm_to_int8 (SCM x)\n"
"@deftypefnx {C Function} scm_t_uint8 scm_to_uint8 (SCM x)\n"
"@deftypefnx {C Function} scm_t_int16 scm_to_int16 (SCM x)\n"
"@deftypefnx {C Function} scm_t_uint16 scm_to_uint16 (SCM x)\n"
"@deftypefnx {C Function} scm_t_int32 scm_to_int32 (SCM x)\n"
"@deftypefnx {C Function} scm_t_uint32 scm_to_uint32 (SCM x)\n"
"@deftypefnx {C Function} scm_t_int64 scm_to_int64 (SCM x)\n"
"@deftypefnx {C Function} scm_t_uint64 scm_to_uint64 (SCM x)\n"
"@deftypefnx {C Function} scm_t_intmax scm_to_intmax (SCM x)\n"
"@deftypefnx {C Function} scm_t_uintmax scm_to_uintmax (SCM x)\n"
"@deftypefnx {C Function} scm_t_intptr scm_to_intptr_t (SCM x)\n"
"@deftypefnx {C Function} scm_t_uintptr scm_to_uintptr_t (SCM x)\n"
"When @var{x} represents an exact integer that fits into the indicated\n"
"C type, return that integer.  Else signal an error, either a\n"
"`wrong-type' error when @var{x} is not an exact integer, or an\n"
"`out-of-range' error when it doesn't fit the given range."
msgstr ""

#: api-data.texi:448
msgid ""
"The functions @code{scm_to_long_long}, @code{scm_to_ulong_long},\n"
"@code{scm_to_int64}, and @code{scm_to_uint64} are only available when\n"
"the corresponding types are.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:480
msgid ""
"@deftypefn  {C Function} SCM scm_from_char (char x)\n"
"@deftypefnx {C Function} SCM scm_from_schar (signed char x)\n"
"@deftypefnx {C Function} SCM scm_from_uchar (unsigned char x)\n"
"@deftypefnx {C Function} SCM scm_from_short (short x)\n"
"@deftypefnx {C Function} SCM scm_from_ushort (unsigned short x)\n"
"@deftypefnx {C Function} SCM scm_from_int (int  x)\n"
"@deftypefnx {C Function} SCM scm_from_uint (unsigned int x)\n"
"@deftypefnx {C Function} SCM scm_from_long (long x)\n"
"@deftypefnx {C Function} SCM scm_from_ulong (unsigned long x)\n"
"@deftypefnx {C Function} SCM scm_from_long_long (long long x)\n"
"@deftypefnx {C Function} SCM scm_from_ulong_long (unsigned long long x)\n"
"@deftypefnx {C Function} SCM scm_from_size_t (size_t x)\n"
"@deftypefnx {C Function} SCM scm_from_ssize_t (ssize_t x)\n"
"@deftypefnx {C Function} SCM scm_from_uintptr_t (uintptr_t x)\n"
"@deftypefnx {C Function} SCM scm_from_ptrdiff_t (scm_t_ptrdiff x)\n"
"@deftypefnx {C Function} SCM scm_from_int8 (scm_t_int8 x)\n"
"@deftypefnx {C Function} SCM scm_from_uint8 (scm_t_uint8 x)\n"
"@deftypefnx {C Function} SCM scm_from_int16 (scm_t_int16 x)\n"
"@deftypefnx {C Function} SCM scm_from_uint16 (scm_t_uint16 x)\n"
"@deftypefnx {C Function} SCM scm_from_int32 (scm_t_int32 x)\n"
"@deftypefnx {C Function} SCM scm_from_uint32 (scm_t_uint32 x)\n"
"@deftypefnx {C Function} SCM scm_from_int64 (scm_t_int64 x)\n"
"@deftypefnx {C Function} SCM scm_from_uint64 (scm_t_uint64 x)\n"
"@deftypefnx {C Function} SCM scm_from_intmax (scm_t_intmax x)\n"
"@deftypefnx {C Function} SCM scm_from_uintmax (scm_t_uintmax x)\n"
"@deftypefnx {C Function} SCM scm_from_intptr_t (scm_t_intptr x)\n"
"@deftypefnx {C Function} SCM scm_from_uintptr_t (scm_t_uintptr x)\n"
"Return the @code{SCM} value that represents the integer @var{x}.\n"
"These functions will always succeed and will always return an exact\n"
"number.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:489
msgid ""
"@deftypefn {C Function} void scm_to_mpz (SCM val, mpz_t rop)\n"
"Assign @var{val} to the multiple precision integer @var{rop}.\n"
"@var{val} must be an exact integer, otherwise an error will be\n"
"signalled.  @var{rop} must have been initialized with @code{mpz_init}\n"
"before this function is called.  When @var{rop} is no longer needed\n"
"the occupied space must be freed with @code{mpz_clear}.\n"
"@xref{Initializing Integers,,, gmp, GNU MP Manual}, for details.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:493
msgid ""
"@deftypefn {C Function} SCM scm_from_mpz (mpz_t val)\n"
"Return the @code{SCM} value that represents @var{val}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:498
msgid ""
"@node Reals and Rationals\n"
"@subsubsection Real and Rational Numbers\n"
"@tpindex Real numbers\n"
"@tpindex Rational numbers"
msgstr ""

#: api-data.texi:501
msgid ""
"@rnindex real?\n"
"@rnindex rational?"
msgstr ""

#: api-data.texi:509
msgid ""
"Mathematically, the real numbers are the set of numbers that describe\n"
"all possible points along a continuous, infinite, one-dimensional line.\n"
"The rational numbers are the set of all numbers that can be written as\n"
"fractions @var{p}/@var{q}, where @var{p} and @var{q} are integers.\n"
"All rational numbers are also real, but there are real numbers that\n"
"are not rational, for example @m{\\sqrt{2}, the square root of 2}, and\n"
"@m{\\pi,pi}."
msgstr ""
"Математически вещественные числа представляют собой набор чисел, \n"
"описывающих все возможные точки вдоль непрерывной бесконечной\n"
"одномерной линии. Рациональные числа - это совокупность всех\n"
"чисел которые могут быть записаны как дроби @var{p}/@var{q}, \n"
"где @var{p} и @var{q} целые числа. Все рациональные числа являются\n"
"также и вещественными, но существуют вещественные числа, которые\n"
"не являются рациональными, например: @m{\\sqrt{2}, квадратный корень из 2},\n"
"и @m{\\pi,pi}."

#: api-data.texi:515
msgid ""
"Guile can represent both exact and inexact rational numbers, but it\n"
"cannot represent precise finite irrational numbers.  Exact rationals are\n"
"represented by storing the numerator and denominator as two exact\n"
"integers.  Inexact rationals are stored as floating point numbers using\n"
"the C type @code{double}."
msgstr ""
"Guile может представлять как точные, так и не точные рациональные числа,\n"
"не не может представлять тоными конечные иррациональные числа. Точные\n"
"рациональности представлены путем хранения числителя и знаменателя в \n"
"виде двух точных целых чисел. Неточные рациональности храняться как\n"
"числа с плавающей запятой, использущие тип Си @code{double}."

#: api-data.texi:518
msgid ""
"Exact rationals are written as a fraction of integers.  There must be\n"
"no whitespace around the slash:"
msgstr ""
"Точные рациональные числа записываются как часть целых чисел. Не должно\n"
"быть пробелов вокруг косой черты."

#: api-data.texi:523
msgid ""
"@lisp\n"
"1/2\n"
"-22/7\n"
"@end lisp"
msgstr ""

#: api-data.texi:529
msgid ""
"Even though the actual encoding of inexact rationals is in binary, it\n"
"may be helpful to think of it as a decimal number with a limited\n"
"number of significant figures and a decimal point somewhere, since\n"
"this corresponds to the standard notation for non-whole numbers.  For\n"
"example:"
msgstr ""
"Несмотря на то, что фактическое кодирование неточных рациональных чисел\n"
"находиться в двоичном представлении, может оказаться полезным думать о\n"
"нем как о десятичном числе с ограниченным числом значимых цифр и \n"
"десятичной точкой стоящей гдето, так как это соответствует стандартной \n"
"нотации для нецелых чисел.\n"
"Например:"

#: api-data.texi:536
msgid ""
"@lisp\n"
"0.34\n"
"-0.00000142857931198\n"
"-5648394822220000000000.0\n"
"4.0\n"
"@end lisp"
msgstr ""

#: api-data.texi:544
msgid ""
"The limited precision of Guile's encoding means that any finite ``real''\n"
"number in Guile can be written in a rational form, by multiplying and\n"
"then dividing by sufficient powers of 10 (or in fact, 2).  For example,\n"
"@samp{-0.00000142857931198} is the same as @minus{}142857931198 divided\n"
"by 100000000000000000.  In Guile's current incarnation, therefore, the\n"
"@code{rational?} and @code{real?} predicates are equivalent for finite\n"
"numbers."
msgstr ""
"Ограниченная точность кодирования Guile's означает, что любое конечное\n"
"``реальное'' число в Guile может быть записано в рациональной форме,\n"
"умножая и деля на достаточные степени 10 (или фактически, 2).  Например,\n"
"@samp{-0.00000142857931198} это тоже, что и @minus{}142857931198 деленное\n"
"на 100000000000000000.  В текущей реализации Guile's , следовательно, \n"
"предикаты @code{rational?} и @code{real?} эквивалентны для конечных\n"
"чисел."

#: api-data.texi:552
msgid ""
"Dividing by an exact zero leads to a error message, as one might expect.\n"
"However, dividing by an inexact zero does not produce an error.\n"
"Instead, the result of the division is either plus or minus infinity,\n"
"depending on the sign of the divided number and the sign of the zero\n"
"divisor (some platforms support signed zeroes @samp{-0.0} and\n"
"@samp{+0.0}; @samp{0.0} is the same as @samp{+0.0})."
msgstr ""

#: api-data.texi:561
msgid ""
"Dividing zero by an inexact zero yields a @acronym{NaN} (`not a number')\n"
"value, although they are actually considered numbers by Scheme.\n"
"Attempts to compare a @acronym{NaN} value with any number (including\n"
"itself) using @code{=}, @code{<}, @code{>}, @code{<=} or @code{>=}\n"
"always returns @code{#f}.  Although a @acronym{NaN} value is not\n"
"@code{=} to itself, it is both @code{eqv?} and @code{equal?} to itself\n"
"and other @acronym{NaN} values.  However, the preferred way to test for\n"
"them is by using @code{nan?}."
msgstr ""

#: api-data.texi:572
msgid ""
"The real @acronym{NaN} values and infinities are written @samp{+nan.0},\n"
"@samp{+inf.0} and @samp{-inf.0}.  This syntax is also recognized by\n"
"@code{read} as an extension to the usual Scheme syntax.  These special\n"
"values are considered by Scheme to be inexact real numbers but not\n"
"rational.  Note that non-real complex numbers may also contain\n"
"infinities or @acronym{NaN} values in their real or imaginary parts.  To\n"
"test a real number to see if it is infinite, a @acronym{NaN} value, or\n"
"neither, use @code{inf?}, @code{nan?}, or @code{finite?}, respectively.\n"
"Every real number in Scheme belongs to precisely one of those three\n"
"classes."
msgstr ""

#: api-data.texi:578
msgid ""
"On platforms that follow @acronym{IEEE} 754 for their floating point\n"
"arithmetic, the @samp{+inf.0}, @samp{-inf.0}, and @samp{+nan.0} values\n"
"are implemented using the corresponding @acronym{IEEE} 754 values.\n"
"They behave in arithmetic operations like @acronym{IEEE} 754 describes\n"
"it, i.e., @code{(= +nan.0 +nan.0)} @result{} @code{#f}."
msgstr ""

#: api-data.texi:586
msgid ""
"@deffn {Scheme Procedure} real? obj\n"
"@deffnx {C Function} scm_real_p (obj)\n"
"Return @code{#t} if @var{obj} is a real number, else @code{#f}.  Note\n"
"that the sets of integer and rational values form subsets of the set\n"
"of real numbers, so the predicate will also be fulfilled if @var{obj}\n"
"is an integer number or a rational number.\n"
"@end deffn"
msgstr ""

#: api-data.texi:594
msgid ""
"@deffn {Scheme Procedure} rational? x\n"
"@deffnx {C Function} scm_rational_p (x)\n"
"Return @code{#t} if @var{x} is a rational number, @code{#f} otherwise.\n"
"Note that the set of integer values forms a subset of the set of\n"
"rational numbers, i.e.@: the predicate will also be fulfilled if\n"
"@var{x} is an integer number.\n"
"@end deffn"
msgstr ""

#: api-data.texi:599
msgid ""
"@deffn {Scheme Procedure} rationalize x eps\n"
"@deffnx {C Function} scm_rationalize (x, eps)\n"
"Returns the @emph{simplest} rational number differing\n"
"from @var{x} by no more than @var{eps}.  "
msgstr ""

#: api-data.texi:603
msgid ""
"As required by @acronym{R5RS}, @code{rationalize} only returns an\n"
"exact result when both its arguments are exact.  Thus, you might need\n"
"to use @code{inexact->exact} on the arguments."
msgstr ""

#: api-data.texi:608
msgid ""
"@lisp\n"
"(rationalize (inexact->exact 1.2) 1/100)\n"
"@result{} 6/5\n"
"@end lisp"
msgstr ""

#: api-data.texi:610
msgctxt "api-data.texi:610"
msgid "@end deffn"
msgstr ""

#: api-data.texi:616
msgid ""
"@deffn  {Scheme Procedure} inf? x\n"
"@deffnx {C Function} scm_inf_p (x)\n"
"Return @code{#t} if the real number @var{x} is @samp{+inf.0} or\n"
"@samp{-inf.0}.  Otherwise return @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:622
msgid ""
"@deffn {Scheme Procedure} nan? x\n"
"@deffnx {C Function} scm_nan_p (x)\n"
"Return @code{#t} if the real number @var{x} is @samp{+nan.0}, or\n"
"@code{#f} otherwise.\n"
"@end deffn"
msgstr ""

#: api-data.texi:628
msgid ""
"@deffn {Scheme Procedure} finite? x\n"
"@deffnx {C Function} scm_finite_p (x)\n"
"Return @code{#t} if the real number @var{x} is neither infinite nor a\n"
"NaN, @code{#f} otherwise.\n"
"@end deffn"
msgstr ""

#: api-data.texi:633
msgid ""
"@deffn {Scheme Procedure} nan\n"
"@deffnx {C Function} scm_nan ()\n"
"Return @samp{+nan.0}, a @acronym{NaN} value.\n"
"@end deffn"
msgstr ""

#: api-data.texi:638
msgid ""
"@deffn {Scheme Procedure} inf\n"
"@deffnx {C Function} scm_inf ()\n"
"Return @samp{+inf.0}, positive infinity.\n"
"@end deffn"
msgstr ""

#: api-data.texi:643
msgid ""
"@deffn {Scheme Procedure} numerator x\n"
"@deffnx {C Function} scm_numerator (x)\n"
"Return the numerator of the rational number @var{x}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:648
msgid ""
"@deffn {Scheme Procedure} denominator x\n"
"@deffnx {C Function} scm_denominator (x)\n"
"Return the denominator of the rational number @var{x}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:654
msgid ""
"@deftypefn  {C Function} int scm_is_real (SCM val)\n"
"@deftypefnx {C Function} int scm_is_rational (SCM val)\n"
"Equivalent to @code{scm_is_true (scm_real_p (val))} and\n"
"@code{scm_is_true (scm_rational_p (val))}, respectively.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:660
msgid ""
"@deftypefn {C Function} double scm_to_double (SCM val)\n"
"Returns the number closest to @var{val} that is representable as a\n"
"@code{double}.  Returns infinity for a @var{val} that is too large in\n"
"magnitude.  The argument @var{val} must be a real number.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:666
msgid ""
"@deftypefn {C Function} SCM scm_from_double (double val)\n"
"Return the @code{SCM} value that represents @var{val}.  The returned\n"
"value is inexact according to the predicate @code{inexact?}, but it\n"
"will be exactly equal to @var{val}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:670
msgid ""
"@node Complex Numbers\n"
"@subsubsection Complex Numbers\n"
"@tpindex Complex numbers"
msgstr ""

#: api-data.texi:672
msgid "@rnindex complex?"
msgstr ""

#: api-data.texi:677
msgid ""
"Complex numbers are the set of numbers that describe all possible points\n"
"in a two-dimensional space.  The two coordinates of a particular point\n"
"in this space are known as the @dfn{real} and @dfn{imaginary} parts of\n"
"the complex number that describes that point."
msgstr ""
"Комплексные числа - это набор чисел, описывающих всевозможные точки в\n"
"двумерном пространстве. Известные две координаты конкретной точки в этом\n"
"пространстве называются как @dfn{real(реальная)} и @dfn{imaginary(мнимая)}\n"
"части комплексного числа, которое описывает эту точку."

#: api-data.texi:681
msgid ""
"In Guile, complex numbers are written in rectangular form as the sum of\n"
"their real and imaginary parts, using the symbol @code{i} to indicate\n"
"the imaginary part."
msgstr ""
"В Guile, комплексные числа записываются в прямоугольной форме как сумма\n"
"их реальной и мнимой частей, используя символ @code{i} для обозначения\n"
"мнимой части."

#: api-data.texi:686
msgid ""
"@lisp\n"
"3+4i\n"
"@result{}\n"
"3.0+4.0i"
msgstr ""

#: api-data.texi:691
msgid ""
"(* 3-8i 2.3+0.3i)\n"
"@result{}\n"
"9.3-17.5i\n"
"@end lisp"
msgstr ""

#: api-data.texi:696
msgid ""
"@cindex polar form\n"
"@noindent\n"
"Polar form can also be used, with an @samp{@@} between magnitude and\n"
"angle,"
msgstr ""
"@cindex polar form\n"
"@noindent\n"
"Также может использоваться Полярная форма с симовлом @samp{@@} между\n"
"величиной и углом."

#: api-data.texi:701
msgid ""
"@lisp\n"
"1@@3.141592 @result{} -1.0      (approx)\n"
"-1@@1.57079 @result{} 0.0-1.0i  (approx)\n"
"@end lisp"
msgstr ""

#: api-data.texi:705
msgid ""
"Guile represents a complex number as a pair of inexact reals, so the\n"
"real and imaginary parts of a complex number have the same properties of\n"
"inexactness and limited precision as single inexact real numbers."
msgstr ""
"Guile представляет комплексное число как пару неточных действительных\n"
"чисел, поэтому реальная и мнимая части комплексного числа имеют\n"
"одинаковые свойства неточности и ограниченной точности как единичные\n"
"неточные действительные числа."

#: api-data.texi:710
msgid ""
"Note that each part of a complex number may contain any inexact real\n"
"value, including the special values @samp{+nan.0}, @samp{+inf.0} and\n"
"@samp{-inf.0}, as well as either of the signed zeroes @samp{0.0} or\n"
"@samp{-0.0}."
msgstr ""
"Обратите внимание, что каждая часть комплексного числа может содержать\n"
"любое неточное реальное значение, включая специальные значения "
"@samp{+nan.0},\n"
"@samp{+inf.0} и @samp{-inf.0}, а также любой из нулей со знаком @samp{0.0} "
"или\n"
"@samp{-0.0}."

#: api-data.texi:720
msgid ""
"@deffn {Scheme Procedure} complex? z\n"
"@deffnx {C Function} scm_complex_p (z)\n"
"Return @code{#t} if @var{z} is a complex number, @code{#f}\n"
"otherwise.  Note that the sets of real, rational and integer\n"
"values form subsets of the set of complex numbers, i.e.@: the\n"
"predicate will also be fulfilled if @var{z} is a real,\n"
"rational or integer number.\n"
"@end deffn"
msgstr ""

#: api-data.texi:724
msgid ""
"@deftypefn {C Function} int scm_is_complex (SCM val)\n"
"Equivalent to @code{scm_is_true (scm_complex_p (val))}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:729
msgid ""
"@node Exactness\n"
"@subsubsection Exact and Inexact Numbers\n"
"@tpindex Exact numbers\n"
"@tpindex Inexact numbers"
msgstr ""

#: api-data.texi:734
msgid ""
"@rnindex exact?\n"
"@rnindex inexact?\n"
"@rnindex exact->inexact\n"
"@rnindex inexact->exact"
msgstr ""

#: api-data.texi:742
msgid ""
"R5RS requires that, with few exceptions, a calculation involving inexact\n"
"numbers always produces an inexact result.  To meet this requirement,\n"
"Guile distinguishes between an exact integer value such as @samp{5} and\n"
"the corresponding inexact integer value which, to the limited precision\n"
"available, has no fractional part, and is printed as @samp{5.0}.  Guile\n"
"will only convert the latter value to the former when forced to do so by\n"
"an invocation of the @code{inexact->exact} procedure."
msgstr ""
"R5RS требует чтобы, за небольшим исключением, вычисления с использоанием\n"
"неточных чисел всегда давали неточный результат. Чтобы соответствовать\n"
"этому требованию, Guile различает точное целочисленное значение, такое \n"
"как @samp{5} и соотвественно, неточное целочисленное значение, ограниченной\n"
"точности, не имеющее дробной части и печатающееся как @samp{5.0}.  Guile\n"
"конвертирует последнее значение в первое только, когда оно вынуждено\n"
"делать это путем вызова процедуры @code{inexact->exact}."

#: api-data.texi:747
msgid ""
"The only exception to the above requirement is when the values of the\n"
"inexact numbers do not affect the result.  For example @code{(expt n 0)}\n"
"is @samp{1} for any value of @code{n}, therefore @code{(expt 5.0 0)} is\n"
"permitted to return an exact @samp{1}."
msgstr ""
"Единственное исключение из вышеуказанного требования - когда значения\n"
"неточных чисел не влияют на результат. Например @code{(expt n 0)}\n"
"равно @samp{1} для любого значения  @code{n}, поэтому @code{(expt 5.0 0)} \n"
"разрешено возрващать точное @samp{1}."

#: api-data.texi:752
msgid ""
"@deffn {Scheme Procedure} exact? z\n"
"@deffnx {C Function} scm_exact_p (z)\n"
"Return @code{#t} if the number @var{z} is exact, @code{#f}\n"
"otherwise."
msgstr ""

#: api-data.texi:756
msgid ""
"@lisp\n"
"(exact? 2)\n"
"@result{} #t"
msgstr ""

#: api-data.texi:759
msgid ""
"(exact? 0.5)\n"
"@result{} #f"
msgstr ""

#: api-data.texi:763
msgid ""
"(exact? (/ 2))\n"
"@result{} #t\n"
"@end lisp"
msgstr ""

#: api-data.texi:765
msgctxt "api-data.texi:765"
msgid "@end deffn"
msgstr ""

#: api-data.texi:769
msgid ""
"@deftypefn {C Function} int scm_is_exact (SCM z)\n"
"Return a @code{1} if the number @var{z} is exact, and @code{0}\n"
"otherwise.  This is equivalent to @code{scm_is_true (scm_exact_p (z))}."
msgstr ""

#: api-data.texi:773
msgid ""
"An alternate approch to testing the exactness of a number is to \n"
"use @code{scm_is_signed_integer} or @code{scm_is_unsigned_integer}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:779
msgid ""
"@deffn {Scheme Procedure} inexact? z\n"
"@deffnx {C Function} scm_inexact_p (z)\n"
"Return @code{#t} if the number @var{z} is inexact, @code{#f}\n"
"else.\n"
"@end deffn"
msgstr ""

#: api-data.texi:784
msgid ""
"@deftypefn {C Function} int scm_is_inexact (SCM z)\n"
"Return a @code{1} if the number @var{z} is inexact, and @code{0}\n"
"otherwise.  This is equivalent to @code{scm_is_true (scm_inexact_p (z))}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:791
msgid ""
"@deffn {Scheme Procedure} inexact->exact z\n"
"@deffnx {C Function} scm_inexact_to_exact (z)\n"
"Return an exact number that is numerically closest to @var{z}, when\n"
"there is one.  For inexact rationals, Guile returns the exact rational\n"
"that is numerically equal to the inexact rational.  Inexact complex\n"
"numbers with a non-zero imaginary part can not be made exact."
msgstr ""

#: api-data.texi:796
msgid ""
"@lisp\n"
"(inexact->exact 0.5)\n"
"@result{} 1/2\n"
"@end lisp"
msgstr ""

#: api-data.texi:801
msgid ""
"The following happens because 12/10 is not exactly representable as a\n"
"@code{double} (on most platforms).  However, when reading a decimal\n"
"number that has been marked exact with the ``#e'' prefix, Guile is\n"
"able to represent it correctly."
msgstr ""

#: api-data.texi:805
msgid ""
"@lisp\n"
"(inexact->exact 1.2)  \n"
"@result{} 5404319552844595/4503599627370496"
msgstr ""

#: api-data.texi:809
msgid ""
"#e1.2\n"
"@result{} 6/5\n"
"@end lisp"
msgstr ""

#: api-data.texi:811
msgctxt "api-data.texi:811"
msgid "@end deffn"
msgstr ""

#: api-data.texi:817
msgid ""
"@c begin (texi-doc-string \"guile\" \"exact->inexact\")\n"
"@deffn {Scheme Procedure} exact->inexact z\n"
"@deffnx {C Function} scm_exact_to_inexact (z)\n"
"Convert the number @var{z} to its inexact representation.\n"
"@end deffn"
msgstr ""

#: api-data.texi:821
msgid ""
"@node Number Syntax\n"
"@subsubsection Read Syntax for Numerical Data"
msgstr ""

#: api-data.texi:826
msgid ""
"The read syntax for integers is a string of digits, optionally\n"
"preceded by a minus or plus character, a code indicating the\n"
"base in which the integer is encoded, and a code indicating whether\n"
"the number is exact or inexact.  The supported base codes are:"
msgstr ""
"Синтаксис чтения целых чисел представляет собой строку цифр,\n"
"необязательно предшествует которой символ плюс или минус, код\n"
"указывающий базу системы счисления, в которой закодировано число\n"
"и код указывающий является ли число точным или неточным.\n"
"Поддерживаемые базовые коды:"

#: api-data.texi:831
msgid ""
"@table @code\n"
"@item #b\n"
"@itemx #B\n"
"the integer is written in binary (base 2)"
msgstr ""
"@table @code\n"
"@item #b\n"
"@itemx #B\n"
"целое записанное в бинарном формате (база 2)"

#: api-data.texi:835
msgid ""
"@item #o\n"
"@itemx #O\n"
"the integer is written in octal (base 8)"
msgstr ""
"@item #o\n"
"@itemx #O\n"
"целое записанное в восмеричном формате (base 8)"

#: api-data.texi:839
msgid ""
"@item #d\n"
"@itemx #D\n"
"the integer is written in decimal (base 10)"
msgstr ""
"@item #d\n"
"@itemx #D\n"
"целое записанное в десятичном формате (base 10)"

#: api-data.texi:844
msgid ""
"@item #x\n"
"@itemx #X\n"
"the integer is written in hexadecimal (base 16)\n"
"@end table"
msgstr ""
"@item #x\n"
"@itemx #X\n"
"целое записанное в шестнадцатеричном формате (base 16)\n"
"@end table"

#: api-data.texi:847
msgid ""
"If the base code is omitted, the integer is assumed to be decimal.  The\n"
"following examples show how these base codes are used."
msgstr ""
"Если код базы опущен, целое число считается десятичным. Следующие примеры\n"
"покажут, как использовать эти базовые коды."

#: api-data.texi:851
msgid ""
"@lisp\n"
"-13\n"
"@result{} -13"
msgstr ""

#: api-data.texi:854
msgid ""
"#d-13\n"
"@result{} -13"
msgstr ""

#: api-data.texi:857
msgid ""
"#x-13\n"
"@result{} -19"
msgstr ""

#: api-data.texi:860
msgid ""
"#b+1101\n"
"@result{} 13"
msgstr ""

#: api-data.texi:864
msgid ""
"#o377\n"
"@result{} 255\n"
"@end lisp"
msgstr ""

#: api-data.texi:867
msgid ""
"The codes for indicating exactness (which can, incidentally, be applied\n"
"to all numerical values) are:"
msgstr ""
"Коды для указания точности (которые, кстати, могут применяться ко всем\n"
"числовым значениям):"

#: api-data.texi:872
msgid ""
"@table @code\n"
"@item #e\n"
"@itemx #E\n"
"the number is exact"
msgstr ""

#: api-data.texi:877
msgid ""
"@item #i\n"
"@itemx #I\n"
"the number is inexact.\n"
"@end table"
msgstr ""

#: api-data.texi:881
msgid ""
"If the exactness indicator is omitted, the number is exact unless it\n"
"contains a radix point.  Since Guile can not represent exact complex\n"
"numbers, an error is signalled when asking for them."
msgstr ""
"Если индикатор точности опущен, это число точно, если оно не содержит\n"
"точку. Поскольку Guile не может представлять точные комплексные числа,\n"
"при запросе о точности комплексного числа возникает ошибка."

#: api-data.texi:885
msgid ""
"@lisp\n"
"(exact? 1.2)\n"
"@result{} #f"
msgstr ""

#: api-data.texi:888
msgid ""
"(exact? #e1.2)\n"
"@result{} #t"
msgstr ""

#: api-data.texi:892
msgid ""
"(exact? #e+1i)\n"
"ERROR: Wrong type argument\n"
"@end lisp"
msgstr ""

#: api-data.texi:900
msgid ""
"Guile also understands the syntax @samp{+inf.0} and @samp{-inf.0} for\n"
"plus and minus infinity, respectively.  The value must be written\n"
"exactly as shown, that is, they always must have a sign and exactly\n"
"one zero digit after the decimal point.  It also understands\n"
"@samp{+nan.0} and @samp{-nan.0} for the special `not-a-number' value.\n"
"The sign is ignored for `not-a-number' and the value is always printed\n"
"as @samp{+nan.0}."
msgstr ""

#: api-data.texi:910
msgid ""
"@node Integer Operations\n"
"@subsubsection Operations on Integer Values\n"
"@rnindex odd?\n"
"@rnindex even?\n"
"@rnindex quotient\n"
"@rnindex remainder\n"
"@rnindex modulo\n"
"@rnindex gcd\n"
"@rnindex lcm"
msgstr ""

#: api-data.texi:916
msgid ""
"@deffn {Scheme Procedure} odd? n\n"
"@deffnx {C Function} scm_odd_p (n)\n"
"Return @code{#t} if @var{n} is an odd number, @code{#f}\n"
"otherwise.\n"
"@end deffn"
msgstr ""

#: api-data.texi:922
msgid ""
"@deffn {Scheme Procedure} even? n\n"
"@deffnx {C Function} scm_even_p (n)\n"
"Return @code{#t} if @var{n} is an even number, @code{#f}\n"
"otherwise.\n"
"@end deffn"
msgstr ""

#: api-data.texi:933
msgid ""
"@c begin (texi-doc-string \"guile\" \"quotient\")\n"
"@c begin (texi-doc-string \"guile\" \"remainder\")\n"
"@deffn {Scheme Procedure} quotient n d\n"
"@deffnx {Scheme Procedure} remainder n d\n"
"@deffnx {C Function} scm_quotient (n, d)\n"
"@deffnx {C Function} scm_remainder (n, d)\n"
"Return the quotient or remainder from @var{n} divided by @var{d}.  The\n"
"quotient is rounded towards zero, and the remainder will have the same\n"
"sign as @var{n}.  In all cases quotient and remainder satisfy\n"
"@math{@var{n} = @var{q}*@var{d} + @var{r}}."
msgstr ""

#: api-data.texi:938
msgid ""
"@lisp\n"
"(remainder 13 4) @result{} 1\n"
"(remainder -13 4) @result{} -1\n"
"@end lisp"
msgstr ""

#: api-data.texi:942
msgid ""
"See also @code{truncate-quotient}, @code{truncate-remainder} and\n"
"related operations in @ref{Arithmetic}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:948
msgid ""
"@c begin (texi-doc-string \"guile\" \"modulo\")\n"
"@deffn {Scheme Procedure} modulo n d\n"
"@deffnx {C Function} scm_modulo (n, d)\n"
"Return the remainder from @var{n} divided by @var{d}, with the same\n"
"sign as @var{d}."
msgstr ""

#: api-data.texi:955
msgid ""
"@lisp\n"
"(modulo 13 4) @result{} 1\n"
"(modulo -13 4) @result{} 3\n"
"(modulo 13 -4) @result{} -3\n"
"(modulo -13 -4) @result{} -1\n"
"@end lisp"
msgstr ""

#: api-data.texi:959
msgid ""
"See also @code{floor-quotient}, @code{floor-remainder} and\n"
"related operations in @ref{Arithmetic}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:965
msgid ""
"@c begin (texi-doc-string \"guile\" \"gcd\")\n"
"@deffn {Scheme Procedure} gcd x@dots{}\n"
"@deffnx {C Function} scm_gcd (x, y)\n"
"Return the greatest common divisor of all arguments.\n"
"If called without arguments, 0 is returned."
msgstr ""

#: api-data.texi:969
msgid ""
"The C function @code{scm_gcd} always takes two arguments, while the\n"
"Scheme function can take an arbitrary number.\n"
"@end deffn"
msgstr ""

#: api-data.texi:975
msgid ""
"@c begin (texi-doc-string \"guile\" \"lcm\")\n"
"@deffn {Scheme Procedure} lcm x@dots{}\n"
"@deffnx {C Function} scm_lcm (x, y)\n"
"Return the least common multiple of the arguments.\n"
"If called without arguments, 1 is returned."
msgstr ""

#: api-data.texi:979
msgid ""
"The C function @code{scm_lcm} always takes two arguments, while the\n"
"Scheme function can take an arbitrary number.\n"
"@end deffn"
msgstr ""

#: api-data.texi:984
msgid ""
"@deffn {Scheme Procedure} modulo-expt n k m\n"
"@deffnx {C Function} scm_modulo_expt (n, k, m)\n"
"Return @var{n} raised to the integer exponent\n"
"@var{k}, modulo @var{m}."
msgstr ""

#: api-data.texi:990
msgid ""
"@lisp\n"
"(modulo-expt 2 3 5)\n"
"   @result{} 3\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:997
msgid ""
"@deftypefn {Scheme Procedure} {} exact-integer-sqrt @var{k}\n"
"@deftypefnx {C Function} void scm_exact_integer_sqrt (SCM @var{k}, SCM "
"*@var{s}, SCM *@var{r})\n"
"Return two exact non-negative integers @var{s} and @var{r}\n"
"such that @math{@var{k} = @var{s}^2 + @var{r}} and\n"
"@math{@var{s}^2 <= @var{k} < (@var{s} + 1)^2}.\n"
"An error is raised if @var{k} is not an exact non-negative integer."
msgstr ""

#: api-data.texi:1002
msgid ""
"@lisp\n"
"(exact-integer-sqrt 10) @result{} 3 and 1\n"
"@end lisp\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:1008
msgid ""
"@node Comparison\n"
"@subsubsection Comparison Predicates\n"
"@rnindex zero?\n"
"@rnindex positive?\n"
"@rnindex negative?"
msgstr ""

#: api-data.texi:1016
msgid ""
"The C comparison functions below always takes two arguments, while the\n"
"Scheme functions can take an arbitrary number.  Also keep in mind that\n"
"the C functions return one of the Scheme boolean values\n"
"@code{SCM_BOOL_T} or @code{SCM_BOOL_F} which are both true as far as C\n"
"is concerned.  Thus, always write @code{scm_is_true (scm_num_eq_p (x,\n"
"y))} when testing the two Scheme numbers @code{x} and @code{y} for\n"
"equality, for example."
msgstr ""
"Фукнции сравнения Си ниже всегда принимают два аргумента, а функции\n"
"Scheme могут принимать произвольное число аргументов. Также имейте\n"
"в виду, что функции Си возвращают один из буферных значений Scheme\n"
"@code{SCM_BOOL_T} или @code{SCM_BOOL_F}, которые являются для Си\n"
"истинными(что не верно).  Таким образом, всегда пишите \n"
"@code{scm_is_true (scm_num_eq_p (x, y))} при сравнении двух\n"
"величин Scheme, например для выяснения равенства @code{x} и @code{y}."

#: api-data.texi:1022
msgid ""
"@c begin (texi-doc-string \"guile\" \"=\")\n"
"@deffn {Scheme Procedure} =\n"
"@deffnx {C Function} scm_num_eq_p (x, y)\n"
"Return @code{#t} if all parameters are numerically equal.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1029
msgid ""
"@c begin (texi-doc-string \"guile\" \"<\")\n"
"@deffn {Scheme Procedure} <\n"
"@deffnx {C Function} scm_less_p (x, y)\n"
"Return @code{#t} if the list of parameters is monotonically\n"
"increasing.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1036
msgid ""
"@c begin (texi-doc-string \"guile\" \">\")\n"
"@deffn {Scheme Procedure} >\n"
"@deffnx {C Function} scm_gr_p (x, y)\n"
"Return @code{#t} if the list of parameters is monotonically\n"
"decreasing.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1043
msgid ""
"@c begin (texi-doc-string \"guile\" \"<=\")\n"
"@deffn {Scheme Procedure} <=\n"
"@deffnx {C Function} scm_leq_p (x, y)\n"
"Return @code{#t} if the list of parameters is monotonically\n"
"non-decreasing.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1050
msgid ""
"@c begin (texi-doc-string \"guile\" \">=\")\n"
"@deffn {Scheme Procedure} >=\n"
"@deffnx {C Function} scm_geq_p (x, y)\n"
"Return @code{#t} if the list of parameters is monotonically\n"
"non-increasing.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1057
msgid ""
"@c begin (texi-doc-string \"guile\" \"zero?\")\n"
"@deffn {Scheme Procedure} zero? z\n"
"@deffnx {C Function} scm_zero_p (z)\n"
"Return @code{#t} if @var{z} is an exact or inexact number equal to\n"
"zero.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1064
msgid ""
"@c begin (texi-doc-string \"guile\" \"positive?\")\n"
"@deffn {Scheme Procedure} positive? x\n"
"@deffnx {C Function} scm_positive_p (x)\n"
"Return @code{#t} if @var{x} is an exact or inexact number greater than\n"
"zero.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1071
msgid ""
"@c begin (texi-doc-string \"guile\" \"negative?\")\n"
"@deffn {Scheme Procedure} negative? x\n"
"@deffnx {C Function} scm_negative_p (x)\n"
"Return @code{#t} if @var{x} is an exact or inexact number less than\n"
"zero.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1077
msgid ""
"@node Conversion\n"
"@subsubsection Converting Numbers To and From Strings\n"
"@rnindex number->string\n"
"@rnindex string->number"
msgstr ""

#: api-data.texi:1083
msgid ""
"The following procedures read and write numbers according to their\n"
"external representation as defined by R5RS (@pxref{Lexical structure,\n"
"R5RS Lexical Structure,, r5rs, The Revised^5 Report on the Algorithmic\n"
"Language Scheme}).  @xref{Number Input and Output, the @code{(ice-9\n"
"i18n)} module}, for locale-dependent number parsing."
msgstr ""
"Следующие процедуры считывают и записывают числа в соответствии с их\n"
"внешним представлением как определено в  R5RS (@pxref{Lexical structure,\n"
"R5RS Lexical Structure,, r5rs, The Revised^5 Report on the Algorithmic\n"
"Language Scheme}).  @xref{Number Input and Output, the @code{(ice-9\n"
"i18n)} module}, для разбора числа, зависящего от текущей локали."

#: api-data.texi:1090
msgid ""
"@deffn {Scheme Procedure} number->string n [radix]\n"
"@deffnx {C Function} scm_number_to_string (n, radix)\n"
"Return a string holding the external representation of the\n"
"number @var{n} in the given @var{radix}.  If @var{n} is\n"
"inexact, a radix of 10 will be used.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1102
msgid ""
"@deffn {Scheme Procedure} string->number string [radix]\n"
"@deffnx {C Function} scm_string_to_number (string, radix)\n"
"Return a number of the maximally precise representation\n"
"expressed by the given @var{string}. @var{radix} must be an\n"
"exact integer, either 2, 8, 10, or 16. If supplied, @var{radix}\n"
"is a default radix that may be overridden by an explicit radix\n"
"prefix in @var{string} (e.g.@: \"#o177\"). If @var{radix} is not\n"
"supplied, then the default radix is 10. If string is not a\n"
"syntactically valid notation for a number, then\n"
"@code{string->number} returns @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1109
msgid ""
"@deftypefn {C Function} SCM scm_c_locale_stringn_to_number (const char "
"*string, size_t len, unsigned radix)\n"
"As per @code{string->number} above, but taking a C string, as pointer\n"
"and length.  The string characters should be in the current locale\n"
"encoding (@code{locale} in the name refers only to that, there's no\n"
"locale-dependent parsing).\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:1119
msgid ""
"@node Complex\n"
"@subsubsection Complex Number Operations\n"
"@rnindex make-rectangular\n"
"@rnindex make-polar\n"
"@rnindex real-part\n"
"@rnindex imag-part\n"
"@rnindex magnitude\n"
"@rnindex angle"
msgstr ""

#: api-data.texi:1124
msgid ""
"@deffn {Scheme Procedure} make-rectangular real_part imaginary_part\n"
"@deffnx {C Function} scm_make_rectangular (real_part, imaginary_part)\n"
"Return a complex number constructed of the given @var{real-part} and "
"@var{imaginary-part} parts.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1130
msgid ""
"@deffn {Scheme Procedure} make-polar mag ang\n"
"@deffnx {C Function} scm_make_polar (mag, ang)\n"
"@cindex polar form\n"
"Return the complex number @var{mag} * e^(i * @var{ang}).\n"
"@end deffn"
msgstr ""

#: api-data.texi:1136
msgid ""
"@c begin (texi-doc-string \"guile\" \"real-part\")\n"
"@deffn {Scheme Procedure} real-part z\n"
"@deffnx {C Function} scm_real_part (z)\n"
"Return the real part of the number @var{z}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1142
msgid ""
"@c begin (texi-doc-string \"guile\" \"imag-part\")\n"
"@deffn {Scheme Procedure} imag-part z\n"
"@deffnx {C Function} scm_imag_part (z)\n"
"Return the imaginary part of the number @var{z}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1149
msgid ""
"@c begin (texi-doc-string \"guile\" \"magnitude\")\n"
"@deffn {Scheme Procedure} magnitude z\n"
"@deffnx {C Function} scm_magnitude (z)\n"
"Return the magnitude of the number @var{z}. This is the same as\n"
"@code{abs} for real arguments, but also allows complex numbers.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1155
msgid ""
"@c begin (texi-doc-string \"guile\" \"angle\")\n"
"@deffn {Scheme Procedure} angle z\n"
"@deffnx {C Function} scm_angle (z)\n"
"Return the angle of the complex number @var{z}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1162
msgid ""
"@deftypefn  {C Function} SCM scm_c_make_rectangular (double re, double im)\n"
"@deftypefnx {C Function} SCM scm_c_make_polar (double x, double y)\n"
"Like @code{scm_make_rectangular} or @code{scm_make_polar},\n"
"respectively, but these functions take @code{double}s as their\n"
"arguments.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:1167
msgid ""
"@deftypefn  {C Function} double scm_c_real_part (z)\n"
"@deftypefnx {C Function} double scm_c_imag_part (z)\n"
"Returns the real or imaginary part of @var{z} as a @code{double}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:1172
msgid ""
"@deftypefn  {C Function} double scm_c_magnitude (z)\n"
"@deftypefnx {C Function} double scm_c_angle (z)\n"
"Returns the magnitude or angle of @var{z} as a @code{double}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:1207
msgid ""
"@node Arithmetic\n"
"@subsubsection Arithmetic Functions\n"
"@rnindex max\n"
"@rnindex min\n"
"@rnindex +\n"
"@rnindex *\n"
"@rnindex -\n"
"@rnindex /\n"
"@findex 1+\n"
"@findex 1-\n"
"@rnindex abs\n"
"@rnindex floor\n"
"@rnindex ceiling\n"
"@rnindex truncate\n"
"@rnindex round\n"
"@rnindex euclidean/\n"
"@rnindex euclidean-quotient\n"
"@rnindex euclidean-remainder\n"
"@rnindex floor/\n"
"@rnindex floor-quotient\n"
"@rnindex floor-remainder\n"
"@rnindex ceiling/\n"
"@rnindex ceiling-quotient\n"
"@rnindex ceiling-remainder\n"
"@rnindex truncate/\n"
"@rnindex truncate-quotient\n"
"@rnindex truncate-remainder\n"
"@rnindex centered/\n"
"@rnindex centered-quotient\n"
"@rnindex centered-remainder\n"
"@rnindex round/\n"
"@rnindex round-quotient\n"
"@rnindex round-remainder"
msgstr ""

#: api-data.texi:1213
msgid ""
"The C arithmetic functions below always takes two arguments, while the\n"
"Scheme functions can take an arbitrary number.  When you need to\n"
"invoke them with just one argument, for example to compute the\n"
"equivalent of @code{(- x)}, pass @code{SCM_UNDEFINED} as the second\n"
"one: @code{scm_difference (x, SCM_UNDEFINED)}."
msgstr ""
"Арфиметические функции Си ниже всегда принимают два аргумента,\n"
"а функции Scheme могут принимать произвольное число аргументов.\n"
"Когда вам нужно вызвать их только с одним аргуметом, например для\n"
"вычисления эквивалента @code{(- x)}, передайте @code{SCM_UNDEFINED} \n"
"вторым аргументом, вот так: @code{scm_difference (x, SCM_UNDEFINED)}."

#: api-data.texi:1220
msgid ""
"@c begin (texi-doc-string \"guile\" \"+\")\n"
"@deffn {Scheme Procedure} + z1 @dots{}\n"
"@deffnx {C Function} scm_sum (z1, z2)\n"
"Return the sum of all parameter values.  Return 0 if called without any\n"
"parameters.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1228
msgid ""
"@c begin (texi-doc-string \"guile\" \"-\")\n"
"@deffn {Scheme Procedure} - z1 z2 @dots{}\n"
"@deffnx {C Function} scm_difference (z1, z2)\n"
"If called with one argument @var{z1}, -@var{z1} is returned. Otherwise\n"
"the sum of all but the first argument are subtracted from the first\n"
"argument.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1235
msgid ""
"@c begin (texi-doc-string \"guile\" \"*\")\n"
"@deffn {Scheme Procedure} * z1 @dots{}\n"
"@deffnx {C Function} scm_product (z1, z2)\n"
"Return the product of all arguments.  If called without arguments, 1 is\n"
"returned.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1242
msgid ""
"@c begin (texi-doc-string \"guile\" \"/\")\n"
"@deffn {Scheme Procedure} / z1 z2 @dots{}\n"
"@deffnx {C Function} scm_divide (z1, z2)\n"
"Divide the first argument by the product of the remaining arguments.  If\n"
"called with one argument @var{z1}, 1/@var{z1} is returned.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1247
msgid ""
"@deffn {Scheme Procedure} 1+ z\n"
"@deffnx {C Function} scm_oneplus (z)\n"
"Return @math{@var{z} + 1}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1252
msgid ""
"@deffn {Scheme Procedure} 1- z\n"
"@deffnx {C function} scm_oneminus (z)\n"
"Return @math{@var{z} - 1}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1257
msgid ""
"@c begin (texi-doc-string \"guile\" \"abs\")\n"
"@deffn {Scheme Procedure} abs x\n"
"@deffnx {C Function} scm_abs (x)\n"
"Return the absolute value of @var{x}."
msgstr ""

#: api-data.texi:1261
msgid ""
"@var{x} must be a number with zero imaginary part.  To calculate the\n"
"magnitude of a complex number, use @code{magnitude} instead.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1267
msgid ""
"@c begin (texi-doc-string \"guile\" \"max\")\n"
"@deffn {Scheme Procedure} max x1 x2 @dots{}\n"
"@deffnx {C Function} scm_max (x1, x2)\n"
"Return the maximum of all parameter values.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1273
msgid ""
"@c begin (texi-doc-string \"guile\" \"min\")\n"
"@deffn {Scheme Procedure} min x1 x2 @dots{}\n"
"@deffnx {C Function} scm_min (x1, x2)\n"
"Return the minimum of all parameter values.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1279
msgid ""
"@c begin (texi-doc-string \"guile\" \"truncate\")\n"
"@deffn {Scheme Procedure} truncate x\n"
"@deffnx {C Function} scm_truncate_number (x)\n"
"Round the inexact number @var{x} towards zero.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1286
msgid ""
"@c begin (texi-doc-string \"guile\" \"round\")\n"
"@deffn {Scheme Procedure} round x\n"
"@deffnx {C Function} scm_round_number (x)\n"
"Round the inexact number @var{x} to the nearest integer.  When exactly\n"
"halfway between two integers, round to the even one.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1292
msgid ""
"@c begin (texi-doc-string \"guile\" \"floor\")\n"
"@deffn {Scheme Procedure} floor x\n"
"@deffnx {C Function} scm_floor (x)\n"
"Round the number @var{x} towards minus infinity.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1298
msgid ""
"@c begin (texi-doc-string \"guile\" \"ceiling\")\n"
"@deffn {Scheme Procedure} ceiling x\n"
"@deffnx {C Function} scm_ceiling (x)\n"
"Round the number @var{x} towards infinity.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1305
msgid ""
"@deftypefn  {C Function} double scm_c_truncate (double x)\n"
"@deftypefnx {C Function} double scm_c_round (double x)\n"
"Like @code{scm_truncate_number} or @code{scm_round_number},\n"
"respectively, but these functions take and return @code{double}\n"
"values.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:1321
msgid ""
"@deftypefn {Scheme Procedure} {} euclidean/ @var{x} @var{y}\n"
"@deftypefnx {Scheme Procedure} {} euclidean-quotient @var{x} @var{y}\n"
"@deftypefnx {Scheme Procedure} {} euclidean-remainder @var{x} @var{y}\n"
"@deftypefnx {C Function} void scm_euclidean_divide (SCM @var{x}, SCM "
"@var{y}, SCM *@var{q}, SCM *@var{r})\n"
"@deftypefnx {C Function} SCM scm_euclidean_quotient (SCM @var{x}, SCM "
"@var{y})\n"
"@deftypefnx {C Function} SCM scm_euclidean_remainder (SCM @var{x}, SCM "
"@var{y})\n"
"These procedures accept two real numbers @var{x} and @var{y}, where the\n"
"divisor @var{y} must be non-zero.  @code{euclidean-quotient} returns the\n"
"integer @var{q} and @code{euclidean-remainder} returns the real number\n"
"@var{r} such that @math{@var{x} = @var{q}*@var{y} + @var{r}} and\n"
"@math{0 <= @var{r} < |@var{y}|}.  @code{euclidean/} returns both @var{q} "
"and\n"
"@var{r}, and is more efficient than computing each separately.  Note\n"
"that when @math{@var{y} > 0}, @code{euclidean-quotient} returns\n"
"@math{floor(@var{x}/@var{y})}, otherwise it returns\n"
"@math{ceiling(@var{x}/@var{y})}."
msgstr ""

#: api-data.texi:1324
msgid ""
"Note that these operators are equivalent to the R6RS operators\n"
"@code{div}, @code{mod}, and @code{div-and-mod}."
msgstr ""

#: api-data.texi:1336
msgid ""
"@lisp\n"
"(euclidean-quotient 123 10) @result{} 12\n"
"(euclidean-remainder 123 10) @result{} 3\n"
"(euclidean/ 123 10) @result{} 12 and 3\n"
"(euclidean/ 123 -10) @result{} -12 and 3\n"
"(euclidean/ -123 10) @result{} -13 and 7\n"
"(euclidean/ -123 -10) @result{} 13 and 7\n"
"(euclidean/ -123.2 -63.5) @result{} 2.0 and 3.8\n"
"(euclidean/ 16/3 -10/7) @result{} -3 and 22/21\n"
"@end lisp\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:1351
msgid ""
"@deftypefn {Scheme Procedure} {} floor/ @var{x} @var{y}\n"
"@deftypefnx {Scheme Procedure} {} floor-quotient @var{x} @var{y}\n"
"@deftypefnx {Scheme Procedure} {} floor-remainder @var{x} @var{y}\n"
"@deftypefnx {C Function} void scm_floor_divide (SCM @var{x}, SCM @var{y}, "
"SCM *@var{q}, SCM *@var{r})\n"
"@deftypefnx {C Function} SCM scm_floor_quotient (@var{x}, @var{y})\n"
"@deftypefnx {C Function} SCM scm_floor_remainder (@var{x}, @var{y})\n"
"These procedures accept two real numbers @var{x} and @var{y}, where the\n"
"divisor @var{y} must be non-zero.  @code{floor-quotient} returns the\n"
"integer @var{q} and @code{floor-remainder} returns the real number\n"
"@var{r} such that @math{@var{q} = floor(@var{x}/@var{y})} and\n"
"@math{@var{x} = @var{q}*@var{y} + @var{r}}.  @code{floor/} returns\n"
"both @var{q} and @var{r}, and is more efficient than computing each\n"
"separately.  Note that @var{r}, if non-zero, will have the same sign\n"
"as @var{y}."
msgstr ""

#: api-data.texi:1354
msgid ""
"When @var{x} and @var{y} are integers, @code{floor-remainder} is\n"
"equivalent to the R5RS integer-only operator @code{modulo}."
msgstr ""

#: api-data.texi:1366
msgid ""
"@lisp\n"
"(floor-quotient 123 10) @result{} 12\n"
"(floor-remainder 123 10) @result{} 3\n"
"(floor/ 123 10) @result{} 12 and 3\n"
"(floor/ 123 -10) @result{} -13 and -7\n"
"(floor/ -123 10) @result{} -13 and 7\n"
"(floor/ -123 -10) @result{} 12 and -3\n"
"(floor/ -123.2 -63.5) @result{} 1.0 and -59.7\n"
"(floor/ 16/3 -10/7) @result{} -4 and -8/21\n"
"@end lisp\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:1381
msgid ""
"@deftypefn {Scheme Procedure} {} ceiling/ @var{x} @var{y}\n"
"@deftypefnx {Scheme Procedure} {} ceiling-quotient @var{x} @var{y}\n"
"@deftypefnx {Scheme Procedure} {} ceiling-remainder @var{x} @var{y}\n"
"@deftypefnx {C Function} void scm_ceiling_divide (SCM @var{x}, SCM @var{y}, "
"SCM *@var{q}, SCM *@var{r})\n"
"@deftypefnx {C Function} SCM scm_ceiling_quotient (@var{x}, @var{y})\n"
"@deftypefnx {C Function} SCM scm_ceiling_remainder (@var{x}, @var{y})\n"
"These procedures accept two real numbers @var{x} and @var{y}, where the\n"
"divisor @var{y} must be non-zero.  @code{ceiling-quotient} returns the\n"
"integer @var{q} and @code{ceiling-remainder} returns the real number\n"
"@var{r} such that @math{@var{q} = ceiling(@var{x}/@var{y})} and\n"
"@math{@var{x} = @var{q}*@var{y} + @var{r}}.  @code{ceiling/} returns\n"
"both @var{q} and @var{r}, and is more efficient than computing each\n"
"separately.  Note that @var{r}, if non-zero, will have the opposite sign\n"
"of @var{y}."
msgstr ""

#: api-data.texi:1393
msgid ""
"@lisp\n"
"(ceiling-quotient 123 10) @result{} 13\n"
"(ceiling-remainder 123 10) @result{} -7\n"
"(ceiling/ 123 10) @result{} 13 and -7\n"
"(ceiling/ 123 -10) @result{} -12 and 3\n"
"(ceiling/ -123 10) @result{} -12 and -3\n"
"(ceiling/ -123 -10) @result{} 13 and 7\n"
"(ceiling/ -123.2 -63.5) @result{} 2.0 and 3.8\n"
"(ceiling/ 16/3 -10/7) @result{} -3 and 22/21\n"
"@end lisp\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:1408
msgid ""
"@deftypefn {Scheme Procedure} {} truncate/ @var{x} @var{y}\n"
"@deftypefnx {Scheme Procedure} {} truncate-quotient @var{x} @var{y}\n"
"@deftypefnx {Scheme Procedure} {} truncate-remainder @var{x} @var{y}\n"
"@deftypefnx {C Function} void scm_truncate_divide (SCM @var{x}, SCM @var{y}, "
"SCM *@var{q}, SCM *@var{r})\n"
"@deftypefnx {C Function} SCM scm_truncate_quotient (@var{x}, @var{y})\n"
"@deftypefnx {C Function} SCM scm_truncate_remainder (@var{x}, @var{y})\n"
"These procedures accept two real numbers @var{x} and @var{y}, where the\n"
"divisor @var{y} must be non-zero.  @code{truncate-quotient} returns the\n"
"integer @var{q} and @code{truncate-remainder} returns the real number\n"
"@var{r} such that @var{q} is @math{@var{x}/@var{y}} rounded toward zero,\n"
"and @math{@var{x} = @var{q}*@var{y} + @var{r}}.  @code{truncate/} returns\n"
"both @var{q} and @var{r}, and is more efficient than computing each\n"
"separately.  Note that @var{r}, if non-zero, will have the same sign\n"
"as @var{x}."
msgstr ""

#: api-data.texi:1412
msgid ""
"When @var{x} and @var{y} are integers, these operators are\n"
"equivalent to the R5RS integer-only operators @code{quotient} and\n"
"@code{remainder}."
msgstr ""

#: api-data.texi:1424
msgid ""
"@lisp\n"
"(truncate-quotient 123 10) @result{} 12\n"
"(truncate-remainder 123 10) @result{} 3\n"
"(truncate/ 123 10) @result{} 12 and 3\n"
"(truncate/ 123 -10) @result{} -12 and 3\n"
"(truncate/ -123 10) @result{} -12 and -3\n"
"(truncate/ -123 -10) @result{} 12 and -3\n"
"(truncate/ -123.2 -63.5) @result{} 1.0 and -59.7\n"
"(truncate/ 16/3 -10/7) @result{} -3 and 22/21\n"
"@end lisp\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:1438
msgid ""
"@deftypefn {Scheme Procedure} {} centered/ @var{x} @var{y}\n"
"@deftypefnx {Scheme Procedure} {} centered-quotient @var{x} @var{y}\n"
"@deftypefnx {Scheme Procedure} {} centered-remainder @var{x} @var{y}\n"
"@deftypefnx {C Function} void scm_centered_divide (SCM @var{x}, SCM @var{y}, "
"SCM *@var{q}, SCM *@var{r})\n"
"@deftypefnx {C Function} SCM scm_centered_quotient (SCM @var{x}, SCM "
"@var{y})\n"
"@deftypefnx {C Function} SCM scm_centered_remainder (SCM @var{x}, SCM "
"@var{y})\n"
"These procedures accept two real numbers @var{x} and @var{y}, where the\n"
"divisor @var{y} must be non-zero.  @code{centered-quotient} returns the\n"
"integer @var{q} and @code{centered-remainder} returns the real number\n"
"@var{r} such that @math{@var{x} = @var{q}*@var{y} + @var{r}} and\n"
"@math{-|@var{y}/2| <= @var{r} < |@var{y}/2|}.  @code{centered/}\n"
"returns both @var{q} and @var{r}, and is more efficient than computing\n"
"each separately."
msgstr ""

#: api-data.texi:1446
msgid ""
"Note that @code{centered-quotient} returns @math{@var{x}/@var{y}}\n"
"rounded to the nearest integer.  When @math{@var{x}/@var{y}} lies\n"
"exactly half-way between two integers, the tie is broken according to\n"
"the sign of @var{y}.  If @math{@var{y} > 0}, ties are rounded toward\n"
"positive infinity, otherwise they are rounded toward negative infinity.\n"
"This is a consequence of the requirement that\n"
"@math{-|@var{y}/2| <= @var{r} < |@var{y}/2|}."
msgstr ""

#: api-data.texi:1449
msgid ""
"Note that these operators are equivalent to the R6RS operators\n"
"@code{div0}, @code{mod0}, and @code{div0-and-mod0}."
msgstr ""

#: api-data.texi:1464
msgid ""
"@lisp\n"
"(centered-quotient 123 10) @result{} 12\n"
"(centered-remainder 123 10) @result{} 3\n"
"(centered/ 123 10) @result{} 12 and 3\n"
"(centered/ 123 -10) @result{} -12 and 3\n"
"(centered/ -123 10) @result{} -12 and -3\n"
"(centered/ -123 -10) @result{} 12 and -3\n"
"(centered/ 125 10) @result{} 13 and -5\n"
"(centered/ 127 10) @result{} 13 and -3\n"
"(centered/ 135 10) @result{} 14 and -5\n"
"(centered/ -123.2 -63.5) @result{} 2.0 and 3.8\n"
"(centered/ 16/3 -10/7) @result{} -4 and -8/21\n"
"@end lisp\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:1479
msgid ""
"@deftypefn {Scheme Procedure} {} round/ @var{x} @var{y}\n"
"@deftypefnx {Scheme Procedure} {} round-quotient @var{x} @var{y}\n"
"@deftypefnx {Scheme Procedure} {} round-remainder @var{x} @var{y}\n"
"@deftypefnx {C Function} void scm_round_divide (SCM @var{x}, SCM @var{y}, "
"SCM *@var{q}, SCM *@var{r})\n"
"@deftypefnx {C Function} SCM scm_round_quotient (@var{x}, @var{y})\n"
"@deftypefnx {C Function} SCM scm_round_remainder (@var{x}, @var{y})\n"
"These procedures accept two real numbers @var{x} and @var{y}, where the\n"
"divisor @var{y} must be non-zero.  @code{round-quotient} returns the\n"
"integer @var{q} and @code{round-remainder} returns the real number\n"
"@var{r} such that @math{@var{x} = @var{q}*@var{y} + @var{r}} and\n"
"@var{q} is @math{@var{x}/@var{y}} rounded to the nearest integer,\n"
"with ties going to the nearest even integer.  @code{round/}\n"
"returns both @var{q} and @var{r}, and is more efficient than computing\n"
"each separately."
msgstr ""

#: api-data.texi:1491
msgid ""
"Note that @code{round/} and @code{centered/} are almost equivalent, but\n"
"their behavior differs when @math{@var{x}/@var{y}} lies exactly half-way\n"
"between two integers.  In this case, @code{round/} chooses the nearest\n"
"even integer, whereas @code{centered/} chooses in such a way to satisfy\n"
"the constraint @math{-|@var{y}/2| <= @var{r} < |@var{y}/2|}, which\n"
"is stronger than the corresponding constraint for @code{round/},\n"
"@math{-|@var{y}/2| <= @var{r} <= |@var{y}/2|}.  In particular,\n"
"when @var{x} and @var{y} are integers, the number of possible remainders\n"
"returned by @code{centered/} is @math{|@var{y}|}, whereas the number of\n"
"possible remainders returned by @code{round/} is @math{|@var{y}|+1} when\n"
"@var{y} is even."
msgstr ""

#: api-data.texi:1506
msgid ""
"@lisp\n"
"(round-quotient 123 10) @result{} 12\n"
"(round-remainder 123 10) @result{} 3\n"
"(round/ 123 10) @result{} 12 and 3\n"
"(round/ 123 -10) @result{} -12 and 3\n"
"(round/ -123 10) @result{} -12 and -3\n"
"(round/ -123 -10) @result{} 12 and -3\n"
"(round/ 125 10) @result{} 12 and 5\n"
"(round/ 127 10) @result{} 13 and -3\n"
"(round/ 135 10) @result{} 14 and -5\n"
"(round/ -123.2 -63.5) @result{} 2.0 and 3.8\n"
"(round/ 16/3 -10/7) @result{} -4 and -8/21\n"
"@end lisp\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:1509
msgid ""
"@node Scientific\n"
"@subsubsection Scientific Functions"
msgstr ""

#: api-data.texi:1512
msgid ""
"The following procedures accept any kind of number as arguments,\n"
"including complex numbers."
msgstr ""
"Следующие процедуры принимают любое число в качестве аргументов,\n"
"включая комплексные числа."

#: api-data.texi:1519
msgid ""
"@rnindex sqrt\n"
"@c begin (texi-doc-string \"guile\" \"sqrt\")\n"
"@deffn {Scheme Procedure} sqrt z\n"
"Return the square root of @var{z}.  Of the two possible roots\n"
"(positive and negative), the one with a positive real part is\n"
"returned, or if that's zero then a positive imaginary part.  Thus,"
msgstr ""

#: api-data.texi:1527
msgid ""
"@example\n"
"(sqrt 9.0)       @result{} 3.0\n"
"(sqrt -9.0)      @result{} 0.0+3.0i\n"
"(sqrt 1.0+1.0i)  @result{} 1.09868411346781+0.455089860562227i\n"
"(sqrt -1.0-1.0i) @result{} 0.455089860562227-1.09868411346781i\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:1533
msgid ""
"@rnindex expt\n"
"@c begin (texi-doc-string \"guile\" \"expt\")\n"
"@deffn {Scheme Procedure} expt z1 z2\n"
"Return @var{z1} raised to the power of @var{z2}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1539
msgid ""
"@rnindex sin\n"
"@c begin (texi-doc-string \"guile\" \"sin\")\n"
"@deffn {Scheme Procedure} sin z\n"
"Return the sine of @var{z}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1545
msgid ""
"@rnindex cos\n"
"@c begin (texi-doc-string \"guile\" \"cos\")\n"
"@deffn {Scheme Procedure} cos z\n"
"Return the cosine of @var{z}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1551
msgid ""
"@rnindex tan\n"
"@c begin (texi-doc-string \"guile\" \"tan\")\n"
"@deffn {Scheme Procedure} tan z\n"
"Return the tangent of @var{z}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1557
msgid ""
"@rnindex asin\n"
"@c begin (texi-doc-string \"guile\" \"asin\")\n"
"@deffn {Scheme Procedure} asin z\n"
"Return the arcsine of @var{z}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1563
msgid ""
"@rnindex acos\n"
"@c begin (texi-doc-string \"guile\" \"acos\")\n"
"@deffn {Scheme Procedure} acos z\n"
"Return the arccosine of @var{z}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1570
msgid ""
"@rnindex atan\n"
"@c begin (texi-doc-string \"guile\" \"atan\")\n"
"@deffn {Scheme Procedure} atan z\n"
"@deffnx {Scheme Procedure} atan y x\n"
"Return the arctangent of @var{z}, or of @math{@var{y}/@var{x}}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1577
msgid ""
"@rnindex exp\n"
"@c begin (texi-doc-string \"guile\" \"exp\")\n"
"@deffn {Scheme Procedure} exp z\n"
"Return e to the power of @var{z}, where e is the base of natural\n"
"logarithms (2.71828@dots{}).\n"
"@end deffn"
msgstr ""

#: api-data.texi:1583
msgid ""
"@rnindex log\n"
"@c begin (texi-doc-string \"guile\" \"log\")\n"
"@deffn {Scheme Procedure} log z\n"
"Return the natural logarithm of @var{z}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1588
msgid ""
"@c begin (texi-doc-string \"guile\" \"log10\")\n"
"@deffn {Scheme Procedure} log10 z\n"
"Return the base 10 logarithm of @var{z}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1593
msgid ""
"@c begin (texi-doc-string \"guile\" \"sinh\")\n"
"@deffn {Scheme Procedure} sinh z\n"
"Return the hyperbolic sine of @var{z}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1598
msgid ""
"@c begin (texi-doc-string \"guile\" \"cosh\")\n"
"@deffn {Scheme Procedure} cosh z\n"
"Return the hyperbolic cosine of @var{z}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1603
msgid ""
"@c begin (texi-doc-string \"guile\" \"tanh\")\n"
"@deffn {Scheme Procedure} tanh z\n"
"Return the hyperbolic tangent of @var{z}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1608
msgid ""
"@c begin (texi-doc-string \"guile\" \"asinh\")\n"
"@deffn {Scheme Procedure} asinh z\n"
"Return the hyperbolic arcsine of @var{z}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1613
msgid ""
"@c begin (texi-doc-string \"guile\" \"acosh\")\n"
"@deffn {Scheme Procedure} acosh z\n"
"Return the hyperbolic arccosine of @var{z}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1618
msgid ""
"@c begin (texi-doc-string \"guile\" \"atanh\")\n"
"@deffn {Scheme Procedure} atanh z\n"
"Return the hyperbolic arctangent of @var{z}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:1622
msgid ""
"@node Bitwise Operations\n"
"@subsubsection Bitwise Operations"
msgstr ""

#: api-data.texi:1628
msgid ""
"For the following bitwise functions, negative numbers are treated as\n"
"infinite precision twos-complements.  For instance @math{-6} is bits\n"
"@math{@dots{}111010}, with infinitely many ones on the left.  It can\n"
"be seen that adding 6 (binary 110) to such a bit pattern gives all\n"
"zeros."
msgstr ""
"Для следующих побитовых функций отритцательные числа рассматриваются\n"
"как двоичные дополнения бесконечной точности.  Например @math{-6} \n"
"в битовом представлении @math{@dots{}111010}, как число бесконечным\n"
"числом единиц слева.  Это видно, что добавление  6 (binary 110) к\n"
"такой битовой схеме дает все нули."

#: api-data.texi:1632
msgid ""
"@deffn {Scheme Procedure} logand n1 n2 @dots{}\n"
"@deffnx {C Function} scm_logand (n1, n2)\n"
"Return the bitwise @sc{and} of the integer arguments."
msgstr ""

#: api-data.texi:1639
msgid ""
"@lisp\n"
"(logand) @result{} -1\n"
"(logand 7) @result{} 7\n"
"(logand #b111 #b011 #b001) @result{} 1\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:1643
msgid ""
"@deffn {Scheme Procedure} logior n1 n2 @dots{}\n"
"@deffnx {C Function} scm_logior (n1, n2)\n"
"Return the bitwise @sc{or} of the integer arguments."
msgstr ""

#: api-data.texi:1650
msgid ""
"@lisp\n"
"(logior) @result{} 0\n"
"(logior 7) @result{} 7\n"
"(logior #b000 #b001 #b011) @result{} 3\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:1655
msgid ""
"@deffn {Scheme Procedure} logxor n1 n2 @dots{}\n"
"@deffnx {C Function} scm_loxor (n1, n2)\n"
"Return the bitwise @sc{xor} of the integer arguments.  A bit is\n"
"set in the result if it is set in an odd number of arguments."
msgstr ""

#: api-data.texi:1663
msgid ""
"@lisp\n"
"(logxor) @result{} 0\n"
"(logxor 7) @result{} 7\n"
"(logxor #b000 #b001 #b011) @result{} 2\n"
"(logxor #b000 #b001 #b011 #b011) @result{} 1\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:1668
msgid ""
"@deffn {Scheme Procedure} lognot n\n"
"@deffnx {C Function} scm_lognot (n)\n"
"Return the integer which is the ones-complement of the integer\n"
"argument, ie.@: each 0 bit is changed to 1 and each 1 bit to 0."
msgstr ""

#: api-data.texi:1676
msgid ""
"@lisp\n"
"(number->string (lognot #b10000000) 2)\n"
"   @result{} \"-10000001\"\n"
"(number->string (lognot #b0) 2)\n"
"   @result{} \"-1\"\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:1682
msgid ""
"@deffn {Scheme Procedure} logtest j k\n"
"@deffnx {C Function} scm_logtest (j, k)\n"
"Test whether @var{j} and @var{k} have any 1 bits in common.  This is\n"
"equivalent to @code{(not (zero? (logand j k)))}, but without actually\n"
"calculating the @code{logand}, just testing for non-zero."
msgstr ""

#: api-data.texi:1688
msgid ""
"@lisp\n"
"(logtest #b0100 #b1011) @result{} #f\n"
"(logtest #b0100 #b0111) @result{} #t\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:1693
msgid ""
"@deffn {Scheme Procedure} logbit? index j\n"
"@deffnx {C Function} scm_logbit_p (index, j)\n"
"Test whether bit number @var{index} in @var{j} is set.  @var{index}\n"
"starts from 0 for the least significant bit."
msgstr ""

#: api-data.texi:1702
msgid ""
"@lisp\n"
"(logbit? 0 #b1101) @result{} #t\n"
"(logbit? 1 #b1101) @result{} #f\n"
"(logbit? 2 #b1101) @result{} #t\n"
"(logbit? 3 #b1101) @result{} #t\n"
"(logbit? 4 #b1101) @result{} #f\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:1707
msgid ""
"@deffn {Scheme Procedure} ash n count\n"
"@deffnx {C Function} scm_ash (n, count)\n"
"Return @math{floor(n * 2^{count})}.\n"
"@var{n} and @var{count} must be exact integers."
msgstr ""

#: api-data.texi:1712
msgid ""
"With @var{n} viewed as an infinite-precision twos-complement\n"
"integer, @code{ash} means a left shift introducing zero bits\n"
"when @var{count} is positive, or a right shift dropping bits\n"
"when @var{count} is negative.  This is an ``arithmetic'' shift."
msgstr ""

#: api-data.texi:1716
msgid ""
"@lisp\n"
"(number->string (ash #b1 3) 2)     @result{} \"1000\"\n"
"(number->string (ash #b1010 -1) 2) @result{} \"101\""
msgstr ""

#: api-data.texi:1721
msgid ""
";; -23 is bits ...11101001, -6 is bits ...111010\n"
"(ash -23 -2) @result{} -6\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:1726
msgid ""
"@deffn {Scheme Procedure} round-ash n count\n"
"@deffnx {C Function} scm_round_ash (n, count)\n"
"Return @math{round(n * 2^count)}.\n"
"@var{n} and @var{count} must be exact integers."
msgstr ""

#: api-data.texi:1733
msgid ""
"With @var{n} viewed as an infinite-precision twos-complement\n"
"integer, @code{round-ash} means a left shift introducing zero\n"
"bits when @var{count} is positive, or a right shift rounding\n"
"to the nearest integer (with ties going to the nearest even\n"
"integer) when @var{count} is negative.  This is a rounded\n"
"``arithmetic'' shift."
msgstr ""

#: api-data.texi:1743
msgid ""
"@lisp\n"
"(number->string (round-ash #b1 3) 2)     @result{} \\\"1000\\\"\n"
"(number->string (round-ash #b1010 -1) 2) @result{} \\\"101\\\"\n"
"(number->string (round-ash #b1010 -2) 2) @result{} \\\"10\\\"\n"
"(number->string (round-ash #b1011 -2) 2) @result{} \\\"11\\\"\n"
"(number->string (round-ash #b1101 -2) 2) @result{} \\\"11\\\"\n"
"(number->string (round-ash #b1110 -2) 2) @result{} \\\"100\\\"\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:1750
msgid ""
"@deffn {Scheme Procedure} logcount n\n"
"@deffnx {C Function} scm_logcount (n)\n"
"Return the number of bits in integer @var{n}.  If @var{n} is\n"
"positive, the 1-bits in its binary representation are counted.\n"
"If negative, the 0-bits in its two's-complement binary\n"
"representation are counted.  If zero, 0 is returned."
msgstr ""

#: api-data.texi:1760
msgid ""
"@lisp\n"
"(logcount #b10101010)\n"
"   @result{} 4\n"
"(logcount 0)\n"
"   @result{} 0\n"
"(logcount -2)\n"
"   @result{} 1\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:1764
msgid ""
"@deffn {Scheme Procedure} integer-length n\n"
"@deffnx {C Function} scm_integer_length (n)\n"
"Return the number of bits necessary to represent @var{n}."
msgstr ""

#: api-data.texi:1768
msgid ""
"For positive @var{n} this is how many bits to the most significant one\n"
"bit.  For negative @var{n} it's how many bits to the most significant\n"
"zero bit in twos complement form."
msgstr ""

#: api-data.texi:1778
msgid ""
"@lisp\n"
"(integer-length #b10101010) @result{} 8\n"
"(integer-length #b1111)     @result{} 4\n"
"(integer-length 0)          @result{} 0\n"
"(integer-length -1)         @result{} 0\n"
"(integer-length -256)       @result{} 8\n"
"(integer-length -257)       @result{} 9\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:1783
msgid ""
"@deffn {Scheme Procedure} integer-expt n k\n"
"@deffnx {C Function} scm_integer_expt (n, k)\n"
"Return @var{n} raised to the power @var{k}.  @var{k} must be an exact\n"
"integer, @var{n} can be any number."
msgstr ""

#: api-data.texi:1787
msgid ""
"Negative @var{k} is supported, and results in @m{1/n^|k|, 1/n^abs(k)}\n"
"in the usual way.  @math{@var{n}^0} is 1, as usual, and that includes\n"
"@math{0^0} is 1."
msgstr ""

#: api-data.texi:1795
msgid ""
"@lisp\n"
"(integer-expt 2 5)   @result{} 32\n"
"(integer-expt -3 3)  @result{} -27\n"
"(integer-expt 5 -3)  @result{} 1/125\n"
"(integer-expt 0 0)   @result{} 1\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:1801
msgid ""
"@deffn {Scheme Procedure} bit-extract n start end\n"
"@deffnx {C Function} scm_bit_extract (n, start, end)\n"
"Return the integer composed of the @var{start} (inclusive)\n"
"through @var{end} (exclusive) bits of @var{n}.  The\n"
"@var{start}th bit becomes the 0-th bit in the result."
msgstr ""

#: api-data.texi:1809
msgid ""
"@lisp\n"
"(number->string (bit-extract #b1101101010 0 4) 2)\n"
"   @result{} \"1010\"\n"
"(number->string (bit-extract #b1101101010 4 9) 2)\n"
"   @result{} \"10110\"\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:1813
msgid ""
"@node Random\n"
"@subsubsection Random Number Generation"
msgstr ""

#: api-data.texi:1822
msgid ""
"Pseudo-random numbers are generated from a random state object, which\n"
"can be created with @code{seed->random-state} or\n"
"@code{datum->random-state}.  An external representation (i.e.@: one\n"
"which can written with @code{write} and read with @code{read}) of a\n"
"random state object can be obtained via\n"
"@code{random-state->datum}.  The @var{state} parameter to the\n"
"various functions below is optional, it defaults to the state object\n"
"in the @code{*random-state*} variable."
msgstr ""
"Псевдослучайные чила генерируются из объекта случаного состояния,\n"
"который может быть создан функциями @code{seed->random-state} или\n"
"@code{datum->random-state}.  Внешнее представление (т.е..@: \n"
"которое может быть записано @code{write} и считано @code{read}) \n"
"объекта случайного состояния) может быть получено вызовом\n"
"@code{random-state->datum}.  Параметр @var{state} для различных\n"
"функци ниже, не обязателен, по умолчанию используется объект \n"
"состояния в переменной  @code{*random-state*}."

#: api-data.texi:1827
msgid ""
"@deffn {Scheme Procedure} copy-random-state [state]\n"
"@deffnx {C Function} scm_copy_random_state (state)\n"
"Return a copy of the random state @var{state}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} copy-random-state [state]\n"
"@deffnx {C Function} scm_copy_random_state (state)\n"
"Возвращает копию случайного состояния @var{state}.\n"
"@end deffn"

#: api-data.texi:1831
msgid ""
"@deffn {Scheme Procedure} random n [state]\n"
"@deffnx {C Function} scm_random (n, state)\n"
"Return a number in [0, @var{n})."
msgstr ""
"@deffn {Scheme Procedure} random n [state]\n"
"@deffnx {C Function} scm_random (n, state)\n"
"Возвращает номер в рамках [0, @var{n})."

#: api-data.texi:1837
msgid ""
"Accepts a positive integer or real n and returns a\n"
"number of the same type between zero (inclusive) and\n"
"@var{n} (exclusive). The values returned have a uniform\n"
"distribution.\n"
"@end deffn"
msgstr ""
"Принимает полжительное целое или вещественное n и \n"
"возвращает число того же типа между нулем(включительно)\n"
"и @var{n} (исключая). Возвращаемые значения имеют\n"
"равномерное распределение.\n"
"@end deffn"

#: api-data.texi:1844
msgid ""
"@deffn {Scheme Procedure} random:exp [state]\n"
"@deffnx {C Function} scm_random_exp (state)\n"
"Return an inexact real in an exponential distribution with mean\n"
"1.  For an exponential distribution with mean @var{u} use @code{(*\n"
"@var{u} (random:exp))}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} random:exp [state]\n"
"@deffnx {C Function} scm_random_exp (state)\n"
"Возвращает не точное вещественное значение в экспотенциальном\n"
"распределении со средним 1.  Для экспотенциального распределения\n"
"со средним равным @var{u} используйте @code{(* @var{u} (random:exp))}.\n"
"@end deffn"

#: api-data.texi:1853
msgid ""
"@deffn {Scheme Procedure} random:hollow-sphere! vect [state]\n"
"@deffnx {C Function} scm_random_hollow_sphere_x (vect, state)\n"
"Fills @var{vect} with inexact real random numbers the sum of whose\n"
"squares is equal to 1.0.  Thinking of @var{vect} as coordinates in\n"
"space of dimension @var{n} @math{=} @code{(vector-length @var{vect})},\n"
"the coordinates are uniformly distributed over the surface of the unit\n"
"n-sphere.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} random:hollow-sphere! vect [state]\n"
"@deffnx {C Function} scm_random_hollow_sphere_x (vect, state)\n"
"Заполняет вектор @var{vect} неточными вещественными случайными\n"
"числами сумма квадратов которых равна 1.0.  Думая о векторе @var{vect}\n"
"как о пространстве размерности @var{n} @math{=} @code{(vector-length "
"@var{vect})},\n"
"координаты равномерно распределены по поверхности единичной n-сферы.\n"
"@end deffn"

#: api-data.texi:1861
msgid ""
"@deffn {Scheme Procedure} random:normal [state]\n"
"@deffnx {C Function} scm_random_normal (state)\n"
"Return an inexact real in a normal distribution.  The distribution\n"
"used has mean 0 and standard deviation 1.  For a normal distribution\n"
"with mean @var{m} and standard deviation @var{d} use @code{(+ @var{m}\n"
"(* @var{d} (random:normal)))}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} random:normal [state]\n"
"@deffnx {C Function} scm_random_normal (state)\n"
"Возвращает не точное нормальное распределение. Это распределение\n"
"имеет среднее 0 и стандартное отклонение 1.  Для номрмального распределения\n"
"со средним @var{m} и стандартным отклонением @var{d} используйте @code{(+ "
"@var{m}\n"
"(* @var{d} (random:normal)))}.\n"
"@end deffn"

#: api-data.texi:1868
msgid ""
"@deffn {Scheme Procedure} random:normal-vector! vect [state]\n"
"@deffnx {C Function} scm_random_normal_vector_x (vect, state)\n"
"Fills @var{vect} with inexact real random numbers that are\n"
"independent and standard normally distributed\n"
"(i.e., with mean 0 and variance 1).\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} random:normal-vector! vect [state]\n"
"@deffnx {C Function} scm_random_normal_vector_x (vect, state)\n"
"Заполняет вектор  @var{vect} неточными вещественными случайными\n"
"числами, которые являются независимыми и стандартно распределенными\n"
"(т.е со средним 0 и дисперсией 1).\n"
"@end deffn"

#: api-data.texi:1878
msgid ""
"@deffn {Scheme Procedure} random:solid-sphere! vect [state]\n"
"@deffnx {C Function} scm_random_solid_sphere_x (vect, state)\n"
"Fills @var{vect} with inexact real random numbers the sum of whose\n"
"squares is less than 1.0.  Thinking of @var{vect} as coordinates in\n"
"space of dimension @var{n} @math{=} @code{(vector-length @var{vect})},\n"
"the coordinates are uniformly distributed within the unit\n"
"@var{n}-sphere.\n"
"@c FIXME: What does this mean, particularly the n-sphere part?\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} random:solid-sphere! vect [state]\n"
"@deffnx {C Function} scm_random_solid_sphere_x (vect, state)\n"
"Заполняет вектор @var{vect} неточными вещественными случайными числами,\n"
"сумма квадратов которых меньше 1.0.  Думая о векторе @var{vect} как о\n"
"координатах в пространстве размерности @var{n} \n"
"@math{=} @code{(vector-length @var{vect})}, координаты равномерно\n"
"распределены внутри единично @var{n}-сферы.\n"
"@c FIXME: What does this mean, particularly the n-sphere part?\n"
"@end deffn"

#: api-data.texi:1884
msgid ""
"@deffn {Scheme Procedure} random:uniform [state]\n"
"@deffnx {C Function} scm_random_uniform (state)\n"
"Return a uniformly distributed inexact real random number in\n"
"[0,1).\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} random:uniform [state]\n"
"@deffnx {C Function} scm_random_uniform (state)\n"
"Возвращает равномернораспределенное неточное вещественное\n"
"число в границах [0,1).\n"
"@end deffn"

#: api-data.texi:1889
msgid ""
"@deffn {Scheme Procedure} seed->random-state seed\n"
"@deffnx {C Function} scm_seed_to_random_state (seed)\n"
"Return a new random state using @var{seed}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} seed->random-state seed\n"
"@deffnx {C Function} scm_seed_to_random_state (seed)\n"
"Возвращает новое случайное состояние с использванием\n"
"@var{seed}.\n"
"@end deffn"

#: api-data.texi:1895
msgid ""
"@deffn {Scheme Procedure} datum->random-state datum\n"
"@deffnx {C Function} scm_datum_to_random_state (datum)\n"
"Return a new random state from @var{datum}, which should have been\n"
"obtained by @code{random-state->datum}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} datum->random-state datum\n"
"@deffnx {C Function} scm_datum_to_random_state (datum)\n"
"Возвращает новое случайное состояние из @var{datum}, которое\n"
"должно быть получено вызовом @code{random-state->datum}.\n"
"@end deffn"

#: api-data.texi:1901
msgid ""
"@deffn {Scheme Procedure} random-state->datum state\n"
"@deffnx {C Function} scm_random_state_to_datum (state)\n"
"Return a datum representation of @var{state} that may be written out and\n"
"read back with the Scheme reader.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} random-state->datum state\n"
"@deffnx {C Function} scm_random_state_to_datum (state)\n"
"Возвращает представление случайного состояния @var{state} которое может "
"быть\n"
"записано и прочитано с помощью функций чтения Scheme.\n"
"@end deffn"

#: api-data.texi:1911
msgid ""
"@deffn {Scheme Procedure} random-state-from-platform\n"
"@deffnx {C Function} scm_random_state_from_platform ()\n"
"Construct a new random state seeded from a platform-specific source of\n"
"entropy, appropriate for use in non-security-critical applications.\n"
"Currently @file{/dev/urandom} is tried first, or else the seed is based\n"
"on the time, date, process ID, an address from a freshly allocated heap\n"
"cell, an address from the local stack frame, and a high-resolution timer\n"
"if available.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} random-state-from-platform\n"
"@deffnx {C Function} scm_random_state_from_platform ()\n"
"Создание нового случайного состояния, сгенерированное из энтропии, \n"
"специфичной для платформы, подходящее для использования в не критичных\n"
"для безопасности приложениях. В настоящее время @file{/dev/urandom} \n"
"сначала, основывается на времени и дате, идентификаторе процесса, адресе\n"
"недавно выделенной ячейки кучи, адресе из локального фрейма стека и таймере\n"
"высокого разрешения, если он доступен.\n"
"@end deffn"

#: api-data.texi:1916
msgid ""
"@defvar *random-state*\n"
"The global random state used by the above functions when the\n"
"@var{state} parameter is not given.\n"
"@end defvar"
msgstr ""
"@defvar *random-state*\n"
"Глобальное случайное состояние, используемое вышеуказанными функциями, \n"
"когда параметр @var{state} не задан.\n"
"@end defvar"

#: api-data.texi:1923
msgid ""
"Note that the initial value of @code{*random-state*} is the same every\n"
"time Guile starts up.  Therefore, if you don't pass a @var{state}\n"
"parameter to the above procedures, and you don't set\n"
"@code{*random-state*} to @code{(seed->random-state your-seed)}, where\n"
"@code{your-seed} is something that @emph{isn't} the same every time,\n"
"you'll get the same sequence of ``random'' numbers on every run."
msgstr ""
"Обратите внимание, что начальное значение @code{*random-state*} одинаково\n"
"при каждом запуске Guile. Поэтому, если вы не передадите параметр\n"
"состояния указанным выше процедурам, и вы не установите\n"
"@code{*random-state*} вызвом @code{(seed->random-state your-seed)}, где\n"
"@code{your-seed} это не одно и тоже значение каждый раз, вы получите\n"
"одну и туже последовательность ``случайных'' чисел при каждом запуске\n"
"программы."

#: api-data.texi:1927
msgid ""
"For example, unless the relevant source code has changed, @code{(map\n"
"random (cdr (iota 30)))}, if the first use of random numbers since\n"
"Guile started up, will always give:"
msgstr ""
"Например, если соответствующий код не был изменен, \n"
"@code{(map random (cdr (iota 30)))}, если первое использование\n"
"случайных чисел с момента запуска Guile всегда будет давать:"

#: api-data.texi:1933
msgid ""
"@lisp\n"
"(map random (cdr (iota 19)))\n"
"@result{}\n"
"(0 1 1 2 2 2 1 2 6 7 10 0 5 3 12 5 5 12)\n"
"@end lisp"
msgstr ""

#: api-data.texi:1936
msgid ""
"To seed the random state in a sensible way for non-security-critical\n"
"applications, do this during initialization of your program:"
msgstr ""
"Чтобы разумно распределять случайное состояние для приложений, не\n"
"относящихся к супер безопасным, сделайте это во время инициализации\n"
"вашей программы."

#: api-data.texi:1940
msgid ""
"@lisp\n"
"(set! *random-state* (random-state-from-platform))\n"
"@end lisp"
msgstr ""

#: api-data.texi:1945
msgid ""
"@node Characters\n"
"@subsection Characters\n"
"@tpindex Characters"
msgstr ""

#: api-data.texi:1947
msgid "In Scheme, there is a data type to describe a single character.  "
msgstr "В схеме существует тип данных для описания одиночных символов"

#: api-data.texi:1952
msgid ""
"Defining what exactly a character @emph{is} can be more complicated\n"
"than it seems.  Guile follows the advice of R6RS and uses The Unicode\n"
"Standard to help define what a character is.  So, for Guile, a\n"
"character is anything in the Unicode Character Database."
msgstr ""
"Определение того, что такое символ может быть сложнее, чем кажется. Guile\n"
"следует рекомендациям R6RS и использует стандарт Unicode, чтобы "
"определить, \n"
"что является символом. Итак, для Guile символ - это что-то из базы данных\n"
"символов Юникода."

#: api-data.texi:1955
msgid ""
"@cindex code point\n"
"@cindex Unicode code point"
msgstr ""

#: api-data.texi:1960
msgid ""
"The Unicode Character Database is basically a table of characters\n"
"indexed using integers called 'code points'.  Valid code points are in\n"
"the ranges 0 to @code{#xD7FF} inclusive or @code{#xE000} to\n"
"@code{#x10FFFF} inclusive, which is about 1.1 million code points."
msgstr ""
"База данных символов Юникода представляет собой таблицу символов,\n"
"индексированную с использованием целых чисел называемых «кодовыми\n"
"точками». Действительные кодовые точки находятся в диапазоне от \n"
"0 до @code{#xD7FF} включительно или @code{#xE000} до  @code{#x10FFFF} \n"
"включительно, что составляет около 1,1 миллиона кодовых точек.\n"

#: api-data.texi:1963
msgid ""
"@cindex designated code point\n"
"@cindex code point, designated"
msgstr ""

#: api-data.texi:1971
msgid ""
"Any code point that has been assigned to a character or that has\n"
"otherwise been given a meaning by Unicode is called a 'designated code\n"
"point'.  Most of the designated code points, about 200,000 of them,\n"
"indicate characters, accents or other combining marks that modify\n"
"other characters, symbols, whitespace, and control characters.  Some\n"
"are not characters but indicators that suggest how to format or\n"
"display neighboring characters."
msgstr ""
"Любая кодовая точка, которая была назначена символу или которая \n"
"имеет значение в Unicode называется «обозначенной кодовой точкой».\n"
"Большинство обозначенных кодовых точек, около 200 000 указывают \n"
"на символы, акценты или сочетания меток, которые изменяют\n"
"другие символы, символы, пробелы и управляющие символы. Некоторые \n"
"из них не являются символами, но являются индикаторами, которые \n"
"указывают, как форматировать или отображать соседние символы."

#: api-data.texi:1974
msgid ""
"@cindex reserved code point\n"
"@cindex code point, reserved"
msgstr ""

#: api-data.texi:1979
msgid ""
"If a code point is not a designated code point -- if it has not been\n"
"assigned to a character by The Unicode Standard -- it is a 'reserved\n"
"code point', meaning that they are reserved for future use.  Most of\n"
"the code points, about 800,000, are 'reserved code points'."
msgstr ""
"Если кодовая точка не является назначенной кодовой точкой - т.е если \n"
"она не назначена символу в стандарте Unicode - это 'зарезервированная \n"
"кодовая точка', что означает, что она зарезервирована для\n"
"будущего использования. Большинство кодовых точек, около 800 000, \n"
"являются «зарезервированными кодовыми точками»."

#: api-data.texi:1984
msgid ""
"By convention, a Unicode code point is written as\n"
"``U+XXXX'' where ``XXXX'' is a hexadecimal number.  Please note that\n"
"this convenient notation is not valid code.  Guile does not interpret\n"
"``U+XXXX'' as a character."
msgstr ""
"По соглашению, кодовая точка Unicode записывается как \n"
"``U+XXXX'', где ``XXXX'' является шестнадцатеричным числом. \n"
"Обратите внимание, что это удобное обозначение является недопустимым \n"
"кодом. Guile не интерпретирует ``U+XXXX'' как символ.\n"

#: api-data.texi:1989
msgid ""
"In Scheme, a character literal is written as @code{#\\@var{name}} where\n"
"@var{name} is the name of the character that you want.  Printable\n"
"characters have their usual single character name; for example,\n"
"@code{#\\a} is a lower case @code{a}.  "
msgstr ""
"В Scheme символьный литерал записывается как @code{#\\@var{name}}, где \n"
"@var{name} - это имя символа, который вам нужен. Печатные \n"
"символы имеют свое обычное односимвольное имя; Например, \n"
"@code{#\\a} - это нижний регистр @code{a}."

#: api-data.texi:1997
msgid ""
"Some of the code points are 'combining characters' that are not meant\n"
"to be printed by themselves but are instead meant to modify the\n"
"appearance of the previous character.  For combining characters, an\n"
"alternate form of the character literal is @code{#\\} followed by\n"
"U+25CC (a small, dotted circle), followed by the combining character.\n"
"This allows the combining character to be drawn on the circle, not on\n"
"the backslash of @code{#\\}."
msgstr ""
"Некоторые из кодовых точек - это 'комбинирующие символы', которые не \n"
"предназначены для печати а вместо этого предназначены для изменения \n"
"внешнего вида предыдущего символа. Для комбинирующих символов, \n"
"альтернативная форма символьного литерала - @code{#\\}, затем U+25CC\n"
"(маленький, пунктирный круг), за которым следует комбинирующий символ. \n"
"Это позволяет создать комбинированный символ, который будет нарисован \n"
"на круге, а не обычную обратную косую черту  @code{#\\}."

#: api-data.texi:2000
msgid ""
"Many of the non-printing characters, such as whitespace characters and\n"
"control characters, also have names."
msgstr ""
"Многие из непечатаемых символов, таких как символы пробелов и управляющие \n"
"символы, также имеют имена."

#: api-data.texi:2003
msgid ""
"The most commonly used non-printing characters have long character\n"
"names, described in the table below."
msgstr ""
"Наиболее часто используемые непечатаемые символы имеют длинные имена \n"
"символов, описанны в таблице ниже"

#: api-data.texi:2019
msgid ""
"@multitable {@code{#\\backspace}} {Preferred}\n"
"@item Character Name @tab Codepoint\n"
"@item @code{#\\nul} @tab U+0000\n"
"@item @code{#\\alarm} @tab U+0007\n"
"@item @code{#\\backspace} @tab U+0008\n"
"@item @code{#\\tab} @tab U+0009\n"
"@item @code{#\\linefeed} @tab U+000A\n"
"@item @code{#\\newline} @tab U+000A\n"
"@item @code{#\\vtab} @tab U+000B\n"
"@item @code{#\\page} @tab U+000C\n"
"@item @code{#\\return} @tab U+000D\n"
"@item @code{#\\esc} @tab U+001B\n"
"@item @code{#\\space} @tab U+0020\n"
"@item @code{#\\delete} @tab U+007F\n"
"@end multitable"
msgstr ""

#: api-data.texi:2023
msgid ""
"There are also short names for all of the ``C0 control characters''\n"
"(those with code points below 32).  The following table lists the short\n"
"name for each character."
msgstr ""
"Также есть короткие имена для всех ``C0 управляющих символов''\n"
"(те, у кого есть кодовые точки ниже 32).  В следующей таблице\n"
"указаны краткие имена для каждого символа."

#: api-data.texi:2059
msgid ""
"@multitable @columnfractions .25 .25 .25 .25\n"
"@item 0 = @code{#\\nul}\n"
" @tab 1 = @code{#\\soh}\n"
" @tab 2 = @code{#\\stx}\n"
" @tab 3 = @code{#\\etx}\n"
"@item 4 = @code{#\\eot}\n"
" @tab 5 = @code{#\\enq}\n"
" @tab 6 = @code{#\\ack}\n"
" @tab 7 = @code{#\\bel}\n"
"@item 8 = @code{#\\bs}\n"
" @tab 9 = @code{#\\ht}\n"
" @tab 10 = @code{#\\lf}\n"
" @tab 11 = @code{#\\vt}\n"
"@item 12 = @code{#\\ff}\n"
" @tab 13 = @code{#\\cr}\n"
" @tab 14 = @code{#\\so}\n"
" @tab 15 = @code{#\\si}\n"
"@item 16 = @code{#\\dle}\n"
" @tab 17 = @code{#\\dc1}\n"
" @tab 18 = @code{#\\dc2}\n"
" @tab 19 = @code{#\\dc3}\n"
"@item 20 = @code{#\\dc4}\n"
" @tab 21 = @code{#\\nak}\n"
" @tab 22 = @code{#\\syn}\n"
" @tab 23 = @code{#\\etb}\n"
"@item 24 = @code{#\\can}\n"
" @tab 25 = @code{#\\em}\n"
" @tab 26 = @code{#\\sub}\n"
" @tab 27 = @code{#\\esc}\n"
"@item 28 = @code{#\\fs}\n"
" @tab 29 = @code{#\\gs}\n"
" @tab 30 = @code{#\\rs}\n"
" @tab 31 = @code{#\\us}\n"
"@item 32 = @code{#\\sp}\n"
"@end multitable"
msgstr ""

#: api-data.texi:2062
msgid ""
"The short name for the ``delete'' character (code point U+007F) is\n"
"@code{#\\del}."
msgstr ""
"Короткое имя для символа удалить ``delete'' (кодовая точка U+007F)\n"
"@code{#\\del}."

#: api-data.texi:2065
msgid ""
"The R7RS name for the ``escape'' character (code point U+001B) is\n"
"@code{#\\escape}."
msgstr ""

#: api-data.texi:2068
msgid ""
"There are also a few alternative names left over for compatibility with\n"
"previous versions of Guile."
msgstr ""
"Есть также несколько альтернативных имен, оставшихся для совместимости с\n"
"предыдущими версиями из Guile."

#: api-data.texi:2075
msgid ""
"@multitable {@code{#\\backspace}} {Preferred}\n"
"@item Alternate @tab Standard\n"
"@item @code{#\\nl} @tab @code{#\\newline}\n"
"@item @code{#\\np} @tab @code{#\\page}\n"
"@item @code{#\\null} @tab @code{#\\nul}\n"
"@end multitable"
msgstr ""

#: api-data.texi:2079
msgid ""
"Characters may also be written using their code point values.  They can\n"
"be written with as an octal number, such as @code{#\\10} for\n"
"@code{#\\bs} or @code{#\\177} for @code{#\\del}."
msgstr ""

#: api-data.texi:2083
msgid ""
"If one prefers hex to octal, there is an additional syntax for character\n"
"escapes: @code{#\\xHHHH} -- the letter 'x' followed by a hexadecimal\n"
"number of one to eight digits."
msgstr ""
"Если кто-то предпочитает использовать шестнадцатеричный код, \n"
"сущетствует дополнительный синткасис с обратной косой чертой:\n"
"@code{#\\xHHHH} -- за символом 'x' следует шестнадцатеричное число\n"
"от одной до восми цифр."

#: api-data.texi:2089
msgid ""
"@rnindex char?\n"
"@deffn {Scheme Procedure} char? x\n"
"@deffnx {C Function} scm_char_p (x)\n"
"Return @code{#t} if @var{x} is a character, else @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2092
msgid ""
"Fundamentally, the character comparison operations below are\n"
"numeric comparisons of the character's code points."
msgstr ""

#: api-data.texi:2098
msgid ""
"@rnindex char=?\n"
"@deffn {Scheme Procedure} char=? x y\n"
"Return @code{#t} if code point of @var{x} is equal to the code point\n"
"of @var{y}, else @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2104
msgid ""
"@rnindex char<?\n"
"@deffn {Scheme Procedure} char<? x y\n"
"Return @code{#t} if the code point of @var{x} is less than the code\n"
"point of @var{y}, else @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2110
msgid ""
"@rnindex char<=?\n"
"@deffn {Scheme Procedure} char<=? x y\n"
"Return @code{#t} if the code point of @var{x} is less than or equal\n"
"to the code point of @var{y}, else @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2116
msgid ""
"@rnindex char>?\n"
"@deffn {Scheme Procedure} char>? x y\n"
"Return @code{#t} if the code point of @var{x} is greater than the\n"
"code point of @var{y}, else @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2122
msgid ""
"@rnindex char>=?\n"
"@deffn {Scheme Procedure} char>=? x y\n"
"Return @code{#t} if the code point of @var{x} is greater than or\n"
"equal to the code point of @var{y}, else @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2124
msgid "@cindex case folding"
msgstr ""

#: api-data.texi:2134
msgid ""
"Case-insensitive character comparisons use @emph{Unicode case\n"
"folding}.  In case folding comparisons, if a character is lowercase\n"
"and has an uppercase form that can be expressed as a single character,\n"
"it is converted to uppercase before comparison.  All other characters\n"
"undergo no conversion before the comparison occurs.  This includes the\n"
"German sharp S (Eszett) which is not uppercased before conversion\n"
"because its uppercase form has two characters.  Unicode case folding\n"
"is language independent: it uses rules that are generally true, but,\n"
"it cannot cover all cases for all languages."
msgstr ""

#: api-data.texi:2140
msgid ""
"@rnindex char-ci=?\n"
"@deffn {Scheme Procedure} char-ci=? x y\n"
"Return @code{#t} if the case-folded code point of @var{x} is the same\n"
"as the case-folded code point of @var{y}, else @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2146
msgid ""
"@rnindex char-ci<?\n"
"@deffn {Scheme Procedure} char-ci<? x y\n"
"Return @code{#t} if the case-folded code point of @var{x} is less\n"
"than the case-folded code point of @var{y}, else @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2153
msgid ""
"@rnindex char-ci<=?\n"
"@deffn {Scheme Procedure} char-ci<=? x y\n"
"Return @code{#t} if the case-folded code point of @var{x} is less\n"
"than or equal to the case-folded code point of @var{y}, else\n"
"@code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2159
msgid ""
"@rnindex char-ci>?\n"
"@deffn {Scheme Procedure} char-ci>? x y\n"
"Return @code{#t} if the case-folded code point of @var{x} is greater\n"
"than the case-folded code point of @var{y}, else @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2166
msgid ""
"@rnindex char-ci>=?\n"
"@deffn {Scheme Procedure} char-ci>=? x y\n"
"Return @code{#t} if the case-folded code point of @var{x} is greater\n"
"than or equal to the case-folded code point of @var{y}, else\n"
"@code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2172
msgid ""
"@rnindex char-alphabetic?\n"
"@deffn {Scheme Procedure} char-alphabetic? chr\n"
"@deffnx {C Function} scm_char_alphabetic_p (chr)\n"
"Return @code{#t} if @var{chr} is alphabetic, else @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2178
msgid ""
"@rnindex char-numeric?\n"
"@deffn {Scheme Procedure} char-numeric? chr\n"
"@deffnx {C Function} scm_char_numeric_p (chr)\n"
"Return @code{#t} if @var{chr} is numeric, else @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2184
msgid ""
"@rnindex char-whitespace?\n"
"@deffn {Scheme Procedure} char-whitespace? chr\n"
"@deffnx {C Function} scm_char_whitespace_p (chr)\n"
"Return @code{#t} if @var{chr} is whitespace, else @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2190
msgid ""
"@rnindex char-upper-case?\n"
"@deffn {Scheme Procedure} char-upper-case? chr\n"
"@deffnx {C Function} scm_char_upper_case_p (chr)\n"
"Return @code{#t} if @var{chr} is uppercase, else @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2196
msgid ""
"@rnindex char-lower-case?\n"
"@deffn {Scheme Procedure} char-lower-case? chr\n"
"@deffnx {C Function} scm_char_lower_case_p (chr)\n"
"Return @code{#t} if @var{chr} is lowercase, else @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2202
msgid ""
"@deffn {Scheme Procedure} char-is-both? chr\n"
"@deffnx {C Function} scm_char_is_both_p (chr)\n"
"Return @code{#t} if @var{chr} is either uppercase or lowercase, else\n"
"@code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2209
msgid ""
"@deffn {Scheme Procedure} char-general-category chr\n"
"@deffnx {C Function} scm_char_general_category (chr)\n"
"Return a symbol giving the two-letter name of the Unicode general \n"
"category assigned to @var{chr} or @code{#f} if no named category is \n"
"assigned.  The following table provides a list of category names along\n"
"with their meanings."
msgstr ""

#: api-data.texi:2277
msgid ""
"@multitable @columnfractions .1 .4 .1 .4\n"
"@item Lu\n"
" @tab Uppercase letter\n"
" @tab Pf\n"
" @tab Final quote punctuation\n"
"@item Ll\n"
" @tab Lowercase letter\n"
" @tab Po\n"
" @tab Other punctuation\n"
"@item Lt\n"
" @tab Titlecase letter\n"
" @tab Sm\n"
" @tab Math symbol\n"
"@item Lm\n"
" @tab Modifier letter\n"
" @tab Sc\n"
" @tab Currency symbol\n"
"@item Lo\n"
" @tab Other letter\n"
" @tab Sk\n"
" @tab Modifier symbol\n"
"@item Mn\n"
" @tab Non-spacing mark\n"
" @tab So\n"
" @tab Other symbol\n"
"@item Mc\n"
" @tab Combining spacing mark\n"
" @tab Zs\n"
" @tab Space separator\n"
"@item Me\n"
" @tab Enclosing mark\n"
" @tab Zl\n"
" @tab Line separator\n"
"@item Nd\n"
" @tab Decimal digit number\n"
" @tab Zp\n"
" @tab Paragraph separator\n"
"@item Nl\n"
" @tab Letter number\n"
" @tab Cc\n"
" @tab Control\n"
"@item No\n"
" @tab Other number\n"
" @tab Cf\n"
" @tab Format\n"
"@item Pc\n"
" @tab Connector punctuation\n"
" @tab Cs\n"
" @tab Surrogate\n"
"@item Pd\n"
" @tab Dash punctuation\n"
" @tab Co\n"
" @tab Private use\n"
"@item Ps\n"
" @tab Open punctuation\n"
" @tab Cn\n"
" @tab Unassigned\n"
"@item Pe\n"
" @tab Close punctuation\n"
" @tab\n"
" @tab\n"
"@item Pi\n"
" @tab Initial quote punctuation\n"
" @tab\n"
" @tab\n"
"@end multitable\n"
"@end deffn"
msgstr ""

#: api-data.texi:2283
msgid ""
"@rnindex char->integer\n"
"@deffn {Scheme Procedure} char->integer chr\n"
"@deffnx {C Function} scm_char_to_integer (chr)\n"
"Return the code point of @var{chr}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2291
msgid ""
"@rnindex integer->char\n"
"@deffn {Scheme Procedure} integer->char n\n"
"@deffnx {C Function} scm_integer_to_char (n)\n"
"Return the character that has code point @var{n}.  The integer @var{n}\n"
"must be a valid code point.  Valid code points are in the ranges 0 to\n"
"@code{#xD7FF} inclusive or @code{#xE000} to @code{#x10FFFF} inclusive.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2297
msgid ""
"@rnindex char-upcase\n"
"@deffn {Scheme Procedure} char-upcase chr\n"
"@deffnx {C Function} scm_char_upcase (chr)\n"
"Return the uppercase character version of @var{chr}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2303
msgid ""
"@rnindex char-downcase\n"
"@deffn {Scheme Procedure} char-downcase chr\n"
"@deffnx {C Function} scm_char_downcase (chr)\n"
"Return the lowercase character version of @var{chr}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2309
msgid ""
"@rnindex char-titlecase\n"
"@deffn {Scheme Procedure} char-titlecase chr\n"
"@deffnx {C Function} scm_char_titlecase (chr)\n"
"Return the titlecase character version of @var{chr} if one exists;\n"
"otherwise return the uppercase version.  "
msgstr ""

#: api-data.texi:2316
msgid ""
"For most characters these will be the same, but the Unicode Standard \n"
"includes certain digraph compatibility characters, such as @code{U+01F3}\n"
"``dz'', for which the uppercase and titlecase characters are different \n"
"(@code{U+01F1} ``DZ'' and @code{U+01F2} ``Dz'' in this case, \n"
"respectively).\n"
"@end deffn"
msgstr ""

#: api-data.texi:2321
msgid ""
"@tindex scm_t_wchar\n"
"@deftypefn {C Function} scm_t_wchar scm_c_upcase (scm_t_wchar @var{c})\n"
"@deftypefnx {C Function} scm_t_wchar scm_c_downcase (scm_t_wchar @var{c})\n"
"@deftypefnx {C Function} scm_t_wchar scm_c_titlecase (scm_t_wchar @var{c})"
msgstr ""

#: api-data.texi:2327
msgid ""
"These C functions take an integer representation of a Unicode\n"
"codepoint and return the codepoint corresponding to its uppercase,\n"
"lowercase, and titlecase forms respectively.  The type\n"
"@code{scm_t_wchar} is a signed, 32-bit integer.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:2331
msgid ""
"Characters also have ``formal names'', which are defined by Unicode.\n"
"These names can be accessed in Guile from the @code{(ice-9 unicode)}\n"
"module:"
msgstr ""
"Символы также имеют ``формальные имена'', которые определены Unicode.\n"
"Этим имена могут быть доступны в Guile из модуля @code{(ice-9 unicode)}:\n"

#: api-data.texi:2335
msgid ""
"@example\n"
"(use-modules (ice-9 unicode))\n"
"@end example"
msgstr ""

#: api-data.texi:2340
msgid ""
"@deffn {Scheme Procedure} char->formal-name chr\n"
"Return the formal all-upper-case Unicode name of @var{ch},\n"
"as a string, or @code{#f} if the character has no name.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2345
msgid ""
"@deffn {Scheme Procedure} formal-name->char name\n"
"Return the character whose formal all-upper-case Unicode name is\n"
"@var{name}, or @code{#f} if no such character is known.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2348
msgid ""
"@node Character Sets\n"
"@subsection Character Sets"
msgstr ""

#: api-data.texi:2350
msgid "The features described in this section correspond directly to SRFI-14."
msgstr "Функции, описанные в данном разделе, соответствуют SRFI-14."

#: api-data.texi:2355
msgid ""
"The data type @dfn{charset} implements sets of characters\n"
"(@pxref{Characters}).  Because the internal representation of\n"
"character sets is not visible to the user, a lot of procedures for\n"
"handling them are provided."
msgstr ""
"Тип данных @dfn{(Набор символов)charset} реализует множество символов.\n"
"(@pxref{Characters}).  Поскольку внутреннее представление множества \n"
"символов не видно пользователю, предоставляется множество процедур для\n"
"их обработки."

#: api-data.texi:2358
msgid ""
"Character sets can be created, extended, tested for the membership of a\n"
"characters and be compared to other character sets."
msgstr ""
"Наборы символов могут быть созданы, расширены, проверены на принадлежность\n"
"символов и могут быть сравнены с другими наборами символов."

#: api-data.texi:2367
msgid ""
"@menu\n"
"* Character Set Predicates/Comparison::\n"
"* Iterating Over Character Sets::  Enumerate charset elements.\n"
"* Creating Character Sets::        Making new charsets.\n"
"* Querying Character Sets::        Test charsets for membership etc.\n"
"* Character-Set Algebra::          Calculating new charsets.\n"
"* Standard Character Sets::        Variables containing predefined "
"charsets.\n"
"@end menu"
msgstr ""

#: api-data.texi:2370
msgid ""
"@node Character Set Predicates/Comparison\n"
"@subsubsection Character Set Predicates/Comparison"
msgstr ""

#: api-data.texi:2375
msgid ""
"Use these procedures for testing whether an object is a character set,\n"
"or whether several character sets are equal or subsets of each other.\n"
"@code{char-set-hash} can be used for calculating a hash value, maybe for\n"
"usage in fast lookup procedures."
msgstr ""
"Используйте эти процедуры для проверки того, является ли объект набором\n"
"символов, или проверки равны ли между собой несколько наборов символов\n"
"или является ли один набор символов, подмножеством другого. Функция\n"
"@code{char-set-hash} вычисляет хеш-значение набора символов и может \n"
"быть использована в быстрых процедурах поиска.\n"

#: api-data.texi:2381
msgid ""
"@deffn {Scheme Procedure} char-set? obj\n"
"@deffnx {C Function} scm_char_set_p (obj)\n"
"Return @code{#t} if @var{obj} is a character set, @code{#f}\n"
"otherwise.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2386
msgid ""
"@deffn {Scheme Procedure} char-set= char_set @dots{}\n"
"@deffnx {C Function} scm_char_set_eq (char_sets)\n"
"Return @code{#t} if all given character sets are equal.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2392
msgid ""
"@deffn {Scheme Procedure} char-set<= char_set @dots{}\n"
"@deffnx {C Function} scm_char_set_leq (char_sets)\n"
"Return @code{#t} if every character set @var{char_set}i is a subset\n"
"of character set @var{char_set}i+1.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2399
msgid ""
"@deffn {Scheme Procedure} char-set-hash cs [bound]\n"
"@deffnx {C Function} scm_char_set_hash (cs, bound)\n"
"Compute a hash value for the character set @var{cs}.  If\n"
"@var{bound} is given and non-zero, it restricts the\n"
"returned value to the range 0 @dots{} @var{bound} - 1.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2401
msgctxt "api-data.texi:2401"
msgid "@c ==================================================================="
msgstr ""

#: api-data.texi:2404
msgid ""
"@node Iterating Over Character Sets\n"
"@subsubsection Iterating Over Character Sets"
msgstr ""

#: api-data.texi:2411
msgid ""
"Character set cursors are a means for iterating over the members of a\n"
"character sets.  After creating a character set cursor with\n"
"@code{char-set-cursor}, a cursor can be dereferenced with\n"
"@code{char-set-ref}, advanced to the next member with\n"
"@code{char-set-cursor-next}.  Whether a cursor has passed past the last\n"
"element of the set can be checked with @code{end-of-char-set?}."
msgstr ""
"Указатели в наборе символов - это средство для итерации над элементами\n"
"набора символов.  После создания указателя(курсора) набора символов\n"
"с помощью функции @code{char-set-cursor}, указатель может быть\n"
"разименован(получен элемент набора символов) @code{char-set-ref}, \n"
"перемещен к следующему элементу @code{char-set-cursor-next}.  \n"
"Проверить когда указатель прошел последний элемент можно \n"
"функцией @code{end-of-char-set?}."

#: api-data.texi:2414
msgid ""
"Additionally, mapping and (un-)folding procedures for character sets are\n"
"provided."
msgstr ""
"Кроме того, предоставляются функции сопоставления(mapping) и функции\n"
"складывания(fold)/создания(unfold) набора символов."

#: api-data.texi:2419
msgid ""
"@deffn {Scheme Procedure} char-set-cursor cs\n"
"@deffnx {C Function} scm_char_set_cursor (cs)\n"
"Return a cursor into the character set @var{cs}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2426
msgid ""
"@deffn {Scheme Procedure} char-set-ref cs cursor\n"
"@deffnx {C Function} scm_char_set_ref (cs, cursor)\n"
"Return the character at the current cursor position\n"
"@var{cursor} in the character set @var{cs}.  It is an error to\n"
"pass a cursor for which @code{end-of-char-set?} returns true.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2433
msgid ""
"@deffn {Scheme Procedure} char-set-cursor-next cs cursor\n"
"@deffnx {C Function} scm_char_set_cursor_next (cs, cursor)\n"
"Advance the character set cursor @var{cursor} to the next\n"
"character in the character set @var{cs}.  It is an error if the\n"
"cursor given satisfies @code{end-of-char-set?}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2439
msgid ""
"@deffn {Scheme Procedure} end-of-char-set? cursor\n"
"@deffnx {C Function} scm_end_of_char_set_p (cursor)\n"
"Return @code{#t} if @var{cursor} has reached the end of a\n"
"character set, @code{#f} otherwise.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2445
msgid ""
"@deffn {Scheme Procedure} char-set-fold kons knil cs\n"
"@deffnx {C Function} scm_char_set_fold (kons, knil, cs)\n"
"Fold the procedure @var{kons} over the character set @var{cs},\n"
"initializing it with @var{knil}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2460
msgid ""
"@deffn {Scheme Procedure} char-set-unfold p f g seed [base_cs]\n"
"@deffnx {C Function} scm_char_set_unfold (p, f, g, seed, base_cs)\n"
"This is a fundamental constructor for character sets.\n"
"@itemize @bullet\n"
"@item @var{g} is used to generate a series of ``seed'' values\n"
"from the initial seed: @var{seed}, (@var{g} @var{seed}),\n"
"(@var{g}^2 @var{seed}), (@var{g}^3 @var{seed}), @dots{}\n"
"@item @var{p} tells us when to stop -- when it returns true\n"
"when applied to one of the seed values.\n"
"@item @var{f} maps each seed value to a character. These\n"
"characters are added to the base character set @var{base_cs} to\n"
"form the result; @var{base_cs} defaults to the empty set.\n"
"@end itemize\n"
"@end deffn"
msgstr ""

#: api-data.texi:2475
msgid ""
"@deffn {Scheme Procedure} char-set-unfold! p f g seed base_cs\n"
"@deffnx {C Function} scm_char_set_unfold_x (p, f, g, seed, base_cs)\n"
"This is a fundamental constructor for character sets.\n"
"@itemize @bullet\n"
"@item @var{g} is used to generate a series of ``seed'' values\n"
"from the initial seed: @var{seed}, (@var{g} @var{seed}),\n"
"(@var{g}^2 @var{seed}), (@var{g}^3 @var{seed}), @dots{}\n"
"@item @var{p} tells us when to stop -- when it returns true\n"
"when applied to one of the seed values.\n"
"@item @var{f} maps each seed value to a character. These\n"
"characters are added to the base character set @var{base_cs} to\n"
"form the result; @var{base_cs} defaults to the empty set.\n"
"@end itemize\n"
"@end deffn"
msgstr ""

#: api-data.texi:2481
msgid ""
"@deffn {Scheme Procedure} char-set-for-each proc cs\n"
"@deffnx {C Function} scm_char_set_for_each (proc, cs)\n"
"Apply @var{proc} to every character in the character set\n"
"@var{cs}.  The return value is not specified.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2487
msgid ""
"@deffn {Scheme Procedure} char-set-map proc cs\n"
"@deffnx {C Function} scm_char_set_map (proc, cs)\n"
"Map the procedure @var{proc} over every character in @var{cs}.\n"
"@var{proc} must be a character -> character procedure.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2489
msgctxt "api-data.texi:2489"
msgid "@c ==================================================================="
msgstr ""

#: api-data.texi:2492
msgid ""
"@node Creating Character Sets\n"
"@subsubsection Creating Character Sets"
msgstr ""

#: api-data.texi:2494
msgid "New character sets are produced with these procedures."
msgstr "С помощью этих процедур создаются новые наборы символов."

#: api-data.texi:2500
msgid ""
"@deffn {Scheme Procedure} char-set-copy cs\n"
"@deffnx {C Function} scm_char_set_copy (cs)\n"
"Return a newly allocated character set containing all\n"
"characters in @var{cs}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2505
msgid ""
"@deffn {Scheme Procedure} char-set chr @dots{}\n"
"@deffnx {C Function} scm_char_set (chrs)\n"
"Return a character set containing all given characters.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2512
msgid ""
"@deffn {Scheme Procedure} list->char-set list [base_cs]\n"
"@deffnx {C Function} scm_list_to_char_set (list, base_cs)\n"
"Convert the character list @var{list} to a character set.  If\n"
"the character set @var{base_cs} is given, the character in this\n"
"set are also included in the result.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2519
msgid ""
"@deffn {Scheme Procedure} list->char-set! list base_cs\n"
"@deffnx {C Function} scm_list_to_char_set_x (list, base_cs)\n"
"Convert the character list @var{list} to a character set.  The\n"
"characters are added to @var{base_cs} and @var{base_cs} is\n"
"returned.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2526
msgid ""
"@deffn {Scheme Procedure} string->char-set str [base_cs]\n"
"@deffnx {C Function} scm_string_to_char_set (str, base_cs)\n"
"Convert the string @var{str} to a character set.  If the\n"
"character set @var{base_cs} is given, the characters in this\n"
"set are also included in the result.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2533
msgid ""
"@deffn {Scheme Procedure} string->char-set! str base_cs\n"
"@deffnx {C Function} scm_string_to_char_set_x (str, base_cs)\n"
"Convert the string @var{str} to a character set.  The\n"
"characters from the string are added to @var{base_cs}, and\n"
"@var{base_cs} is returned.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2540
msgid ""
"@deffn {Scheme Procedure} char-set-filter pred cs [base_cs]\n"
"@deffnx {C Function} scm_char_set_filter (pred, cs, base_cs)\n"
"Return a character set containing every character from @var{cs}\n"
"so that it satisfies @var{pred}.  If provided, the characters\n"
"from @var{base_cs} are added to the result.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2547
msgid ""
"@deffn {Scheme Procedure} char-set-filter! pred cs base_cs\n"
"@deffnx {C Function} scm_char_set_filter_x (pred, cs, base_cs)\n"
"Return a character set containing every character from @var{cs}\n"
"so that it satisfies @var{pred}.  The characters are added to\n"
"@var{base_cs} and @var{base_cs} is returned.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2553
msgid ""
"@deffn {Scheme Procedure} ucs-range->char-set lower upper [error [base_cs]]\n"
"@deffnx {C Function} scm_ucs_range_to_char_set (lower, upper, error, "
"base_cs)\n"
"Return a character set containing all characters whose\n"
"character codes lie in the half-open range\n"
"[@var{lower},@var{upper})."
msgstr ""

#: api-data.texi:2559
msgctxt "api-data.texi:2559"
msgid ""
"If @var{error} is a true value, an error is signalled if the\n"
"specified range contains characters which are not contained in\n"
"the implemented character range.  If @var{error} is @code{#f},\n"
"these characters are silently left out of the resulting\n"
"character set."
msgstr ""

#: api-data.texi:2563
msgid ""
"The characters in @var{base_cs} are added to the result, if\n"
"given.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2569
msgid ""
"@deffn {Scheme Procedure} ucs-range->char-set! lower upper error base_cs\n"
"@deffnx {C Function} scm_ucs_range_to_char_set_x (lower, upper, error, "
"base_cs)\n"
"Return a character set containing all characters whose\n"
"character codes lie in the half-open range\n"
"[@var{lower},@var{upper})."
msgstr ""

#: api-data.texi:2575
msgctxt "api-data.texi:2575"
msgid ""
"If @var{error} is a true value, an error is signalled if the\n"
"specified range contains characters which are not contained in\n"
"the implemented character range.  If @var{error} is @code{#f},\n"
"these characters are silently left out of the resulting\n"
"character set."
msgstr ""

#: api-data.texi:2579
msgid ""
"The characters are added to @var{base_cs} and @var{base_cs} is\n"
"returned.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2587
msgid ""
"@deffn {Scheme Procedure} ->char-set x\n"
"@deffnx {C Function} scm_to_char_set (x)\n"
"Coerces x into a char-set. @var{x} may be a string, character or\n"
"char-set. A string is converted to the set of its constituent\n"
"characters; a character is converted to a singleton set; a char-set is\n"
"returned as-is.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2589
msgctxt "api-data.texi:2589"
msgid "@c ==================================================================="
msgstr ""

#: api-data.texi:2592
msgid ""
"@node Querying Character Sets\n"
"@subsubsection Querying Character Sets"
msgstr ""

#: api-data.texi:2595
msgid ""
"Access the elements and other information of a character set with these\n"
"procedures."
msgstr ""
"С помощью этих процедур осущетсвляется получение доступа к элементам и \n"
"получение другой информации о наборе символов."

#: api-data.texi:2612
msgid ""
"@deffn {Scheme Procedure} %char-set-dump cs\n"
"Returns an association list containing debugging information\n"
"for @var{cs}. The association list has the following entries.\n"
"@table @code\n"
"@item char-set\n"
"The char-set itself\n"
"@item len\n"
"The number of groups of contiguous code points the char-set\n"
"contains\n"
"@item ranges\n"
"A list of lists where each sublist is a range of code points\n"
"and their associated characters\n"
"@end table\n"
"The return value of this function cannot be relied upon to be\n"
"consistent between versions of Guile and should not be used in code.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2617
msgid ""
"@deffn {Scheme Procedure} char-set-size cs\n"
"@deffnx {C Function} scm_char_set_size (cs)\n"
"Return the number of elements in character set @var{cs}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2623
msgid ""
"@deffn {Scheme Procedure} char-set-count pred cs\n"
"@deffnx {C Function} scm_char_set_count (pred, cs)\n"
"Return the number of the elements int the character set\n"
"@var{cs} which satisfy the predicate @var{pred}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2629
msgid ""
"@deffn {Scheme Procedure} char-set->list cs\n"
"@deffnx {C Function} scm_char_set_to_list (cs)\n"
"Return a list containing the elements of the character set\n"
"@var{cs}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2636
msgid ""
"@deffn {Scheme Procedure} char-set->string cs\n"
"@deffnx {C Function} scm_char_set_to_string (cs)\n"
"Return a string containing the elements of the character set\n"
"@var{cs}.  The order in which the characters are placed in the\n"
"string is not defined.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2642
msgid ""
"@deffn {Scheme Procedure} char-set-contains? cs ch\n"
"@deffnx {C Function} scm_char_set_contains_p (cs, ch)\n"
"Return @code{#t} if the character @var{ch} is contained in the\n"
"character set @var{cs}, or @code{#f} otherwise.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2648
msgid ""
"@deffn {Scheme Procedure} char-set-every pred cs\n"
"@deffnx {C Function} scm_char_set_every (pred, cs)\n"
"Return a true value if every character in the character set\n"
"@var{cs} satisfies the predicate @var{pred}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2654
msgid ""
"@deffn {Scheme Procedure} char-set-any pred cs\n"
"@deffnx {C Function} scm_char_set_any (pred, cs)\n"
"Return a true value if any character in the character set\n"
"@var{cs} satisfies the predicate @var{pred}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2656
msgctxt "api-data.texi:2656"
msgid "@c ==================================================================="
msgstr ""

#: api-data.texi:2659
msgid ""
"@node Character-Set Algebra\n"
"@subsubsection Character-Set Algebra"
msgstr ""

#: api-data.texi:2664
msgid ""
"Character sets can be manipulated with the common set algebra operation,\n"
"such as union, complement, intersection etc.  All of these procedures\n"
"provide side-effecting variants, which modify their character set\n"
"argument(s)."
msgstr ""
"Наборами символов можно манипулировать с помощью операций общей алгебры\n"
"множеств, таких как объединение, дополнения, пересечения и т.д. Все эти\n"
"процедуры имеют побочные эффекты, которые изменяют их аргумент(ы) - \n"
"наборы символов."

#: api-data.texi:2670
msgid ""
"@deffn {Scheme Procedure} char-set-adjoin cs chr @dots{}\n"
"@deffnx {C Function} scm_char_set_adjoin (cs, chrs)\n"
"Add all character arguments to the first argument, which must\n"
"be a character set.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2676
msgid ""
"@deffn {Scheme Procedure} char-set-delete cs chr @dots{}\n"
"@deffnx {C Function} scm_char_set_delete (cs, chrs)\n"
"Delete all character arguments from the first argument, which\n"
"must be a character set.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2682
msgid ""
"@deffn {Scheme Procedure} char-set-adjoin! cs chr @dots{}\n"
"@deffnx {C Function} scm_char_set_adjoin_x (cs, chrs)\n"
"Add all character arguments to the first argument, which must\n"
"be a character set.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2688
msgid ""
"@deffn {Scheme Procedure} char-set-delete! cs chr @dots{}\n"
"@deffnx {C Function} scm_char_set_delete_x (cs, chrs)\n"
"Delete all character arguments from the first argument, which\n"
"must be a character set.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2693
msgid ""
"@deffn {Scheme Procedure} char-set-complement cs\n"
"@deffnx {C Function} scm_char_set_complement (cs)\n"
"Return the complement of the character set @var{cs}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2699
msgid ""
"Note that the complement of a character set is likely to contain many\n"
"reserved code points (code points that are not associated with\n"
"characters).  It may be helpful to modify the output of\n"
"@code{char-set-complement} by computing its intersection with the set\n"
"of designated code points, @code{char-set:designated}."
msgstr ""

#: api-data.texi:2704
msgid ""
"@deffn {Scheme Procedure} char-set-union cs @dots{}\n"
"@deffnx {C Function} scm_char_set_union (char_sets)\n"
"Return the union of all argument character sets.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2709
msgid ""
"@deffn {Scheme Procedure} char-set-intersection cs @dots{}\n"
"@deffnx {C Function} scm_char_set_intersection (char_sets)\n"
"Return the intersection of all argument character sets.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2714
msgid ""
"@deffn {Scheme Procedure} char-set-difference cs1 cs @dots{}\n"
"@deffnx {C Function} scm_char_set_difference (cs1, char_sets)\n"
"Return the difference of all argument character sets.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2719
msgid ""
"@deffn {Scheme Procedure} char-set-xor cs @dots{}\n"
"@deffnx {C Function} scm_char_set_xor (char_sets)\n"
"Return the exclusive-or of all argument character sets.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2725
msgid ""
"@deffn {Scheme Procedure} char-set-diff+intersection cs1 cs @dots{}\n"
"@deffnx {C Function} scm_char_set_diff_plus_intersection (cs1, char_sets)\n"
"Return the difference and the intersection of all argument\n"
"character sets.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2730
msgid ""
"@deffn {Scheme Procedure} char-set-complement! cs\n"
"@deffnx {C Function} scm_char_set_complement_x (cs)\n"
"Return the complement of the character set @var{cs}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2735
msgid ""
"@deffn {Scheme Procedure} char-set-union! cs1 cs @dots{}\n"
"@deffnx {C Function} scm_char_set_union_x (cs1, char_sets)\n"
"Return the union of all argument character sets.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2740
msgid ""
"@deffn {Scheme Procedure} char-set-intersection! cs1 cs @dots{}\n"
"@deffnx {C Function} scm_char_set_intersection_x (cs1, char_sets)\n"
"Return the intersection of all argument character sets.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2745
msgid ""
"@deffn {Scheme Procedure} char-set-difference! cs1 cs @dots{}\n"
"@deffnx {C Function} scm_char_set_difference_x (cs1, char_sets)\n"
"Return the difference of all argument character sets.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2750
msgid ""
"@deffn {Scheme Procedure} char-set-xor! cs1 cs @dots{}\n"
"@deffnx {C Function} scm_char_set_xor_x (cs1, char_sets)\n"
"Return the exclusive-or of all argument character sets.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2756
msgid ""
"@deffn {Scheme Procedure} char-set-diff+intersection! cs1 cs2 cs @dots{}\n"
"@deffnx {C Function} scm_char_set_diff_plus_intersection_x (cs1, cs2, "
"char_sets)\n"
"Return the difference and the intersection of all argument\n"
"character sets.\n"
"@end deffn"
msgstr ""

#: api-data.texi:2758
msgctxt "api-data.texi:2758"
msgid "@c ==================================================================="
msgstr ""

#: api-data.texi:2761
msgid ""
"@node Standard Character Sets\n"
"@subsubsection Standard Character Sets"
msgstr ""

#: api-data.texi:2764
msgid ""
"In order to make the use of the character set data type and procedures\n"
"useful, several predefined character set variables exist."
msgstr ""
"Чтобы использовать тип данных и процедуры набора символов, существуют\n"
"предопределенные наборы символов."

#: api-data.texi:2768
msgid ""
"@cindex codeset\n"
"@cindex charset\n"
"@cindex locale"
msgstr ""

#: api-data.texi:2773
msgid ""
"These character sets are locale independent and are not recomputed\n"
"upon a @code{setlocale} call.  They contain characters from the whole\n"
"range of Unicode code points. For instance, @code{char-set:letter}\n"
"contains about 100,000 characters."
msgstr ""
"Эти наборы символов независимы от локали и не пересчитываются при\n"
"вызове @code{setlocale}.  Они содержат символы из всего диапазона\n"
"кодовых точек Unicode. Например, @code{char-set:letter} содержит\n"
"около 100,000 символов."

#: api-data.texi:2778
msgid ""
"@defvr {Scheme Variable} char-set:lower-case\n"
"@defvrx {C Variable} scm_char_set_lower_case\n"
"All lower-case characters.\n"
"@end defvr"
msgstr ""

#: api-data.texi:2783
msgid ""
"@defvr {Scheme Variable} char-set:upper-case\n"
"@defvrx {C Variable} scm_char_set_upper_case\n"
"All upper-case characters.\n"
"@end defvr"
msgstr ""

#: api-data.texi:2789
msgid ""
"@defvr {Scheme Variable} char-set:title-case\n"
"@defvrx {C Variable} scm_char_set_title_case\n"
"All single characters that function as if they were an upper-case\n"
"letter followed by a lower-case letter.\n"
"@end defvr"
msgstr ""

#: api-data.texi:2797
msgid ""
"@defvr {Scheme Variable} char-set:letter\n"
"@defvrx {C Variable} scm_char_set_letter\n"
"All letters.  This includes @code{char-set:lower-case},\n"
"@code{char-set:upper-case}, @code{char-set:title-case}, and many\n"
"letters that have no case at all.  For example, Chinese and Japanese\n"
"characters typically have no concept of case.\n"
"@end defvr"
msgstr ""

#: api-data.texi:2802
msgid ""
"@defvr {Scheme Variable} char-set:digit\n"
"@defvrx {C Variable} scm_char_set_digit\n"
"All digits.\n"
"@end defvr"
msgstr ""

#: api-data.texi:2807
msgid ""
"@defvr {Scheme Variable} char-set:letter+digit\n"
"@defvrx {C Variable} scm_char_set_letter_and_digit\n"
"The union of @code{char-set:letter} and @code{char-set:digit}.\n"
"@end defvr"
msgstr ""

#: api-data.texi:2812
msgid ""
"@defvr {Scheme Variable} char-set:graphic\n"
"@defvrx {C Variable} scm_char_set_graphic\n"
"All characters which would put ink on the paper.\n"
"@end defvr"
msgstr ""

#: api-data.texi:2817
msgid ""
"@defvr {Scheme Variable} char-set:printing\n"
"@defvrx {C Variable} scm_char_set_printing\n"
"The union of @code{char-set:graphic} and @code{char-set:whitespace}.\n"
"@end defvr"
msgstr ""

#: api-data.texi:2822
msgid ""
"@defvr {Scheme Variable} char-set:whitespace\n"
"@defvrx {C Variable} scm_char_set_whitespace\n"
"All whitespace characters.\n"
"@end defvr"
msgstr ""

#: api-data.texi:2828
msgid ""
"@defvr {Scheme Variable} char-set:blank\n"
"@defvrx {C Variable} scm_char_set_blank\n"
"All horizontal whitespace characters, which notably includes\n"
"@code{#\\space} and @code{#\\tab}.\n"
"@end defvr"
msgstr ""

#: api-data.texi:2835
msgid ""
"@defvr {Scheme Variable} char-set:iso-control\n"
"@defvrx {C Variable} scm_char_set_iso_control\n"
"The ISO control characters are the C0 control characters (U+0000 to\n"
"U+001F), delete (U+007F), and the C1 control characters (U+0080 to\n"
"U+009F).\n"
"@end defvr"
msgstr ""

#: api-data.texi:2841
msgid ""
"@defvr {Scheme Variable} char-set:punctuation\n"
"@defvrx {C Variable} scm_char_set_punctuation\n"
"All punctuation characters, such as the characters\n"
"@code{!\"#%&'()*,-./:;?@@[\\\\]_@{@}}\n"
"@end defvr"
msgstr ""

#: api-data.texi:2846
msgid ""
"@defvr {Scheme Variable} char-set:symbol\n"
"@defvrx {C Variable} scm_char_set_symbol\n"
"All symbol characters, such as the characters @code{$+<=>^`|~}.\n"
"@end defvr"
msgstr ""

#: api-data.texi:2851
msgid ""
"@defvr {Scheme Variable} char-set:hex-digit\n"
"@defvrx {C Variable} scm_char_set_hex_digit\n"
"The hexadecimal digits @code{0123456789abcdefABCDEF}.\n"
"@end defvr"
msgstr ""

#: api-data.texi:2856
msgid ""
"@defvr {Scheme Variable} char-set:ascii\n"
"@defvrx {C Variable} scm_char_set_ascii\n"
"All ASCII characters.\n"
"@end defvr"
msgstr ""

#: api-data.texi:2861
msgid ""
"@defvr {Scheme Variable} char-set:empty\n"
"@defvrx {C Variable} scm_char_set_empty\n"
"The empty character set.\n"
"@end defvr"
msgstr ""

#: api-data.texi:2868
msgid ""
"@defvr {Scheme Variable} char-set:designated\n"
"@defvrx {C Variable} scm_char_set_designated\n"
"This character set contains all designated code points.  This includes\n"
"all the code points to which Unicode has assigned a character or other\n"
"meaning.\n"
"@end defvr"
msgstr ""

#: api-data.texi:2874
msgid ""
"@defvr {Scheme Variable} char-set:full\n"
"@defvrx {C Variable} scm_char_set_full\n"
"This character set contains all possible code points.  This includes\n"
"both designated and reserved code points.\n"
"@end defvr"
msgstr ""

#: api-data.texi:2878
msgid ""
"@node Strings\n"
"@subsection Strings\n"
"@tpindex Strings"
msgstr ""

#: api-data.texi:2882
msgid ""
"Strings are fixed-length sequences of characters.  They can be created\n"
"by calling constructor procedures, but they can also literally get\n"
"entered at the @acronym{REPL} or in Scheme source files."
msgstr ""
"Строки представляют собой последовательности символов фиксированной длины.\n"
"Они могут быть созданы путем вызова процедуры конструктора, но они так же \n"
"могут непосредственно вводиться в REPL или размещаться в исходных файлах\n"
"Scheme."

#: api-data.texi:2885
msgid ""
"@c Guile provides a rich set of string processing procedures, because text\n"
"@c handling is very important when Guile is used as a scripting language."
msgstr ""

#: api-data.texi:2890
msgid ""
"Strings always carry the information about how many characters they are\n"
"composed of with them, so there is no special end-of-string character,\n"
"like in C.  That means that Scheme strings can contain any character,\n"
"even the @samp{#\\nul} character @samp{\\0}."
msgstr ""
"Строки всегда содержат информацию о том, сколько символов они содержат,\n"
"поэтому нет специального симовола конца строки, как например в Си. Это\n"
"означает, что Scheme строки могут содержать любой символ, даже \n"
"@samp{#\\nul}  @samp{\\0}."

#: api-data.texi:2897
msgid ""
"To use strings efficiently, you need to know a bit about how Guile\n"
"implements them.  In Guile, a string consists of two parts, a head and\n"
"the actual memory where the characters are stored.  When a string (or\n"
"a substring of it) is copied, only a new head gets created, the memory\n"
"is usually not copied.  The two heads start out pointing to the same\n"
"memory."
msgstr ""
"Чтобы эффективно использовать строки, вам нужно немного узнать о том,\n"
"как Guile их реализует. В Guile, строка состоит из двух частей, головы\n"
"и выделенной памяти, где фактически хранятся символы. Когда копируется\n"
"строка(или ее подстрока), создается только новый заголовок, память\n"
"обычно не копируется. Два заголовка начинают указывать на одну и туже\n"
"память."

#: api-data.texi:2903
msgid ""
"When one of these two strings is modified, as with @code{string-set!},\n"
"their common memory does get copied so that each string has its own\n"
"memory and modifying one does not accidentally modify the other as well.\n"
"Thus, Guile's strings are `copy on write'; the actual copying of their\n"
"memory is delayed until one string is written to."
msgstr ""
"Когда одна из этих двух строк изменяется, например вызовом @code{string-"
"set!}\n"
"их общая память копируется так, что каждая строка получает свою копию\n"
"собственной памяти и модификация не может случайно изменить другие строки.\n"
"Таким образом, строки Guile являются \"копируемыми при записи\"; Настоящее\n"
"копирование их памяти задерживается до тех пор, пока не будет изменена "
"какая\n"
"либо из строк."

#: api-data.texi:2907
msgid ""
"This implementation makes functions like @code{substring} very\n"
"efficient in the common case that no modifications are done to the\n"
"involved strings."
msgstr ""
"Эта реализация делает такие функции, как @code{substring} очень\n"
"эффективными в общем случаее когда никаких изменений используемых\n"
"строк не производиться."

#: api-data.texi:2915
msgid ""
"If you do know that your strings are getting modified right away, you\n"
"can use @code{substring/copy} instead of @code{substring}.  This\n"
"function performs the copy immediately at the time of creation.  This\n"
"is more efficient, especially in a multi-threaded program.  Also,\n"
"@code{substring/copy} can avoid the problem that a short substring\n"
"holds on to the memory of a very large original string that could\n"
"otherwise be recycled."
msgstr ""
"Если вы знаете, что ваши строки сразу изменяются, вы можете использовать\n"
"@code{substring/copy} вместо @code{substring}. Эта функция немедленно\n"
"выполняет копию во время создания подстроки. Это более эффективно, особенно\n"
"в многопоточной программе. Также @code{substring/copy} поможет избежать\n"
"проблемы, заключающейся в том, что короткая подстрока сохраняется в памяти\n"
"очень большой оригинальной строки, которую в противном случае можно было бы\n"
"повторно использовать."

#: api-data.texi:2921
msgid ""
"If you want to avoid the copy altogether, so that modifications of one\n"
"string show up in the other, you can use @code{substring/shared}.  The\n"
"strings created by this procedure are called @dfn{mutation sharing\n"
"substrings} since the substring and the original string share\n"
"modifications to each other."
msgstr ""
"Если вы хотите полностью отказаться от копирования, что бы изменения\n"
"одной строки отображались в другой, вы можете использовать функцию\n"
"@code{substring/shared}. Строки созданные процедурой, называются\n"
"изменяющимися разделяемыми строками, которые меняются при модификации\n"
"каждой из строк."

#: api-data.texi:2923
msgid "If you want to prevent modifications, use @code{substring/read-only}."
msgstr ""
"Если вы хотите предотвратить изменения, используйте вызов\n"
"@code{substring/read-only}."

#: api-data.texi:2925
msgid "Guile provides all procedures of SRFI-13 and a few more."
msgstr "Guile предоставляет все процедуры SRFI-13 и еще несколько."

#: api-data.texi:2943
msgid ""
"@menu\n"
"* String Syntax::                   Read syntax for strings.\n"
"* String Predicates::               Testing strings for certain properties.\n"
"* String Constructors::             Creating new string objects.\n"
"* List/String Conversion::          Converting from/to lists of characters.\n"
"* String Selection::                Select portions from strings.\n"
"* String Modification::             Modify parts or whole strings.\n"
"* String Comparison::               Lexicographic ordering predicates.\n"
"* String Searching::                Searching in strings.\n"
"* Alphabetic Case Mapping::         Convert the alphabetic case of strings.\n"
"* Reversing and Appending Strings:: Appending strings to form a new string.\n"
"* Mapping Folding and Unfolding::   Iterating over strings.\n"
"* Miscellaneous String Operations:: Replicating, insertion, parsing, ...\n"
"* Representing Strings as Bytes::   Encoding and decoding strings.\n"
"* Conversion to/from C::\n"
"* String Internals::                The storage strategy for strings.\n"
"@end menu"
msgstr ""

#: api-data.texi:2946
msgid ""
"@node String Syntax\n"
"@subsubsection String Read Syntax"
msgstr ""

#: api-data.texi:2951
msgid ""
"@c  In the following @code is used to get a good font in TeX etc, but\n"
"@c  is omitted for Info format, so as not to risk any confusion over\n"
"@c  whether surrounding ` ' quotes are part of the escape or are\n"
"@c  special in a string (they're not)."
msgstr ""

#: api-data.texi:2954
msgid ""
"The read syntax for strings is an arbitrarily long sequence of\n"
"characters enclosed in double quotes (@nicode{\"})."
msgstr ""
"Синтаксис чтения строк - это произвольно длинная последовательность\n"
"символов, заключенных в двойные кавычки(@nicode{\"})."

#: api-data.texi:2960
msgid ""
"Backslash is an escape character and can be used to insert the following\n"
"special characters.  @nicode{\\\"} and @nicode{\\\\} are R5RS standard,\n"
"@nicode{\\|} is R7RS standard, the next seven are R6RS standard ---\n"
"notice they follow C syntax --- and the remaining four are Guile\n"
"extensions."
msgstr ""
"Обратная косая черта это символ экранирования и может использоваться\n"
"для вставки следующих специальных символов. @nicode{\\\"} и @nicode{\\\\}\n"
"в соответсвии со стандартом R5RS, @nicode{\\|} по стандарту R7RS,\n"
"следующие за ними 7 символов по стандарту R6RS --- обратите внимание\n"
"они следуют Си синтаксису, а остальные 4 --- Guile расширения."

#: api-data.texi:2964
msgid ""
"@table @asis\n"
"@item @nicode{\\\\}\n"
"Backslash character."
msgstr ""

#: api-data.texi:2968
msgid ""
"@item @nicode{\\\"}\n"
"Double quote character (an unescaped @nicode{\"} is otherwise the end\n"
"of the string)."
msgstr ""

#: api-data.texi:2971
msgid ""
"@item @nicode{\\|}\n"
"Vertical bar character."
msgstr ""

#: api-data.texi:2974
msgid ""
"@item @nicode{\\a}\n"
"Bell character (ASCII 7)."
msgstr ""

#: api-data.texi:2977
msgid ""
"@item @nicode{\\f}\n"
"Formfeed character (ASCII 12)."
msgstr ""

#: api-data.texi:2980
msgid ""
"@item @nicode{\\n}\n"
"Newline character (ASCII 10)."
msgstr ""

#: api-data.texi:2983
msgid ""
"@item @nicode{\\r}\n"
"Carriage return character (ASCII 13)."
msgstr ""

#: api-data.texi:2986
msgid ""
"@item @nicode{\\t}\n"
"Tab character (ASCII 9)."
msgstr ""

#: api-data.texi:2989
msgid ""
"@item @nicode{\\v}\n"
"Vertical tab character (ASCII 11)."
msgstr ""

#: api-data.texi:2992
msgid ""
"@item @nicode{\\b}\n"
"Backspace character (ASCII 8)."
msgstr ""

#: api-data.texi:2995
msgid ""
"@item @nicode{\\0}\n"
"NUL character (ASCII 0)."
msgstr ""

#: api-data.texi:2999
msgid ""
"@item @nicode{\\(}\n"
"Open parenthesis.  This is intended for use at the beginning of lines in\n"
"multiline strings to avoid confusing Emacs lisp modes."
msgstr ""
"@item @nicode{\\(}\n"
"Открывающая скобка. Этот символ предназначен для использования в начале\n"
"строк в многострочной строке, чтобы избежать путаницы режимов в Emacs lisp."

#: api-data.texi:3004
msgid ""
"@item @nicode{\\} followed by newline (ASCII 10)\n"
"Nothing.  This way if @nicode{\\} is the last character in a line, the\n"
"string will continue with the first character from the next line,\n"
"without a line break."
msgstr ""
"@item @nicode{\\} следует новая линия (ASCII 10)\n"
"Ничего.  Таким образом, если @nicode{\\} это последний символ в строке,\n"
"строка будет продолжена с первым символом из следующей строки\n"
"без разрыва строки.\n"

#: api-data.texi:3007
msgid ""
"If the @code{hungry-eol-escapes} reader option is enabled, which is not\n"
"the case by default, leading whitespace on the next line is discarded."
msgstr ""
"Если включен режим чтения @code{hungry-eol-escapes}, что не соотвествует\n"
"умолчанию, начальные пробелы на следующей строке отбрасываются."

#: api-data.texi:3020
msgid ""
"@lisp\n"
"\"foo\\\n"
"  bar\"\n"
"@result{} \"foo  bar\"\n"
"(read-enable 'hungry-eol-escapes)\n"
"\"foo\\\n"
"  bar\"\n"
"@result{} \"foobar\"\n"
"@end lisp\n"
"@item @nicode{\\xHH}\n"
"Character code given by two hexadecimal digits.  For example\n"
"@nicode{\\x7f} for an ASCII DEL (127)."
msgstr ""

#: api-data.texi:3024
msgid ""
"@item @nicode{\\uHHHH}\n"
"Character code given by four hexadecimal digits.  For example\n"
"@nicode{\\u0100} for a capital A with macron (U+0100)."
msgstr ""

#: api-data.texi:3029
msgid ""
"@item @nicode{\\UHHHHHH}\n"
"Character code given by six hexadecimal digits.  For example\n"
"@nicode{\\U010402}.\n"
"@end table"
msgstr ""

#: api-data.texi:3032
msgid ""
"@noindent\n"
"The following are examples of string literals:"
msgstr ""

#: api-data.texi:3039
msgid ""
"@lisp\n"
"\"foo\"\n"
"\"bar plonk\"\n"
"\"Hello World\"\n"
"\"\\\"Hi\\\", he said.\"\n"
"@end lisp"
msgstr ""

#: api-data.texi:3046
msgid ""
"The three escape sequences @code{\\xHH}, @code{\\uHHHH} and @code{\\UHHHHHH} "
"were\n"
"chosen to not break compatibility with code written for previous versions "
"of\n"
"Guile.  The R6RS specification suggests a different, incompatible syntax for "
"hex\n"
"escapes: @code{\\xHHHH;} -- a character code followed by one to eight "
"hexadecimal\n"
"digits terminated with a semicolon.  If this escape format is desired "
"instead,\n"
"it can be enabled with the reader option @code{r6rs-hex-escapes}."
msgstr ""
"Три эскейп последовательности @code{\\xHH}, @code{\\uHHHH} и "
"@code{\\UHHHHHH} были\n"
"выбраны так, чтобы не нарушать совместимость с кодом, написанным для "
"предыдущих\n"
"версий Guile.  Спецификация R6RS предлагает другой, несовместимый синтаксис "
"для\n"
"экранирования шестнадцатеричных символов: @code{\\xHHHH;} -- код символа, за "
"которым\n"
"следуют от одной до восьми шестнадцатеричных цифр, заканчивающихся\n"
"точкой с запятой. Если вам надо использовать этот формат для функции чтения, "
"его\n"
"можно включить с помощью опции @code{r6rs-hex-escapes}."

#: api-data.texi:3050
msgid ""
"@lisp\n"
"(read-enable 'r6rs-hex-escapes)\n"
"@end lisp"
msgstr ""

#: api-data.texi:3052
msgid "For more on reader options, @xref{Scheme Read}."
msgstr ""

#: api-data.texi:3055
msgid ""
"@node String Predicates\n"
"@subsubsection String Predicates"
msgstr ""
"@node String Predicates\n"
"@subsubsection Строковые Предикаты"

#: api-data.texi:3058
msgid ""
"The following procedures can be used to check whether a given string\n"
"fulfills some specified property."
msgstr ""
"Следующие процедуры могут использваться для проверки того, соответствует\n"
"ли данная строка некоторым определенным свойствам."

#: api-data.texi:3064
msgid ""
"@rnindex string?\n"
"@deffn {Scheme Procedure} string? obj\n"
"@deffnx {C Function} scm_string_p (obj)\n"
"Return @code{#t} if @var{obj} is a string, else @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3068
msgid ""
"@deftypefn {C Function} int scm_is_string (SCM obj)\n"
"Returns @code{1} if @var{obj} is a string, @code{0} otherwise.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:3079
msgid ""
"@deffn {Scheme Procedure} string-null? str\n"
"@deffnx {C Function} scm_string_null_p (str)\n"
"Return @code{#t} if @var{str}'s length is zero, and\n"
"@code{#f} otherwise.\n"
"@lisp\n"
"(string-null? \"\")  @result{} #t\n"
"y                    @result{} \"foo\"\n"
"(string-null? y)     @result{} #f\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:3083
msgid ""
"@deffn {Scheme Procedure} string-any char_pred s [start [end]]\n"
"@deffnx {C Function} scm_string_any (char_pred, s, start, end)\n"
"Check if @var{char_pred} is true for any character in string @var{s}."
msgstr ""

#: api-data.texi:3087
msgid ""
"@var{char_pred} can be a character to check for any equal to that, or\n"
"a character set (@pxref{Character Sets}) to check for any in that set,\n"
"or a predicate procedure to call."
msgstr ""

#: api-data.texi:3094
msgid ""
"For a procedure, calls @code{(@var{char_pred} c)} are made\n"
"successively on the characters from @var{start} to @var{end}.  If\n"
"@var{char_pred} returns true (ie.@: non-@code{#f}), @code{string-any}\n"
"stops and that return value is the return from @code{string-any}.  The\n"
"call on the last character (ie.@: at @math{@var{end}-1}), if that\n"
"point is reached, is a tail call."
msgstr ""

#: api-data.texi:3098
msgid ""
"If there are no characters in @var{s} (ie.@: @var{start} equals\n"
"@var{end}) then the return is @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3103
msgid ""
"@deffn {Scheme Procedure} string-every char_pred s [start [end]]\n"
"@deffnx {C Function} scm_string_every (char_pred, s, start, end)\n"
"Check if @var{char_pred} is true for every character in string\n"
"@var{s}."
msgstr ""

#: api-data.texi:3107
msgid ""
"@var{char_pred} can be a character to check for every character equal\n"
"to that, or a character set (@pxref{Character Sets}) to check for\n"
"every character being in that set, or a predicate procedure to call."
msgstr ""

#: api-data.texi:3114
msgid ""
"For a procedure, calls @code{(@var{char_pred} c)} are made\n"
"successively on the characters from @var{start} to @var{end}.  If\n"
"@var{char_pred} returns @code{#f}, @code{string-every} stops and\n"
"returns @code{#f}.  The call on the last character (ie.@: at\n"
"@math{@var{end}-1}), if that point is reached, is a tail call and the\n"
"return from that call is the return from @code{string-every}."
msgstr ""

#: api-data.texi:3118
msgid ""
"If there are no characters in @var{s} (ie.@: @var{start} equals\n"
"@var{end}) then the return is @code{#t}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3121
msgid ""
"@node String Constructors\n"
"@subsubsection String Constructors"
msgstr ""
"@node String Constructors\n"
"@subsubsection Конструкторы Строк"

#: api-data.texi:3126
msgid ""
"The string constructor procedures create new string objects, possibly\n"
"initializing them with some specified character data.  See also\n"
"@xref{String Selection}, for ways to create strings from existing\n"
"strings."
msgstr ""
"Процедуры создания строк создают новые строковые объекты, повозможности\n"
"инициализируя их некоторыми заданными символьными данными.  Смотри также\n"
"@xref{String Selection}, для ознакомления со способами создания строк\n"
"из существующих строк."

#: api-data.texi:3128
msgid "@c FIXME::martin: list->string belongs into `List/String Conversion'"
msgstr ""

#: api-data.texi:3133
msgid ""
"@deffn {Scheme Procedure} string char@dots{}\n"
"@rnindex string\n"
"Return a newly allocated string made from the given character\n"
"arguments."
msgstr ""

#: api-data.texi:3139
msgid ""
"@example\n"
"(string #\\x #\\y #\\z) @result{} \"xyz\"\n"
"(string)             @result{} \"\"\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:3144
msgid ""
"@deffn {Scheme Procedure} list->string lst\n"
"@deffnx {C Function} scm_string (lst)\n"
"@rnindex list->string\n"
"Return a newly allocated string made from a list of characters."
msgstr ""

#: api-data.texi:3149
msgid ""
"@example\n"
"(list->string '(#\\a #\\b #\\c)) @result{} \"abc\"\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:3154
msgid ""
"@deffn {Scheme Procedure} reverse-list->string lst\n"
"@deffnx {C Function} scm_reverse_list_to_string (lst)\n"
"Return a newly allocated string made from a list of characters, in\n"
"reverse order."
msgstr ""

#: api-data.texi:3159
msgid ""
"@example\n"
"(reverse-list->string '(#\\a #\\B #\\c)) @result{} \"cBa\"\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:3168
msgid ""
"@rnindex make-string\n"
"@deffn {Scheme Procedure} make-string k [chr]\n"
"@deffnx {C Function} scm_make_string (k, chr)\n"
"Return a newly allocated string of\n"
"length @var{k}.  If @var{chr} is given, then all elements of\n"
"the string are initialized to @var{chr}, otherwise the contents\n"
"of the string are unspecified.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3173
msgid ""
"@deftypefn {C Function} SCM scm_c_make_string (size_t len, SCM chr)\n"
"Like @code{scm_make_string}, but expects the length as a\n"
"@code{size_t}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:3181
msgid ""
"@deffn {Scheme Procedure} string-tabulate proc len\n"
"@deffnx {C Function} scm_string_tabulate (proc, len)\n"
"@var{proc} is an integer->char procedure.  Construct a string\n"
"of size @var{len} by applying @var{proc} to each index to\n"
"produce the corresponding string element.  The order in which\n"
"@var{proc} is applied to the indices is not specified.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3189
msgid ""
"@deffn {Scheme Procedure} string-join ls [delimiter [grammar]]\n"
"@deffnx {C Function} scm_string_join (ls, delimiter, grammar)\n"
"Append the string in the string list @var{ls}, using the string\n"
"@var{delimiter} as a delimiter between the elements of @var{ls}.\n"
"@var{grammar} is a symbol which specifies how the delimiter is\n"
"placed between the strings, and defaults to the symbol\n"
"@code{infix}."
msgstr ""

#: api-data.texi:3203
msgid ""
"@table @code\n"
"@item infix\n"
"Insert the separator between list elements.  An empty string\n"
"will produce an empty list.\n"
"@item strict-infix\n"
"Like @code{infix}, but will raise an error if given the empty\n"
"list.\n"
"@item suffix\n"
"Insert the separator after every list element.\n"
"@item prefix\n"
"Insert the separator before each list element.\n"
"@end table\n"
"@end deffn"
msgstr ""

#: api-data.texi:3206
msgid ""
"@node List/String Conversion\n"
"@subsubsection List/String conversion"
msgstr ""
"@node List/String Conversion\n"
"@subsubsection Преобразование Список/Строка"

#: api-data.texi:3211
msgid ""
"When processing strings, it is often convenient to first convert them\n"
"into a list representation by using the procedure @code{string->list},\n"
"work with the resulting list, and then convert it back into a string.\n"
"These procedures are useful for similar tasks."
msgstr ""
"При обработке строк часто бывает удобно сначала перобразовать их в \n"
"представление списка с помощью процедуры @code{string->list},\n"
"работать с результирующим списком, а затем преобразовать его обратно\n"
"в строку. Эти процедуры полезны для подобных задач."

#: api-data.texi:3218
msgid ""
"@rnindex string->list\n"
"@deffn {Scheme Procedure} string->list str [start [end]]\n"
"@deffnx {C Function} scm_substring_to_list (str, start, end)\n"
"@deffnx {C Function} scm_string_to_list (str)\n"
"Convert the string @var{str} into a list of characters.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3223
msgid ""
"@deffn {Scheme Procedure} string-split str char_pred\n"
"@deffnx {C Function} scm_string_split (str, char_pred)\n"
"Split the string @var{str} into a list of substrings delimited\n"
"by appearances of characters that"
msgstr ""

#: api-data.texi:3227
msgid ""
"@itemize @bullet\n"
"@item\n"
"equal @var{char_pred}, if it is a character,"
msgstr ""

#: api-data.texi:3230
msgid ""
"@item\n"
"satisfy the predicate @var{char_pred}, if it is a procedure,"
msgstr ""

#: api-data.texi:3234
msgid ""
"@item\n"
"are in the set @var{char_pred}, if it is a character set.\n"
"@end itemize"
msgstr ""

#: api-data.texi:3237
msgid ""
"Note that an empty substring between separator characters will result in\n"
"an empty string in the result list."
msgstr ""

#: api-data.texi:3242
msgid ""
"@lisp\n"
"(string-split \"root:x:0:0:root:/root:/bin/bash\" #\\:)\n"
"@result{}\n"
"(\"root\" \"x\" \"0\" \"0\" \"root\" \"/root\" \"/bin/bash\")"
msgstr ""

#: api-data.texi:3246
msgid ""
"(string-split \"::\" #\\:)\n"
"@result{}\n"
"(\"\" \"\" \"\")"
msgstr ""

#: api-data.texi:3252
msgid ""
"(string-split \"\" #\\:)\n"
"@result{}\n"
"(\"\")\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:3256
msgid ""
"@node String Selection\n"
"@subsubsection String Selection"
msgstr ""
"@node String Selection\n"
"@subsubsection Строковые Селекторы"

#: api-data.texi:3260
msgid ""
"Portions of strings can be extracted by these procedures.\n"
"@code{string-ref} delivers individual characters whereas\n"
"@code{substring} can be used to extract substrings from longer strings."
msgstr ""
"Этими процедурами могут быть извлечены части строк. \n"
"@code{string-ref} предоставляет индивидуальне символы, в то время как\n"
"@code{substring} можно использовать для извлечения подстрок из более\n"
"длинных строк."

#: api-data.texi:3266
msgid ""
"@rnindex string-length\n"
"@deffn {Scheme Procedure} string-length string\n"
"@deffnx {C Function} scm_string_length (string)\n"
"Return the number of characters in @var{string}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3270
msgid ""
"@deftypefn {C Function} size_t scm_c_string_length (SCM str)\n"
"Return the number of characters in @var{str} as a @code{size_t}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:3277
msgid ""
"@rnindex string-ref\n"
"@deffn {Scheme Procedure} string-ref str k\n"
"@deffnx {C Function} scm_string_ref (str, k)\n"
"Return character @var{k} of @var{str} using zero-origin\n"
"indexing. @var{k} must be a valid index of @var{str}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3282
msgid ""
"@deftypefn {C Function} SCM scm_c_string_ref (SCM str, size_t k)\n"
"Return character @var{k} of @var{str} using zero-origin\n"
"indexing. @var{k} must be a valid index of @var{str}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:3288
msgid ""
"@rnindex string-copy\n"
"@deffn {Scheme Procedure} string-copy str [start [end]]\n"
"@deffnx {C Function} scm_substring_copy (str, start, end)\n"
"@deffnx {C Function} scm_string_copy (str)\n"
"Return a copy of the given string @var{str}."
msgstr ""

#: api-data.texi:3292
msgctxt "api-data.texi:3292"
msgid ""
"The returned string shares storage with @var{str} initially, but it is\n"
"copied as soon as one of the two strings is modified.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3301
msgid ""
"@rnindex substring\n"
"@deffn {Scheme Procedure} substring str start [end]\n"
"@deffnx {C Function} scm_substring (str, start, end)\n"
"Return a new string formed from the characters\n"
"of @var{str} beginning with index @var{start} (inclusive) and\n"
"ending with index @var{end} (exclusive).\n"
"@var{str} must be a string, @var{start} and @var{end} must be\n"
"exact integers satisfying:"
msgstr ""

#: api-data.texi:3303
msgid "0 <= @var{start} <= @var{end} <= @code{(string-length @var{str})}."
msgstr ""

#: api-data.texi:3307
msgctxt "api-data.texi:3307"
msgid ""
"The returned string shares storage with @var{str} initially, but it is\n"
"copied as soon as one of the two strings is modified.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3314
msgid ""
"@deffn {Scheme Procedure} substring/shared str start [end]\n"
"@deffnx {C Function} scm_substring_shared (str, start, end)\n"
"Like @code{substring}, but the strings continue to share their storage\n"
"even if they are modified.  Thus, modifications to @var{str} show up\n"
"in the new string, and vice versa.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3320
msgid ""
"@deffn {Scheme Procedure} substring/copy str start [end]\n"
"@deffnx {C Function} scm_substring_copy (str, start, end)\n"
"Like @code{substring}, but the storage for the new string is copied\n"
"immediately.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3325
msgid ""
"@deffn {Scheme Procedure} substring/read-only str start [end]\n"
"@deffnx {C Function} scm_substring_read_only (str, start, end)\n"
"Like @code{substring}, but the resulting string can not be modified.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3332
msgid ""
"@deftypefn  {C Function} SCM scm_c_substring (SCM str, size_t start, size_t "
"end)\n"
"@deftypefnx {C Function} SCM scm_c_substring_shared (SCM str, size_t start, "
"size_t end)\n"
"@deftypefnx {C Function} SCM scm_c_substring_copy (SCM str, size_t start, "
"size_t end)\n"
"@deftypefnx {C Function} SCM scm_c_substring_read_only (SCM str, size_t "
"start, size_t end)\n"
"Like @code{scm_substring}, etc. but the bounds are given as a "
"@code{size_t}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:3337
msgid ""
"@deffn {Scheme Procedure} string-take s n\n"
"@deffnx {C Function} scm_string_take (s, n)\n"
"Return the @var{n} first characters of @var{s}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3342
msgid ""
"@deffn {Scheme Procedure} string-drop s n\n"
"@deffnx {C Function} scm_string_drop (s, n)\n"
"Return all but the first @var{n} characters of @var{s}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3347
msgid ""
"@deffn {Scheme Procedure} string-take-right s n\n"
"@deffnx {C Function} scm_string_take_right (s, n)\n"
"Return the @var{n} last characters of @var{s}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3352
msgid ""
"@deffn {Scheme Procedure} string-drop-right s n\n"
"@deffnx {C Function} scm_string_drop_right (s, n)\n"
"Return all but the last @var{n} characters of @var{s}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3360
msgid ""
"@deffn {Scheme Procedure} string-pad s len [chr [start [end]]]\n"
"@deffnx {Scheme Procedure} string-pad-right s len [chr [start [end]]]\n"
"@deffnx {C Function} scm_string_pad (s, len, chr, start, end)\n"
"@deffnx {C Function} scm_string_pad_right (s, len, chr, start, end)\n"
"Take characters @var{start} to @var{end} from the string @var{s} and\n"
"either pad with @var{chr} or truncate them to give @var{len}\n"
"characters."
msgstr ""

#: api-data.texi:3362
msgid "@code{string-pad} pads or truncates on the left, so for example"
msgstr ""

#: api-data.texi:3367
msgid ""
"@example\n"
"(string-pad \"x\" 3)     @result{} \"  x\"\n"
"(string-pad \"abcde\" 3) @result{} \"cde\"\n"
"@end example"
msgstr ""

#: api-data.texi:3369
msgid "@code{string-pad-right} pads or truncates on the right, so for example"
msgstr ""

#: api-data.texi:3375
msgid ""
"@example\n"
"(string-pad-right \"x\" 3)     @result{} \"x  \"\n"
"(string-pad-right \"abcde\" 3) @result{} \"abc\"\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:3383
msgid ""
"@deffn {Scheme Procedure} string-trim s [char_pred [start [end]]]\n"
"@deffnx {Scheme Procedure} string-trim-right s [char_pred [start [end]]]\n"
"@deffnx {Scheme Procedure} string-trim-both s [char_pred [start [end]]]\n"
"@deffnx {C Function} scm_string_trim (s, char_pred, start, end)\n"
"@deffnx {C Function} scm_string_trim_right (s, char_pred, start, end)\n"
"@deffnx {C Function} scm_string_trim_both (s, char_pred, start, end)\n"
"Trim occurrences of @var{char_pred} from the ends of @var{s}."
msgstr ""

#: api-data.texi:3388
msgid ""
"@code{string-trim} trims @var{char_pred} characters from the left\n"
"(start) of the string, @code{string-trim-right} trims them from the\n"
"right (end) of the string, @code{string-trim-both} trims from both\n"
"ends."
msgstr ""

#: api-data.texi:3393
msgid ""
"@var{char_pred} can be a character, a character set, or a predicate\n"
"procedure to call on each character.  If @var{char_pred} is not given\n"
"the default is whitespace as per @code{char-set:whitespace}\n"
"(@pxref{Standard Character Sets})."
msgstr ""

#: api-data.texi:3405
msgid ""
"@example\n"
"(string-trim \" x \")              @result{} \"x \"\n"
"(string-trim-right \"banana\" #\\a) @result{} \"banan\"\n"
"(string-trim-both \".,xy:;\" char-set:punctuation)\n"
"                  @result{} \"xy\"\n"
"(string-trim-both \"xyzzy\" (lambda (c)\n"
"                             (or (eqv? c #\\x)\n"
"                                 (eqv? c #\\y))))\n"
"                  @result{} \"zz\"\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:3408
msgid ""
"@node String Modification\n"
"@subsubsection String Modification"
msgstr ""
"@node String Modification\n"
"@subsubsection Модификация Строк"

#: api-data.texi:3412
msgid ""
"These procedures are for modifying strings in-place.  This means that the\n"
"result of the operation is not a new string; instead, the original string's\n"
"memory representation is modified."
msgstr ""
"Эти процедуры предназначены для изменения строк на месте. Это означает, что\n"
"результат операции является не новой строкой; вместо этого изменяется \n"
"представление памяти исходной строки."

#: api-data.texi:3420
msgid ""
"@rnindex string-set!\n"
"@deffn {Scheme Procedure} string-set! str k chr\n"
"@deffnx {C Function} scm_string_set_x (str, k, chr)\n"
"Store @var{chr} in element @var{k} of @var{str} and return\n"
"an unspecified value. @var{k} must be a valid index of\n"
"@var{str}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3424
msgid ""
"@deftypefn {C Function} void scm_c_string_set_x (SCM str, size_t k, SCM "
"chr)\n"
"Like @code{scm_string_set_x}, but the index is given as a @code{size_t}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:3432
msgid ""
"@rnindex string-fill!\n"
"@deffn {Scheme Procedure} string-fill! str chr [start [end]]\n"
"@deffnx {C Function} scm_substring_fill_x (str, chr, start, end)\n"
"@deffnx {C Function} scm_string_fill_x (str, chr)\n"
"Stores @var{chr} in every element of the given @var{str} and\n"
"returns an unspecified value.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3437
msgid ""
"@deffn {Scheme Procedure} substring-fill! str start end fill\n"
"@deffnx {C Function} scm_substring_fill_x (str, start, end, fill)\n"
"Change every character in @var{str} between @var{start} and\n"
"@var{end} to @var{fill}."
msgstr ""

#: api-data.texi:3445
msgid ""
"@lisp\n"
"(define y (string-copy \"abcdefg\"))\n"
"(substring-fill! y 1 3 #\\r)\n"
"y\n"
"@result{} \"arrdefg\"\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:3452
msgid ""
"@deffn {Scheme Procedure} substring-move! str1 start1 end1 str2 start2\n"
"@deffnx {C Function} scm_substring_move_x (str1, start1, end1, str2, "
"start2)\n"
"Copy the substring of @var{str1} bounded by @var{start1} and @var{end1}\n"
"into @var{str2} beginning at position @var{start2}.\n"
"@var{str1} and @var{str2} can be the same string.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3463
msgid ""
"@deffn {Scheme Procedure} string-copy! target tstart s [start [end]]\n"
"@deffnx {C Function} scm_string_copy_x (target, tstart, s, start, end)\n"
"Copy the sequence of characters from index range [@var{start},\n"
"@var{end}) in string @var{s} to string @var{target}, beginning\n"
"at index @var{tstart}.  The characters are copied left-to-right\n"
"or right-to-left as needed -- the copy is guaranteed to work,\n"
"even if @var{target} and @var{s} are the same string.  It is an\n"
"error if the copy operation runs off the end of the target\n"
"string.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3467
msgid ""
"@node String Comparison\n"
"@subsubsection String Comparison"
msgstr ""
"@node String Comparison\n"
"@subsubsection Сравнение строк"

#: api-data.texi:3470
msgid ""
"The procedures in this section are similar to the character ordering\n"
"predicates (@pxref{Characters}), but are defined on character sequences."
msgstr ""
"Процедуры в этом разделе аналогичны предиката используемым для сравнения\n"
"символов (@pxref{Characters}), но определены на последовательностях\n"
"символов."

#: api-data.texi:3474
msgid ""
"The first set is specified in R5RS and has names that end in @code{?}.\n"
"The second set is specified in SRFI-13 and the names have not ending\n"
"@code{?}."
msgstr ""
"Первый набор указан в R5RS и имеет имена, которые заканчиваются @code{?}.\n"
"Второй набор указан в SRFI-13 и его имена не заканчиваюься @code{?}."

#: api-data.texi:3481
msgid ""
"The predicates ending in @code{-ci} ignore the character case\n"
"when comparing strings.  For now, case-insensitive comparison is done\n"
"using the R5RS rules, where every lower-case character that has a\n"
"single character upper-case form is converted to uppercase before\n"
"comparison.  See @xref{Text Collation, the @code{(ice-9\n"
"i18n)} module}, for locale-dependent string comparison."
msgstr ""
"Предикаты, заканчивающиеся на @code{-ci} игнорируют регистр символов\n"
"когда сравнивают строки.  На данный момент, сравнение без учета \n"
"регистра выполняется с использованием правил R5RS, где каждый\n"
"строчный символ который имеет одну форму в верхнем регистре\n"
"преобразуется в верхний регистр перед сравнением.  См.\n"
"@xref{Text Collation, the @code{(ice-9 i18n)} module}, \n"
"для сравнения строк, зависящих от локали."

#: api-data.texi:3487
msgid ""
"@rnindex string=?\n"
"@deffn {Scheme Procedure} string=? s1 s2 s3 @dots{}\n"
"Lexicographic equality predicate; return @code{#t} if all strings are\n"
"the same length and contain the same characters in the same positions,\n"
"otherwise return @code{#f}."
msgstr ""

#: api-data.texi:3493
msgid ""
"The procedure @code{string-ci=?} treats upper and lower case\n"
"letters as though they were the same character, but\n"
"@code{string=?} treats upper and lower case as distinct\n"
"characters.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3500
msgid ""
"@rnindex string<?\n"
"@deffn {Scheme Procedure} string<? s1 s2 s3 @dots{}\n"
"Lexicographic ordering predicate; return @code{#t} if, for every pair of\n"
"consecutive string arguments @var{str_i} and @var{str_i+1}, @var{str_i} is\n"
"lexicographically less than @var{str_i+1}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3507
msgid ""
"@rnindex string<=?\n"
"@deffn {Scheme Procedure} string<=? s1 s2 s3 @dots{}\n"
"Lexicographic ordering predicate; return @code{#t} if, for every pair of\n"
"consecutive string arguments @var{str_i} and @var{str_i+1}, @var{str_i} is\n"
"lexicographically less than or equal to @var{str_i+1}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3514
msgid ""
"@rnindex string>?\n"
"@deffn {Scheme Procedure} string>? s1 s2 s3 @dots{}\n"
"Lexicographic ordering predicate; return @code{#t} if, for every pair of\n"
"consecutive string arguments @var{str_i} and @var{str_i+1}, @var{str_i} is\n"
"lexicographically greater than @var{str_i+1}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3521
msgid ""
"@rnindex string>=?\n"
"@deffn {Scheme Procedure} string>=? s1 s2 s3 @dots{}\n"
"Lexicographic ordering predicate; return @code{#t} if, for every pair of\n"
"consecutive string arguments @var{str_i} and @var{str_i+1}, @var{str_i} is\n"
"lexicographically greater than or equal to @var{str_i+1}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3529
msgid ""
"@rnindex string-ci=?\n"
"@deffn {Scheme Procedure} string-ci=? s1 s2 s3 @dots{}\n"
"Case-insensitive string equality predicate; return @code{#t} if\n"
"all strings are the same length and their component\n"
"characters match (ignoring case) at each position; otherwise\n"
"return @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3537
msgid ""
"@rnindex string-ci<?\n"
"@deffn {Scheme Procedure} string-ci<? s1 s2 s3 @dots{}\n"
"Case insensitive lexicographic ordering predicate; return @code{#t} if,\n"
"for every pair of consecutive string arguments @var{str_i} and\n"
"@var{str_i+1}, @var{str_i} is lexicographically less than @var{str_i+1}\n"
"regardless of case.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3545
msgid ""
"@rnindex string<=?\n"
"@deffn {Scheme Procedure} string-ci<=? s1 s2 s3 @dots{}\n"
"Case insensitive lexicographic ordering predicate; return @code{#t} if,\n"
"for every pair of consecutive string arguments @var{str_i} and\n"
"@var{str_i+1}, @var{str_i} is lexicographically less than or equal to\n"
"@var{str_i+1} regardless of case.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3553
msgid ""
"@rnindex string-ci>?\n"
"@deffn {Scheme Procedure} string-ci>? s1 s2 s3 @dots{}\n"
"Case insensitive lexicographic ordering predicate; return @code{#t} if,\n"
"for every pair of consecutive string arguments @var{str_i} and\n"
"@var{str_i+1}, @var{str_i} is lexicographically greater than\n"
"@var{str_i+1} regardless of case.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3561
msgid ""
"@rnindex string-ci>=?\n"
"@deffn {Scheme Procedure} string-ci>=? s1 s2 s3 @dots{}\n"
"Case insensitive lexicographic ordering predicate; return @code{#t} if,\n"
"for every pair of consecutive string arguments @var{str_i} and\n"
"@var{str_i+1}, @var{str_i} is lexicographically greater than or equal to\n"
"@var{str_i+1} regardless of case.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3571
msgid ""
"@deffn {Scheme Procedure} string-compare s1 s2 proc_lt proc_eq proc_gt "
"[start1 [end1 [start2 [end2]]]]\n"
"@deffnx {C Function} scm_string_compare (s1, s2, proc_lt, proc_eq, proc_gt, "
"start1, end1, start2, end2)\n"
"Apply @var{proc_lt}, @var{proc_eq}, @var{proc_gt} to the\n"
"mismatch index, depending upon whether @var{s1} is less than,\n"
"equal to, or greater than @var{s2}.  The mismatch index is the\n"
"largest index @var{i} such that for every 0 <= @var{j} <\n"
"@var{i}, @var{s1}[@var{j}] = @var{s2}[@var{j}] -- that is,\n"
"@var{i} is the first position that does not match.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3581
msgid ""
"@deffn {Scheme Procedure} string-compare-ci s1 s2 proc_lt proc_eq proc_gt "
"[start1 [end1 [start2 [end2]]]]\n"
"@deffnx {C Function} scm_string_compare_ci (s1, s2, proc_lt, proc_eq, "
"proc_gt, start1, end1, start2, end2)\n"
"Apply @var{proc_lt}, @var{proc_eq}, @var{proc_gt} to the\n"
"mismatch index, depending upon whether @var{s1} is less than,\n"
"equal to, or greater than @var{s2}.  The mismatch index is the\n"
"largest index @var{i} such that for every 0 <= @var{j} <\n"
"@var{i}, @var{s1}[@var{j}] = @var{s2}[@var{j}] -- that is,\n"
"@var{i} is the first position where the lowercased letters \n"
"do not match."
msgstr ""

#: api-data.texi:3583
msgctxt "api-data.texi:3583"
msgid "@end deffn"
msgstr ""

#: api-data.texi:3589
msgid ""
"@deffn {Scheme Procedure} string= s1 s2 [start1 [end1 [start2 [end2]]]]\n"
"@deffnx {C Function} scm_string_eq (s1, s2, start1, end1, start2, end2)\n"
"Return @code{#f} if @var{s1} and @var{s2} are not equal, a true\n"
"value otherwise.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3595
msgid ""
"@deffn {Scheme Procedure} string<> s1 s2 [start1 [end1 [start2 [end2]]]]\n"
"@deffnx {C Function} scm_string_neq (s1, s2, start1, end1, start2, end2)\n"
"Return @code{#f} if @var{s1} and @var{s2} are equal, a true\n"
"value otherwise.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3601
msgid ""
"@deffn {Scheme Procedure} string< s1 s2 [start1 [end1 [start2 [end2]]]]\n"
"@deffnx {C Function} scm_string_lt (s1, s2, start1, end1, start2, end2)\n"
"Return @code{#f} if @var{s1} is greater or equal to @var{s2}, a\n"
"true value otherwise.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3607
msgid ""
"@deffn {Scheme Procedure} string> s1 s2 [start1 [end1 [start2 [end2]]]]\n"
"@deffnx {C Function} scm_string_gt (s1, s2, start1, end1, start2, end2)\n"
"Return @code{#f} if @var{s1} is less or equal to @var{s2}, a\n"
"true value otherwise.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3613
msgid ""
"@deffn {Scheme Procedure} string<= s1 s2 [start1 [end1 [start2 [end2]]]]\n"
"@deffnx {C Function} scm_string_le (s1, s2, start1, end1, start2, end2)\n"
"Return @code{#f} if @var{s1} is greater to @var{s2}, a true\n"
"value otherwise.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3619
msgid ""
"@deffn {Scheme Procedure} string>= s1 s2 [start1 [end1 [start2 [end2]]]]\n"
"@deffnx {C Function} scm_string_ge (s1, s2, start1, end1, start2, end2)\n"
"Return @code{#f} if @var{s1} is less to @var{s2}, a true value\n"
"otherwise.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3626
msgid ""
"@deffn {Scheme Procedure} string-ci= s1 s2 [start1 [end1 [start2 [end2]]]]\n"
"@deffnx {C Function} scm_string_ci_eq (s1, s2, start1, end1, start2, end2)\n"
"Return @code{#f} if @var{s1} and @var{s2} are not equal, a true\n"
"value otherwise.  The character comparison is done\n"
"case-insensitively.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3633
msgid ""
"@deffn {Scheme Procedure} string-ci<> s1 s2 [start1 [end1 [start2 [end2]]]]\n"
"@deffnx {C Function} scm_string_ci_neq (s1, s2, start1, end1, start2, end2)\n"
"Return @code{#f} if @var{s1} and @var{s2} are equal, a true\n"
"value otherwise.  The character comparison is done\n"
"case-insensitively.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3640
msgid ""
"@deffn {Scheme Procedure} string-ci< s1 s2 [start1 [end1 [start2 [end2]]]]\n"
"@deffnx {C Function} scm_string_ci_lt (s1, s2, start1, end1, start2, end2)\n"
"Return @code{#f} if @var{s1} is greater or equal to @var{s2}, a\n"
"true value otherwise.  The character comparison is done\n"
"case-insensitively.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3647
msgid ""
"@deffn {Scheme Procedure} string-ci> s1 s2 [start1 [end1 [start2 [end2]]]]\n"
"@deffnx {C Function} scm_string_ci_gt (s1, s2, start1, end1, start2, end2)\n"
"Return @code{#f} if @var{s1} is less or equal to @var{s2}, a\n"
"true value otherwise.  The character comparison is done\n"
"case-insensitively.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3654
msgid ""
"@deffn {Scheme Procedure} string-ci<= s1 s2 [start1 [end1 [start2 [end2]]]]\n"
"@deffnx {C Function} scm_string_ci_le (s1, s2, start1, end1, start2, end2)\n"
"Return @code{#f} if @var{s1} is greater to @var{s2}, a true\n"
"value otherwise.  The character comparison is done\n"
"case-insensitively.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3661
msgid ""
"@deffn {Scheme Procedure} string-ci>= s1 s2 [start1 [end1 [start2 [end2]]]]\n"
"@deffnx {C Function} scm_string_ci_ge (s1, s2, start1, end1, start2, end2)\n"
"Return @code{#f} if @var{s1} is less to @var{s2}, a true value\n"
"otherwise.  The character comparison is done\n"
"case-insensitively.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3666
msgid ""
"@deffn {Scheme Procedure} string-hash s [bound [start [end]]]\n"
"@deffnx {C Function} scm_substring_hash (s, bound, start, end)\n"
"Compute a hash value for @var{s}.  The optional argument @var{bound} is a "
"non-negative exact integer specifying the range of the hash function. A "
"positive value restricts the return value to the range [0,bound).\n"
"@end deffn"
msgstr ""

#: api-data.texi:3671
msgid ""
"@deffn {Scheme Procedure} string-hash-ci s [bound [start [end]]]\n"
"@deffnx {C Function} scm_substring_hash_ci (s, bound, start, end)\n"
"Compute a hash value for @var{s}.  The optional argument @var{bound} is a "
"non-negative exact integer specifying the range of the hash function. A "
"positive value restricts the return value to the range [0,bound).\n"
"@end deffn"
msgstr ""

#: api-data.texi:3681
msgid ""
"Because the same visual appearance of an abstract Unicode character can \n"
"be obtained via multiple sequences of Unicode characters, even the \n"
"case-insensitive string comparison functions described above may return\n"
"@code{#f} when presented with strings containing different \n"
"representations of the same character.  For example, the Unicode \n"
"character ``LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE'' can be \n"
"represented with a single character (U+1E69) or by the character ``LATIN\n"
"SMALL LETTER S'' (U+0073) followed by the combining marks ``COMBINING \n"
"DOT BELOW'' (U+0323) and ``COMBINING DOT ABOVE'' (U+0307)."
msgstr ""
"Поскольку один и тот же визуальный вид абстрактного символа Unicode может\n"
"быть получен через несколько последовательностей символов Unicode, даже\n"
"при сравнении строк без учета регистра, функции\n"
"описанные вышеe, могут возвращать  @code{#f} когда представлены строки,\n"
"содержащие разные представления одного и того же символа.  Например,\n"
"символ Unicode ``LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE'' может\n"
"быть представлен одним символом (U+1E69) или символом ``LATIN\n"
"SMALL LETTER S'' (U+0073), за которым следует комбинирующие метки "
"``COMBINING \n"
"DOT BELOW'' (U+0323) и ``COMBINING DOT ABOVE'' (U+0307)."

#: api-data.texi:3688
msgid ""
"For this reason, it is often desirable to ensure that the strings\n"
"to be compared are using a mutually consistent representation for every \n"
"character.  The Unicode standard defines two methods of normalizing the\n"
"contents of strings: Decomposition, which breaks composite characters \n"
"into a set of constituent characters with an ordering defined by the\n"
"Unicode Standard; and composition, which performs the converse."
msgstr ""
"По этой причине часто желательно обеспечить, чтобы сопоставляемые строки\n"
"использовали взаимно согласованное представление для каждого символа.\n"
"Стандарт Unicode  определяет два метода нормализации содержимого строк:\n"
"разложение, которое разбивает сотавные символы в набор составных символов\n"
"с упорядочением, определенным стандартом Unicode, и композицию, выполняющую\n"
"обратное преобразование."

#: api-data.texi:3694
msgid ""
"There are two decomposition operations.  ``Canonical decomposition'' \n"
"produces character sequences that share the same visual appearance as\n"
"the original characters, while ``compatibility decomposition'' produces\n"
"ones whose visual appearances may differ from the originals but which\n"
"represent the same abstract character."
msgstr ""
"Существуют две операции разложения. ``Каноническое разложение''\n"
"порождает последовательность символов, которые имеют тот же внешний\n"
"вид, что и исходные символы, тогда как ``Совместимое разложение''\n"
"производит такие последовательности, чьи визуальные отображения\n"
"могут отличаться от оригиналов, но которые представляют собой\n"
"абстрактный символ."

#: api-data.texi:3697
msgid ""
"These operations are encapsulated in the following set of normalization\n"
"forms:"
msgstr "Эти операции инкапсулируются в следующем набор нормализационных форм:"

#: api-data.texi:3701
msgid ""
"@table @dfn\n"
"@item NFD\n"
"Characters are decomposed to their canonical forms."
msgstr ""
"@table @dfn\n"
"@item NFD\n"
"Символы разлагаются на их канонические формы."

#: api-data.texi:3704
msgid ""
"@item NFKD\n"
"Characters are decomposed to their compatibility forms."
msgstr ""
"@item NFKD\n"
"Символы разлагаются на их совместимые формы."

#: api-data.texi:3707
msgid ""
"@item NFC\n"
"Characters are decomposed to their canonical forms, then composed."
msgstr ""
"@item NFC\n"
"Символы разлагаются на их канонические формы, а затем объединяются"

#: api-data.texi:3710
msgid ""
"@item NFKC\n"
"Characters are decomposed to their compatibility forms, then composed."
msgstr ""
"@item NFKC\n"
"Символы разлагаются на их совместимые формы, а затем объединяются"

#: api-data.texi:3712
msgctxt "api-data.texi:3712"
msgid "@end table"
msgstr ""

#: api-data.texi:3715
msgid ""
"The functions below put their arguments into one of the forms described\n"
"above."
msgstr ""
"Приведенные ниже функции приводят аргументы в одну из описанных выше форм."

#: api-data.texi:3720
msgid ""
"@deffn {Scheme Procedure} string-normalize-nfd s\n"
"@deffnx {C Function} scm_string_normalize_nfd (s)\n"
"Return the @code{NFD} normalized form of @var{s}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3725
msgid ""
"@deffn {Scheme Procedure} string-normalize-nfkd s\n"
"@deffnx {C Function} scm_string_normalize_nfkd (s)\n"
"Return the @code{NFKD} normalized form of @var{s}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3730
msgid ""
"@deffn {Scheme Procedure} string-normalize-nfc s\n"
"@deffnx {C Function} scm_string_normalize_nfc (s)\n"
"Return the @code{NFC} normalized form of @var{s}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3735
msgid ""
"@deffn {Scheme Procedure} string-normalize-nfkc s\n"
"@deffnx {C Function} scm_string_normalize_nfkc (s)\n"
"Return the @code{NFKC} normalized form of @var{s}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3738
msgid ""
"@node String Searching\n"
"@subsubsection String Searching"
msgstr ""
"@node String Searching\n"
"@subsubsection Строковый Поиск"

#: api-data.texi:3743
msgid ""
"@deffn {Scheme Procedure} string-index s char_pred [start [end]]\n"
"@deffnx {C Function} scm_string_index (s, char_pred, start, end)\n"
"Search through the string @var{s} from left to right, returning\n"
"the index of the first occurrence of a character which"
msgstr ""

#: api-data.texi:3747
msgctxt "api-data.texi:3747"
msgid ""
"@itemize @bullet\n"
"@item\n"
"equals @var{char_pred}, if it is character,"
msgstr ""

#: api-data.texi:3750
msgctxt "api-data.texi:3750"
msgid ""
"@item\n"
"satisfies the predicate @var{char_pred}, if it is a procedure,"
msgstr ""

#: api-data.texi:3754
msgid ""
"@item\n"
"is in the set @var{char_pred}, if it is a character set.\n"
"@end itemize"
msgstr ""

#: api-data.texi:3757
msgctxt "api-data.texi:3757"
msgid ""
"Return @code{#f} if no match is found.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3762
msgid ""
"@deffn {Scheme Procedure} string-rindex s char_pred [start [end]]\n"
"@deffnx {C Function} scm_string_rindex (s, char_pred, start, end)\n"
"Search through the string @var{s} from right to left, returning\n"
"the index of the last occurrence of a character which"
msgstr ""

#: api-data.texi:3766
msgctxt "api-data.texi:3766"
msgid ""
"@itemize @bullet\n"
"@item\n"
"equals @var{char_pred}, if it is character,"
msgstr ""

#: api-data.texi:3769
msgctxt "api-data.texi:3769"
msgid ""
"@item\n"
"satisfies the predicate @var{char_pred}, if it is a procedure,"
msgstr ""

#: api-data.texi:3773
msgctxt "api-data.texi:3773"
msgid ""
"@item\n"
"is in the set if @var{char_pred} is a character set.\n"
"@end itemize"
msgstr ""

#: api-data.texi:3776
msgctxt "api-data.texi:3776"
msgid ""
"Return @code{#f} if no match is found.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3782
msgid ""
"@deffn {Scheme Procedure} string-prefix-length s1 s2 [start1 [end1 [start2 "
"[end2]]]]\n"
"@deffnx {C Function} scm_string_prefix_length (s1, s2, start1, end1, start2, "
"end2)\n"
"Return the length of the longest common prefix of the two\n"
"strings.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3788
msgid ""
"@deffn {Scheme Procedure} string-prefix-length-ci s1 s2 [start1 [end1 "
"[start2 [end2]]]]\n"
"@deffnx {C Function} scm_string_prefix_length_ci (s1, s2, start1, end1, "
"start2, end2)\n"
"Return the length of the longest common prefix of the two\n"
"strings, ignoring character case.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3794
msgid ""
"@deffn {Scheme Procedure} string-suffix-length s1 s2 [start1 [end1 [start2 "
"[end2]]]]\n"
"@deffnx {C Function} scm_string_suffix_length (s1, s2, start1, end1, start2, "
"end2)\n"
"Return the length of the longest common suffix of the two\n"
"strings.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3800
msgid ""
"@deffn {Scheme Procedure} string-suffix-length-ci s1 s2 [start1 [end1 "
"[start2 [end2]]]]\n"
"@deffnx {C Function} scm_string_suffix_length_ci (s1, s2, start1, end1, "
"start2, end2)\n"
"Return the length of the longest common suffix of the two\n"
"strings, ignoring character case.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3805
msgid ""
"@deffn {Scheme Procedure} string-prefix? s1 s2 [start1 [end1 [start2 "
"[end2]]]]\n"
"@deffnx {C Function} scm_string_prefix_p (s1, s2, start1, end1, start2, "
"end2)\n"
"Is @var{s1} a prefix of @var{s2}?\n"
"@end deffn"
msgstr ""

#: api-data.texi:3810
msgid ""
"@deffn {Scheme Procedure} string-prefix-ci? s1 s2 [start1 [end1 [start2 "
"[end2]]]]\n"
"@deffnx {C Function} scm_string_prefix_ci_p (s1, s2, start1, end1, start2, "
"end2)\n"
"Is @var{s1} a prefix of @var{s2}, ignoring character case?\n"
"@end deffn"
msgstr ""

#: api-data.texi:3815
msgid ""
"@deffn {Scheme Procedure} string-suffix? s1 s2 [start1 [end1 [start2 "
"[end2]]]]\n"
"@deffnx {C Function} scm_string_suffix_p (s1, s2, start1, end1, start2, "
"end2)\n"
"Is @var{s1} a suffix of @var{s2}?\n"
"@end deffn"
msgstr ""

#: api-data.texi:3820
msgid ""
"@deffn {Scheme Procedure} string-suffix-ci? s1 s2 [start1 [end1 [start2 "
"[end2]]]]\n"
"@deffnx {C Function} scm_string_suffix_ci_p (s1, s2, start1, end1, start2, "
"end2)\n"
"Is @var{s1} a suffix of @var{s2}, ignoring character case?\n"
"@end deffn"
msgstr ""

#: api-data.texi:3825
msgid ""
"@deffn {Scheme Procedure} string-index-right s char_pred [start [end]]\n"
"@deffnx {C Function} scm_string_index_right (s, char_pred, start, end)\n"
"Search through the string @var{s} from right to left, returning\n"
"the index of the last occurrence of a character which"
msgstr ""

#: api-data.texi:3829
msgctxt "api-data.texi:3829"
msgid ""
"@itemize @bullet\n"
"@item\n"
"equals @var{char_pred}, if it is character,"
msgstr ""

#: api-data.texi:3832
msgctxt "api-data.texi:3832"
msgid ""
"@item\n"
"satisfies the predicate @var{char_pred}, if it is a procedure,"
msgstr ""

#: api-data.texi:3836
msgctxt "api-data.texi:3836"
msgid ""
"@item\n"
"is in the set if @var{char_pred} is a character set.\n"
"@end itemize"
msgstr ""

#: api-data.texi:3839
msgctxt "api-data.texi:3839"
msgid ""
"Return @code{#f} if no match is found.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3844
msgid ""
"@deffn {Scheme Procedure} string-skip s char_pred [start [end]]\n"
"@deffnx {C Function} scm_string_skip (s, char_pred, start, end)\n"
"Search through the string @var{s} from left to right, returning\n"
"the index of the first occurrence of a character which"
msgstr ""

#: api-data.texi:3848
msgctxt "api-data.texi:3848"
msgid ""
"@itemize @bullet\n"
"@item\n"
"does not equal @var{char_pred}, if it is character,"
msgstr ""

#: api-data.texi:3852
msgctxt "api-data.texi:3852"
msgid ""
"@item\n"
"does not satisfy the predicate @var{char_pred}, if it is a\n"
"procedure,"
msgstr ""

#: api-data.texi:3857
msgctxt "api-data.texi:3857"
msgid ""
"@item\n"
"is not in the set if @var{char_pred} is a character set.\n"
"@end itemize\n"
"@end deffn"
msgstr ""

#: api-data.texi:3862
msgid ""
"@deffn {Scheme Procedure} string-skip-right s char_pred [start [end]]\n"
"@deffnx {C Function} scm_string_skip_right (s, char_pred, start, end)\n"
"Search through the string @var{s} from right to left, returning\n"
"the index of the last occurrence of a character which"
msgstr ""

#: api-data.texi:3866
msgctxt "api-data.texi:3866"
msgid ""
"@itemize @bullet\n"
"@item\n"
"does not equal @var{char_pred}, if it is character,"
msgstr ""

#: api-data.texi:3870
msgctxt "api-data.texi:3870"
msgid ""
"@item\n"
"does not satisfy the predicate @var{char_pred}, if it is a\n"
"procedure,"
msgstr ""

#: api-data.texi:3875
msgctxt "api-data.texi:3875"
msgid ""
"@item\n"
"is not in the set if @var{char_pred} is a character set.\n"
"@end itemize\n"
"@end deffn"
msgstr ""

#: api-data.texi:3880
msgid ""
"@deffn {Scheme Procedure} string-count s char_pred [start [end]]\n"
"@deffnx {C Function} scm_string_count (s, char_pred, start, end)\n"
"Return the count of the number of characters in the string\n"
"@var{s} which"
msgstr ""

#: api-data.texi:3884
msgctxt "api-data.texi:3884"
msgid ""
"@itemize @bullet\n"
"@item\n"
"equals @var{char_pred}, if it is character,"
msgstr ""

#: api-data.texi:3887
msgid ""
"@item\n"
"satisfies the predicate @var{char_pred}, if it is a procedure."
msgstr ""

#: api-data.texi:3892
msgid ""
"@item\n"
"is in the set @var{char_pred}, if it is a character set.\n"
"@end itemize\n"
"@end deffn"
msgstr ""

#: api-data.texi:3900
msgid ""
"@deffn {Scheme Procedure} string-contains s1 s2 [start1 [end1 [start2 "
"[end2]]]]\n"
"@deffnx {C Function} scm_string_contains (s1, s2, start1, end1, start2, "
"end2)\n"
"Does string @var{s1} contain string @var{s2}?  Return the index\n"
"in @var{s1} where @var{s2} occurs as a substring, or false.\n"
"The optional start/end indices restrict the operation to the\n"
"indicated substrings.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3909
msgid ""
"@deffn {Scheme Procedure} string-contains-ci s1 s2 [start1 [end1 [start2 "
"[end2]]]]\n"
"@deffnx {C Function} scm_string_contains_ci (s1, s2, start1, end1, start2, "
"end2)\n"
"Does string @var{s1} contain string @var{s2}?  Return the index\n"
"in @var{s1} where @var{s2} occurs as a substring, or false.\n"
"The optional start/end indices restrict the operation to the\n"
"indicated substrings.  Character comparison is done\n"
"case-insensitively.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3912
msgid ""
"@node Alphabetic Case Mapping\n"
"@subsubsection Alphabetic Case Mapping"
msgstr ""
"@node Alphabetic Case Mapping\n"
"@subsubsection Алфавитное Преобразование"

#: api-data.texi:3915
msgid ""
"These are procedures for mapping strings to their upper- or lower-case\n"
"equivalents, respectively, or for capitalizing strings."
msgstr ""
"Это процедуры дле преобразования строк в их эквиваленты в верхнем\n"
"или нижнем регистре, соотвественно, или для заглавных строк."

#: api-data.texi:3919
msgid ""
"They use the basic case mapping rules for Unicode characters.  No\n"
"special language or context rules are considered.  The resulting strings\n"
"are guaranteed to be the same length as the input strings."
msgstr ""
"Они используют основные правила отображение регистров для символов\n"
"Unicode. Нет специального языка или рассматриваются контекстные\n"
"правила. Полученные строки будут гарантированно иметь ту же длину,\n"
"что и входные строки."

#: api-data.texi:3922
msgid ""
"@xref{Character Case Mapping, the @code{(ice-9\n"
"i18n)} module}, for locale-dependent case conversions."
msgstr ""
"@xref{Character Case Mapping, the @code{(ice-9 i18n)} module}, \n"
"для преобразований зависящих от локали."

#: api-data.texi:3928
msgid ""
"@deffn {Scheme Procedure} string-upcase str [start [end]]\n"
"@deffnx {C Function} scm_substring_upcase (str, start, end)\n"
"@deffnx {C Function} scm_string_upcase (str)\n"
"Upcase every character in @code{str}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3933
msgid ""
"@deffn {Scheme Procedure} string-upcase! str [start [end]]\n"
"@deffnx {C Function} scm_substring_upcase_x (str, start, end)\n"
"@deffnx {C Function} scm_string_upcase_x (str)\n"
"Destructively upcase every character in @code{str}."
msgstr ""

#: api-data.texi:3941
msgid ""
"@lisp\n"
"(string-upcase! y)\n"
"@result{} \"ARRDEFG\"\n"
"y\n"
"@result{} \"ARRDEFG\"\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:3947
msgid ""
"@deffn {Scheme Procedure} string-downcase str [start [end]]\n"
"@deffnx {C Function} scm_substring_downcase (str, start, end)\n"
"@deffnx {C Function} scm_string_downcase (str)\n"
"Downcase every character in @var{str}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3952
msgid ""
"@deffn {Scheme Procedure} string-downcase! str [start [end]]\n"
"@deffnx {C Function} scm_substring_downcase_x (str, start, end)\n"
"@deffnx {C Function} scm_string_downcase_x (str)\n"
"Destructively downcase every character in @var{str}."
msgstr ""

#: api-data.texi:3962
msgid ""
"@lisp\n"
"y\n"
"@result{} \"ARRDEFG\"\n"
"(string-downcase! y)\n"
"@result{} \"arrdefg\"\n"
"y\n"
"@result{} \"arrdefg\"\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:3969
msgid ""
"@deffn {Scheme Procedure} string-capitalize str\n"
"@deffnx {C Function} scm_string_capitalize (str)\n"
"Return a freshly allocated string with the characters in\n"
"@var{str}, where the first character of every word is\n"
"capitalized.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3974
msgid ""
"@deffn {Scheme Procedure} string-capitalize! str\n"
"@deffnx {C Function} scm_string_capitalize_x (str)\n"
"Upcase the first character of every word in @var{str}\n"
"destructively and return @var{str}."
msgstr ""

#: api-data.texi:3981
msgid ""
"@lisp\n"
"y                      @result{} \"hello world\"\n"
"(string-capitalize! y) @result{} \"Hello World\"\n"
"y                      @result{} \"Hello World\"\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:3986
msgid ""
"@deffn {Scheme Procedure} string-titlecase str [start [end]]\n"
"@deffnx {C Function} scm_string_titlecase (str, start, end)\n"
"Titlecase every first character in a word in @var{str}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3992
msgid ""
"@deffn {Scheme Procedure} string-titlecase! str [start [end]]\n"
"@deffnx {C Function} scm_string_titlecase_x (str, start, end)\n"
"Destructively titlecase every first character in a word in\n"
"@var{str}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:3995
msgid ""
"@node Reversing and Appending Strings\n"
"@subsubsection Reversing and Appending Strings"
msgstr ""
"@node Reversing and Appending Strings\n"
"@subsubsection Поворот и Добавление Строк"

#: api-data.texi:4002
msgid ""
"@deffn {Scheme Procedure} string-reverse str [start [end]]\n"
"@deffnx {C Function} scm_string_reverse (str, start, end)\n"
"Reverse the string @var{str}.  The optional arguments\n"
"@var{start} and @var{end} delimit the region of @var{str} to\n"
"operate on.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4009
msgid ""
"@deffn {Scheme Procedure} string-reverse! str [start [end]]\n"
"@deffnx {C Function} scm_string_reverse_x (str, start, end)\n"
"Reverse the string @var{str} in-place.  The optional arguments\n"
"@var{start} and @var{end} delimit the region of @var{str} to\n"
"operate on.  The return value is unspecified.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4015
msgid ""
"@rnindex string-append\n"
"@deffn {Scheme Procedure} string-append arg @dots{}\n"
"@deffnx {C Function} scm_string_append (args)\n"
"Return a newly allocated string whose characters form the\n"
"concatenation of the given strings, @var{arg} @enddots{}."
msgstr ""

#: api-data.texi:4022
msgid ""
"@example\n"
"(let ((h \"hello \"))\n"
"  (string-append h \"world\"))\n"
"@result{} \"hello world\"\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:4028
msgid ""
"@deffn {Scheme Procedure} string-append/shared arg @dots{}\n"
"@deffnx {C Function} scm_string_append_shared (args)\n"
"Like @code{string-append}, but the result may share memory\n"
"with the argument strings.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4034
msgid ""
"@deffn {Scheme Procedure} string-concatenate ls\n"
"@deffnx {C Function} scm_string_concatenate (ls)\n"
"Append the elements (which must be strings) of @var{ls} together into a\n"
"single string.  Guaranteed to return a freshly allocated string.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4038
msgid ""
"@deffn {Scheme Procedure} string-concatenate-reverse ls [final_string "
"[end]]\n"
"@deffnx {C Function} scm_string_concatenate_reverse (ls, final_string, end)\n"
"Without optional arguments, this procedure is equivalent to"
msgstr ""

#: api-data.texi:4042
msgid ""
"@lisp\n"
"(string-concatenate (reverse ls))\n"
"@end lisp"
msgstr ""

#: api-data.texi:4048
msgid ""
"If the optional argument @var{final_string} is specified, it is\n"
"consed onto the beginning to @var{ls} before performing the\n"
"list-reverse and string-concatenate operations.  If @var{end}\n"
"is given, only the characters of @var{final_string} up to index\n"
"@var{end} are used."
msgstr ""

#: api-data.texi:4051
msgid ""
"Guaranteed to return a freshly allocated string.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4057
msgid ""
"@deffn {Scheme Procedure} string-concatenate/shared ls\n"
"@deffnx {C Function} scm_string_concatenate_shared (ls)\n"
"Like @code{string-concatenate}, but the result may share memory\n"
"with the strings in the list @var{ls}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4063
msgid ""
"@deffn {Scheme Procedure} string-concatenate-reverse/shared ls [final_string "
"[end]]\n"
"@deffnx {C Function} scm_string_concatenate_reverse_shared (ls, "
"final_string, end)\n"
"Like @code{string-concatenate-reverse}, but the result may\n"
"share memory with the strings in the @var{ls} arguments.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4066
msgid ""
"@node Mapping Folding and Unfolding\n"
"@subsubsection Mapping, Folding, and Unfolding"
msgstr ""
"@node Mapping Folding and Unfolding\n"
"@subsubsection Отображение(Map), Сворачивание(Fold) и Разворачивание(Unfold) "
"Строк"

#: api-data.texi:4073
msgid ""
"@deffn {Scheme Procedure} string-map proc s [start [end]]\n"
"@deffnx {C Function} scm_string_map (proc, s, start, end)\n"
"@var{proc} is a char->char procedure, it is mapped over\n"
"@var{s}.  The order in which the procedure is applied to the\n"
"string elements is not specified.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4081
msgid ""
"@deffn {Scheme Procedure} string-map! proc s [start [end]]\n"
"@deffnx {C Function} scm_string_map_x (proc, s, start, end)\n"
"@var{proc} is a char->char procedure, it is mapped over\n"
"@var{s}.  The order in which the procedure is applied to the\n"
"string elements is not specified.  The string @var{s} is\n"
"modified in-place, the return value is not specified.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4087
msgid ""
"@deffn {Scheme Procedure} string-for-each proc s [start [end]]\n"
"@deffnx {C Function} scm_string_for_each (proc, s, start, end)\n"
"@var{proc} is mapped over @var{s} in left-to-right order.  The\n"
"return value is not specified.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4092
msgid ""
"@deffn {Scheme Procedure} string-for-each-index proc s [start [end]]\n"
"@deffnx {C Function} scm_string_for_each_index (proc, s, start, end)\n"
"Call @code{(@var{proc} i)} for each index i in @var{s}, from left to\n"
"right."
msgstr ""

#: api-data.texi:4094
msgid "For example, to change characters to alternately upper and lower case,"
msgstr ""

#: api-data.texi:4106
msgid ""
"@example\n"
"(define str (string-copy \"studly\"))\n"
"(string-for-each-index\n"
"    (lambda (i)\n"
"      (string-set! str i\n"
"        ((if (even? i) char-upcase char-downcase)\n"
"         (string-ref str i))))\n"
"    str)\n"
"str @result{} \"StUdLy\"\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:4114
msgid ""
"@deffn {Scheme Procedure} string-fold kons knil s [start [end]]\n"
"@deffnx {C Function} scm_string_fold (kons, knil, s, start, end)\n"
"Fold @var{kons} over the characters of @var{s}, with @var{knil}\n"
"as the terminating element, from left to right.  @var{kons}\n"
"must expect two arguments: The actual character and the last\n"
"result of @var{kons}' application.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4122
msgid ""
"@deffn {Scheme Procedure} string-fold-right kons knil s [start [end]]\n"
"@deffnx {C Function} scm_string_fold_right (kons, knil, s, start, end)\n"
"Fold @var{kons} over the characters of @var{s}, with @var{knil}\n"
"as the terminating element, from right to left.  @var{kons}\n"
"must expect two arguments: The actual character and the last\n"
"result of @var{kons}' application.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4144
msgid ""
"@deffn {Scheme Procedure} string-unfold p f g seed [base [make_final]]\n"
"@deffnx {C Function} scm_string_unfold (p, f, g, seed, base, make_final)\n"
"@itemize @bullet\n"
"@item @var{g} is used to generate a series of @emph{seed}\n"
"values from the initial @var{seed}: @var{seed}, (@var{g}\n"
"@var{seed}), (@var{g}^2 @var{seed}), (@var{g}^3 @var{seed}),\n"
"@dots{}\n"
"@item @var{p} tells us when to stop -- when it returns true\n"
"when applied to one of these seed values.\n"
"@item @var{f} maps each seed value to the corresponding\n"
"character in the result string.  These chars are assembled\n"
"into the string in a left-to-right order.\n"
"@item @var{base} is the optional initial/leftmost portion\n"
"of the constructed string; it default to the empty\n"
"string.\n"
"@item @var{make_final} is applied to the terminal seed\n"
"value (on which @var{p} returns true) to produce\n"
"the final/rightmost portion of the constructed string.\n"
"The default is nothing extra.\n"
"@end itemize\n"
"@end deffn"
msgstr ""

#: api-data.texi:4166
msgid ""
"@deffn {Scheme Procedure} string-unfold-right p f g seed [base "
"[make_final]]\n"
"@deffnx {C Function} scm_string_unfold_right (p, f, g, seed, base, "
"make_final)\n"
"@itemize @bullet\n"
"@item @var{g} is used to generate a series of @emph{seed}\n"
"values from the initial @var{seed}: @var{seed}, (@var{g}\n"
"@var{seed}), (@var{g}^2 @var{seed}), (@var{g}^3 @var{seed}),\n"
"@dots{}\n"
"@item @var{p} tells us when to stop -- when it returns true\n"
"when applied to one of these seed values.\n"
"@item @var{f} maps each seed value to the corresponding\n"
"character in the result string.  These chars are assembled\n"
"into the string in a right-to-left order.\n"
"@item @var{base} is the optional initial/rightmost portion\n"
"of the constructed string; it default to the empty\n"
"string.\n"
"@item @var{make_final} is applied to the terminal seed\n"
"value (on which @var{p} returns true) to produce\n"
"the final/leftmost portion of the constructed string.\n"
"It defaults to @code{(lambda (x) )}.\n"
"@end itemize\n"
"@end deffn"
msgstr ""

#: api-data.texi:4169
msgid ""
"@node Miscellaneous String Operations\n"
"@subsubsection Miscellaneous String Operations"
msgstr ""
"@node Miscellaneous String Operations\n"
"@subsubsection Различные строковые операции"

#: api-data.texi:4174
msgid ""
"@deffn {Scheme Procedure} xsubstring s from [to [start [end]]]\n"
"@deffnx {C Function} scm_xsubstring (s, from, to, start, end)\n"
"This is the @emph{extended substring} procedure that implements\n"
"replicated copying of a substring of some string."
msgstr ""

#: api-data.texi:4183
msgid ""
"@var{s} is a string, @var{start} and @var{end} are optional\n"
"arguments that demarcate a substring of @var{s}, defaulting to\n"
"0 and the length of @var{s}.  Replicate this substring up and\n"
"down index space, in both the positive and negative directions.\n"
"@code{xsubstring} returns the substring of this string\n"
"beginning at index @var{from}, and ending at @var{to}, which\n"
"defaults to @var{from} + (@var{end} - @var{start}).\n"
"@end deffn"
msgstr ""

#: api-data.texi:4192
msgid ""
"@deffn {Scheme Procedure} string-xcopy! target tstart s sfrom [sto [start "
"[end]]]\n"
"@deffnx {C Function} scm_string_xcopy_x (target, tstart, s, sfrom, sto, "
"start, end)\n"
"Exactly the same as @code{xsubstring}, but the extracted text\n"
"is written into the string @var{target} starting at index\n"
"@var{tstart}.  The operation is not defined if @code{(eq?\n"
"@var{target} @var{s})} or these arguments share storage -- you\n"
"cannot copy a string on top of itself.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4199
msgid ""
"@deffn {Scheme Procedure} string-replace s1 s2 [start1 [end1 [start2 "
"[end2]]]]\n"
"@deffnx {C Function} scm_string_replace (s1, s2, start1, end1, start2, "
"end2)\n"
"Return the string @var{s1}, but with the characters\n"
"@var{start1} @dots{} @var{end1} replaced by the characters\n"
"@var{start2} @dots{} @var{end2} from @var{s2}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4210
msgid ""
"@deffn {Scheme Procedure} string-tokenize s [token_set [start [end]]]\n"
"@deffnx {C Function} scm_string_tokenize (s, token_set, start, end)\n"
"Split the string @var{s} into a list of substrings, where each\n"
"substring is a maximal non-empty contiguous sequence of\n"
"characters from the character set @var{token_set}, which\n"
"defaults to @code{char-set:graphic}.\n"
"If @var{start} or @var{end} indices are provided, they restrict\n"
"@code{string-tokenize} to operating on the indicated substring\n"
"of @var{s}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4215
msgid ""
"@deffn {Scheme Procedure} string-filter char_pred s [start [end]]\n"
"@deffnx {C Function} scm_string_filter (char_pred, s, start, end)\n"
"Filter the string @var{s}, retaining only those characters which\n"
"satisfy @var{char_pred}."
msgstr ""

#: api-data.texi:4220
msgctxt "api-data.texi:4220"
msgid ""
"If @var{char_pred} is a procedure, it is applied to each character as\n"
"a predicate, if it is a character, it is tested for equality and if it\n"
"is a character set, it is tested for membership.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4224
msgid ""
"@deffn {Scheme Procedure} string-delete char_pred s [start [end]]\n"
"@deffnx {C Function} scm_string_delete (char_pred, s, start, end)\n"
"Delete characters satisfying @var{char_pred} from @var{s}."
msgstr ""

#: api-data.texi:4229
msgctxt "api-data.texi:4229"
msgid ""
"If @var{char_pred} is a procedure, it is applied to each character as\n"
"a predicate, if it is a character, it is tested for equality and if it\n"
"is a character set, it is tested for membership.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4232
msgid ""
"@node Representing Strings as Bytes\n"
"@subsubsection Representing Strings as Bytes"
msgstr ""
"@node Representing Strings as Bytes\n"
"@subsubsection Представление строк как байтов."

#: api-data.texi:4237
msgid ""
"Out in the cold world outside of Guile, not all strings are treated in\n"
"the same way.  Out there there are only bytes, and there are many ways\n"
"of representing a strings (sequences of characters) as binary data\n"
"(sequences of bytes)."
msgstr ""
"В холодном мире за пределами Guile не все строки обрабатываются одинаково.\n"
"Снаружи есть только байты, и существует много способов представления строк\n"
"(последовательностей символов) как двоичных данных (последовательностей\n"
"байтов)."

#: api-data.texi:4243
msgid ""
"As a user, usually you don't have to think about this very much.  When\n"
"you type on your keyboard, your system encodes your keystrokes as bytes\n"
"according to the locale that you have configured on your computer.\n"
"Guile uses the locale to decode those bytes back into characters --\n"
"hopefully the same characters that you typed in."
msgstr ""
"Как пользователю, вам обычно не надо думать. Когда вы вводите, ваша\n"
"клавиатура, ваша система кодирует все ваши нажатия клавиш в виде\n"
"байтов в соответствии с языком, который вы настроили на своем \n"
"компьютере. Guile использует локаль для декодирования этих байтов\n"
"назад в символы --- мы надеемся, в те же символы, что вы ввели."

#: api-data.texi:4248
msgid ""
"All is not so clear when dealing with a system with multiple users, such\n"
"as a web server.  Your web server might get a request from one user for\n"
"data encoded in the ISO-8859-1 character set, and then another request\n"
"from a different user for UTF-8 data."
msgstr ""
"Все становиться менее понятным при работе с системой с несколькими \n"
"пользователями, например с веб-сервером. Ваш веб-сервер может получить\n"
"запрос от одного пользователя для данных закодированных в наборе символов\n"
"ISO-8859-1, а затем получить запрос от другого пользователя дя данных UTF-8."

#: api-data.texi:4255
msgid ""
"@cindex iconv\n"
"@cindex character encoding\n"
"Guile provides an @dfn{iconv} module for converting between strings and\n"
"sequences of bytes.  @xref{Bytevectors}, for more on how Guile\n"
"represents raw byte sequences.  This module gets its name from the\n"
"common @sc{unix} command of the same name."
msgstr ""
"@cindex iconv\n"
"@cindex character encoding\n"
"Guile предоставляет модуль @dfn{iconv} для преобразования строк и "
"последовательностей\n"
"байтов.  @xref{Bytevectors}, для получения дополнительной информации о том "
"как Guile\n"
"представляет собой байты исходной последовательности.  Этот модуль получил "
"свое имя\n"
"от общей команды @sc{unix} с тем же именем."

#: api-data.texi:4260
msgid ""
"Note that often it is sufficient to just read and write strings from\n"
"ports instead of using these functions.  To do this, specify the port\n"
"encoding using @code{set-port-encoding!}.  @xref{Ports}, for more on\n"
"ports and character encodings."
msgstr ""
"Обратите внимание, что часто достаточно просто читать и писать\n"
"строки из портов вместо использования этой функции.  Для этого\n"
"укажите кодировку порта с помощью  @code{set-port-encoding!}.  \n"
"@xref{Ports}, еще больше о портаи и кодировках символов."

#: api-data.texi:4263
msgid ""
"Unlike the rest of the procedures in this section, you have to load the\n"
"@code{iconv} module before having access to these procedures:"
msgstr ""
"В отличие от остальных процедур в этом разделе вам нужно загрузить\n"
"модуль @code{iconv} перед доступом к этим процедурам:"

#: api-data.texi:4267
msgid ""
"@example\n"
"(use-modules (ice-9 iconv))\n"
"@end example"
msgstr ""

#: api-data.texi:4270
msgid ""
"@deffn {Scheme Procedure} string->bytevector string encoding [conversion-"
"strategy]\n"
"Encode @var{string} as a sequence of bytes."
msgstr ""

#: api-data.texi:4276
msgid ""
"The string will be encoded in the character set specified by the\n"
"@var{encoding} string.  If the string has characters that cannot be\n"
"represented in the encoding, by default this procedure raises an\n"
"@code{encoding-error}.  Pass a @var{conversion-strategy} argument to\n"
"specify other behaviors."
msgstr ""

#: api-data.texi:4281
msgid ""
"The return value is a bytevector.  @xref{Bytevectors}, for more on\n"
"bytevectors.  @xref{Ports}, for more on character encodings and\n"
"conversion strategies.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4284
msgid ""
"@deffn {Scheme Procedure} bytevector->string bytevector encoding [conversion-"
"strategy]\n"
"Decode @var{bytevector} into a string."
msgstr ""

#: api-data.texi:4292
msgid ""
"The bytes will be decoded from the character set by the @var{encoding}\n"
"string.  If the bytes do not form a valid encoding, by default this\n"
"procedure raises an @code{decoding-error}.  As with\n"
"@code{string->bytevector}, pass the optional @var{conversion-strategy}\n"
"argument to modify this behavior.  @xref{Ports}, for more on character\n"
"encodings and conversion strategies.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4299
msgid ""
"@deffn {Scheme Procedure} call-with-output-encoded-string encoding proc "
"[conversion-strategy]\n"
"Like @code{call-with-output-string}, but instead of returning a string,\n"
"returns a encoding of the string according to @var{encoding}, as a\n"
"bytevector.  This procedure can be more efficient than collecting a\n"
"string and then converting it via @code{string->bytevector}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4302
msgid ""
"@node Conversion to/from C\n"
"@subsubsection Conversion to/from C"
msgstr ""
"@node Conversion to/from C\n"
"@subsubsection Преобразование в/из Си"

#: api-data.texi:4306
msgid ""
"When creating a Scheme string from a C string or when converting a\n"
"Scheme string to a C string, the concept of character encoding becomes\n"
"important."
msgstr ""
"При создании строки Scheme из строки Си или при перобразовании строки \n"
"Scheme в строку Си, концепция кодирования символов становиться важной."

#: api-data.texi:4312
msgid ""
"In C, a string is just a sequence of bytes, and the character encoding\n"
"describes the relation between these bytes and the actual characters\n"
"that make up the string.  For Scheme strings, character encoding is not\n"
"an issue (most of the time), since in Scheme you usually treat strings\n"
"as character sequences, not byte sequences."
msgstr ""
"В Си строка представляет собой всего лишь последовательность байтов, а\n"
"кодировка символов описывает отношение между этими байтами и фактическми\n"
"символами, которые составляют сторку. Для строк Scheme, кодировка символов\n"
"не является проблемой (в основном), так как на Scheme вы обычно используете\n"
"строки как последовательности символов, а не как последовательности байтов."

#: api-data.texi:4314
msgid "Converting to C and converting from C each have their own challenges."
msgstr "Преобразование в Си И преобразование из Си имеют свои проблемы."

#: api-data.texi:4320
msgid ""
"When converting from C to Scheme, it is important that the sequence of\n"
"bytes in the C string be valid with respect to its encoding.  ASCII\n"
"strings, for example, can't have any bytes greater than 127.  An ASCII\n"
"byte greater than 127 is considered @emph{ill-formed} and cannot be\n"
"converted into a Scheme character."
msgstr ""
"При преобразовании из Си в Scheme важно, чтобы последовательность байтов\n"
"в строке Си была действительной впо отношению к ее кодированию. Например,\n"
"стороки  ASCII не могут иметь байтов превышающих значение 127.  Байт ASCII\n"
"превышающий 127 считается  @emph{плохо сформированным} и не может \n"
"преобразовываться в символы Scheme."

#: api-data.texi:4326
msgid ""
"Problems can occur in the reverse operation as well.  Not all character\n"
"encodings can hold all possible Scheme characters.  Some encodings, like\n"
"ASCII for example, can only describe a small subset of all possible\n"
"characters.  So, when converting to C, one must first decide what to do\n"
"with Scheme characters that can't be represented in the C string."
msgstr ""
"Проблемы могут возникнуть и при обратном преобразовании. Не все кодировки\n"
"символов могут содержать все возможные символы Scheme. Например, некоторые\n"
"кодировки, наприер ASCII, могут описать небольшое подмножество всех "
"возможных\n"
"символов. Итак, при преобразовании в Си сначала необходимо решить, что\n"
"деалть с символами Scheme, которые не могут быть представлены в строке Си."

#: api-data.texi:4332
msgid ""
"Converting a Scheme string to a C string will often allocate fresh\n"
"memory to hold the result.  You must take care that this memory is\n"
"properly freed eventually.  In many cases, this can be achieved by\n"
"using @code{scm_dynwind_free} inside an appropriate dynwind context,\n"
"@xref{Dynamic Wind}."
msgstr ""
"Преобразуя стороку Scheme в строку Си часто выделяют свежую память\n"
" для хранения результата. Вы должны позаботиться о том, что бы эта\n"
"память была освобождена должным образом. Во многих случаях, это\n"
"может быть сделано с помощью искользования @code{scm_dynwind_free}\n"
"в соответствующем контексте dynwind, @xref{Dynamic Wind}."

#: api-data.texi:4337
msgid ""
"@deftypefn  {C Function} SCM scm_from_locale_string (const char *str)\n"
"@deftypefnx {C Function} SCM scm_from_locale_stringn (const char *str, "
"size_t len)\n"
"Creates a new Scheme string that has the same contents as @var{str} when\n"
"interpreted in the character encoding of the current locale."
msgstr ""

#: api-data.texi:4339
msgid "For @code{scm_from_locale_string}, @var{str} must be null-terminated."
msgstr ""

#: api-data.texi:4344
msgid ""
"For @code{scm_from_locale_stringn}, @var{len} specifies the length of\n"
"@var{str} in bytes, and @var{str} does not need to be null-terminated.\n"
"If @var{len} is @code{(size_t)-1}, then @var{str} does need to be\n"
"null-terminated and the real length will be found with @code{strlen}."
msgstr ""

#: api-data.texi:4346
msgid "If the C string is ill-formed, an error will be raised."
msgstr ""

#: api-data.texi:4353
msgid ""
"Note that these functions should @emph{not} be used to convert C string\n"
"constants, because there is no guarantee that the current locale will\n"
"match that of the execution character set, used for string and character\n"
"constants.  Most modern C compilers use UTF-8 by default, so to convert\n"
"C string constants we recommend @code{scm_from_utf8_string}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:4362
msgid ""
"@deftypefn  {C Function} SCM scm_take_locale_string (char *str)\n"
"@deftypefnx {C Function} SCM scm_take_locale_stringn (char *str, size_t "
"len)\n"
"Like @code{scm_from_locale_string} and @code{scm_from_locale_stringn},\n"
"respectively, but also frees @var{str} with @code{free} eventually.\n"
"Thus, you can use this function when you would free @var{str} anyway\n"
"immediately after creating the Scheme string.  In certain cases, Guile\n"
"can then use @var{str} directly as its internal representation.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:4369
msgid ""
"@deftypefn  {C Function} {char *} scm_to_locale_string (SCM str)\n"
"@deftypefnx {C Function} {char *} scm_to_locale_stringn (SCM str, size_t "
"*lenp)\n"
"Returns a C string with the same contents as @var{str} in the character\n"
"encoding of the current locale.  The C string must be freed with\n"
"@code{free} eventually, maybe by using @code{scm_dynwind_free},\n"
"@xref{Dynamic Wind}."
msgstr ""

#: api-data.texi:4373
msgid ""
"For @code{scm_to_locale_string}, the returned string is\n"
"null-terminated and an error is signalled when @var{str} contains\n"
"@code{#\\nul} characters."
msgstr ""

#: api-data.texi:4380
msgid ""
"For @code{scm_to_locale_stringn} and @var{lenp} not @code{NULL},\n"
"@var{str} might contain @code{#\\nul} characters and the length of the\n"
"returned string in bytes is stored in @code{*@var{lenp}}.  The\n"
"returned string will not be null-terminated in this case.  If\n"
"@var{lenp} is @code{NULL}, @code{scm_to_locale_stringn} behaves like\n"
"@code{scm_to_locale_string}."
msgstr ""

#: api-data.texi:4384
msgid ""
"If a character in @var{str} cannot be represented in the character\n"
"encoding of the current locale, the default port conversion strategy is\n"
"used.  @xref{Ports}, for more on conversion strategies."
msgstr ""

#: api-data.texi:4390
msgid ""
"If the conversion strategy is @code{error}, an error will be raised.  If\n"
"it is @code{substitute}, a replacement character, such as a question\n"
"mark, will be inserted in its place.  If it is @code{escape}, a hex\n"
"escape will be inserted in its place.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:4396
msgid ""
"@deftypefn {C Function} size_t scm_to_locale_stringbuf (SCM str, char *buf, "
"size_t max_len)\n"
"Puts @var{str} as a C string in the current locale encoding into the\n"
"memory pointed to by @var{buf}.  The buffer at @var{buf} has room for\n"
"@var{max_len} bytes and @code{scm_to_local_stringbuf} will never store\n"
"more than that.  No terminating @code{'\\0'} will be stored."
msgstr ""

#: api-data.texi:4403
msgid ""
"The return value of @code{scm_to_locale_stringbuf} is the number of\n"
"bytes that are needed for all of @var{str}, regardless of whether\n"
"@var{buf} was large enough to hold them.  Thus, when the return value\n"
"is larger than @var{max_len}, only @var{max_len} bytes have been\n"
"stored and you probably need to try again with a larger buffer.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:4410
msgid ""
"For most situations, string conversion should occur using the current\n"
"locale, such as with the functions above.  But there may be cases where\n"
"one wants to convert strings from a character encoding other than the\n"
"locale's character encoding.  For these cases, the lower-level functions\n"
"@code{scm_to_stringn} and @code{scm_from_stringn} are provided.  These\n"
"functions should seldom be necessary if one is properly using locales."
msgstr ""

#: api-data.texi:4424
msgid ""
"@deftp {C Type} scm_t_string_failed_conversion_handler\n"
"This is an enumerated type that can take one of three values:\n"
"@code{SCM_FAILED_CONVERSION_ERROR},\n"
"@code{SCM_FAILED_CONVERSION_QUESTION_MARK}, and\n"
"@code{SCM_FAILED_CONVERSION_ESCAPE_SEQUENCE}.  They are used to indicate\n"
"a strategy for handling characters that cannot be converted to or from a\n"
"given character encoding.  @code{SCM_FAILED_CONVERSION_ERROR} indicates\n"
"that a conversion should throw an error if some characters cannot be\n"
"converted.  @code{SCM_FAILED_CONVERSION_QUESTION_MARK} indicates that a\n"
"conversion should replace unconvertable characters with the question\n"
"mark character.  And, @code{SCM_FAILED_CONVERSION_ESCAPE_SEQUENCE}\n"
"requests that a conversion should replace an unconvertable character\n"
"with an escape sequence."
msgstr ""

#: api-data.texi:4430
msgid ""
"While all three strategies apply when converting Scheme strings to C,\n"
"only @code{SCM_FAILED_CONVERSION_ERROR} and\n"
"@code{SCM_FAILED_CONVERSION_QUESTION_MARK} can be used when converting C\n"
"strings to Scheme.\n"
"@end deftp"
msgstr ""

#: api-data.texi:4438
msgid ""
"@deftypefn {C Function} char *scm_to_stringn (SCM str, size_t *lenp, const "
"char *encoding, scm_t_string_failed_conversion_handler handler)\n"
"This function returns a newly allocated C string from the Guile string\n"
"@var{str}.  The length of the returned string in bytes will be returned in\n"
"@var{lenp}.  The character encoding of the C string is passed as the ASCII,\n"
"null-terminated C string @var{encoding}.  The @var{handler} parameter\n"
"gives a strategy for dealing with characters that cannot be converted\n"
"into @var{encoding}."
msgstr ""

#: api-data.texi:4442
msgid ""
"If @var{lenp} is @code{NULL}, this function will return a null-terminated C\n"
"string.  It will throw an error if the string contains a null\n"
"character."
msgstr ""

#: api-data.texi:4446
msgid ""
"The Scheme interface to this function is @code{string->bytevector}, from "
"the\n"
"@code{ice-9 iconv} module.  @xref{Representing Strings as Bytes}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:4453
msgid ""
"@deftypefn {C Function} SCM scm_from_stringn (const char *str, size_t len, "
"const char *encoding, scm_t_string_failed_conversion_handler handler)\n"
"This function returns a scheme string from the C string @var{str}.  The\n"
"length in bytes of the C string is input as @var{len}.  The encoding of the "
"C\n"
"string is passed as the ASCII, null-terminated C string @code{encoding}.\n"
"The @var{handler} parameters suggests a strategy for dealing with\n"
"unconvertable characters."
msgstr ""

#: api-data.texi:4457
msgid ""
"The Scheme interface to this function is @code{bytevector->string}.\n"
"@xref{Representing Strings as Bytes}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:4460
msgid ""
"The following conversion functions are provided as a convenience for the\n"
"most commonly used encodings."
msgstr ""

#: api-data.texi:4468
msgid ""
"@deftypefn {C Function} SCM scm_from_latin1_string (const char *str)\n"
"@deftypefnx {C Function} SCM scm_from_utf8_string (const char *str)\n"
"@deftypefnx {C Function} SCM scm_from_utf32_string (const scm_t_wchar *str)\n"
"Return a scheme string from the null-terminated C string @var{str},\n"
"which is ISO-8859-1-, UTF-8-, or UTF-32-encoded.  These functions should\n"
"be used to convert hard-coded C string constants into Scheme strings.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:4478
msgid ""
"@deftypefn {C Function} SCM scm_from_latin1_stringn (const char *str, size_t "
"len)\n"
"@deftypefnx {C Function} SCM scm_from_utf8_stringn (const char *str, size_t "
"len)\n"
"@deftypefnx {C Function} SCM scm_from_utf32_stringn (const scm_t_wchar *str, "
"size_t len)\n"
"Return a scheme string from C string @var{str}, which is ISO-8859-1-,\n"
"UTF-8-, or UTF-32-encoded, of length @var{len}.  @var{len} is the number\n"
"of bytes pointed to by @var{str} for @code{scm_from_latin1_stringn} and\n"
"@code{scm_from_utf8_stringn}; it is the number of elements (code points)\n"
"in @var{str} in the case of @code{scm_from_utf32_stringn}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:4493
msgid ""
"@deftypefn {C function} char *scm_to_latin1_stringn (SCM str, size_t *lenp)\n"
"@deftypefnx {C function} char *scm_to_utf8_stringn (SCM str, size_t *lenp)\n"
"@deftypefnx {C function} scm_t_wchar *scm_to_utf32_stringn (SCM str, size_t "
"*lenp)\n"
"Return a newly allocated, ISO-8859-1-, UTF-8-, or UTF-32-encoded C string\n"
"from Scheme string @var{str}.  An error is thrown when @var{str}\n"
"cannot be converted to the specified encoding.  If @var{lenp} is\n"
"@code{NULL}, the returned C string will be null terminated, and an error\n"
"will be thrown if the C string would otherwise contain null\n"
"characters.  If @var{lenp} is not @code{NULL}, the string is not null "
"terminated,\n"
"and the length of the returned string is returned in @var{lenp}.  The "
"length\n"
"returned is the number of bytes for @code{scm_to_latin1_stringn} and\n"
"@code{scm_to_utf8_stringn}; it is the number of elements (code points)\n"
"for @code{scm_to_utf32_stringn}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:4498
msgid ""
"It is not often the case, but sometimes when you are dealing with the\n"
"implementation details of a port, you need to encode and decode strings\n"
"according to the encoding and conversion strategy of the port.  There\n"
"are some convenience functions for that purpose as well."
msgstr ""

#: api-data.texi:4506
msgid ""
"@deftypefn {C Function} SCM scm_from_port_string (const char *str, SCM "
"port)\n"
"@deftypefnx {C Function} SCM scm_from_port_stringn (const char *str, size_t "
"len, SCM port)\n"
"@deftypefnx {C Function} char* scm_to_port_string (SCM str, SCM port)\n"
"@deftypefnx {C Function} char* scm_to_port_stringn (SCM str, size_t *lenp, "
"SCM port)\n"
"Like @code{scm_from_stringn} and friends, except they take their\n"
"encoding and conversion strategy from a given port object.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:4509
msgid ""
"@node String Internals\n"
"@subsubsection String Internals"
msgstr ""
"@node String Internals\n"
"@subsubsection Внутренности строки"

#: api-data.texi:4517
msgid ""
"Guile stores each string in memory as a contiguous array of Unicode code\n"
"points along with an associated set of attributes.  If all of the code\n"
"points of a string have an integer range between 0 and 255 inclusive,\n"
"the code point array is stored as one byte per code point: it is stored\n"
"as an ISO-8859-1 (aka Latin-1) string.  If any of the code points of the\n"
"string has an integer value greater that 255, the code point array is\n"
"stored as four bytes per code point: it is stored as a UTF-32 string."
msgstr ""
"Guile хранит каждую строку в памяти как непрерывный массив кодовых\n"
"точек Unicode связанных с набором атрибутов. Если все кодовые точки\n"
"имеют целочисленный диапазон от 0 до 255 включительно, массив кодовых\n"
"точек храниться как один байт на кодовую точку: такое сохранение является\n"
"строкой в коде ISO-8859-1 (т.е Latin-1).  Если какая-либо из кодовых\n"
"точек стороки имеет целочисленное значение больше 255, мвссив кодовых\n"
"точек храниться как четыре байта на кодовую точку: он сохраняется\n"
"как строка UTF-32."

#: api-data.texi:4521
msgid ""
"Conversion between the one-byte-per-code-point and\n"
"four-bytes-per-code-point representations happens automatically as\n"
"necessary."
msgstr ""
"Преобразование между представлениями в один байт на код и четыре\n"
"байта на кодовую точку происходит автоматически по мере необходимости."

#: api-data.texi:4527
msgid ""
"No API is provided to set the internal representation of strings;\n"
"however, there are pair of procedures available to query it.  These are\n"
"debugging procedures.  Using them in production code is discouraged,\n"
"since the details of Guile's internal representation of strings may\n"
"change from release to release."
msgstr ""
"API для установки внутреннего представления строк не предоставляется,\n"
"однако существуют две процедуры для доступа к ней. Это процедуры\n"
"отладки. Использовать их в рабочем коде крайне не рекомендуется,\n"
"так как детали внутреннего представления строк Guile могут измениться\n"
"в последующих выпусках."

#: api-data.texi:4533
msgid ""
"@deffn {Scheme Procedure} string-bytes-per-char str\n"
"@deffnx {C Function} scm_string_bytes_per_char (str)\n"
"Return the number of bytes used to encode a Unicode code point in string\n"
"@var{str}.  The result is one or four.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4539
msgid ""
"@deffn {Scheme Procedure} %string-dump str\n"
"@deffnx {C Function} scm_sys_string_dump (str)\n"
"Returns an association list containing debugging information for\n"
"@var{str}. The association list has the following entries.\n"
"@table @code"
msgstr ""

#: api-data.texi:4542
msgid ""
"@item string\n"
"The string itself."
msgstr ""

#: api-data.texi:4545
msgid ""
"@item start\n"
"The start index of the string into its stringbuf"
msgstr ""

#: api-data.texi:4548
msgid ""
"@item length\n"
"The length of the string"
msgstr ""

#: api-data.texi:4552
msgid ""
"@item shared\n"
"If this string is a substring, it returns its\n"
"parent string.  Otherwise, it returns @code{#f}"
msgstr ""

#: api-data.texi:4555
msgid ""
"@item read-only\n"
"@code{#t} if the string is read-only"
msgstr ""

#: api-data.texi:4558
msgid ""
"@item stringbuf-chars\n"
"A new string containing this string's stringbuf's characters"
msgstr ""

#: api-data.texi:4561
msgid ""
"@item stringbuf-length\n"
"The number of characters in this stringbuf"
msgstr ""

#: api-data.texi:4564
msgid ""
"@item stringbuf-shared\n"
"@code{#t} if this stringbuf is shared"
msgstr ""

#: api-data.texi:4570
msgid ""
"@item stringbuf-wide\n"
"@code{#t} if this stringbuf's characters are stored in a 32-bit buffer,\n"
"or @code{#f} if they are stored in an 8-bit buffer\n"
"@end table\n"
"@end deffn"
msgstr ""

#: api-data.texi:4575
msgid ""
"@node Symbols\n"
"@subsection Symbols\n"
"@tpindex Symbols"
msgstr ""
"@node Symbols\n"
"@subsection Символы\n"
"@tpindex Symbols"

#: api-data.texi:4579
msgid ""
"Symbols in Scheme are widely used in three ways: as items of discrete\n"
"data, as lookup keys for alists and hash tables, and to denote variable\n"
"references."
msgstr ""
"Символы в Scheme широко используются тремя способами: как элементы\n"
"дискретных данных, как ключи для поиска в ассоциативных списках alist\n"
"и хеш-таблиц, а также для обозначения ссылок на переменные."

#: api-data.texi:4588
msgid ""
"A @dfn{symbol} is similar to a string in that it is defined by a\n"
"sequence of characters.  The sequence of characters is known as the\n"
"symbol's @dfn{name}.  In the usual case --- that is, where the symbol's\n"
"name doesn't include any characters that could be confused with other\n"
"elements of Scheme syntax --- a symbol is written in a Scheme program by\n"
"writing the sequence of characters that make up the name, @emph{without}\n"
"any quotation marks or other special syntax.  For example, the symbol\n"
"whose name is ``multiply-by-2'' is written, simply:"
msgstr ""
"@dfn{Символ} похож на строку, поскольку она определяется "
"последовательностью\n"
"символов. Последовательность символов называется @dfn{Именем} символа.\n"
"В обычном случае, т.е когда имя символа не содержит букв, которые можно\n"
"было бы спутать с другими элементами синтаксиса Scheme --- символ\n"
"записывается в программе Scheme последовательностью букв(цифр и др. "
"символов),\n"
"которые составляют  имя, @emph{без кавычек} или какого другого специального\n"
"синтаксиса.  Например, символ имя которого ``multiply-by-2'' записывается,\n"
"просто:"

#: api-data.texi:4592
msgid ""
"@lisp\n"
"multiply-by-2\n"
"@end lisp"
msgstr ""

#: api-data.texi:4596
msgid ""
"Notice how this differs from a @emph{string} with contents\n"
"``multiply-by-2'', which is written with double quotation marks, like\n"
"this:"
msgstr ""
"Обратите внимание, что объявление отличается от @emph{строки} с содержимым\n"
"``multiply-by-2'', которое записано с двойными кавычками, например:"

#: api-data.texi:4600
msgid ""
"@lisp\n"
"\"multiply-by-2\"\n"
"@end lisp"
msgstr ""

#: api-data.texi:4603
msgid ""
"Looking beyond how they are written, symbols are different from strings\n"
"in two important respects."
msgstr ""
"Выходя за рамки того, как они описаны, символы отличаются от строк в двух\n"
"важных отношениях."

#: api-data.texi:4610
msgid ""
"The first important difference is uniqueness.  If the same-looking\n"
"string is read twice from two different places in a program, the result\n"
"is two @emph{different} string objects whose contents just happen to be\n"
"the same.  If, on the other hand, the same-looking symbol is read twice\n"
"from two different places in a program, the result is the @emph{same}\n"
"symbol object both times."
msgstr ""
"Первым важным отличием является уникальность. Если однотипная строка\n"
"читается дважды в двух разных местах программы, результатом будут\n"
"два разных строковых объекта, содержимое которых будет одно и тоже.\n"
"Если, с другой стороны, один и тот же символ читается дважды из двух\n"
"разных мест программы, результат будет один и тот же символьный объект."

#: api-data.texi:4618
msgid ""
"Given two read symbols, you can use @code{eq?} to test whether they are\n"
"the same (that is, have the same name).  @code{eq?} is the most\n"
"efficient comparison operator in Scheme, and comparing two symbols like\n"
"this is as fast as comparing, for example, two numbers.  Given two\n"
"strings, on the other hand, you must use @code{equal?} or\n"
"@code{string=?}, which are much slower comparison operators, to\n"
"determine whether the strings have the same contents."
msgstr ""
"Получив два прочитанных символа, вы можете использовать @code{eq?}\n"
"для проверки их идентичности (т.е имеют ли они одно и тоже имя).\n"
"Оператор @code{eq?} является наиболее эффективным оператором\n"
"сравнения в Scheme, и сравнивает два таких символа так же быстро\n"
"как сравнивают, например числа.  Получая две строки, с другой\n"
"стороны, вы должны использовать оператор @code{equal?} или\n"
"@code{string=?}, которые значительно медленне оператора eq,\n"
"что бы определить имеют строки одно и тоже содержимое."

#: api-data.texi:4623
msgid ""
"@lisp\n"
"(define sym1 (quote hello))\n"
"(define sym2 (quote hello))\n"
"(eq? sym1 sym2) @result{} #t"
msgstr ""

#: api-data.texi:4629
msgid ""
"(define str1 \"hello\")\n"
"(define str2 \"hello\")\n"
"(eq? str1 str2) @result{} #f\n"
"(equal? str1 str2) @result{} #t\n"
"@end lisp"
msgstr ""

#: api-data.texi:4636
msgid ""
"The second important difference is that symbols, unlike strings, are not\n"
"self-evaluating.  This is why we need the @code{(quote @dots{})}s in the\n"
"example above: @code{(quote hello)} evaluates to the symbol named\n"
"\"hello\" itself, whereas an unquoted @code{hello} is @emph{read} as the\n"
"symbol named \"hello\" and evaluated as a variable reference @dots{} about\n"
"which more below (@pxref{Symbol Variables})."
msgstr ""
"Второе важное отличие состоит в том, что символы, в отличие от строк,\n"
"не являются самовычисляемыми объектами.  Вот почему нам нужена операция\n"
"@code{(quote @dots{})}s в примере выше: @code{(quote hello)} блокирует\n"
"вычисление символа с именем \"hello\", тогда как бескавычек @code{hello}\n"
"@emph{читается} как символ с именем \"hello\" и вычисляется как ссылка\n"
"на переменную @dots{} о чем мы расскажем ниже (@pxref{Symbol Variables})."

#: api-data.texi:4646
msgid ""
"@menu\n"
"* Symbol Data::                 Symbols as discrete data.\n"
"* Symbol Keys::                 Symbols as lookup keys.\n"
"* Symbol Variables::            Symbols as denoting variables.\n"
"* Symbol Primitives::           Operations related to symbols.\n"
"* Symbol Props::                Function slots and property lists.\n"
"* Symbol Read Syntax::          Extended read syntax for symbols.\n"
"* Symbol Uninterned::           Uninterned symbols.\n"
"@end menu"
msgstr ""

#: api-data.texi:4650
msgid ""
"@node Symbol Data\n"
"@subsubsection Symbols as Discrete Data"
msgstr ""
"@node Symbol Data\n"
"@subsubsection Символ как дискретные данные"

#: api-data.texi:4655
msgid ""
"Numbers and symbols are similar to the extent that they both lend\n"
"themselves to @code{eq?} comparison.  But symbols are more descriptive\n"
"than numbers, because a symbol's name can be used directly to describe\n"
"the concept for which that symbol stands."
msgstr ""
"Числа и символы сходны в том отношении, что оба типа поддаются\n"
"сравнению с помощью  @code{eq?}.  Но символы более наглядны,\n"
"чем цифры, поэтому имя символа может использоваться непосредственно\n"
"для описания концепции, для которой используется этот символ."

#: api-data.texi:4660
msgid ""
"For example, imagine that you need to represent some colours in a\n"
"computer program.  Using numbers, you would have to choose arbitrarily\n"
"some mapping between numbers and colours, and then take care to use that\n"
"mapping consistently:"
msgstr ""
"Например, представьте, что вам нужно представить несколько цветов\n"
"в компьютерной программе. Используя числа, вы должны выбрать\n"
"произвольно некоторое сопоставление между числами и цветом, а затем\n"
"позаботиться о том, чтобы использовать это сопоставление корректно."

#: api-data.texi:4663
msgid ""
"@lisp\n"
";; 1=red, 2=green, 3=purple"
msgstr ""

#: api-data.texi:4667
msgid ""
"(if (eq? (colour-of vehicle) 1)\n"
"    ...)\n"
"@end lisp"
msgstr ""

#: api-data.texi:4671
msgid ""
"@noindent\n"
"You can make the mapping more explicit and the code more readable by\n"
"defining constants:"
msgstr ""
"@noindent\n"
"Вы можете сделать это сопоставление более явным, а код более читабельным,\n"
"определяя константы:"

#: api-data.texi:4676
msgid ""
"@lisp\n"
"(define red 1)\n"
"(define green 2)\n"
"(define purple 3)"
msgstr ""

#: api-data.texi:4680
msgid ""
"(if (eq? (colour-of vehicle) red)\n"
"    ...)\n"
"@end lisp"
msgstr ""

#: api-data.texi:4684
msgid ""
"@noindent\n"
"But the simplest and clearest approach is not to use numbers at all, but\n"
"symbols whose names specify the colours that they refer to:"
msgstr ""
"@noindent\n"
"Но самый простой и ясный подход - не испоьзовать числа вообще, а только\n"
"символы, чьи имена определяют цвета, на которые они ссылаются:"

#: api-data.texi:4689
msgid ""
"@lisp\n"
"(if (eq? (colour-of vehicle) 'red)\n"
"    ...)\n"
"@end lisp"
msgstr ""

#: api-data.texi:4693
msgid ""
"The descriptive advantages of symbols over numbers increase as the set\n"
"of concepts that you want to describe grows.  Suppose that a car object\n"
"can have other properties as well, such as whether it has or uses:"
msgstr ""
"Описательные преимущества символов над числами возрастают как набор\n"
"понятий, которые вы хотите описать. Предположим, что объект автомобиль,\n"
"может иметь и другие свойтсва, например имеет или использует:"

#: api-data.texi:4702
msgid ""
"@itemize @bullet\n"
"@item\n"
"automatic or manual transmission\n"
"@item\n"
"leaded or unleaded fuel\n"
"@item\n"
"power steering (or not).\n"
"@end itemize"
msgstr ""

#: api-data.texi:4706
msgid ""
"@noindent\n"
"Then a car's combined property set could be naturally represented and\n"
"manipulated as a list of symbols:"
msgstr ""
"@noindent\n"
"Тогда совокупный набор свойств автомобиля может быть представлен\n"
"естественным образом и управляться как список символов:"

#: api-data.texi:4711
msgid ""
"@lisp\n"
"(properties-of vehicle1)\n"
"@result{}\n"
"(red manual unleaded power-steering)"
msgstr ""

#: api-data.texi:4718
msgid ""
"(if (memq 'power-steering (properties-of vehicle1))\n"
"    (display \"Unfit people can drive this vehicle.\\n\")\n"
"    (display \"You'll need strong arms to drive this vehicle!\\n\"))\n"
"@print{}\n"
"Unfit people can drive this vehicle.\n"
"@end lisp"
msgstr ""

#: api-data.texi:4726
msgid ""
"Remember, the fundamental property of symbols that we are relying on\n"
"here is that an occurrence of @code{'red} in one part of a program is an\n"
"@emph{indistinguishable} symbol from an occurrence of @code{'red} in\n"
"another part of a program; this means that symbols can usefully be\n"
"compared using @code{eq?}.  At the same time, symbols have naturally\n"
"descriptive names.  This combination of efficiency and descriptive power\n"
"makes them ideal for use as discrete data."
msgstr ""
"Запомните, что основное свойство символов, на которое мы полагаеся, \n"
"состоит в том что появление @code{'red} в одной части программы\n"
"является неотличимым символом от появления @code{'red} в другой\n"
"части программы; это означает, что символы можно эффективно\n"
"сравнивать с использованием @code{eq?}.  В то же время символы\n"
"имеют естественные описательные имена.  Это сочетание эффективности\n"
"и описательной мощи делает их идельными для использования в качестве\n"
"дискретных данных."

#: api-data.texi:4730
msgid ""
"@node Symbol Keys\n"
"@subsubsection Symbols as Lookup Keys"
msgstr ""
"@node Symbol Keys\n"
"@subsubsection Символы как Ключи Поиска"

#: api-data.texi:4733
msgid ""
"Given their efficiency and descriptive power, it is natural to use\n"
"symbols as the keys in an association list or hash table."
msgstr ""
"Учитывая их эффективность и описательную силу, естественно использовать\n"
"символы в качестве ключей в ассоциативном списке или хеш-таблицах."

#: api-data.texi:4738
msgid ""
"To illustrate this, consider a more structured representation of the car\n"
"properties example from the preceding subsection.  Rather than\n"
"mixing all the properties up together in a flat list, we could use an\n"
"association list like this:"
msgstr ""
"Чтобы проилюстрировать это, рассмотрим более структурированное "
"представление\n"
"свойств автомобиля из предыдущего подраздела. Вместо того, чтобы смешивать\n"
"все свойства вместе в простом списке, мы могли бы использовать "
"ассоциативный\n"
"список следующим образом:"

#: api-data.texi:4745
msgid ""
"@lisp\n"
"(define car1-properties '((colour . red)\n"
"                          (transmission . manual)\n"
"                          (fuel . unleaded)\n"
"                          (steering . power-assisted)))\n"
"@end lisp"
msgstr ""

#: api-data.texi:4751
msgid ""
"Notice how this structure is more explicit and extensible than the flat\n"
"list.  For example it makes clear that @code{manual} refers to the\n"
"transmission rather than, say, the windows or the locking of the car.\n"
"It also allows further properties to use the same symbols among their\n"
"possible values without becoming ambiguous:"
msgstr ""
"Обратите внимание, что эта структура более ясная и расширяемая, чем\n"
"плоский список. Например он ясно показывает, что ручное относиться к\n"
"передаче, а не к окнам или блокировке автомобиля. Он также позволяет\n"
"другим свойствам использовать одни и те же символы среди своих возможных\n"
"значений, не становясь двусмысленными."

#: api-data.texi:4760
msgid ""
"@lisp\n"
"(define car1-properties '((colour . red)\n"
"                          (transmission . manual)\n"
"                          (fuel . unleaded)\n"
"                          (steering . power-assisted)\n"
"                          (seat-colour . red)\n"
"                          (locking . manual)))\n"
"@end lisp"
msgstr ""

#: api-data.texi:4764
msgid ""
"With a representation like this, it is easy to use the efficient\n"
"@code{assq-XXX} family of procedures (@pxref{Association Lists}) to\n"
"extract or change individual pieces of information:"
msgstr ""
"С таким представлением легко использовать эффективное семейство\n"
"процедур @code{assq-XXX} из списка операций с ассоцированными\n"
"списками (@pxref{Association Lists}) для извлечения или\n"
"изменения отдельных фрагментов информации:"

#: api-data.texi:4768
msgid ""
"@lisp\n"
"(assq-ref car1-properties 'fuel) @result{} unleaded\n"
"(assq-ref car1-properties 'transmission) @result{} manual"
msgstr ""

#: api-data.texi:4778
msgid ""
"(assq-set! car1-properties 'seat-colour 'black)\n"
"@result{}\n"
"((colour . red)\n"
" (transmission . manual)\n"
" (fuel . unleaded)\n"
" (steering . power-assisted)\n"
" (seat-colour . black)\n"
" (locking . manual)))\n"
"@end lisp"
msgstr ""

#: api-data.texi:4783
msgid ""
"Hash tables also have keys, and exactly the same arguments apply to the\n"
"use of symbols in hash tables as in association lists.  The hash value\n"
"that Guile uses to decide where to add a symbol-keyed entry to a hash\n"
"table can be obtained by calling the @code{symbol-hash} procedure:"
msgstr ""
"Хеш-таблицы также имеют ключи, и точно такие же аргументы применяются при\n"
"использовании символов в хеш-таблицах, как и в ассоциативных списках. \n"
"Хэш-значение, которое использует Guile, чтобы решить, где добавить запись\n"
"в виде символа в хеш-таблицу, можно получить, вызвав процедуру @code{symbol-"
"hash}\n"

#: api-data.texi:4788
msgid ""
"@deffn {Scheme Procedure} symbol-hash symbol\n"
"@deffnx {C Function} scm_symbol_hash (symbol)\n"
"Return a hash value for @var{symbol}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4792
msgid ""
"See @ref{Hash Tables} for information about hash tables in general, and\n"
"for why you might choose to use a hash table rather than an association\n"
"list."
msgstr ""
"Смотри @ref{Hash Tables} для получения информации о хеш-таблицах  и почему\n"
"лучше использовать хеш-таблицу, а не ассоциированный список."

#: api-data.texi:4796
msgid ""
"@node Symbol Variables\n"
"@subsubsection Symbols as Denoting Variables"
msgstr ""
"@node Symbol Variables\n"
"@subsubsection Символы, обозначающие Переменные"

#: api-data.texi:4800
msgid ""
"When an unquoted symbol in a Scheme program is evaluated, it is\n"
"interpreted as a variable reference, and the result of the evaluation is\n"
"the appropriate variable's value."
msgstr ""
"Когда вычисляется неквотируемый символ в пограмме  Scheme, он \n"
"интерпретируется как ссылка на переменную, а результат вычисления\n"
"--- значение соответствующей переменной.\n"

#: api-data.texi:4807
msgid ""
"For example, when the expression @code{(string-length \"abcd\")} is read\n"
"and evaluated, the sequence of characters @code{string-length} is read\n"
"as the symbol whose name is \"string-length\".  This symbol is associated\n"
"with a variable whose value is the procedure that implements string\n"
"length calculation.  Therefore evaluation of the @code{string-length}\n"
"symbol results in that procedure."
msgstr ""
"Например, когда выражение @code{(string-length \"abcd\")} считывается и\n"
"вычисляется, последовательность символов @code{string-length} считывается\n"
"как символ, имя которого \"string-length\".  Этот символ связан с "
"переменной,\n"
"значением которой является процедура, которая выполняет вычисление\n"
"длины стоки.  Поэтому вычисление @code{string-length} приводит к выполнению\n"
"этой процедуры."

#: api-data.texi:4813
msgid ""
"The details of the connection between an unquoted symbol and the\n"
"variable to which it refers are explained elsewhere.  See @ref{Binding\n"
"Constructs}, for how associations between symbols and variables are\n"
"created, and @ref{Modules}, for how those associations are affected by\n"
"Guile's module system."
msgstr ""
"Детали объединения символа без кавычек и переменной, отностися к другому\n"
"разделу. Смотри @ref{Binding Constructs}, для ознакомления как создаются\n"
"ассоциации между символами и переменными, и раздел @ref{Modules}, для\n"
"ознакомления как эти ассоциации влияют на модульную систему Guile."

#: api-data.texi:4817
msgid ""
"@node Symbol Primitives\n"
"@subsubsection Operations Related to Symbols"
msgstr ""
"@node Symbol Primitives\n"
"@subsubsection Операции связанные с символами"

#: api-data.texi:4820
msgid ""
"Given any Scheme value, you can determine whether it is a symbol using\n"
"the @code{symbol?} primitive:"
msgstr ""
"В любой Scheme, вы можете определить, является ли некий объект символом\n"
"используя примитив @code{symbol?}:"

#: api-data.texi:4827
msgid ""
"@rnindex symbol?\n"
"@deffn {Scheme Procedure} symbol? obj\n"
"@deffnx {C Function} scm_symbol_p (obj)\n"
"Return @code{#t} if @var{obj} is a symbol, otherwise return\n"
"@code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4831
msgid ""
"@deftypefn {C Function} int scm_is_symbol (SCM val)\n"
"Equivalent to @code{scm_is_true (scm_symbol_p (val))}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:4836
msgid ""
"Once you know that you have a symbol, you can obtain its name as a\n"
"string by calling @code{symbol->string}.  Note that Guile differs by\n"
"default from R5RS on the details of @code{symbol->string} as regards\n"
"case-sensitivity:"
msgstr ""

#: api-data.texi:4844
msgid ""
"@rnindex symbol->string\n"
"@deffn {Scheme Procedure} symbol->string s\n"
"@deffnx {C Function} scm_symbol_to_string (s)\n"
"Return the name of symbol @var{s} as a string.  By default, Guile reads\n"
"symbols case-sensitively, so the string returned will have the same case\n"
"variation as the sequence of characters that caused @var{s} to be\n"
"created."
msgstr ""

#: api-data.texi:4852
msgid ""
"If Guile is set to read symbols case-insensitively (as specified by\n"
"R5RS), and @var{s} comes into being as part of a literal expression\n"
"(@pxref{Literal expressions,,,r5rs, The Revised^5 Report on Scheme}) or\n"
"by a call to the @code{read} or @code{string-ci->symbol} procedures,\n"
"Guile converts any alphabetic characters in the symbol's name to\n"
"lower case before creating the symbol object, so the string returned\n"
"here will be in lower case."
msgstr ""

#: api-data.texi:4857
msgid ""
"If @var{s} was created by @code{string->symbol}, the case of characters\n"
"in the string returned will be the same as that in the string that was\n"
"passed to @code{string->symbol}, regardless of Guile's case-sensitivity\n"
"setting at the time @var{s} was created."
msgstr ""

#: api-data.texi:4861
msgid ""
"It is an error to apply mutation procedures like @code{string-set!} to\n"
"strings returned by this procedure.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4865
msgid ""
"Most symbols are created by writing them literally in code.  However it\n"
"is also possible to create symbols programmatically using the following\n"
"procedures:"
msgstr ""

#: api-data.texi:4869
msgid ""
"@deffn {Scheme Procedure} symbol char@dots{}\n"
"@rnindex symbol\n"
"Return a newly allocated symbol made from the given character arguments."
msgstr ""

#: api-data.texi:4874
msgid ""
"@example\n"
"(symbol #\\x #\\y #\\z) @result{} xyz\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:4878
msgid ""
"@deffn {Scheme Procedure} list->symbol lst\n"
"@rnindex list->symbol\n"
"Return a newly allocated symbol made from a list of characters."
msgstr ""

#: api-data.texi:4883
msgid ""
"@example\n"
"(list->symbol '(#\\a #\\b #\\c)) @result{} abc\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:4888
msgid ""
"@rnindex symbol-append\n"
"@deffn {Scheme Procedure} symbol-append arg @dots{}\n"
"Return a newly allocated symbol whose characters form the\n"
"concatenation of the given symbols, @var{arg} @enddots{}."
msgstr ""

#: api-data.texi:4895
msgid ""
"@example\n"
"(let ((h 'hello))\n"
"  (symbol-append h 'world))\n"
"@result{} helloworld\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:4905
msgid ""
"@rnindex string->symbol\n"
"@deffn {Scheme Procedure} string->symbol string\n"
"@deffnx {C Function} scm_string_to_symbol (string)\n"
"Return the symbol whose name is @var{string}.  This procedure can create\n"
"symbols with names containing special characters or letters in the\n"
"non-standard case, but it is usually a bad idea to create such symbols\n"
"because in some implementations of Scheme they cannot be read as\n"
"themselves.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4912
msgid ""
"@deffn {Scheme Procedure} string-ci->symbol str\n"
"@deffnx {C Function} scm_string_ci_to_symbol (str)\n"
"Return the symbol whose name is @var{str}.  If Guile is currently\n"
"reading symbols case-insensitively, @var{str} is converted to lowercase\n"
"before the returned symbol is looked up or created.\n"
"@end deffn"
msgstr ""

#: api-data.texi:4915
msgid ""
"The following examples illustrate Guile's detailed behaviour as regards\n"
"the case-sensitivity of symbols:"
msgstr ""

#: api-data.texi:4918
msgid ""
"@lisp\n"
"(read-enable 'case-insensitive)   ; R5RS compliant behaviour"
msgstr ""

#: api-data.texi:4923
msgid ""
"(symbol->string 'flying-fish)    @result{} \"flying-fish\"\n"
"(symbol->string 'Martin)         @result{} \"martin\"\n"
"(symbol->string\n"
"   (string->symbol \"Malvina\"))   @result{} \"Malvina\""
msgstr ""

#: api-data.texi:4932
msgid ""
"(eq? 'mISSISSIppi 'mississippi)  @result{} #t\n"
"(string->symbol \"mISSISSIppi\")   @result{} mISSISSIppi\n"
"(eq? 'bitBlt (string->symbol \"bitBlt\")) @result{} #f\n"
"(eq? 'LolliPop\n"
"  (string->symbol (symbol->string 'LolliPop))) @result{} #t\n"
"(string=? \"K. Harper, M.D.\"\n"
"  (symbol->string\n"
"    (string->symbol \"K. Harper, M.D.\"))) @result{} #t"
msgstr ""

#: api-data.texi:4934
msgid "(read-disable 'case-insensitive)   ; Guile default behaviour"
msgstr ""

#: api-data.texi:4939
msgid ""
"(symbol->string 'flying-fish)    @result{} \"flying-fish\"\n"
"(symbol->string 'Martin)         @result{} \"Martin\"\n"
"(symbol->string\n"
"   (string->symbol \"Malvina\"))   @result{} \"Malvina\""
msgstr ""

#: api-data.texi:4949
msgid ""
"(eq? 'mISSISSIppi 'mississippi)  @result{} #f\n"
"(string->symbol \"mISSISSIppi\")   @result{} mISSISSIppi\n"
"(eq? 'bitBlt (string->symbol \"bitBlt\")) @result{} #t\n"
"(eq? 'LolliPop\n"
"  (string->symbol (symbol->string 'LolliPop))) @result{} #t\n"
"(string=? \"K. Harper, M.D.\"\n"
"  (symbol->string\n"
"    (string->symbol \"K. Harper, M.D.\"))) @result{} #t\n"
"@end lisp"
msgstr ""

#: api-data.texi:4952
msgid ""
"From C, there are lower level functions that construct a Scheme symbol\n"
"from a C string in the current locale encoding."
msgstr ""

#: api-data.texi:4956
msgid ""
"When you want to do more from C, you should convert between symbols\n"
"and strings using @code{scm_symbol_to_string} and\n"
"@code{scm_string_to_symbol} and work with the strings."
msgstr ""

#: api-data.texi:4963
msgid ""
"@deftypefn {C Function} SCM scm_from_latin1_symbol (const char *name)\n"
"@deftypefnx {C Function} SCM scm_from_utf8_symbol (const char *name)\n"
"Construct and return a Scheme symbol whose name is specified by the\n"
"null-terminated C string @var{name}.  These are appropriate when\n"
"the C string is hard-coded in the source code.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:4970
msgid ""
"@deftypefn {C Function} SCM scm_from_locale_symbol (const char *name)\n"
"@deftypefnx {C Function} SCM scm_from_locale_symboln (const char *name, "
"size_t len)\n"
"Construct and return a Scheme symbol whose name is specified by\n"
"@var{name}.  For @code{scm_from_locale_symbol}, @var{name} must be null\n"
"terminated; for @code{scm_from_locale_symboln} the length of @var{name} is\n"
"specified explicitly by @var{len}."
msgstr ""

#: api-data.texi:4977
msgid ""
"Note that these functions should @emph{not} be used when @var{name} is a\n"
"C string constant, because there is no guarantee that the current locale\n"
"will match that of the execution character set, used for string and\n"
"character constants.  Most modern C compilers use UTF-8 by default, so\n"
"in such cases we recommend @code{scm_from_utf8_symbol}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:4986
msgid ""
"@deftypefn  {C Function} SCM scm_take_locale_symbol (char *str)\n"
"@deftypefnx {C Function} SCM scm_take_locale_symboln (char *str, size_t "
"len)\n"
"Like @code{scm_from_locale_symbol} and @code{scm_from_locale_symboln},\n"
"respectively, but also frees @var{str} with @code{free} eventually.\n"
"Thus, you can use this function when you would free @var{str} anyway\n"
"immediately after creating the Scheme string.  In certain cases, Guile\n"
"can then use @var{str} directly as its internal representation.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:4988
msgid "The size of a symbol can also be obtained from C:"
msgstr ""

#: api-data.texi:4992
msgid ""
"@deftypefn {C Function} size_t scm_c_symbol_length (SCM sym)\n"
"Return the number of characters in @var{sym}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:4996
msgid ""
"Finally, some applications, especially those that generate new Scheme\n"
"code dynamically, need to generate symbols for use in the generated\n"
"code.  The @code{gensym} primitive meets this need:"
msgstr ""
"Наконец, некоторым приложениям, особенно тем, кторые генерируют новый\n"
"код схемы Scheme динамически, необходимо создавать символы для \n"
"использования в сгенерированном коде. Примитив @code{gensym} \n"
"позволяет это сделать:"

#: api-data.texi:5004
msgid ""
"@deffn {Scheme Procedure} gensym [prefix]\n"
"@deffnx {C Function} scm_gensym (prefix)\n"
"Create a new symbol with a name constructed from a prefix and a counter\n"
"value.  The string @var{prefix} can be specified as an optional\n"
"argument.  Default prefix is @samp{@w{ g}}.  The counter is increased by 1\n"
"at each call.  There is no provision for resetting the counter.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5011
msgid ""
"The symbols generated by @code{gensym} are @emph{likely} to be unique,\n"
"since their names begin with a space and it is only otherwise possible\n"
"to generate such symbols if a programmer goes out of their way to do\n"
"so.  Uniqueness can be guaranteed by instead using uninterned symbols\n"
"(@pxref{Symbol Uninterned}), though they can't be usefully written out\n"
"and read back in."
msgstr ""
"Символы, генерируемые @code{gensym} скорее всего будут уникальными,\n"
"поскольку их имена начинабются с пробелов, и неуникальными если\n"
"программист найдет способ создать подобные символы. Уникальность\n"
"может быть гарантирована, вместо этого, использванием\n"
"неинтерминированных символов (@pxref{Symbol Uninterned}), хоти\n"
"они не могут быть корректно выведены и считаны обратно."

#: api-data.texi:5015
msgid ""
"@node Symbol Props\n"
"@subsubsection Function Slots and Property Lists"
msgstr ""
"@node Symbol Props\n"
"@subsubsection Функциональные слоты и Списки Свойств"

#: api-data.texi:5018
msgid ""
"In traditional Lisp dialects, symbols are often understood as having\n"
"three kinds of value at once:"
msgstr ""
"В традиционных диалектах Lisp, символы часто понимаются как имеющие\n"
"одновременно три вида значений:"

#: api-data.texi:5023
msgid ""
"@itemize @bullet\n"
"@item\n"
"a @dfn{variable} value, which is used when the symbol appears in\n"
"code in a variable reference context"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"значение переменной@dfn{variable}, которое используется, когда\n"
"символ отображается в контексте кода как ссылка на переменную."

#: api-data.texi:5028
msgid ""
"@item\n"
"a @dfn{function} value, which is used when the symbol appears in\n"
"code in a function name position (i.e.@: as the first element in an\n"
"unquoted list)"
msgstr ""
"@item\n"
"Значение функции @dfn{function}, которое используется, когда символ\n"
"появляется в коде в имени функции (т.е @: как первый элемент в\n"
"неквотируемом списке)"

#: api-data.texi:5033
msgid ""
"@item\n"
"a @dfn{property list} value, which is used when the symbol is given as\n"
"the first argument to Lisp's @code{put} or @code{get} functions.\n"
"@end itemize"
msgstr ""
"@item\n"
"Значение списка свойств@dfn{property list}, которое используется, когда\n"
"символ указан в качестве первого аргумента для функции Lisp @code{put}\n"
"или @code{get}.\n"
"@end itemize"

#: api-data.texi:5039
msgid ""
"Although Scheme (as one of its simplifications with respect to Lisp)\n"
"does away with the distinction between variable and function namespaces,\n"
"Guile currently retains some elements of the traditional structure in\n"
"case they turn out to be useful when implementing translators for other\n"
"languages, in particular Emacs Lisp."
msgstr ""
"Хотя Scheme (как одно из упрощений в отошении Lisp) убирает различия\n"
"между пространствами имен переменных и функций, в настоящее время \n"
"Guile сохраняет некоторые элементы традиционной структуры в случае \n"
"если они окажутся полезными при реализации перевода для других\n"
"языков, в частности Emacs Lisp."

#: api-data.texi:5043
msgid ""
"Specifically, Guile symbols have two extra slots, one for a symbol's\n"
"property list, and one for its ``function value.''  The following "
"procedures\n"
"are provided to access these slots."
msgstr ""
"В частности, символы Guile имеют два дополнительных слота: один для\n"
"символа списка свойств и один для ``значения функции''. Для доступа\n"
"к этим слотам предоставляются следующие процедуры."

#: api-data.texi:5048
msgid ""
"@deffn {Scheme Procedure} symbol-fref symbol\n"
"@deffnx {C Function} scm_symbol_fref (symbol)\n"
"Return the contents of @var{symbol}'s @dfn{function slot}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5053
msgid ""
"@deffn {Scheme Procedure} symbol-fset! symbol value\n"
"@deffnx {C Function} scm_symbol_fset_x (symbol, value)\n"
"Set the contents of @var{symbol}'s function slot to @var{value}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5058
msgid ""
"@deffn {Scheme Procedure} symbol-pref symbol\n"
"@deffnx {C Function} scm_symbol_pref (symbol)\n"
"Return the @dfn{property list} currently associated with @var{symbol}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5063
msgid ""
"@deffn {Scheme Procedure} symbol-pset! symbol value\n"
"@deffnx {C Function} scm_symbol_pset_x (symbol, value)\n"
"Set @var{symbol}'s property list to @var{value}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5072
msgid ""
"@deffn {Scheme Procedure} symbol-property sym prop\n"
"From @var{sym}'s property list, return the value for property\n"
"@var{prop}.  The assumption is that @var{sym}'s property list is an\n"
"association list whose keys are distinguished from each other using\n"
"@code{equal?}; @var{prop} should be one of the keys in that list.  If\n"
"the property list has no entry for @var{prop}, @code{symbol-property}\n"
"returns @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5079
msgid ""
"@deffn {Scheme Procedure} set-symbol-property! sym prop val\n"
"In @var{sym}'s property list, set the value for property @var{prop} to\n"
"@var{val}, or add a new entry for @var{prop}, with value @var{val}, if\n"
"none already exists.  For the structure of the property list, see\n"
"@code{symbol-property}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5085
msgid ""
"@deffn {Scheme Procedure} symbol-property-remove! sym prop\n"
"From @var{sym}'s property list, remove the entry for property\n"
"@var{prop}, if there is one.  For the structure of the property list,\n"
"see @code{symbol-property}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5089
msgid ""
"Support for these extra slots may be removed in a future release, and it\n"
"is probably better to avoid using them.  For a more modern and Schemely\n"
"approach to properties, see @ref{Object Properties}."
msgstr ""
"Поддержка этих дополнительных слотов может быть удалена в будущих\n"
"версиях, поэтому лучше избегать их использования. Для более\n"
"современного и комплексного подхода к свойствам см \n"
"@ref{Object Properties}."

#: api-data.texi:5093
msgid ""
"@node Symbol Read Syntax\n"
"@subsubsection Extended Read Syntax for Symbols"
msgstr ""
"@node Symbol Read Syntax\n"
"@subsubsection Синтаксис Расширенного Чтения для Символов"

#: api-data.texi:5095
msgid "@cindex r7rs-symbols"
msgstr ""

#: api-data.texi:5101
msgid ""
"The read syntax for a symbol is a sequence of letters, digits, and\n"
"@dfn{extended alphabetic characters}, beginning with a character that\n"
"cannot begin a number.  In addition, the special cases of @code{+},\n"
"@code{-}, and @code{...} are read as symbols even though numbers can\n"
"begin with @code{+}, @code{-} or @code{.}."
msgstr ""
"Синтаксисом для чтения символов является последовательность букв,\n"
"цифр и расширенного алфавита символов, начинающегося с символа\n"
"с которого не может начинаться число.  Кроме того, символы\n"
"@code{+}, @code{-}, и @code{...} представляют собой особый случай,\n"
"и считаются символами, хотя числа могут начинаться с  @code{+}, \n"
"@code{-} или @code{.}."

#: api-data.texi:5104
msgid ""
"Extended alphabetic characters may be used within identifiers as if\n"
"they were letters.  The set of extended alphabetic characters is:"
msgstr ""
"Расширенные буквенные символы могут использваться в идентификаторах,\n"
"как если бы они были буквами. Набор расширенных буквенных символов:"

#: api-data.texi:5108
msgid ""
"@example\n"
"! $ % & * + - . / : < = > ? @@ ^ _ ~\n"
"@end example"
msgstr ""

#: api-data.texi:5115
msgid ""
"In addition to the standard read syntax defined above (which is taken\n"
"from R5RS (@pxref{Formal syntax,,,r5rs,The Revised^5 Report on\n"
"Scheme})), Guile provides an extended symbol read syntax that allows the\n"
"inclusion of unusual characters such as space characters, newlines and\n"
"parentheses.  If (for whatever reason) you need to write a symbol\n"
"containing characters not mentioned above, you can do so as follows."
msgstr ""
"В дополнение к стандартному синтаксису чтения определенному выше(который "
"взят\n"
"из R5RS (@pxref{Formal syntax,,,r5rs,The Revised^5 Report on Scheme})), "
"Guile\n"
"предоставляет расширенный синтаксис чтения символов, который позволяет\n"
"включать необычные символы, такие как символы пробела, новой строки и "
"круглые\n"
"скобки. Если (по какой-либо причине) вам нужно написать символ, содержащий\n"
"буквы, не упомянутые выше, вы можете сделать это следующим образом."

#: api-data.texi:5119
msgid ""
"@itemize @bullet\n"
"@item\n"
"Begin the symbol with the characters @code{#@{},"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"Начните символ с сочетания симолов @code{#@{},"

#: api-data.texi:5122
msgid ""
"@item\n"
"write the characters of the symbol and"
msgstr ""
"@item\n"
"напишите буквы имени символа и"

#: api-data.texi:5126
msgid ""
"@item\n"
"finish the symbol with the characters @code{@}#}.\n"
"@end itemize"
msgstr ""
"@item\n"
"завершите имя символа сочетанием символов @code{@}#}.\n"
"@end itemize"

#: api-data.texi:5131
msgid ""
"Here are a few examples of this form of read syntax.  The first symbol\n"
"needs to use extended syntax because it contains a space character, the\n"
"second because it contains a line break, and the last because it looks\n"
"like a number."
msgstr ""
"Вот несколько примеров использования этой формы синтаксиса чтения.\n"
"Первый символ должен использовать расширенный синтаксис, поскольку он \n"
"содержит пробельный символ. Второй - потому что он содержит символ \n"
"line break, и последний, потому что он похож на число."

#: api-data.texi:5134
msgid ""
"@lisp\n"
"#@{foo bar@}#"
msgstr ""

#: api-data.texi:5137
msgid ""
"#@{what\n"
"ever@}#"
msgstr ""

#: api-data.texi:5140
msgid ""
"#@{4242@}#\n"
"@end lisp"
msgstr ""

#: api-data.texi:5144
msgid ""
"Although Guile provides this extended read syntax for symbols,\n"
"widespread usage of it is discouraged because it is not portable and not\n"
"very readable."
msgstr ""

#: api-data.texi:5149
msgid ""
"Alternatively, if you enable the @code{r7rs-symbols} read option (see\n"
"@pxref{Scheme Read}), you can write arbitrary symbols using the same\n"
"notation used for strings, except delimited by vertical bars instead of\n"
"double quotes."
msgstr ""

#: api-data.texi:5155
msgid ""
"@example\n"
"|foo bar|\n"
"|\\x3BB; is a greek lambda|\n"
"|\\| is a vertical bar|\n"
"@end example"
msgstr ""

#: api-data.texi:5159
msgid ""
"Note that there's also an @code{r7rs-symbols} print option\n"
"(@pxref{Scheme Write}).  To enable the use of this notation, evaluate\n"
"one or both of the following expressions:"
msgstr ""

#: api-data.texi:5164
msgid ""
"@example\n"
"(read-enable  'r7rs-symbols)\n"
"(print-enable 'r7rs-symbols)\n"
"@end example"
msgstr ""

#: api-data.texi:5168
msgid ""
"@node Symbol Uninterned\n"
"@subsubsection Uninterned Symbols"
msgstr ""
"@node Symbol Uninterned\n"
"@subsubsection Уникальные(uninterned) символы"

#: api-data.texi:5175
msgid ""
"What makes symbols useful is that they are automatically kept unique.\n"
"There are no two symbols that are distinct objects but have the same\n"
"name.  But of course, there is no rule without exception.  In addition\n"
"to the normal symbols that have been discussed up to now, you can also\n"
"create special @dfn{uninterned} symbols that behave slightly\n"
"differently."
msgstr ""
"Что делает символы полезными, так это то, что они автоматически\n"
"сохраняются уникальными. нет двух символов, которые являются\n"
"отдельными объектами и имеют одинаковое имя. Но конечно нет\n"
"правила без исключения. В дополнении к обычным символам, которые\n"
"обсуждались до сих пор, вы так же можете создавать специальные\n"
"неограниченные символы, которые ведут себя несколько иначе."

#: api-data.texi:5178
msgid ""
"To understand what is different about them and why they might be useful,\n"
"we look at how normal symbols are actually kept unique."
msgstr ""
"Чтобы понять, чем эти символы отличаются и почему они полезны, мы\n"
"посмотрим, как обычные символы сохраняют свою уникальность."

#: api-data.texi:5185
msgid ""
"Whenever Guile wants to find the symbol with a specific name, for\n"
"example during @code{read} or when executing @code{string->symbol}, it\n"
"first looks into a table of all existing symbols to find out whether a\n"
"symbol with the given name already exists.  When this is the case, Guile\n"
"just returns that symbol.  When not, a new symbol with the name is\n"
"created and entered into the table so that it can be found later."
msgstr ""
"Всякий раз когда Guile необходимо найти символ с определенным именем,\n"
"например во время четения @code{read} или при выполнении функции\n"
"@code{string->symbol}, он сначала просматривает таблицу всех \n"
"существующих символов, чтобы найти символ с указанным именем.\n"
"Когда такой символ найден, Guile просто возвращает этот символ.\n"
"Когда нет, создается новый символ с именем и вводиться в таблицу,\n"
"чтобы его можно было найти позже."

#: api-data.texi:5193
msgid ""
"Sometimes you might want to create a symbol that is guaranteed `fresh',\n"
"i.e.@: a symbol that did not exist previously.  You might also want to\n"
"somehow guarantee that no one else will ever unintentionally stumble\n"
"across your symbol in the future.  These properties of a symbol are\n"
"often needed when generating code during macro expansion.  When\n"
"introducing new temporary variables, you want to guarantee that they\n"
"don't conflict with variables in other people's code."
msgstr ""
"Иногда вам может понадобиться создать символ, который был бы гарантированно\n"
"`новым', т.е ранее не существовал. Вы также можете както гарантировать, "
"что \n"
"никто другой когда-нибудь непреднамеренно не пересечется с вашим символом\n"
"в будущем. Эти свойства символу часто необходимы при создании кода во время\n"
"расширения макроса. При введении новых временных переменных, вы хотите\n"
"гарантировать, что они не будут конфликтовать с переменными в коде других\n"
"людей."

#: api-data.texi:5199
msgid ""
"The simplest way to arrange for this is to create a new symbol but\n"
"not enter it into the global table of all symbols.  That way, no one\n"
"will ever get access to your symbol by chance.  Symbols that are not in\n"
"the table are called @dfn{uninterned}.  Of course, symbols that\n"
"@emph{are} in the table are called @dfn{interned}."
msgstr ""
"Самый простой способ организовать это - создать новый символ, но\n"
"не вводить его в глобальную таблицу всех символов. Таким образом,\n"
"никто никогда не получит доступ к вашему символу случайно. Символы\n"
"которые не указаны в таблице, называются @dfn{uninterned}.  Конечно\n"
"символы находящиеся в таблице называются @dfn{интернированными(interned)}."

#: api-data.texi:5203
msgid ""
"You create new uninterned symbols with the function @code{make-symbol}.\n"
"You can test whether a symbol is interned or not with\n"
"@code{symbol-interned?}."
msgstr ""
"Вы можете создать новый uninterned символ функцией @code{make-symbol}.\n"
"Вы можете проверить является ли символ интернированным или нет\n"
"функцией @code{symbol-interned?}."

#: api-data.texi:5209
msgid ""
"Uninterned symbols break the rule that the name of a symbol uniquely\n"
"identifies the symbol object.  Because of this, they can not be written\n"
"out and read back in like interned symbols.  Currently, Guile has no\n"
"support for reading uninterned symbols.  Note that the function\n"
"@code{gensym} does not return uninterned symbols for this reason."
msgstr ""
"Uninterned символы нарушают правило, согласно которому имя символа\n"
"однозначно идентифицирует символьный объект.  Из-за этого они\n"
"не могуть быть выведены и прочитаны обратно, как интернированные\n"
"символы. В настоящее время Guile не поддерживает чтение uninterned \n"
"символов.  Обратите внимание, что функция @code{gensym} не возвращает\n"
"uninterned символов по этой причине."

#: api-data.texi:5216
msgid ""
"@deffn {Scheme Procedure} make-symbol name\n"
"@deffnx {C Function} scm_make_symbol (name)\n"
"Return a new uninterned symbol with the name @var{name}.  The returned\n"
"symbol is guaranteed to be unique and future calls to\n"
"@code{string->symbol} will not return it.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5222
msgid ""
"@deffn {Scheme Procedure} symbol-interned? symbol\n"
"@deffnx {C Function} scm_symbol_interned_p (symbol)\n"
"Return @code{#t} if @var{symbol} is interned, otherwise return\n"
"@code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5224
msgctxt "api-data.texi:5224"
msgid "For example:"
msgstr ""

#: api-data.texi:5230
msgid ""
"@lisp\n"
"(define foo-1 (string->symbol \"foo\"))\n"
"(define foo-2 (string->symbol \"foo\"))\n"
"(define foo-3 (make-symbol \"foo\"))\n"
"(define foo-4 (make-symbol \"foo\"))"
msgstr ""

#: api-data.texi:5234
msgid ""
"(eq? foo-1 foo-2)\n"
"@result{} #t\n"
"; Two interned symbols with the same name are the same object,"
msgstr ""

#: api-data.texi:5239
msgid ""
"(eq? foo-1 foo-3)\n"
"@result{} #f\n"
"; but a call to make-symbol with the same name returns a\n"
"; distinct object."
msgstr ""

#: api-data.texi:5244
msgid ""
"(eq? foo-3 foo-4)\n"
"@result{} #f\n"
"; A call to make-symbol always returns a new object, even for\n"
"; the same name."
msgstr ""

#: api-data.texi:5248
msgid ""
"foo-3\n"
"@result{} #<uninterned-symbol foo 8085290>\n"
"; Uninterned symbols print differently from interned symbols,"
msgstr ""

#: api-data.texi:5252
msgid ""
"(symbol? foo-3)\n"
"@result{} #t\n"
"; but they are still symbols,"
msgstr ""

#: api-data.texi:5257
msgid ""
"(symbol-interned? foo-3)\n"
"@result{} #f\n"
"; just not interned.\n"
"@end lisp"
msgstr ""

#: api-data.texi:5262
msgid ""
"@node Keywords\n"
"@subsection Keywords\n"
"@tpindex Keywords"
msgstr ""
"@node Keywords\n"
"@subsection Ключевые слова\n"
"@tpindex Keywords"

#: api-data.texi:5265
msgid ""
"Keywords are self-evaluating objects with a convenient read syntax that\n"
"makes them easy to type."
msgstr ""
"Ключевые слова являются самовычислимым объектом с удобным синтаксисом\n"
"чтения, что упращает их печать."

#: api-data.texi:5269
msgid ""
"Guile's keyword support conforms to R5RS, and adds a (switchable) read\n"
"syntax extension to permit keywords to begin with @code{:} as well as\n"
"@code{#:}, or to end with @code{:}."
msgstr ""
"Поддержка ключевых слов Guile соответствует R5RS, и добавляет\n"
"(с возможностью переключения) расширение синтаксиса чтения чтобы\n"
"разрешить начинаться ключевым словам с @code{:} а так же с\n"
"@code{#:}, или завершаться  @code{:}."

#: api-data.texi:5276
msgid ""
"@menu\n"
"* Why Use Keywords?::           Motivation for keyword usage.\n"
"* Coding With Keywords::        How to use keywords.\n"
"* Keyword Read Syntax::         Read syntax for keywords.\n"
"* Keyword Procedures::          Procedures for dealing with keywords.\n"
"@end menu"
msgstr ""

#: api-data.texi:5279
msgid ""
"@node Why Use Keywords?\n"
"@subsubsection Why Use Keywords?"
msgstr ""
"@node Why Use Keywords?\n"
"@subsubsection Зачем использовать ключевые слова?"

#: api-data.texi:5283
msgid ""
"Keywords are useful in contexts where a program or procedure wants to be\n"
"able to accept a large number of optional arguments without making its\n"
"interface unmanageable."
msgstr ""
"Ключевые слова полезны в контексте, где программе или процедуре необходимо\n"
"принимать большое количество необязательных аргументов, не делая интерфес\n"
"к процедуре неуправляемым."

#: api-data.texi:5289
msgid ""
"To illustrate this, consider a hypothetical @code{make-window}\n"
"procedure, which creates a new window on the screen for drawing into\n"
"using some graphical toolkit.  There are many parameters that the caller\n"
"might like to specify, but which could also be sensibly defaulted, for\n"
"example:"
msgstr ""
"Чтобы проилюстрировать это, рассмотрим гипотетическую процедуру\n"
"создания окна  @code{make-window}, которая создает новое окно\n"
"на экране для рисования с использованием какого либо графического\n"
"инструментария. Здесь очень много параметров, которые вызывающий\n"
"может пожелать указать, но которые также могуть быть установлены\n"
"поумолчанию, Например:"

#: api-data.texi:5293
msgid ""
"@itemize @bullet\n"
"@item\n"
"color depth -- Default: the color depth for the screen"
msgstr ""

#: api-data.texi:5296
msgid ""
"@item\n"
"background color -- Default: white"
msgstr ""

#: api-data.texi:5299
msgid ""
"@item\n"
"width -- Default: 600"
msgstr ""

#: api-data.texi:5303
msgid ""
"@item\n"
"height -- Default: 400\n"
"@end itemize"
msgstr ""

#: api-data.texi:5308
msgid ""
"If @code{make-window} did not use keywords, the caller would have to\n"
"pass in a value for each possible argument, remembering the correct\n"
"argument order and using a special value to indicate the default value\n"
"for that argument:"
msgstr ""
"Если в процедуре  @code{make-window} не использовались ключевые слова,\n"
"вызывающий должен был бы передать значение для каждого возможного\n"
"аргумента, соблюдая правильный порядок аргументов и используя\n"
"специальные значения для указания на значение по умолчанию для\n"
"этого аргумента."

#: api-data.texi:5316
msgid ""
"@lisp\n"
"(make-window 'default              ;; Color depth\n"
"             'default              ;; Background color\n"
"             800                   ;; Width\n"
"             100                   ;; Height\n"
"             @dots{})                  ;; More make-window arguments\n"
"@end lisp"
msgstr ""

#: api-data.texi:5320
msgid ""
"With keywords, on the other hand, defaulted arguments are omitted, and\n"
"non-default arguments are clearly tagged by the appropriate keyword.  As\n"
"a result, the invocation becomes much clearer:"
msgstr ""
"С ключевыми словами, с другой стороны, дефолтные аргументы опускаются,\n"
"а аргументы не по умолчанию четко помечены соответствующими ключевыми\n"
"словами. В результате вызов становиться намного яснее:"

#: api-data.texi:5324
msgid ""
"@lisp\n"
"(make-window #:width 800 #:height 100)\n"
"@end lisp"
msgstr ""

#: api-data.texi:5329
msgid ""
"On the other hand, for a simpler procedure with few arguments, the use\n"
"of keywords would be a hindrance rather than a help.  The primitive\n"
"procedure @code{cons}, for example, would not be improved if it had to\n"
"be invoked as"
msgstr ""
"С другой стороны, для простой процедуры с несколькими аргументами\n"
"использование ключевых слов было бы помехой, а не помощью. Например,\n"
"примитивные процедуры, не следует улучшать вот так:"

#: api-data.texi:5333
msgid ""
"@lisp\n"
"(cons #:car x #:cdr y)\n"
"@end lisp"
msgstr ""

#: api-data.texi:5336
msgid ""
"So the decision whether to use keywords or not is purely pragmatic: use\n"
"them if they will clarify the procedure invocation at point of call."
msgstr ""
"Поэтому решение о том, использовать ли ключевые слова или нет, чисто\n"
"прогматичное: используйте их, если они будут разъяснять вызов \n"
"процедуры в точке вызова."

#: api-data.texi:5339
msgid ""
"@node Coding With Keywords\n"
"@subsubsection Coding With Keywords"
msgstr ""
"@node Coding With Keywords\n"
"@subsubsection Кодирование с использованием ключевых слов"

#: api-data.texi:5343
msgid ""
"If a procedure wants to support keywords, it should take a rest argument\n"
"and then use whatever means is convenient to extract keywords and their\n"
"corresponding arguments from the contents of that rest argument."
msgstr ""
"Если процедуре необходимо поддерживать ключевые слова, она должна принять\n"
"последний аргумент, а затем использовать любые удобные средства для "
"извлечения\n"
"ключевых слов и их соответствующих аргументов из содержимого этого\n"
"последнего аргумента."

#: api-data.texi:5348
msgid ""
"The following example illustrates the principle: the code for\n"
"@code{make-window} uses a helper procedure called\n"
"@code{get-keyword-value} to extract individual keyword arguments from\n"
"the rest argument."
msgstr ""

#: api-data.texi:5355
msgid ""
"@lisp\n"
"(define (get-keyword-value args keyword default)\n"
"  (let ((kv (memq keyword args)))\n"
"    (if (and kv (>= (length kv) 2))\n"
"        (cadr kv)\n"
"        default)))"
msgstr ""

#: api-data.texi:5364
msgid ""
"(define (make-window . args)\n"
"  (let ((depth  (get-keyword-value args #:depth  screen-depth))\n"
"        (bg     (get-keyword-value args #:bg     \"white\"))\n"
"        (width  (get-keyword-value args #:width  800))\n"
"        (height (get-keyword-value args #:height 100))\n"
"        @dots{})\n"
"    @dots{}))\n"
"@end lisp"
msgstr ""

#: api-data.texi:5368
msgid ""
"But you don't need to write @code{get-keyword-value}.  The @code{(ice-9\n"
"optargs)} module provides a set of powerful macros that you can use to\n"
"implement keyword-supporting procedures like this:"
msgstr ""
"Но вам не нужно создавать @code{get-keyword-value}.  Модуль @code{(ice-9\n"
"optargs)} поставляет набор мощных макросов, которые можно использовать\n"
"для реализации процедур поддержки работы с ключевыми словами, таких как:"

#: api-data.texi:5371
msgctxt "api-data.texi:5371"
msgid ""
"@lisp\n"
"(use-modules (ice-9 optargs))"
msgstr ""

#: api-data.texi:5379
msgid ""
"(define (make-window . args)\n"
"  (let-keywords args #f ((depth  screen-depth)\n"
"                         (bg     \"white\")\n"
"                         (width  800)\n"
"                         (height 100))\n"
"    ...))\n"
"@end lisp"
msgstr ""

#: api-data.texi:5382
msgid ""
"@noindent\n"
"Or, even more economically, like this:"
msgstr ""
"@noindent\n"
"Или, еще более экономно, вот так:"

#: api-data.texi:5385
msgctxt "api-data.texi:5385"
msgid ""
"@lisp\n"
"(use-modules (ice-9 optargs))"
msgstr ""

#: api-data.texi:5392
msgid ""
"(define* (make-window #:key (depth  screen-depth)\n"
"                            (bg     \"white\")\n"
"                            (width  800)\n"
"                            (height 100))\n"
"  ...)\n"
"@end lisp"
msgstr ""

#: api-data.texi:5396
msgid ""
"For further details on @code{let-keywords}, @code{define*} and other\n"
"facilities provided by the @code{(ice-9 optargs)} module, see\n"
"@ref{Optional Arguments}."
msgstr ""
"Для получения дополнительной информации о @code{let-keywords}, "
"@code{define*} \n"
"и других возможностях поставляемых модулем @code{(ice-9 optargs)}, смотри\n"
"@ref{Optional Arguments}."

#: api-data.texi:5399
msgid ""
"To handle keyword arguments from procedures implemented in C,\n"
"use @code{scm_c_bind_keyword_arguments} (@pxref{Keyword Procedures})."
msgstr ""
"Чтобы обрабатывать аргументы ключевых слов из процедур реализованных\n"
"на Си, используйте @code{scm_c_bind_keyword_arguments} \n"
"(@pxref{Keyword Procedures})."

#: api-data.texi:5402
msgid ""
"@node Keyword Read Syntax\n"
"@subsubsection Keyword Read Syntax"
msgstr ""
"@node Keyword Read Syntax\n"
"@subsubsection Синтаксис чтения Ключевых Слов"

#: api-data.texi:5410
msgid ""
"Guile, by default, only recognizes a keyword syntax that is compatible\n"
"with R5RS.  A token of the form @code{#:NAME}, where @code{NAME} has the\n"
"same syntax as a Scheme symbol (@pxref{Symbol Read Syntax}), is the\n"
"external representation of the keyword named @code{NAME}.  Keyword\n"
"objects print using this syntax as well, so values containing keyword\n"
"objects can be read back into Guile.  When used in an expression,\n"
"keywords are self-quoting objects."
msgstr ""
"Guile, по умолчанию, распознает только синтаксис ключевых слов, \n"
"совместимый с  R5RS.  Токен формы @code{#:NAME}, где @code{NAME} \n"
"имеет тот же синтаксис, что и символы Scheme (@pxref{Symbol Read Syntax}),\n"
"является внешним представлением ключевого слова с именем @code{NAME}.\n"
"Кроме того, объекты ключевые слова печатются с использованием этого\n"
"синтаксиса, поэтому значения, содержащие объекты ключых слов, могут\n"
"быть прочитаными Guile.  При использовании в выражении ключевые слова\n"
"являются самоквотирующимися выражениями."

#: api-data.texi:5414
msgid ""
"If the @code{keywords} read option is set to @code{'prefix}, Guile also\n"
"recognizes the alternative read syntax @code{:NAME}.  Otherwise, tokens\n"
"of the form @code{:NAME} are read as symbols, as required by R5RS."
msgstr ""
"Если для параметра чтения ключевых слов @code{keywords} устновлено\n"
"значение префикс @code{'prefix}, Guile также распрознает альтернативный\n"
"синтаксис чтения @code{:NAME}.  В противном случае маркеры формы @code{:"
"NAME}\n"
"считаются символами, как это требует R5RS."

#: api-data.texi:5416
msgid "@cindex SRFI-88 keyword syntax"
msgstr ""

#: api-data.texi:5420
msgid ""
"If the @code{keywords} read option is set to @code{'postfix}, Guile\n"
"recognizes the SRFI-88 read syntax @code{NAME:} (@pxref{SRFI-88}).\n"
"Otherwise, tokens of this form are read as symbols."
msgstr ""
"Если для параметра чтения ключевого слова @code{keywords} установлено\n"
"значение @code{'postfix}, Guile распознает синтаксис чтения SRFI-88 \n"
"@code{NAME:} (@pxref{SRFI-88}).\n"
"В противном случае токены этой формы читаются как символы."

#: api-data.texi:5424
msgid ""
"To enable and disable the alternative non-R5RS keyword syntax, you use\n"
"the @code{read-set!} procedure documented @ref{Scheme Read}.  Note that\n"
"the @code{prefix} and @code{postfix} syntax are mutually exclusive."
msgstr ""
"Чтобы включить или отключить альтернативный синтаксис чтения ключевых\n"
"слов, отличный от R5RS, используйте процедуру @code{read-set!} описанную\n"
"@ref{Scheme Read}.  Обратите внимание синтаксисы @code{prefix} и \n"
"@code{postfix} являются взаимоисключающими."

#: api-data.texi:5427
msgid ""
"@lisp\n"
"(read-set! keywords 'prefix)"
msgstr ""

#: api-data.texi:5431
msgctxt "api-data.texi:5431"
msgid ""
"#:type\n"
"@result{}\n"
"#:type"
msgstr ""

#: api-data.texi:5435
msgid ""
":type\n"
"@result{}\n"
"#:type"
msgstr ""

#: api-data.texi:5437
msgid "(read-set! keywords 'postfix)"
msgstr ""

#: api-data.texi:5441
msgid ""
"type:\n"
"@result{}\n"
"#:type"
msgstr ""

#: api-data.texi:5445
msgid ""
":type\n"
"@result{}\n"
":type"
msgstr ""

#: api-data.texi:5447
msgid "(read-set! keywords #f)"
msgstr ""

#: api-data.texi:5451
msgctxt "api-data.texi:5451"
msgid ""
"#:type\n"
"@result{}\n"
"#:type"
msgstr ""

#: api-data.texi:5458
msgid ""
":type\n"
"@print{}\n"
"ERROR: In expression :type:\n"
"ERROR: Unbound variable: :type\n"
"ABORT: (unbound-variable)\n"
"@end lisp"
msgstr ""

#: api-data.texi:5461
msgid ""
"@node Keyword Procedures\n"
"@subsubsection Keyword Procedures"
msgstr ""
"@node Keyword Procedures\n"
"@subsubsection Процедуры работы с Ключевыми Словами"

#: api-data.texi:5467
msgid ""
"@deffn {Scheme Procedure} keyword? obj\n"
"@deffnx {C Function} scm_keyword_p (obj)\n"
"Return @code{#t} if the argument @var{obj} is a keyword, else\n"
"@code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5472
msgid ""
"@deffn {Scheme Procedure} keyword->symbol keyword\n"
"@deffnx {C Function} scm_keyword_to_symbol (keyword)\n"
"Return the symbol with the same name as @var{keyword}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5477
msgid ""
"@deffn {Scheme Procedure} symbol->keyword symbol\n"
"@deffnx {C Function} scm_symbol_to_keyword (symbol)\n"
"Return the keyword with the same name as @var{symbol}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5481
msgid ""
"@deftypefn {C Function} int scm_is_keyword (SCM obj)\n"
"Equivalent to @code{scm_is_true (scm_keyword_p (@var{obj}))}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:5487
msgid ""
"@deftypefn {C Function} SCM scm_from_locale_keyword (const char *name)\n"
"@deftypefnx {C Function} SCM scm_from_locale_keywordn (const char *name, "
"size_t len)\n"
"Equivalent to @code{scm_symbol_to_keyword (scm_from_locale_symbol\n"
"(@var{name}))} and @code{scm_symbol_to_keyword (scm_from_locale_symboln\n"
"(@var{name}, @var{len}))}, respectively."
msgstr ""

#: api-data.texi:5494
msgid ""
"Note that these functions should @emph{not} be used when @var{name} is a\n"
"C string constant, because there is no guarantee that the current locale\n"
"will match that of the execution character set, used for string and\n"
"character constants.  Most modern C compilers use UTF-8 by default, so\n"
"in such cases we recommend @code{scm_from_utf8_keyword}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:5501
msgid ""
"@deftypefn {C Function} SCM scm_from_latin1_keyword (const char *name)\n"
"@deftypefnx {C Function} SCM scm_from_utf8_keyword (const char *name)\n"
"Equivalent to @code{scm_symbol_to_keyword (scm_from_latin1_symbol\n"
"(@var{name}))} and @code{scm_symbol_to_keyword (scm_from_utf8_symbol\n"
"(@var{name}))}, respectively.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:5508
msgid ""
"@deftypefn {C Function} void scm_c_bind_keyword_arguments (const char *subr, "
"@\n"
"                             SCM rest, scm_t_keyword_arguments_flags flags, "
"@\n"
"                             SCM keyword1, SCM *argp1, @\n"
"                             @dots{}, @\n"
"                             SCM keywordN, SCM *argpN, @\n"
"                             @nicode{SCM_UNDEFINED})"
msgstr ""

#: api-data.texi:5517
msgid ""
"Extract the specified keyword arguments from @var{rest}, which is not\n"
"modified.  If the keyword argument @var{keyword1} is present in\n"
"@var{rest} with an associated value, that value is stored in the\n"
"variable pointed to by @var{argp1}, otherwise the variable is left\n"
"unchanged.  Similarly for the other keywords and argument pointers up to\n"
"@var{keywordN} and @var{argpN}.  The argument list to\n"
"@code{scm_c_bind_keyword_arguments} must be terminated by\n"
"@code{SCM_UNDEFINED}."
msgstr ""

#: api-data.texi:5524
msgid ""
"Note that since the variables pointed to by @var{argp1} through\n"
"@var{argpN} are left unchanged if the associated keyword argument is not\n"
"present, they should be initialized to their default values before\n"
"calling @code{scm_c_bind_keyword_arguments}.  Alternatively, you can\n"
"initialize them to @code{SCM_UNDEFINED} before the call, and then use\n"
"@code{SCM_UNBNDP} after the call to see which ones were provided."
msgstr ""

#: api-data.texi:5531
msgid ""
"If an unrecognized keyword argument is present in @var{rest} and\n"
"@var{flags} does not contain @code{SCM_ALLOW_OTHER_KEYS}, or if\n"
"non-keyword arguments are present and @var{flags} does not contain\n"
"@code{SCM_ALLOW_NON_KEYWORD_ARGUMENTS}, an exception is raised.\n"
"@var{subr} should be the name of the procedure receiving the keyword\n"
"arguments, for purposes of error reporting."
msgstr ""

#: api-data.texi:5533
msgctxt "api-data.texi:5533"
msgid "For example:"
msgstr ""

#: api-data.texi:5538
msgid ""
"@example\n"
"SCM k_delimiter;\n"
"SCM k_grammar;\n"
"SCM sym_infix;"
msgstr ""

#: api-data.texi:5543
msgid ""
"SCM my_string_join (SCM strings, SCM rest)\n"
"@{\n"
"  SCM delimiter = SCM_UNDEFINED;\n"
"  SCM grammar   = sym_infix;"
msgstr ""

#: api-data.texi:5548
msgid ""
"  scm_c_bind_keyword_arguments (\"my-string-join\", rest, 0,\n"
"                                k_delimiter, &delimiter,\n"
"                                k_grammar, &grammar,\n"
"                                SCM_UNDEFINED);"
msgstr ""

#: api-data.texi:5551
msgid ""
"  if (SCM_UNBNDP (delimiter))\n"
"    delimiter = scm_from_utf8_string (\" \");"
msgstr ""

#: api-data.texi:5554
msgid ""
"  return scm_string_join (strings, delimiter, grammar);\n"
"@}"
msgstr ""

#: api-data.texi:5564
msgid ""
"void my_init ()\n"
"@{\n"
"  k_delimiter = scm_from_utf8_keyword (\"delimiter\");\n"
"  k_grammar   = scm_from_utf8_keyword (\"grammar\");\n"
"  sym_infix   = scm_from_utf8_symbol  (\"infix\");\n"
"  scm_c_define_gsubr (\"my-string-join\", 1, 0, 1, my_string_join);\n"
"@}\n"
"@end example\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:5569
msgid ""
"@node Pairs\n"
"@subsection Pairs\n"
"@tpindex Pairs"
msgstr ""
"@node Pairs\n"
"@subsection Пары\n"
"@tpindex Pairs"

#: api-data.texi:5572
msgid ""
"Pairs are used to combine two Scheme objects into one compound object.\n"
"Hence the name: A pair stores a pair of objects."
msgstr ""
"Пары используются для объединения двух объектов Scheme в один\n"
"составной объект.\n"
"Отсюда и название: Пара хранит пару объектов."

#: api-data.texi:5578
msgid ""
"The data type @dfn{pair} is extremely important in Scheme, just like in\n"
"any other Lisp dialect.  The reason is that pairs are not only used to\n"
"make two values available as one object, but that pairs are used for\n"
"constructing lists of values.  Because lists are so important in Scheme,\n"
"they are described in a section of their own (@pxref{Lists})."
msgstr ""
"Тип данных Пара @dfn{pair} чрезвычайно важен в Scheme, как и в любом\n"
"другом диалекте Lisp.  Причина в том, что пары используются не только\n"
"для того чтобы сделать два значения доступными как один объект, но\n"
"эти пары используются для построения списков значений.  Поскольку\n"
"списки так важны в Scheme, они описаны в отдельном разделе \n"
"(@pxref{Lists})."

#: api-data.texi:5587
msgid ""
"Pairs can literally get entered in source code or at the REPL, in the\n"
"so-called @dfn{dotted list} syntax.  This syntax consists of an opening\n"
"parentheses, the first element of the pair, a dot, the second element\n"
"and a closing parentheses.  The following example shows how a pair\n"
"consisting of the two numbers 1 and 2, and a pair containing the symbols\n"
"@code{foo} and @code{bar} can be entered.  It is very important to write\n"
"the whitespace before and after the dot, because otherwise the Scheme\n"
"parser would not be able to figure out where to split the tokens."
msgstr ""
"Пары могут буквально вводиться в исходный код или в REPL, в так называемом\n"
"точечном синтаксисе списка @dfn{dotted list}.  Этот синтаксис состоит из\n"
"открывающей круглой скобки, первого элемента пары, точки, второго элемента,\n"
"закрывающей круглой скобки.  В следующем примере показано, формирование \n"
"пары из двух чисел 1 и 2, и пары содержащей символы @code{foo} и "
"@code{bar}.\n"
"Очень важно писать пробелы до и после точки, потому что в противном случае\n"
"анализатор Scheme не сможет определить, где разделять токены."

#: api-data.texi:5592
msgid ""
"@lisp\n"
"(1 . 2)\n"
"(foo . bar)\n"
"@end lisp"
msgstr ""

#: api-data.texi:5597
msgid ""
"But beware, if you want to try out these examples, you have to\n"
"@dfn{quote} the expressions.  More information about quotation is\n"
"available in the section @ref{Expression Syntax}.  The correct way\n"
"to try these examples is as follows."
msgstr ""
"Но будьте осторожны, если вы хотите попробовать эти примеры, вам\n"
"нужно квотировать@dfn{quote} эти выражения.  Более подробную информацию\n"
"можно найти в разделе @ref{Expression Syntax}.  Правильный способ\n"
"использовать эти примеры состоит в следующем."

#: api-data.texi:5606
msgid ""
"@lisp\n"
"'(1 . 2)\n"
"@result{}\n"
"(1 . 2)\n"
"'(foo . bar)\n"
"@result{}\n"
"(foo . bar)\n"
"@end lisp"
msgstr ""

#: api-data.texi:5612
msgid ""
"A new pair is made by calling the procedure @code{cons} with two\n"
"arguments.  Then the argument values are stored into a newly allocated\n"
"pair, and the pair is returned.  The name @code{cons} stands for\n"
"\"construct\".  Use the procedure @code{pair?} to test whether a\n"
"given Scheme object is a pair or not."
msgstr ""
"Новая пара создается путем вызова процедуры @code{cons} с двумя\n"
"аргументами.  Затем значения аргументов сохраняются во вновь\n"
"выделенную пару, и пара возвращается.  Имя @code{cons} означает\n"
"\"Конструировать(construct)\".  Используйте процедуру @code{pair?}\n"
"что бы проверить является ли данный объект Scheme парой или нет."

#: api-data.texi:5620
msgid ""
"@rnindex cons\n"
"@deffn {Scheme Procedure} cons x y\n"
"@deffnx {C Function} scm_cons (x, y)\n"
"Return a newly allocated pair whose car is @var{x} and whose\n"
"cdr is @var{y}.  The pair is guaranteed to be different (in the\n"
"sense of @code{eq?}) from every previously existing object.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5627
msgid ""
"@rnindex pair?\n"
"@deffn {Scheme Procedure} pair? x\n"
"@deffnx {C Function} scm_pair_p (x)\n"
"Return @code{#t} if @var{x} is a pair; otherwise return\n"
"@code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5631
msgid ""
"@deftypefn {C Function} int scm_is_pair (SCM x)\n"
"Return 1 when @var{x} is a pair; otherwise return 0.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:5636
msgid ""
"The two parts of a pair are traditionally called @dfn{car} and\n"
"@dfn{cdr}.  They can be retrieved with procedures of the same name\n"
"(@code{car} and @code{cdr}), and can be modified with the procedures\n"
"@code{set-car!} and @code{set-cdr!}."
msgstr ""

#: api-data.texi:5643
msgid ""
"Since a very common operation in Scheme programs is to access the car of\n"
"a car of a pair, or the car of the cdr of a pair, etc., the procedures\n"
"called @code{caar}, @code{cadr} and so on are also predefined.  However,\n"
"using these procedures is often detrimental to readability, and\n"
"error-prone.  Thus, accessing the contents of a list is usually better\n"
"achieved using pattern matching techniques (@pxref{Pattern Matching})."
msgstr ""

#: api-data.texi:5652
msgid ""
"@rnindex car\n"
"@rnindex cdr\n"
"@deffn {Scheme Procedure} car pair\n"
"@deffnx {Scheme Procedure} cdr pair\n"
"@deffnx {C Function} scm_car (pair)\n"
"@deffnx {C Function} scm_cdr (pair)\n"
"Return the car or the cdr of @var{pair}, respectively.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5658
msgid ""
"@deftypefn  {C Macro} SCM SCM_CAR (SCM pair)\n"
"@deftypefnx {C Macro} SCM SCM_CDR (SCM pair)\n"
"These two macros are the fastest way to access the car or cdr of a\n"
"pair; they can be thought of as compiling into a single memory\n"
"reference."
msgstr ""

#: api-data.texi:5662
msgid ""
"These macros do no checking at all.  The argument @var{pair} must be a\n"
"valid pair.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:5721
msgid ""
"@deffn  {Scheme Procedure} cddr pair\n"
"@deffnx {Scheme Procedure} cdar pair\n"
"@deffnx {Scheme Procedure} cadr pair\n"
"@deffnx {Scheme Procedure} caar pair\n"
"@deffnx {Scheme Procedure} cdddr pair\n"
"@deffnx {Scheme Procedure} cddar pair\n"
"@deffnx {Scheme Procedure} cdadr pair\n"
"@deffnx {Scheme Procedure} cdaar pair\n"
"@deffnx {Scheme Procedure} caddr pair\n"
"@deffnx {Scheme Procedure} cadar pair\n"
"@deffnx {Scheme Procedure} caadr pair\n"
"@deffnx {Scheme Procedure} caaar pair\n"
"@deffnx {Scheme Procedure} cddddr pair\n"
"@deffnx {Scheme Procedure} cdddar pair\n"
"@deffnx {Scheme Procedure} cddadr pair\n"
"@deffnx {Scheme Procedure} cddaar pair\n"
"@deffnx {Scheme Procedure} cdaddr pair\n"
"@deffnx {Scheme Procedure} cdadar pair\n"
"@deffnx {Scheme Procedure} cdaadr pair\n"
"@deffnx {Scheme Procedure} cdaaar pair\n"
"@deffnx {Scheme Procedure} cadddr pair\n"
"@deffnx {Scheme Procedure} caddar pair\n"
"@deffnx {Scheme Procedure} cadadr pair\n"
"@deffnx {Scheme Procedure} cadaar pair\n"
"@deffnx {Scheme Procedure} caaddr pair\n"
"@deffnx {Scheme Procedure} caadar pair\n"
"@deffnx {Scheme Procedure} caaadr pair\n"
"@deffnx {Scheme Procedure} caaaar pair\n"
"@deffnx {C Function} scm_cddr (pair)\n"
"@deffnx {C Function} scm_cdar (pair)\n"
"@deffnx {C Function} scm_cadr (pair)\n"
"@deffnx {C Function} scm_caar (pair)\n"
"@deffnx {C Function} scm_cdddr (pair)\n"
"@deffnx {C Function} scm_cddar (pair)\n"
"@deffnx {C Function} scm_cdadr (pair)\n"
"@deffnx {C Function} scm_cdaar (pair)\n"
"@deffnx {C Function} scm_caddr (pair)\n"
"@deffnx {C Function} scm_cadar (pair)\n"
"@deffnx {C Function} scm_caadr (pair)\n"
"@deffnx {C Function} scm_caaar (pair)\n"
"@deffnx {C Function} scm_cddddr (pair)\n"
"@deffnx {C Function} scm_cdddar (pair)\n"
"@deffnx {C Function} scm_cddadr (pair)\n"
"@deffnx {C Function} scm_cddaar (pair)\n"
"@deffnx {C Function} scm_cdaddr (pair)\n"
"@deffnx {C Function} scm_cdadar (pair)\n"
"@deffnx {C Function} scm_cdaadr (pair)\n"
"@deffnx {C Function} scm_cdaaar (pair)\n"
"@deffnx {C Function} scm_cadddr (pair)\n"
"@deffnx {C Function} scm_caddar (pair)\n"
"@deffnx {C Function} scm_cadadr (pair)\n"
"@deffnx {C Function} scm_cadaar (pair)\n"
"@deffnx {C Function} scm_caaddr (pair)\n"
"@deffnx {C Function} scm_caadar (pair)\n"
"@deffnx {C Function} scm_caaadr (pair)\n"
"@deffnx {C Function} scm_caaaar (pair)\n"
"These procedures are compositions of @code{car} and @code{cdr}, where\n"
"for example @code{caddr} could be defined by"
msgstr ""

#: api-data.texi:5725
msgid ""
"@lisp\n"
"(define caddr (lambda (x) (car (cdr (cdr x)))))\n"
"@end lisp"
msgstr ""

#: api-data.texi:5731
msgid ""
"@code{cadr}, @code{caddr} and @code{cadddr} pick out the second, third\n"
"or fourth elements of a list, respectively.  SRFI-1 provides the same\n"
"under the names @code{second}, @code{third} and @code{fourth}\n"
"(@pxref{SRFI-1 Selectors}).\n"
"@end deffn"
msgstr ""

#: api-data.texi:5738
msgid ""
"@rnindex set-car!\n"
"@deffn {Scheme Procedure} set-car! pair value\n"
"@deffnx {C Function} scm_set_car_x (pair, value)\n"
"Stores @var{value} in the car field of @var{pair}.  The value returned\n"
"by @code{set-car!} is unspecified.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5745
msgid ""
"@rnindex set-cdr!\n"
"@deffn {Scheme Procedure} set-cdr! pair value\n"
"@deffnx {C Function} scm_set_cdr_x (pair, value)\n"
"Stores @var{value} in the cdr field of @var{pair}.  The value returned\n"
"by @code{set-cdr!} is unspecified.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5750
msgid ""
"@node Lists\n"
"@subsection Lists\n"
"@tpindex Lists"
msgstr ""
"@node Lists\n"
"@subsection Списки\n"
"@tpindex Lists"

#: api-data.texi:5756
msgid ""
"A very important data type in Scheme---as well as in all other Lisp\n"
"dialects---is the data type @dfn{list}.@footnote{Strictly speaking,\n"
"Scheme does not have a real datatype @dfn{list}.  Lists are made up of\n"
"@dfn{chained pairs}, and only exist by definition---a list is a chain\n"
"of pairs which looks like a list.}"
msgstr ""
"Очень важным типом данных в Scheme, а также во всех других диалектах\n"
"Lisp, является тип данных типа Список@dfn{list}.@footnote{Строго говоря,\n"
"Scheme не имеет реально сущетствующего типа данных @dfn{list}.  Список "
"представляет\n"
"собой @dfn{цепочки пар(chained pairs)}, и используется только как "
"определение ---\n"
"список это цепочка пар выглядящая как список.}"

#: api-data.texi:5758
msgid "This is the short definition of what a list is:"
msgstr "Это краткое определение того, что такое список:"

#: api-data.texi:5762
msgid ""
"@itemize @bullet\n"
"@item\n"
"Either the empty list @code{()},"
msgstr ""
"@itemize @bullet\n"
"@item\n"
"Либо пустой список @code{()},"

#: api-data.texi:5766
msgid ""
"@item\n"
"or a pair which has a list in its cdr.\n"
"@end itemize"
msgstr ""
"@item\n"
"либо пара, которая имеет списко в своем cdr.\n"
"@end itemize"

#: api-data.texi:5768
msgid "@c FIXME::martin: Describe the pair chaining in more detail."
msgstr ""

#: api-data.texi:5771
msgid ""
"@c FIXME::martin: What is a proper, what an improper list?\n"
"@c What is a circular list?"
msgstr ""

#: api-data.texi:5774
msgid ""
"@c FIXME::martin: Maybe steal some graphics from the Elisp reference \n"
"@c manual?"
msgstr ""

#: api-data.texi:5785
msgid ""
"@menu\n"
"* List Syntax::                 Writing literal lists.\n"
"* List Predicates::             Testing lists.\n"
"* List Constructors::           Creating new lists.\n"
"* List Selection::              Selecting from lists, getting their length.\n"
"* Append/Reverse::              Appending and reversing lists.\n"
"* List Modification::           Modifying existing lists.\n"
"* List Searching::              Searching for list elements\n"
"* List Mapping::                Applying procedures to lists.\n"
"@end menu"
msgstr ""

#: api-data.texi:5788
msgid ""
"@node List Syntax\n"
"@subsubsection List Read Syntax"
msgstr ""
"@node List Syntax\n"
"@subsubsection Синтаксис чтения Списка"

#: api-data.texi:5793
msgid ""
"The syntax for lists is an opening parentheses, then all the elements of\n"
"the list (separated by whitespace) and finally a closing\n"
"parentheses.@footnote{Note that there is no separation character between\n"
"the list elements, like a comma or a semicolon.}."
msgstr ""
"Синтаксис списка - это открывающая круглая скобка, затем все элементы "
"списка\n"
"(разделяемые пробелами) и наконец, закрывающая круглая скобка.\n"
"@footnote{Обратите внимание, что между элементами списка нет "
"разделительного\n"
"символа, например запятой или точки с запятой.}."

#: api-data.texi:5799
msgid ""
"@lisp\n"
"(1 2 3)            ; @r{a list of the numbers 1, 2 and 3}\n"
"(\"foo\" bar 3.1415) ; @r{a string, a symbol and a real number}\n"
"()                 ; @r{the empty list}\n"
"@end lisp"
msgstr ""

#: api-data.texi:5804
msgid ""
"The last example needs a bit more explanation.  A list with no elements,\n"
"called the @dfn{empty list}, is special in some ways.  It is used for\n"
"terminating lists by storing it into the cdr of the last pair that makes\n"
"up a list.  An example will clear that up:"
msgstr ""
"В последнем примере требуется немного объяснений. Список без элементов,\n"
"называемый Пустой список @dfn{empty list}, используется особенным образом.\n"
"Он используется для завершения списков, сохраняя его в  cdr последнй пары,\n"
"составляющих список.  Приведем пример:"

#: api-data.texi:5813
msgid ""
"@lisp\n"
"(car '(1))\n"
"@result{}\n"
"1\n"
"(cdr '(1))\n"
"@result{}\n"
"()\n"
"@end lisp"
msgstr ""

#: api-data.texi:5818
msgid ""
"This example also shows that lists have to be quoted when written\n"
"(@pxref{Expression Syntax}), because they would otherwise be\n"
"mistakingly taken as procedure applications (@pxref{Simple\n"
"Invocation})."
msgstr ""
"Этот пример также показывает. что списки должны квотироваться \n"
"при записи(@pxref{Expression Syntax}), потому что иначе они \n"
"были бы ошибочно приняты как вызов процедуры (@pxref{Simple\n"
"Invocation})."

#: api-data.texi:5822
msgid ""
"@node List Predicates\n"
"@subsubsection List Predicates"
msgstr ""
"@node List Predicates\n"
"@subsubsection Списковые предикаты"

#: api-data.texi:5827
msgid ""
"Often it is useful to test whether a given Scheme object is a list or\n"
"not.  List-processing procedures could use this information to test\n"
"whether their input is valid, or they could do different things\n"
"depending on the datatype of their arguments."
msgstr ""
"Часто полезно проверить, является ли данный объект Scheme списком\n"
"или нет. Процедуры Обработки Списков могут использовать эту \n"
"информацию, чтобы проверить, действительно ли им на вход подали \n"
"список, или они могут выполнять различные действия в зависимости\n"
"от типа данных аргументов."

#: api-data.texi:5833
msgid ""
"@rnindex list?\n"
"@deffn {Scheme Procedure} list? x\n"
"@deffnx {C Function} scm_list_p (x)\n"
"Return @code{#t} if @var{x} is a proper list, else @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5838
msgid ""
"The predicate @code{null?} is often used in list-processing code to\n"
"tell whether a given list has run out of elements.  That is, a loop\n"
"somehow deals with the elements of a list until the list satisfies\n"
"@code{null?}.  Then, the algorithm terminates."
msgstr ""

#: api-data.texi:5844
msgid ""
"@rnindex null?\n"
"@deffn {Scheme Procedure} null? x\n"
"@deffnx {C Function} scm_null_p (x)\n"
"Return @code{#t} if @var{x} is the empty list, else @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5848
msgid ""
"@deftypefn {C Function} int scm_is_null (SCM x)\n"
"Return 1 when @var{x} is the empty list; otherwise return 0.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:5852
msgid ""
"@node List Constructors\n"
"@subsubsection List Constructors"
msgstr ""
"@node List Constructors\n"
"@subsubsection Конструкторы Списков"

#: api-data.texi:5857
msgid ""
"This section describes the procedures for constructing new lists.\n"
"@code{list} simply returns a list where the elements are the arguments,\n"
"@code{cons*} is similar, but the last argument is stored in the cdr of\n"
"the last pair of the list."
msgstr ""
"В этом разделе описываются процедуры построения новых списков.\n"
"Функция @code{list} просто возвращает список, переданных ей\n"
"аргументов, аналогично работает @code{cons*}, но последний\n"
"аргумент сохраняется в cdr последней пары списка."

#: api-data.texi:5871
msgid ""
"@c  C Function scm_list(rest) used to be documented here, but it's a\n"
"@c  no-op since it does nothing but return the list the caller must\n"
"@c  have already created.\n"
"@c\n"
"@deffn {Scheme Procedure} list elem @dots{}\n"
"@deffnx {C Function} scm_list_1 (elem1)\n"
"@deffnx {C Function} scm_list_2 (elem1, elem2)\n"
"@deffnx {C Function} scm_list_3 (elem1, elem2, elem3)\n"
"@deffnx {C Function} scm_list_4 (elem1, elem2, elem3, elem4)\n"
"@deffnx {C Function} scm_list_5 (elem1, elem2, elem3, elem4, elem5)\n"
"@deffnx {C Function} scm_list_n (elem1, @dots{}, elemN, "
"@nicode{SCM_UNDEFINED})\n"
"@rnindex list\n"
"Return a new list containing elements @var{elem} @enddots{}."
msgstr ""

#: api-data.texi:5878
msgid ""
"@code{scm_list_n} takes a variable number of arguments, terminated by\n"
"the special @code{SCM_UNDEFINED}.  That final @code{SCM_UNDEFINED} is\n"
"not included in the list.  None of @var{elem} @dots{} can\n"
"themselves be @code{SCM_UNDEFINED}, or @code{scm_list_n} will\n"
"terminate at that point.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5892
msgid ""
"@c  C Function scm_cons_star(arg1,rest) used to be documented here,\n"
"@c  but it's not really a useful interface, since it expects the\n"
"@c  caller to have already consed up all but the first argument\n"
"@c  already.\n"
"@c\n"
"@deffn {Scheme Procedure} cons* arg1 arg2 @dots{}\n"
"Like @code{list}, but the last arg provides the tail of the\n"
"constructed list, returning @code{(cons @var{arg1} (cons\n"
"@var{arg2} (cons @dots{} @var{argn})))}.  Requires at least one\n"
"argument.  If given one argument, that argument is returned as\n"
"result.  This function is called @code{list*} in some other\n"
"Schemes and in Common LISP.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5897
msgid ""
"@deffn {Scheme Procedure} list-copy lst\n"
"@deffnx {C Function} scm_list_copy (lst)\n"
"Return a (newly-created) copy of @var{lst}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5903
msgid ""
"@deffn {Scheme Procedure} make-list n [init]\n"
"Create a list containing of @var{n} elements, where each element is\n"
"initialized to @var{init}.  @var{init} defaults to the empty list\n"
"@code{()} if not given.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5911
msgid ""
"Note that @code{list-copy} only makes a copy of the pairs which make up\n"
"the spine of the lists.  The list elements are not copied, which means\n"
"that modifying the elements of the new list also modifies the elements\n"
"of the old list.  On the other hand, applying procedures like\n"
"@code{set-cdr!} or @code{delv!} to the new list will not alter the old\n"
"list.  If you also need to copy the list elements (making a deep copy),\n"
"use the procedure @code{copy-tree} (@pxref{Copying})."
msgstr ""
"Обратите внимание, что в процедуре @code{list-copy} делается только\n"
"копирование пар, составляющих основу списка. Элементы списка не \n"
"копируются, что означает, что изменение элементов нового списка,\n"
"также изменит и элементы старого списка.  С другой стороны, применяя\n"
"такие процедуры как @code{set-cdr!} или @code{delv!} для нового\n"
"списка, старый список не будет изменен. Если вам также необходимо\n"
"скопировать элементы списка(сделать глубокую копию), используйте \n"
"процедуру @code{copy-tree} (@pxref{Copying})."

#: api-data.texi:5914
msgid ""
"@node List Selection\n"
"@subsubsection List Selection"
msgstr ""
"@node List Selection\n"
"@subsubsection Операции Выбора в Списке"

#: api-data.texi:5917
msgid ""
"These procedures are used to get some information about a list, or to\n"
"retrieve one or more elements of a list."
msgstr ""
"Эти процедуры используются для получения некоторой информации о списке\n"
"или для извлечения одного или нескольких элементов списка."

#: api-data.texi:5923
msgid ""
"@rnindex length\n"
"@deffn {Scheme Procedure} length lst\n"
"@deffnx {C Function} scm_length (lst)\n"
"Return the number of elements in list @var{lst}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5929
msgid ""
"@deffn {Scheme Procedure} last-pair lst\n"
"@deffnx {C Function} scm_last_pair (lst)\n"
"Return the last pair in @var{lst}, signalling an error if\n"
"@var{lst} is circular.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5935
msgid ""
"@rnindex list-ref\n"
"@deffn {Scheme Procedure} list-ref list k\n"
"@deffnx {C Function} scm_list_ref (list, k)\n"
"Return the @var{k}th element from @var{list}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5942
msgid ""
"@rnindex list-tail\n"
"@deffn {Scheme Procedure} list-tail lst k\n"
"@deffnx {Scheme Procedure} list-cdr-ref lst k\n"
"@deffnx {C Function} scm_list_tail (lst, k)\n"
"Return the \"tail\" of @var{lst} beginning with its @var{k}th element.\n"
"The first element of the list is considered to be element 0."
msgstr ""

#: api-data.texi:5947
msgid ""
"@code{list-tail} and @code{list-cdr-ref} are identical.  It may help to\n"
"think of @code{list-cdr-ref} as accessing the @var{k}th cdr of the list,\n"
"or returning the results of cdring @var{k} times down @var{lst}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5953
msgid ""
"@deffn {Scheme Procedure} list-head lst k\n"
"@deffnx {C Function} scm_list_head (lst, k)\n"
"Copy the first @var{k} elements from @var{lst} into a new list, and\n"
"return it.\n"
"@end deffn"
msgstr ""

#: api-data.texi:5956
msgid ""
"@node Append/Reverse\n"
"@subsubsection Append and Reverse"
msgstr ""
"@node Append/Reverse\n"
"@subsubsection Добавление и Переворачивание"

#: api-data.texi:5964
msgid ""
"@code{append} and @code{append!} are used to concatenate two or more\n"
"lists in order to form a new list.  @code{reverse} and @code{reverse!}\n"
"return lists with the same elements as their arguments, but in reverse\n"
"order.  The procedure variants with an @code{!} directly modify the\n"
"pairs which form the list, whereas the other procedures create new\n"
"pairs.  This is why you should be careful when using the side-effecting\n"
"variants."
msgstr ""
"@code{append} и @code{append!} используются для объединения двух и более\n"
"списков, что бы сформировать новый список.  @code{reverse} и "
"@code{reverse!}\n"
"возвращаеют списки с теми же элементами, но идущими в обратном порядке.\n"
"Варианты процедур с @code{!} непосредственно изменяют пары, которые "
"образуют\n"
"список, а другие процедуры создают новые пары. Вот почему вы должны быть\n"
"осторожны, когда используете побочные эффекты процедур."

#: api-data.texi:5974
msgid ""
"@rnindex append\n"
"@deffn {Scheme Procedure} append lst @dots{} obj\n"
"@deffnx {Scheme Procedure} append\n"
"@deffnx {Scheme Procedure} append! lst @dots{} obj\n"
"@deffnx {Scheme Procedure} append!\n"
"@deffnx {C Function} scm_append (lstlst)\n"
"@deffnx {C Function} scm_append_x (lstlst)\n"
"Return a list comprising all the elements of lists @var{lst} @dots{}\n"
"@var{obj}.  If called with no arguments, return the empty list."
msgstr ""

#: api-data.texi:5980
msgid ""
"@lisp\n"
"(append '(x) '(y))          @result{}  (x y)\n"
"(append '(a) '(b c d))      @result{}  (a b c d)\n"
"(append '(a (b)) '((c)))    @result{}  (a (b) (c))\n"
"@end lisp"
msgstr ""

#: api-data.texi:5983
msgid ""
"The last argument @var{obj} may actually be any object; an improper\n"
"list results if the last argument is not a proper list."
msgstr ""

#: api-data.texi:5988
msgid ""
"@lisp\n"
"(append '(a b) '(c . d))    @result{}  (a b c . d)\n"
"(append '() 'a)             @result{}  a\n"
"@end lisp"
msgstr ""

#: api-data.texi:5992
msgid ""
"@code{append} doesn't modify the given lists, but the return may share\n"
"structure with the final @var{obj}.  @code{append!} is permitted, but\n"
"not required, to modify the given lists to form its return."
msgstr ""

#: api-data.texi:5997
msgid ""
"For @code{scm_append} and @code{scm_append_x}, @var{lstlst} is a list\n"
"of the list operands @var{lst} @dots{} @var{obj}.  That @var{lstlst}\n"
"itself is not modified or used in the return.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6004
msgid ""
"@rnindex reverse\n"
"@deffn {Scheme Procedure} reverse lst\n"
"@deffnx {Scheme Procedure} reverse! lst [newtail]\n"
"@deffnx {C Function} scm_reverse (lst)\n"
"@deffnx {C Function} scm_reverse_x (lst, newtail)\n"
"Return a list comprising the elements of @var{lst}, in reverse order."
msgstr ""

#: api-data.texi:6007
msgid ""
"@code{reverse} constructs a new list.  @code{reverse!} is permitted, but\n"
"not required, to modify @var{lst} in constructing its return."
msgstr ""

#: api-data.texi:6013
msgid ""
"For @code{reverse!}, the optional @var{newtail} is appended to the\n"
"result.  @var{newtail} isn't reversed, it simply becomes the list\n"
"tail.  For @code{scm_reverse_x}, the @var{newtail} parameter is\n"
"mandatory, but can be @code{SCM_EOL} if no further tail is required.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6016
msgid ""
"@node List Modification\n"
"@subsubsection List Modification"
msgstr ""
"@node List Modification\n"
"@subsubsection Изменение Списка"

#: api-data.texi:6019
msgid ""
"The following procedures modify an existing list, either by changing\n"
"elements of the list, or by changing the list structure itself."
msgstr ""
"Следующие процедуры изменяют существующий список либо путем\n"
"изменения элементов списка, либо путем изменения самой\n"
"структуры списка."

#: api-data.texi:6024
msgid ""
"@deffn {Scheme Procedure} list-set! list k val\n"
"@deffnx {C Function} scm_list_set_x (list, k, val)\n"
"Set the @var{k}th element of @var{list} to @var{val}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} list-set! list k val\n"
"@deffnx {C Function} scm_list_set_x (list, k, val)\n"
"Устанавливает @var{k}-тый элемент списка @var{list} значением @var{val}.\n"
"@end deffn\n"
"@lisp\n"
";;ВНИМАНИЕ!!! меня ждал тут сюрприз!!!\n"
"(define t1 '(1 2 3 4 5))\n"
"(list-set! t1 0 100)  @result{} \n"
"@result{} ERROR: In procedure list-set!:\n"
" set-car!: Wrong type argument in position 1 (expecting mutable pair)\n"
";; А так РАБОТАЕТ!!! значит важно различить mutable и imutable list\n"
"(define t1 (list 1 2 3 4 5))\n"
"(list-set! t1 0 100) (display t1)  @result{}  (100 2 3 4 5)\n"
"@end lisp"

#: api-data.texi:6029
msgid ""
"@deffn {Scheme Procedure} list-cdr-set! list k val\n"
"@deffnx {C Function} scm_list_cdr_set_x (list, k, val)\n"
"Set the @var{k}th cdr of @var{list} to @var{val}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6037
msgid ""
"@deffn {Scheme Procedure} delq item lst\n"
"@deffnx {C Function} scm_delq (item, lst)\n"
"Return a newly-created copy of @var{lst} with elements\n"
"@code{eq?} to @var{item} removed.  This procedure mirrors\n"
"@code{memq}: @code{delq} compares elements of @var{lst} against\n"
"@var{item} with @code{eq?}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6045
msgid ""
"@deffn {Scheme Procedure} delv item lst\n"
"@deffnx {C Function} scm_delv (item, lst)\n"
"Return a newly-created copy of @var{lst} with elements\n"
"@code{eqv?} to @var{item} removed.  This procedure mirrors\n"
"@code{memv}: @code{delv} compares elements of @var{lst} against\n"
"@var{item} with @code{eqv?}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6052
msgid ""
"@deffn {Scheme Procedure} delete item lst\n"
"@deffnx {C Function} scm_delete (item, lst)\n"
"Return a newly-created copy of @var{lst} with elements\n"
"@code{equal?} to @var{item} removed.  This procedure mirrors\n"
"@code{member}: @code{delete} compares elements of @var{lst}\n"
"against @var{item} with @code{equal?}."
msgstr ""

#: api-data.texi:6057
msgid ""
"See also SRFI-1 which has an extended @code{delete} (@ref{SRFI-1\n"
"Deleting}), and also an @code{lset-difference} which can delete\n"
"multiple @var{item}s in one call (@ref{SRFI-1 Set Operations}).\n"
"@end deffn"
msgstr ""

#: api-data.texi:6071
msgid ""
"@deffn {Scheme Procedure} delq! item lst\n"
"@deffnx {Scheme Procedure} delv! item lst\n"
"@deffnx {Scheme Procedure} delete! item lst\n"
"@deffnx {C Function} scm_delq_x (item, lst)\n"
"@deffnx {C Function} scm_delv_x (item, lst)\n"
"@deffnx {C Function} scm_delete_x (item, lst)\n"
"These procedures are destructive versions of @code{delq}, @code{delv}\n"
"and @code{delete}: they modify the pointers in the existing @var{lst}\n"
"rather than creating a new list.  Caveat evaluator: Like other\n"
"destructive list functions, these functions cannot modify the binding of\n"
"@var{lst}, and so cannot be used to delete the first element of\n"
"@var{lst} destructively.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6078
msgid ""
"@deffn {Scheme Procedure} delq1! item lst\n"
"@deffnx {C Function} scm_delq1_x (item, lst)\n"
"Like @code{delq!}, but only deletes the first occurrence of\n"
"@var{item} from @var{lst}.  Tests for equality using\n"
"@code{eq?}.  See also @code{delv1!} and @code{delete1!}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6085
msgid ""
"@deffn {Scheme Procedure} delv1! item lst\n"
"@deffnx {C Function} scm_delv1_x (item, lst)\n"
"Like @code{delv!}, but only deletes the first occurrence of\n"
"@var{item} from @var{lst}.  Tests for equality using\n"
"@code{eqv?}.  See also @code{delq1!} and @code{delete1!}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6092
msgid ""
"@deffn {Scheme Procedure} delete1! item lst\n"
"@deffnx {C Function} scm_delete1_x (item, lst)\n"
"Like @code{delete!}, but only deletes the first occurrence of\n"
"@var{item} from @var{lst}.  Tests for equality using\n"
"@code{equal?}.  See also @code{delq1!} and @code{delv1!}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6099
msgid ""
"@deffn {Scheme Procedure} filter pred lst\n"
"@deffnx {Scheme Procedure} filter! pred lst\n"
"Return a list containing all elements from @var{lst} which satisfy the\n"
"predicate @var{pred}.  The elements in the result list have the same\n"
"order as in @var{lst}.  The order in which @var{pred} is applied to\n"
"the list elements is not specified."
msgstr ""

#: api-data.texi:6104
msgid ""
"@code{filter} does not change @var{lst}, but the result may share a\n"
"tail with it.  @code{filter!} may modify @var{lst} to construct its\n"
"return.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6107
msgid ""
"@node List Searching\n"
"@subsubsection List Searching"
msgstr ""
"@node List Searching\n"
"@subsubsection Поиск по Списку"

#: api-data.texi:6113
msgid ""
"The following procedures search lists for particular elements.  They use\n"
"different comparison predicates for comparing list elements with the\n"
"object to be searched.  When they fail, they return @code{#f}, otherwise\n"
"they return the sublist whose car is equal to the search object, where\n"
"equality depends on the equality predicate used."
msgstr ""
"Следующие процедуры выполняют поиск по конкретным элементам. Они используют\n"
"различные типы предикатов сравнения элементов списка с объектом, подлежащем\n"
"поиску. Когда поиск неудачен, функции возвращают @code{#f}, иначе они\n"
"возвращают подсписок, car для которого равен искомому объекту, результат\n"
"сравнения(и поиска) зависит от используемого предиката равенства."

#: api-data.texi:6124
msgid ""
"@rnindex memq\n"
"@deffn {Scheme Procedure} memq x lst\n"
"@deffnx {C Function} scm_memq (x, lst)\n"
"Return the first sublist of @var{lst} whose car is @code{eq?}\n"
"to @var{x} where the sublists of @var{lst} are the non-empty\n"
"lists returned by @code{(list-tail @var{lst} @var{k})} for\n"
"@var{k} less than the length of @var{lst}.  If @var{x} does not\n"
"occur in @var{lst}, then @code{#f} (not the empty list) is\n"
"returned.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6135
msgid ""
"@rnindex memv\n"
"@deffn {Scheme Procedure} memv x lst\n"
"@deffnx {C Function} scm_memv (x, lst)\n"
"Return the first sublist of @var{lst} whose car is @code{eqv?}\n"
"to @var{x} where the sublists of @var{lst} are the non-empty\n"
"lists returned by @code{(list-tail @var{lst} @var{k})} for\n"
"@var{k} less than the length of @var{lst}.  If @var{x} does not\n"
"occur in @var{lst}, then @code{#f} (not the empty list) is\n"
"returned.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6145
msgid ""
"@rnindex member\n"
"@deffn {Scheme Procedure} member x lst\n"
"@deffnx {C Function} scm_member (x, lst)\n"
"Return the first sublist of @var{lst} whose car is\n"
"@code{equal?} to @var{x} where the sublists of @var{lst} are\n"
"the non-empty lists returned by @code{(list-tail @var{lst}\n"
"@var{k})} for @var{k} less than the length of @var{lst}.  If\n"
"@var{x} does not occur in @var{lst}, then @code{#f} (not the\n"
"empty list) is returned."
msgstr ""

#: api-data.texi:6149
msgid ""
"See also SRFI-1 which has an extended @code{member} function\n"
"(@ref{SRFI-1 Searching}).\n"
"@end deffn"
msgstr ""

#: api-data.texi:6153
msgid ""
"@node List Mapping\n"
"@subsubsection List Mapping"
msgstr ""
"@node List Mapping\n"
"@subsubsection Поэлементная обработка Списка"

#: api-data.texi:6160
msgid ""
"List processing is very convenient in Scheme because the process of\n"
"iterating over the elements of a list can be highly abstracted.  The\n"
"procedures in this section are the most basic iterating procedures for\n"
"lists.  They take a procedure and one or more lists as arguments, and\n"
"apply the procedure to each element of the list.  They differ in their\n"
"return value."
msgstr ""
"Обработка списков очень удобна в Scheme, потому что, процесс итерации\n"
"по элементам списка может быть сильно абстрагирован. Процедуры описанные\n"
"в этом разделе являются базовыми процедурами итерации для списков.\n"
"Они принимают процедуру и один или несколько списков в качесве\n"
"аргументов, и применяют процедуру к каждому элементу списка. Процедуры\n"
"отличаются значением которое они возвращают."

#: api-data.texi:6174
msgid ""
"@rnindex map\n"
"@c begin (texi-doc-string \"guile\" \"map\")\n"
"@deffn {Scheme Procedure} map proc arg1 arg2 @dots{}\n"
"@deffnx {Scheme Procedure} map-in-order proc arg1 arg2 @dots{}\n"
"@deffnx {C Function} scm_map (proc, arg1, args)\n"
"Apply @var{proc} to each element of the list @var{arg1} (if only two\n"
"arguments are given), or to the corresponding elements of the argument\n"
"lists (if more than two arguments are given).  The result(s) of the\n"
"procedure applications are saved and returned in a list.  For\n"
"@code{map}, the order of procedure applications is not specified,\n"
"@code{map-in-order} applies the procedure from left to right to the list\n"
"elements.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6182
msgid ""
"@rnindex for-each\n"
"@c begin (texi-doc-string \"guile\" \"for-each\")\n"
"@deffn {Scheme Procedure} for-each proc arg1 arg2 @dots{}\n"
"Like @code{map}, but the procedure is always applied from left to right,\n"
"and the result(s) of the procedure applications are thrown away.  The\n"
"return value is not specified.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6185
msgid ""
"See also SRFI-1 which extends these functions to take lists of unequal\n"
"lengths (@ref{SRFI-1 Fold and Map})."
msgstr ""

#: api-data.texi:6189
msgid ""
"@node Vectors\n"
"@subsection Vectors\n"
"@tpindex Vectors"
msgstr ""
"@node Vectors\n"
"@subsection Векторы\n"
"@tpindex Vectors"

#: api-data.texi:6196
msgid ""
"Vectors are sequences of Scheme objects.  Unlike lists, the length of a\n"
"vector, once the vector is created, cannot be changed.  The advantage of\n"
"vectors over lists is that the time required to access one element of a "
"vector\n"
"given its @dfn{position} (synonymous with @dfn{index}), a zero-origin "
"number,\n"
"is constant, whereas lists have an access time linear to the position of "
"the\n"
"accessed element in the list."
msgstr ""
"Векторы - это последовательности объектов Scheme.  В отличие от списков "
"длина\n"
"вектора, после создания вектора, не может быть изменена. Преимущество\n"
"векторов над списками заключается в том, что требуемое время для доступа\n"
"к одному элементу вектора, с учетом его положения(синоним индекса) "
"относительно\n"
"нулевой позиции, является константой, тогда как списки имеют время доступа\n"
"линейное по отношению к позиции доступа элемета в списке."

#: api-data.texi:6203
msgid ""
"Vectors can contain any kind of Scheme object; it is even possible to\n"
"have different types of objects in the same vector.  For vectors\n"
"containing vectors, you may wish to use arrays, instead.  Note, too,\n"
"that vectors are the special case of one dimensional non-uniform arrays\n"
"and that most array procedures operate happily on vectors\n"
"(@pxref{Arrays})."
msgstr ""
"Векторы могут содержать любой объект Scheme; возможно даже иметь\n"
"разные типы объектов в одном и том же векторе. Для векторов,\n"
"содержащих векторы, вместо них вы можете использовать Массивы.\n"
"Заметим также, что векторы являются частным случаем одномерных\n"
"неоднородных массивов и большинство процедур для Массивов успешно\n"
"работают и на Векорах. (@pxref{Arrays})"

#: api-data.texi:6205
msgid "Also see @ref{SRFI-43}, for a comprehensive vector library."
msgstr ""

#: api-data.texi:6213
msgid ""
"@menu\n"
"* Vector Syntax::               Read syntax for vectors.\n"
"* Vector Creation::             Dynamic vector creation and validation.\n"
"* Vector Accessors::            Accessing and modifying vector contents.\n"
"* Vector Accessing from C::     Ways to work with vectors from C.\n"
"* Uniform Numeric Vectors::     Vectors of unboxed numeric values.\n"
"@end menu"
msgstr ""

#: api-data.texi:6217
msgid ""
"@node Vector Syntax\n"
"@subsubsection Read Syntax for Vectors"
msgstr ""
"@node Vector Syntax\n"
"@subsubsection Синтаксис чтения для Векторов"

#: api-data.texi:6224
msgid ""
"Vectors can literally be entered in source code, just like strings,\n"
"characters or some of the other data types.  The read syntax for vectors\n"
"is as follows: A sharp sign (@code{#}), followed by an opening\n"
"parentheses, all elements of the vector in their respective read syntax,\n"
"and finally a closing parentheses.  Like strings, vectors do not have to\n"
"be quoted."
msgstr ""
"Векторы можно определить в исходном коде, подобно строкам, символам или \n"
"некоторым другим типам данных. Синтаксис чтения для векторов слеюдующий:\n"
"символ решетки (@code{#}), за которым следует открывающая круглая скобка,\n"
"далее все элементы вектора в соотвествующем им синтаксисе чтения и, \n"
"наконец, закрывающая круглая скобка. Подобно строкам векторам не нужно\n"
"указывать знак квотирования.\n"
"\n"

#: api-data.texi:6228
msgid ""
"The following are examples of the read syntax for vectors; where the\n"
"first vector only contains numbers and the second three different object\n"
"types: a string, a symbol and a number in hexadecimal notation."
msgstr ""
"Ниже приведены примеры синтаксиса чтения для векторов; где только первый\n"
"вектор содержит числа и три разных типа объекта: строку, символ и\n"
"число в шестнадцатеричной форме."

#: api-data.texi:6233
msgid ""
"@lisp\n"
"#(1 2 3)\n"
"#(\"Hello\" foo #xdeadbeef)\n"
"@end lisp"
msgstr ""

#: api-data.texi:6236
msgid ""
"@node Vector Creation\n"
"@subsubsection Dynamic Vector Creation and Validation"
msgstr ""
"@node Vector Creation\n"
"@subsubsection Динамическое создание и проверка Вектора"

#: api-data.texi:6242
msgid ""
"Instead of creating a vector implicitly by using the read syntax just\n"
"described, you can create a vector dynamically by calling one of the\n"
"@code{vector} and @code{list->vector} primitives with the list of Scheme\n"
"values that you want to place into a vector.  The size of the vector\n"
"thus created is determined implicitly by the number of arguments given."
msgstr ""
"Вместо того, чтобы создавать векторы неявно, используя только что \n"
"описанный синтаксис чтения, вы можете создать вектор динамически, \n"
"вызывая одну из процедур @code{vector} и @code{list->vector} со\n"
"списком значений Scheme, которые вы хотите поместить в вектор.\n"
"Размер вектора созданный таким образом, определяется неявно\n"
"количеством доступных аргументов."

#: api-data.texi:6250
msgid ""
"@rnindex vector\n"
"@rnindex list->vector\n"
"@deffn {Scheme Procedure} vector arg @dots{}\n"
"@deffnx {Scheme Procedure} list->vector l\n"
"@deffnx {C Function} scm_vector (l)\n"
"Return a newly allocated vector composed of the\n"
"given arguments.  Analogous to @code{list}."
msgstr ""

#: api-data.texi:6255
msgid ""
"@lisp\n"
"(vector 'a 'b 'c) @result{} #(a b c)\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:6257
msgid "The inverse operation is @code{vector->list}:"
msgstr ""

#: api-data.texi:6262
msgid ""
"@rnindex vector->list\n"
"@deffn {Scheme Procedure} vector->list v\n"
"@deffnx {C Function} scm_vector_to_list (v)\n"
"Return a newly allocated list composed of the elements of @var{v}."
msgstr ""

#: api-data.texi:6268
msgid ""
"@lisp\n"
"(vector->list #(dah dah didah)) @result{}  (dah dah didah)\n"
"(list->vector '(dididit dah)) @result{}  #(dididit dah)\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:6273
msgid ""
"To allocate a vector with an explicitly specified size, use\n"
"@code{make-vector}.  With this primitive you can also specify an initial\n"
"value for the vector elements (the same value for all elements, that\n"
"is):"
msgstr ""

#: api-data.texi:6282
msgid ""
"@rnindex make-vector\n"
"@deffn {Scheme Procedure} make-vector len [fill]\n"
"@deffnx {C Function} scm_make_vector (len, fill)\n"
"Return a newly allocated vector of @var{len} elements.  If a\n"
"second argument is given, then each position is initialized to\n"
"@var{fill}.  Otherwise the initial contents of each position is\n"
"unspecified.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6286
msgid ""
"@deftypefn {C Function} SCM scm_c_make_vector (size_t k, SCM fill)\n"
"Like @code{scm_make_vector}, but the length is given as a @code{size_t}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6289
msgid ""
"To check whether an arbitrary Scheme value @emph{is} a vector, use the\n"
"@code{vector?} primitive:"
msgstr ""

#: api-data.texi:6296
msgid ""
"@rnindex vector?\n"
"@deffn {Scheme Procedure} vector? obj\n"
"@deffnx {C Function} scm_vector_p (obj)\n"
"Return @code{#t} if @var{obj} is a vector, otherwise return\n"
"@code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6301
msgid ""
"@deftypefn {C Function} int scm_is_vector (SCM obj)\n"
"Return non-zero when @var{obj} is a vector, otherwise return\n"
"@code{zero}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6304
msgid ""
"@node Vector Accessors\n"
"@subsubsection Accessing and Modifying Vector Contents"
msgstr ""
"@node Vector Accessors\n"
"@subsubsection Доступ и Модификация содержимого Вектора"

#: api-data.texi:6308
msgid ""
"@code{vector-length} and @code{vector-ref} return information about a\n"
"given vector, respectively its size and the elements that are contained\n"
"in the vector."
msgstr ""
"процедуры @code{vector-length} и @code{vector-ref} возвращают информацию\n"
"об определенном векторе, соответственно длину вектора и элементы,\n"
"которые содержит вектор."

#: api-data.texi:6314
msgid ""
"@rnindex vector-length\n"
"@deffn {Scheme Procedure} vector-length vector\n"
"@deffnx {C Function} scm_vector_length (vector)\n"
"Return the number of elements in @var{vector} as an exact integer.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6318
msgid ""
"@deftypefn {C Function} size_t scm_c_vector_length (SCM vec)\n"
"Return the number of elements in @var{vec} as a @code{size_t}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6333
msgid ""
"@rnindex vector-ref\n"
"@deffn {Scheme Procedure} vector-ref vec k\n"
"@deffnx {C Function} scm_vector_ref (vec, k)\n"
"Return the contents of position @var{k} of @var{vec}.\n"
"@var{k} must be a valid index of @var{vec}.\n"
"@lisp\n"
"(vector-ref #(1 1 2 3 5 8 13 21) 5) @result{} 8\n"
"(vector-ref #(1 1 2 3 5 8 13 21)\n"
"    (let ((i (round (* 2 (acos -1)))))\n"
"      (if (inexact? i)\n"
"        (inexact->exact i)\n"
"           i))) @result{} 13\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:6338
msgid ""
"@deftypefn {C Function} SCM scm_c_vector_ref (SCM vec, size_t k)\n"
"Return the contents of position @var{k} (a @code{size_t}) of\n"
"@var{vec}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6342
msgid ""
"A vector created by one of the dynamic vector constructor procedures\n"
"(@pxref{Vector Creation}) can be modified using the following\n"
"procedures."
msgstr ""

#: api-data.texi:6347
msgid ""
"@emph{NOTE:} According to R5RS, it is an error to use any of these\n"
"procedures on a literally read vector, because such vectors should be\n"
"considered as constants.  Currently, however, Guile does not detect this\n"
"error."
msgstr ""

#: api-data.texi:6360
msgid ""
"@rnindex vector-set!\n"
"@deffn {Scheme Procedure} vector-set! vec k obj\n"
"@deffnx {C Function} scm_vector_set_x (vec, k, obj)\n"
"Store @var{obj} in position @var{k} of @var{vec}.\n"
"@var{k} must be a valid index of @var{vec}.\n"
"The value returned by @samp{vector-set!} is unspecified.\n"
"@lisp\n"
"(let ((vec (vector 0 '(2 2 2 2) \"Anna\")))\n"
"  (vector-set! vec 1 '(\"Sue\" \"Sue\"))\n"
"  vec) @result{}  #(0 (\"Sue\" \"Sue\") \"Anna\")\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:6364
msgid ""
"@deftypefn {C Function} void scm_c_vector_set_x (SCM vec, size_t k, SCM "
"obj)\n"
"Store @var{obj} in position @var{k} (a @code{size_t}) of @var{vec}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6371
msgid ""
"@rnindex vector-fill!\n"
"@deffn {Scheme Procedure} vector-fill! vec fill\n"
"@deffnx {C Function} scm_vector_fill_x (vec, fill)\n"
"Store @var{fill} in every position of @var{vec}.  The value\n"
"returned by @code{vector-fill!} is unspecified.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6376
msgid ""
"@deffn {Scheme Procedure} vector-copy vec\n"
"@deffnx {C Function} scm_vector_copy (vec)\n"
"Return a copy of @var{vec}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6382
msgid ""
"@deffn {Scheme Procedure} vector-move-left! vec1 start1 end1 vec2 start2\n"
"@deffnx {C Function} scm_vector_move_left_x (vec1, start1, end1, vec2, "
"start2)\n"
"Copy elements from @var{vec1}, positions @var{start1} to @var{end1},\n"
"to @var{vec2} starting at position @var{start2}.  @var{start1} and\n"
"@var{start2} are inclusive indices; @var{end1} is exclusive."
msgstr ""

#: api-data.texi:6388
msgid ""
"@code{vector-move-left!} copies elements in leftmost order.\n"
"Therefore, in the case where @var{vec1} and @var{vec2} refer to the\n"
"same vector, @code{vector-move-left!} is usually appropriate when\n"
"@var{start1} is greater than @var{start2}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6394
msgid ""
"@deffn {Scheme Procedure} vector-move-right! vec1 start1 end1 vec2 start2\n"
"@deffnx {C Function} scm_vector_move_right_x (vec1, start1, end1, vec2, "
"start2)\n"
"Copy elements from @var{vec1}, positions @var{start1} to @var{end1},\n"
"to @var{vec2} starting at position @var{start2}.  @var{start1} and\n"
"@var{start2} are inclusive indices; @var{end1} is exclusive."
msgstr ""

#: api-data.texi:6400
msgid ""
"@code{vector-move-right!} copies elements in rightmost order.\n"
"Therefore, in the case where @var{vec1} and @var{vec2} refer to the\n"
"same vector, @code{vector-move-right!} is usually appropriate when\n"
"@var{start1} is less than @var{start2}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6403
msgid ""
"@node Vector Accessing from C\n"
"@subsubsection Vector Accessing from C"
msgstr ""
"@node Vector Accessing from C\n"
"@subsubsection Доступк в Вектору из Си"

#: api-data.texi:6415
msgid ""
"A vector can be read and modified from C with the functions\n"
"@code{scm_c_vector_ref} and @code{scm_c_vector_set_x}, for example.  In\n"
"addition to these functions, there are two more ways to access vectors\n"
"from C that might be more efficient in certain situations: you can\n"
"restrict yourself to @dfn{simple vectors} and then use the very fast\n"
"@emph{simple vector macros}; or you can use the very general framework\n"
"for accessing all kinds of arrays (@pxref{Accessing Arrays from C}),\n"
"which is more verbose, but can deal efficiently with all kinds of\n"
"vectors (and arrays).  For vectors, you can use the\n"
"@code{scm_vector_elements} and @code{scm_vector_writable_elements}\n"
"functions as shortcuts."
msgstr ""
"Вектор можно считывать и изменять из Си ,например, с помощью функций\n"
"@code{scm_c_vector_ref} и @code{scm_c_vector_set_x}.  В дополнение\n"
"к этим функциям есть еще два способа доступа к векторам из Си,\n"
"которые могут быть эффективными в определенных ситуациях: вы можете\n"
"ограничить себя работой с простыми векторами @dfn{simple vectors} и\n"
"затем использовать очень быстрые простые векторные макросы; или вы\n"
"можете воспользоваться базовым доступом ко всем типам Массивов\n"
"(@pxref{Accessing Arrays from C}), более подробно, но может \n"
"эффективно работать со всеми видами векторов(и массивов).  \n"
"Для векторов, вы можете использовать функции @code{scm_vector_elements} \n"
"и  @code{scm_vector_writable_elements}.\n"

#: api-data.texi:6420
msgid ""
"@deftypefn {C Function} int scm_is_simple_vector (SCM obj)\n"
"Return non-zero if @var{obj} is a simple vector, else return zero.  A\n"
"simple vector is a vector that can be used with the @code{SCM_SIMPLE_*}\n"
"macros below."
msgstr ""

#: api-data.texi:6425
msgid ""
"The following functions are guaranteed to return simple vectors:\n"
"@code{scm_make_vector}, @code{scm_c_make_vector}, @code{scm_vector},\n"
"@code{scm_list_to_vector}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6430
msgid ""
"@deftypefn {C Macro} size_t SCM_SIMPLE_VECTOR_LENGTH (SCM vec)\n"
"Evaluates to the length of the simple vector @var{vec}.  No type\n"
"checking is done.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6435
msgid ""
"@deftypefn {C Macro} SCM SCM_SIMPLE_VECTOR_REF (SCM vec, size_t idx)\n"
"Evaluates to the element at position @var{idx} in the simple vector\n"
"@var{vec}.  No type or range checking is done.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6440
msgid ""
"@deftypefn {C Macro} void SCM_SIMPLE_VECTOR_SET (SCM vec, size_t idx, SCM "
"val)\n"
"Sets the element at position @var{idx} in the simple vector\n"
"@var{vec} to @var{val}.  No type or range checking is done.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6447
msgid ""
"@deftypefn {C Function} {const SCM *} scm_vector_elements (SCM vec, "
"scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"Acquire a handle for the vector @var{vec} and return a pointer to the\n"
"elements of it.  This pointer can only be used to read the elements of\n"
"@var{vec}.  When @var{vec} is not a vector, an error is signaled.  The\n"
"handle must eventually be released with\n"
"@code{scm_array_handle_release}."
msgstr ""

#: api-data.texi:6454
msgid ""
"The variables pointed to by @var{lenp} and @var{incp} are filled with\n"
"the number of elements of the vector and the increment (number of\n"
"elements) between successive elements, respectively.  Successive\n"
"elements of @var{vec} need not be contiguous in their underlying\n"
"``root vector'' returned here; hence the increment is not necessarily\n"
"equal to 1 and may well be negative too (@pxref{Shared Arrays})."
msgstr ""

#: api-data.texi:6457
msgid ""
"The following example shows the typical way to use this function.  It\n"
"creates a list of all elements of @var{vec} (in reverse order)."
msgstr ""

#: api-data.texi:6464
msgid ""
"@example\n"
"scm_t_array_handle handle;\n"
"size_t i, len;\n"
"ssize_t inc;\n"
"const SCM *elt;\n"
"SCM list;"
msgstr ""

#: api-data.texi:6471
msgid ""
"elt = scm_vector_elements (vec, &handle, &len, &inc);\n"
"list = SCM_EOL;\n"
"for (i = 0; i < len; i++, elt += inc)\n"
"  list = scm_cons (*elt, list);\n"
"scm_array_handle_release (&handle);\n"
"@end example"
msgstr ""

#: api-data.texi:6473
msgctxt "api-data.texi:6473"
msgid "@end deftypefn"
msgstr ""

#: api-data.texi:6477
msgid ""
"@deftypefn {C Function} {SCM *} scm_vector_writable_elements (SCM vec, "
"scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"Like @code{scm_vector_elements} but the pointer can be used to modify\n"
"the vector."
msgstr ""

#: api-data.texi:6480
msgid ""
"The following example shows the typical way to use this function.  It\n"
"fills a vector with @code{#t}."
msgstr ""

#: api-data.texi:6486
msgid ""
"@example\n"
"scm_t_array_handle handle;\n"
"size_t i, len;\n"
"ssize_t inc;\n"
"SCM *elt;"
msgstr ""

#: api-data.texi:6492
msgid ""
"elt = scm_vector_writable_elements (vec, &handle, &len, &inc);\n"
"for (i = 0; i < len; i++, elt += inc)\n"
"  *elt = SCM_BOOL_T;\n"
"scm_array_handle_release (&handle);\n"
"@end example"
msgstr ""

#: api-data.texi:6494
msgctxt "api-data.texi:6494"
msgid "@end deftypefn"
msgstr ""

#: api-data.texi:6497
msgid ""
"@node Uniform Numeric Vectors\n"
"@subsubsection Uniform Numeric Vectors"
msgstr ""
"@node Uniform Numeric Vectors\n"
"@subsubsection Унифицированные Числовые Вектора"

#: api-data.texi:6503
msgid ""
"A uniform numeric vector is a vector whose elements are all of a single\n"
"numeric type.  Guile offers uniform numeric vectors for signed and\n"
"unsigned 8-bit, 16-bit, 32-bit, and 64-bit integers, two sizes of\n"
"floating point values, and complex floating-point numbers of these two\n"
"sizes. @xref{SRFI-4}, for more information."
msgstr ""
"Унифицированным числовым вектором является вектор, элементы которого \n"
"представляют собой один числовой тип. Guile предоставляет унифицированные\n"
"числовые вектора для знаковых и бесзнаковых 8-битных, 16-битных, 32 и 64\n"
"битных целых, чисел с плавающей точкой, комплексных чисел. Дополнительная \n"
"информация @xref{SRFI-4}"

#: api-data.texi:6507
msgid ""
"For many purposes, bytevectors work just as well as uniform vectors, and "
"have\n"
"the advantage that they integrate well with binary input and output.\n"
"@xref{Bytevectors}, for more information on bytevectors."
msgstr ""
"Для многих целей, байтовые векторы работают также, как и унифицированные\n"
"векторы, и имеют преимущество тем что хорошо интегрируются с \n"
"двоичным вводом и выводом. Для получения дополнительной информации\n"
"о байтовых векторах @xref{Bytevectors}."

#: api-data.texi:6510
msgid ""
"@node Bit Vectors\n"
"@subsection Bit Vectors"
msgstr ""
"@node Bit Vectors\n"
"@subsection Битовые Вектора"

#: api-data.texi:6515
msgid ""
"@noindent\n"
"Bit vectors are zero-origin, one-dimensional arrays of booleans.  They\n"
"are displayed as a sequence of @code{0}s and @code{1}s prefixed by\n"
"@code{#*}, e.g.,"
msgstr ""
"@noindent\n"
"Битовыми векторами являются с нулевого индекса одномерные булевые \n"
"массивы. Они отображаются как последовательность @code{0} и @code{1} \n"
"с префиксом @code{#*}, например,"

#: api-data.texi:6520
msgid ""
"@example\n"
"(make-bitvector 8 #f) @result{}\n"
"#*00000000\n"
"@end example"
msgstr ""

#: api-data.texi:6523
msgid ""
"Bit vectors are the special case of one dimensional bit arrays, and can\n"
"thus be used with the array procedures, @xref{Arrays}."
msgstr ""
"Битовые векторы являются частным случаем одномерных битовых массивов\n"
"и поэтому к ним могут быть применены процедуры для работы с Массивами,\n"
"@xref{Arrays}."

#: api-data.texi:6529
msgid ""
"@deffn {Scheme Procedure} bitvector? obj\n"
"@deffnx {C Function} scm_bitvector_p (obj)\n"
"Return @code{#t} when @var{obj} is a bitvector, else\n"
"return @code{#f}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6533
msgid ""
"@deftypefn {C Function} int scm_is_bitvector (SCM obj)\n"
"Return @code{1} when @var{obj} is a bitvector, else return @code{0}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6539
msgid ""
"@deffn {Scheme Procedure} make-bitvector len [fill]\n"
"@deffnx {C Function} scm_make_bitvector (len, fill)\n"
"Create a new bitvector of length @var{len} and\n"
"optionally initialize all elements to @var{fill}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6544
msgid ""
"@deftypefn {C Function} SCM scm_c_make_bitvector (size_t len, SCM fill)\n"
"Like @code{scm_make_bitvector}, but the length is given as a\n"
"@code{size_t}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6549
msgid ""
"@deffn {Scheme Procedure} bitvector bit @dots{}\n"
"@deffnx {C Function} scm_bitvector (bits)\n"
"Create a new bitvector with the arguments as elements.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6554
msgid ""
"@deffn {Scheme Procedure} bitvector-length vec\n"
"@deffnx {C Function} scm_bitvector_length (vec)\n"
"Return the length of the bitvector @var{vec}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6559
msgid ""
"@deftypefn {C Function} size_t scm_c_bitvector_length (SCM vec)\n"
"Like @code{scm_bitvector_length}, but the length is returned as a\n"
"@code{size_t}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6565
msgid ""
"@deffn {Scheme Procedure} bitvector-ref vec idx\n"
"@deffnx {C Function} scm_bitvector_ref (vec, idx)\n"
"Return the element at index @var{idx} of the bitvector\n"
"@var{vec}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6570
msgid ""
"@deftypefn {C Function} SCM scm_c_bitvector_ref (SCM vec, size_t idx)\n"
"Return the element at index @var{idx} of the bitvector\n"
"@var{vec}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6576
msgid ""
"@deffn {Scheme Procedure} bitvector-set! vec idx val\n"
"@deffnx {C Function} scm_bitvector_set_x (vec, idx, val)\n"
"Set the element at index @var{idx} of the bitvector\n"
"@var{vec} when @var{val} is true, else clear it.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6581
msgid ""
"@deftypefn {C Function} SCM scm_c_bitvector_set_x (SCM vec, size_t idx, SCM "
"val)\n"
"Set the element at index @var{idx} of the bitvector\n"
"@var{vec} when @var{val} is true, else clear it.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6587
msgid ""
"@deffn {Scheme Procedure} bitvector-fill! vec val\n"
"@deffnx {C Function} scm_bitvector_fill_x (vec, val)\n"
"Set all elements of the bitvector\n"
"@var{vec} when @var{val} is true, else clear them.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6593
msgid ""
"@deffn {Scheme Procedure} list->bitvector list\n"
"@deffnx {C Function} scm_list_to_bitvector (list)\n"
"Return a new bitvector initialized with the elements\n"
"of @var{list}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6599
msgid ""
"@deffn {Scheme Procedure} bitvector->list vec\n"
"@deffnx {C Function} scm_bitvector_to_list (vec)\n"
"Return a new list initialized with the elements\n"
"of the bitvector @var{vec}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6604
msgid ""
"@deffn {Scheme Procedure} bit-count bool bitvector\n"
"@deffnx {C Function} scm_bit_count (bool, bitvector)\n"
"Return a count of how many entries in @var{bitvector} are equal to\n"
"@var{bool}.  For example,"
msgstr ""

#: api-data.texi:6609
msgid ""
"@example\n"
"(bit-count #f #*000111000)  @result{} 6\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:6616
msgid ""
"@deffn {Scheme Procedure} bit-position bool bitvector start\n"
"@deffnx {C Function} scm_bit_position (bool, bitvector, start)\n"
"Return the index of the first occurrence of @var{bool} in\n"
"@var{bitvector}, starting from @var{start}.  If there is no @var{bool}\n"
"entry between @var{start} and the end of @var{bitvector}, then return\n"
"@code{#f}.  For example,"
msgstr ""

#: api-data.texi:6622
msgid ""
"@example\n"
"(bit-position #t #*000101 0)  @result{} 3\n"
"(bit-position #f #*0001111 3) @result{} #f\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:6627
msgid ""
"@deffn {Scheme Procedure} bit-invert! bitvector\n"
"@deffnx {C Function} scm_bit_invert_x (bitvector)\n"
"Modify @var{bitvector} by replacing each element with its negation.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6632
msgid ""
"@deffn {Scheme Procedure} bit-set*! bitvector uvec bool\n"
"@deffnx {C Function} scm_bit_set_star_x (bitvector, uvec, bool)\n"
"Set entries of @var{bitvector} to @var{bool}, with @var{uvec}\n"
"selecting the entries to change.  The return value is unspecified."
msgstr ""

#: api-data.texi:6639
msgid ""
"If @var{uvec} is a bit vector, then those entries where it has\n"
"@code{#t} are the ones in @var{bitvector} which are set to @var{bool}.\n"
"@var{uvec} and @var{bitvector} must be the same length.  When\n"
"@var{bool} is @code{#t} it's like @var{uvec} is OR'ed into\n"
"@var{bitvector}.  Or when @var{bool} is @code{#f} it can be seen as an\n"
"ANDNOT."
msgstr ""

#: api-data.texi:6646
msgid ""
"@example\n"
"(define bv #*01000010)\n"
"(bit-set*! bv #*10010001 #t)\n"
"bv\n"
"@result{} #*11010011\n"
"@end example"
msgstr ""

#: api-data.texi:6649
msgid ""
"If @var{uvec} is a uniform vector of unsigned long integers, then\n"
"they're indexes into @var{bitvector} which are set to @var{bool}.  "
msgstr ""

#: api-data.texi:6657
msgid ""
"@example\n"
"(define bv #*01000010)\n"
"(bit-set*! bv #u(5 2 7) #t)\n"
"bv\n"
"@result{} #*01100111\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:6662
msgid ""
"@deffn {Scheme Procedure} bit-count* bitvector uvec bool\n"
"@deffnx {C Function} scm_bit_count_star (bitvector, uvec, bool)\n"
"Return a count of how many entries in @var{bitvector} are equal to\n"
"@var{bool}, with @var{uvec} selecting the entries to consider."
msgstr ""

#: api-data.texi:6668
msgid ""
"@var{uvec} is interpreted in the same way as for @code{bit-set*!}\n"
"above.  Namely, if @var{uvec} is a bit vector then entries which have\n"
"@code{#t} there are considered in @var{bitvector}.  Or if @var{uvec}\n"
"is a uniform vector of unsigned long integers then it's the indexes in\n"
"@var{bitvector} to consider."
msgstr ""

#: api-data.texi:6670
msgctxt "api-data.texi:6670"
msgid "For example,"
msgstr ""

#: api-data.texi:6676
msgid ""
"@example\n"
"(bit-count* #*01110111 #*11001101 #t) @result{} 3\n"
"(bit-count* #*01110111 #u32(7 0 4) #f)  @result{} 2\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:6684
msgid ""
"@deftypefn {C Function} {const scm_t_uint32 *} scm_bitvector_elements (SCM "
"vec, scm_t_array_handle *handle, size_t *offp, size_t *lenp, ssize_t *incp)\n"
"Like @code{scm_vector_elements} (@pxref{Vector Accessing from C}), but\n"
"for bitvectors.  The variable pointed to by @var{offp} is set to the\n"
"value returned by @code{scm_array_handle_bit_elements_offset}.  See\n"
"@code{scm_array_handle_bit_elements} for how to use the returned\n"
"pointer and the offset.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6689
msgid ""
"@deftypefn {C Function} {scm_t_uint32 *} scm_bitvector_writable_elements "
"(SCM vec, scm_t_array_handle *handle, size_t *offp, size_t *lenp, ssize_t "
"*incp)\n"
"Like @code{scm_bitvector_elements}, but the pointer is good for reading\n"
"and writing.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6692
msgid ""
"@node Bytevectors\n"
"@subsection Bytevectors"
msgstr ""
"@node Bytevectors\n"
"@subsection Байтовые вектора"

#: api-data.texi:6695
msgid ""
"@cindex bytevector\n"
"@cindex R6RS"
msgstr ""

#: api-data.texi:6704
msgid ""
"A @dfn{bytevector} is a raw bit string.  The @code{(rnrs bytevectors)}\n"
"module provides the programming interface specified by the\n"
"@uref{http://www.r6rs.org/, Revised^6 Report on the Algorithmic Language\n"
"Scheme (R6RS)}.  It contains procedures to manipulate bytevectors and\n"
"interpret their contents in a number of ways: bytevector contents can be\n"
"accessed as signed or unsigned integer of various sizes and endianness,\n"
"as IEEE-754 floating point numbers, or as strings.  It is a useful tool\n"
"to encode and decode binary data."
msgstr ""
"A @dfn{bytevector}байтовый вектор это чистая байтовая строка.  \n"
"Модуль @code{(rnrs bytevectors)} обеспечивает программный интерфес, \n"
"указанный в @uref{http://www.r6rs.org/, Revised^6 Report on the Algorithmic\n"
" Language Scheme (R6RS)}.  Он содержит процедуры манипулирования байтовыми\n"
"векторами и функции их интерпретации различными способами: байтовый вектор\n"
"может представить как знаковое или беззнаковое целое различной длины и\n"
"порядка следования байт, как число с плавающей точкой представленное по "
"стандарту\n"
"IEEE-754, или как стороку.  Это полезный инструмент для кодирования и "
"декодирования\n"
"двоичных данных."

#: api-data.texi:6708
msgid ""
"The R6RS (Section 4.3.4) specifies an external representation for\n"
"bytevectors, whereby the octets (integers in the range 0--255) contained\n"
"in the bytevector are represented as a list prefixed by @code{#vu8}:"
msgstr ""
"R6RS (Section 4.3.4) определяет внешнее представление для байтовых "
"векторов,\n"
"в соответствии с которым октеты (целые числа в пределах 0--255) "
"содержащиеся\n"
"в байтовом векторе представляются в виде списка с префиксом @code{#vu8}:"

#: api-data.texi:6712
msgid ""
"@lisp\n"
"#vu8(1 53 204)\n"
"@end lisp"
msgstr ""

#: api-data.texi:6716
msgid ""
"denotes a 3-byte bytevector containing the octets 1, 53, and 204.  Like\n"
"string literals, booleans, etc., bytevectors are ``self-quoting'', i.e.,\n"
"they do not need to be quoted:"
msgstr ""
"обозначает 3-байтовый байтовый вектор содержащий октеты 1, 53, и 204.  "
"Подобно\n"
"строковым литералам, булевым знчениям и др., байтовые векторы являюстя\n"
"``само-квотируемыми'', т.е. им не нужно указвать квотирование:"

#: api-data.texi:6721
msgid ""
"@lisp\n"
"#vu8(1 53 204)\n"
"@result{} #vu8(1 53 204)\n"
"@end lisp"
msgstr ""

#: api-data.texi:6724
msgid ""
"Bytevectors can be used with the binary input/output primitives\n"
"(@pxref{Binary I/O})."
msgstr ""
"Байтовые вектора могут использоваться с двоичными входными/выходными\n"
"примитивами (@pxref{Binary I/O})."

#: api-data.texi:6735
msgid ""
"@menu\n"
"* Bytevector Endianness::       Dealing with byte order.\n"
"* Bytevector Manipulation::     Creating, copying, manipulating "
"bytevectors.\n"
"* Bytevectors as Integers::     Interpreting bytes as integers.\n"
"* Bytevectors and Integer Lists::  Converting to/from an integer list.\n"
"* Bytevectors as Floats::       Interpreting bytes as real numbers.\n"
"* Bytevectors as Strings::      Interpreting bytes as Unicode strings.\n"
"* Bytevectors as Arrays::       Guile extension to the bytevector API.\n"
"* Bytevectors as Uniform Vectors::  Bytevectors and SRFI-4.\n"
"@end menu"
msgstr ""

#: api-data.texi:6738
msgid ""
"@node Bytevector Endianness\n"
"@subsubsection Endianness"
msgstr ""
"@node Bytevector Endianness\n"
"@subsubsection Порядок байтов"

#: api-data.texi:6742
msgid ""
"@cindex endianness\n"
"@cindex byte order\n"
"@cindex word order"
msgstr ""

#: api-data.texi:6753
msgid ""
"Some of the following procedures take an @var{endianness} parameter.\n"
"The @dfn{endianness} is defined as the order of bytes in multi-byte\n"
"numbers: numbers encoded in @dfn{big endian} have their most\n"
"significant bytes written first, whereas numbers encoded in\n"
"@dfn{little endian} have their least significant bytes\n"
"first@footnote{Big-endian and little-endian are the most common\n"
"``endiannesses'', but others do exist. For instance, the GNU MP\n"
"library allows @dfn{word order} to be specified independently of\n"
"@dfn{byte order} (@pxref{Integer Import and Export,,, gmp, The GNU\n"
"Multiple Precision Arithmetic Library Manual}).}."
msgstr ""
"Некоторые из следующих процедур принимают параметр порядок байтов\n"
"@var{endianness}. Порядок байтов @dfn{endianness} определяет какой\n"
"порядок у байтов в многобайтовых числах: числа кодированные как\n"
"@dfn{big endian} имеют свои самые значащие байты записанными первыми,\n"
"тогда как числа кодированные как @dfn{little endian} первыми имеют\n"
"самые младшие байты@footnote{Big-endian и little-endian являются \n"
"наиболее распространенными способами упорядочения байт в многобайтовых\n"
"числах, но существуют и другие. Например библиотека  GNU MP\n"
"допускает @dfn{порядок слов} независимый от @dfn{порядка байтов} \n"
"(@pxref{Integer Import and Export,,, gmp, The GNU\n"
"Multiple Precision Arithmetic Library Manual}).}."

#: api-data.texi:6758
msgid ""
"Little-endian is the native endianness of the IA32 architecture and\n"
"its derivatives, while big-endian is native to SPARC and PowerPC,\n"
"among others. The @code{native-endianness} procedure returns the\n"
"native endianness of the machine it runs on."
msgstr ""
"Little-endian -это внутренняя спецификация порядка байтов архитектуры\n"
"IA32 и ее производных, в то время как big-endian является родным для\n"
"SPARC и PowerPC, среди прочих. Процедура @code{native-endianness} \n"
"возвращает внутреннюю спецификацию машины, на которой она работает."

#: api-data.texi:6763
msgid ""
"@deffn {Scheme Procedure} native-endianness\n"
"@deffnx {C Function} scm_native_endianness ()\n"
"Return a value denoting the native endianness of the host machine.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6769
msgid ""
"@deffn {Scheme Macro} endianness symbol\n"
"Return an object denoting the endianness specified by @var{symbol}.  If\n"
"@var{symbol} is neither @code{big} nor @code{little} then an error is\n"
"raised at expand-time.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6774
msgid ""
"@defvr {C Variable} scm_endianness_big\n"
"@defvrx {C Variable} scm_endianness_little\n"
"The objects denoting big- and little-endianness, respectively.\n"
"@end defvr"
msgstr ""

#: api-data.texi:6778
msgid ""
"@node Bytevector Manipulation\n"
"@subsubsection Manipulating Bytevectors"
msgstr ""
"@node Bytevector Manipulation\n"
"@subsubsection Манипулирование Байтовыми Векторами"

#: api-data.texi:6781
msgid ""
"Bytevectors can be created, copied, and analyzed with the following\n"
"procedures and C functions."
msgstr ""
"Байтовый вектор может быть создан, скопирован и проанализирован и передан\n"
"процедурам и функциям Си."

#: api-data.texi:6789
msgid ""
"@deffn {Scheme Procedure} make-bytevector len [fill]\n"
"@deffnx {C Function} scm_make_bytevector (len, fill)\n"
"@deffnx {C Function} scm_c_make_bytevector (size_t len)\n"
"Return a new bytevector of @var{len} bytes.  Optionally, if @var{fill}\n"
"is given, fill it with @var{fill}; @var{fill} must be in the range\n"
"[-128,255].\n"
"@end deffn"
msgstr ""

#: api-data.texi:6794
msgid ""
"@deffn {Scheme Procedure} bytevector? obj\n"
"@deffnx {C Function} scm_bytevector_p (obj)\n"
"Return true if @var{obj} is a bytevector.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6798
msgid ""
"@deftypefn {C Function} int scm_is_bytevector (SCM obj)\n"
"Equivalent to @code{scm_is_true (scm_bytevector_p (obj))}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6803
msgid ""
"@deffn {Scheme Procedure} bytevector-length bv\n"
"@deffnx {C Function} scm_bytevector_length (bv)\n"
"Return the length in bytes of bytevector @var{bv}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6807
msgid ""
"@deftypefn {C Function} size_t scm_c_bytevector_length (SCM bv)\n"
"Likewise, return the length in bytes of bytevector @var{bv}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6813
msgid ""
"@deffn {Scheme Procedure} bytevector=? bv1 bv2\n"
"@deffnx {C Function} scm_bytevector_eq_p (bv1, bv2)\n"
"Return is @var{bv1} equals to @var{bv2}---i.e., if they have the same\n"
"length and contents.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6818
msgid ""
"@deffn {Scheme Procedure} bytevector-fill! bv fill\n"
"@deffnx {C Function} scm_bytevector_fill_x (bv, fill)\n"
"Fill bytevector @var{bv} with @var{fill}, a byte.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6826
msgid ""
"@deffn {Scheme Procedure} bytevector-copy! source source-start target target-"
"start len\n"
"@deffnx {C Function} scm_bytevector_copy_x (source, source_start, target, "
"target_start, len)\n"
"Copy @var{len} bytes from @var{source} into @var{target}, starting\n"
"reading from @var{source-start} (a positive index within @var{source})\n"
"and start writing at @var{target-start}.  It is permitted for the\n"
"@var{source} and @var{target} regions to overlap.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6831
msgid ""
"@deffn {Scheme Procedure} bytevector-copy bv\n"
"@deffnx {C Function} scm_bytevector_copy (bv)\n"
"Return a newly allocated copy of @var{bv}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6835
msgid ""
"@deftypefn {C Function} scm_t_uint8 scm_c_bytevector_ref (SCM bv, size_t "
"index)\n"
"Return the byte at @var{index} in bytevector @var{bv}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6839
msgid ""
"@deftypefn {C Function} void scm_c_bytevector_set_x (SCM bv, size_t index, "
"scm_t_uint8 value)\n"
"Set the byte at @var{index} in @var{bv} to @var{value}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6842
msgid ""
"Low-level C macros are available.  They do not perform any\n"
"type-checking; as such they should be used with care."
msgstr ""

#: api-data.texi:6846
msgid ""
"@deftypefn {C Macro} size_t SCM_BYTEVECTOR_LENGTH (bv)\n"
"Return the length in bytes of bytevector @var{bv}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6850
msgid ""
"@deftypefn {C Macro} {signed char *} SCM_BYTEVECTOR_CONTENTS (bv)\n"
"Return a pointer to the contents of bytevector @var{bv}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:6854
msgid ""
"@node Bytevectors as Integers\n"
"@subsubsection Interpreting Bytevector Contents as Integers"
msgstr ""
"@node Bytevectors as Integers\n"
"@subsubsection Интерпретация Байтового Вектора как Целого"

#: api-data.texi:6857
msgid ""
"The contents of a bytevector can be interpreted as a sequence of\n"
"integers of any given size, sign, and endianness."
msgstr ""
"Содержимое байтовго вектора можно интерпретировать как последовательность\n"
"целых чисел любого заданного размера, знака и порядка следования байтов."

#: api-data.texi:6864
msgid ""
"@lisp\n"
"(let ((bv (make-bytevector 4)))\n"
"  (bytevector-u8-set! bv 0 #x12)\n"
"  (bytevector-u8-set! bv 1 #x34)\n"
"  (bytevector-u8-set! bv 2 #x56)\n"
"  (bytevector-u8-set! bv 3 #x78)"
msgstr ""

#: api-data.texi:6870
msgid ""
"  (map (lambda (number)\n"
"         (number->string number 16))\n"
"       (list (bytevector-u8-ref bv 0)\n"
"             (bytevector-u16-ref bv 0 (endianness big))\n"
"             (bytevector-u32-ref bv 0 (endianness little)))))"
msgstr ""

#: api-data.texi:6873
msgid ""
"@result{} (\"12\" \"1234\" \"78563412\")\n"
"@end lisp"
msgstr ""

#: api-data.texi:6876
msgid ""
"The most generic procedures to interpret bytevector contents as integers\n"
"are described below."
msgstr ""
"Ниже описаны наиболее общие процедуры для интерпретации содержимого в виде\n"
"целых чисел."

#: api-data.texi:6882
msgid ""
"@deffn {Scheme Procedure} bytevector-uint-ref bv index endianness size\n"
"@deffnx {C Function} scm_bytevector_uint_ref (bv, index, endianness, size)\n"
"Return the @var{size}-byte long unsigned integer at index @var{index} in\n"
"@var{bv}, decoded according to @var{endianness}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6888
msgid ""
"@deffn {Scheme Procedure} bytevector-sint-ref bv index endianness size\n"
"@deffnx {C Function} scm_bytevector_sint_ref (bv, index, endianness, size)\n"
"Return the @var{size}-byte long signed integer at index @var{index} in\n"
"@var{bv}, decoded according to @var{endianness}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6894
msgid ""
"@deffn {Scheme Procedure} bytevector-uint-set! bv index value endianness "
"size\n"
"@deffnx {C Function} scm_bytevector_uint_set_x (bv, index, value, "
"endianness, size)\n"
"Set the @var{size}-byte long unsigned integer at @var{index} to\n"
"@var{value}, encoded according to @var{endianness}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6900
msgid ""
"@deffn {Scheme Procedure} bytevector-sint-set! bv index value endianness "
"size\n"
"@deffnx {C Function} scm_bytevector_sint_set_x (bv, index, value, "
"endianness, size)\n"
"Set the @var{size}-byte long signed integer at @var{index} to\n"
"@var{value}, encoded according to @var{endianness}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6903
msgid ""
"The following procedures are similar to the ones above, but specialized\n"
"to a given integer size:"
msgstr ""

#: api-data.texi:6924
msgid ""
"@deffn {Scheme Procedure} bytevector-u8-ref bv index\n"
"@deffnx {Scheme Procedure} bytevector-s8-ref bv index\n"
"@deffnx {Scheme Procedure} bytevector-u16-ref bv index endianness\n"
"@deffnx {Scheme Procedure} bytevector-s16-ref bv index endianness\n"
"@deffnx {Scheme Procedure} bytevector-u32-ref bv index endianness\n"
"@deffnx {Scheme Procedure} bytevector-s32-ref bv index endianness\n"
"@deffnx {Scheme Procedure} bytevector-u64-ref bv index endianness\n"
"@deffnx {Scheme Procedure} bytevector-s64-ref bv index endianness\n"
"@deffnx {C Function} scm_bytevector_u8_ref (bv, index)\n"
"@deffnx {C Function} scm_bytevector_s8_ref (bv, index)\n"
"@deffnx {C Function} scm_bytevector_u16_ref (bv, index, endianness)\n"
"@deffnx {C Function} scm_bytevector_s16_ref (bv, index, endianness)\n"
"@deffnx {C Function} scm_bytevector_u32_ref (bv, index, endianness)\n"
"@deffnx {C Function} scm_bytevector_s32_ref (bv, index, endianness)\n"
"@deffnx {C Function} scm_bytevector_u64_ref (bv, index, endianness)\n"
"@deffnx {C Function} scm_bytevector_s64_ref (bv, index, endianness)\n"
"Return the unsigned @var{n}-bit (signed) integer (where @var{n} is 8,\n"
"16, 32 or 64) from @var{bv} at @var{index}, decoded according to\n"
"@var{endianness}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6945
msgid ""
"@deffn {Scheme Procedure} bytevector-u8-set! bv index value\n"
"@deffnx {Scheme Procedure} bytevector-s8-set! bv index value\n"
"@deffnx {Scheme Procedure} bytevector-u16-set! bv index value endianness\n"
"@deffnx {Scheme Procedure} bytevector-s16-set! bv index value endianness\n"
"@deffnx {Scheme Procedure} bytevector-u32-set! bv index value endianness\n"
"@deffnx {Scheme Procedure} bytevector-s32-set! bv index value endianness\n"
"@deffnx {Scheme Procedure} bytevector-u64-set! bv index value endianness\n"
"@deffnx {Scheme Procedure} bytevector-s64-set! bv index value endianness\n"
"@deffnx {C Function} scm_bytevector_u8_set_x (bv, index, value)\n"
"@deffnx {C Function} scm_bytevector_s8_set_x (bv, index, value)\n"
"@deffnx {C Function} scm_bytevector_u16_set_x (bv, index, value, "
"endianness)\n"
"@deffnx {C Function} scm_bytevector_s16_set_x (bv, index, value, "
"endianness)\n"
"@deffnx {C Function} scm_bytevector_u32_set_x (bv, index, value, "
"endianness)\n"
"@deffnx {C Function} scm_bytevector_s32_set_x (bv, index, value, "
"endianness)\n"
"@deffnx {C Function} scm_bytevector_u64_set_x (bv, index, value, "
"endianness)\n"
"@deffnx {C Function} scm_bytevector_s64_set_x (bv, index, value, "
"endianness)\n"
"Store @var{value} as an @var{n}-bit (signed) integer (where @var{n} is\n"
"8, 16, 32 or 64) in @var{bv} at @var{index}, encoded according to\n"
"@var{endianness}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6950
msgid ""
"Finally, a variant specialized for the host's endianness is available\n"
"for each of these functions (with the exception of the @code{u8} and\n"
"@code{s8} accessors, as endianness is about byte order and there is only\n"
"1 byte):"
msgstr ""

#: api-data.texi:6967
msgid ""
"@deffn {Scheme Procedure} bytevector-u16-native-ref bv index\n"
"@deffnx {Scheme Procedure} bytevector-s16-native-ref bv index\n"
"@deffnx {Scheme Procedure} bytevector-u32-native-ref bv index\n"
"@deffnx {Scheme Procedure} bytevector-s32-native-ref bv index\n"
"@deffnx {Scheme Procedure} bytevector-u64-native-ref bv index\n"
"@deffnx {Scheme Procedure} bytevector-s64-native-ref bv index\n"
"@deffnx {C Function} scm_bytevector_u16_native_ref (bv, index)\n"
"@deffnx {C Function} scm_bytevector_s16_native_ref (bv, index)\n"
"@deffnx {C Function} scm_bytevector_u32_native_ref (bv, index)\n"
"@deffnx {C Function} scm_bytevector_s32_native_ref (bv, index)\n"
"@deffnx {C Function} scm_bytevector_u64_native_ref (bv, index)\n"
"@deffnx {C Function} scm_bytevector_s64_native_ref (bv, index)\n"
"Return the unsigned @var{n}-bit (signed) integer (where @var{n} is 8,\n"
"16, 32 or 64) from @var{bv} at @var{index}, decoded according to the\n"
"host's native endianness.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6984
msgid ""
"@deffn {Scheme Procedure} bytevector-u16-native-set! bv index value\n"
"@deffnx {Scheme Procedure} bytevector-s16-native-set! bv index value\n"
"@deffnx {Scheme Procedure} bytevector-u32-native-set! bv index value\n"
"@deffnx {Scheme Procedure} bytevector-s32-native-set! bv index value\n"
"@deffnx {Scheme Procedure} bytevector-u64-native-set! bv index value\n"
"@deffnx {Scheme Procedure} bytevector-s64-native-set! bv index value\n"
"@deffnx {C Function} scm_bytevector_u16_native_set_x (bv, index, value)\n"
"@deffnx {C Function} scm_bytevector_s16_native_set_x (bv, index, value)\n"
"@deffnx {C Function} scm_bytevector_u32_native_set_x (bv, index, value)\n"
"@deffnx {C Function} scm_bytevector_s32_native_set_x (bv, index, value)\n"
"@deffnx {C Function} scm_bytevector_u64_native_set_x (bv, index, value)\n"
"@deffnx {C Function} scm_bytevector_s64_native_set_x (bv, index, value)\n"
"Store @var{value} as an @var{n}-bit (signed) integer (where @var{n} is\n"
"8, 16, 32 or 64) in @var{bv} at @var{index}, encoded according to the\n"
"host's native endianness.\n"
"@end deffn"
msgstr ""

#: api-data.texi:6988
msgid ""
"@node Bytevectors and Integer Lists\n"
"@subsubsection Converting Bytevectors to/from Integer Lists"
msgstr ""
"@node Bytevectors and Integer Lists\n"
"@subsubsection Преобразование байтового вектора в/из списка целых чисел"

#: api-data.texi:6991
msgid ""
"Bytevector contents can readily be converted to/from lists of signed or\n"
"unsigned integers:"
msgstr ""
"Содержимое байтового вектора может быть легко преобразовано в/из спис(ок/"
"ка)\n"
"знаковых или беззнаковых целых чисел:"

#: api-data.texi:6997
msgid ""
"@lisp\n"
"(bytevector->sint-list (u8-list->bytevector (make-list 4 255))\n"
"                       (endianness little) 2)\n"
"@result{} (-1 -1)\n"
"@end lisp"
msgstr ""

#: api-data.texi:7003
msgid ""
"@deffn {Scheme Procedure} bytevector->u8-list bv\n"
"@deffnx {C Function} scm_bytevector_to_u8_list (bv)\n"
"Return a newly allocated list of unsigned 8-bit integers from the\n"
"contents of @var{bv}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7009
msgid ""
"@deffn {Scheme Procedure} u8-list->bytevector lst\n"
"@deffnx {C Function} scm_u8_list_to_bytevector (lst)\n"
"Return a newly allocated bytevector consisting of the unsigned 8-bit\n"
"integers listed in @var{lst}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7015
msgid ""
"@deffn {Scheme Procedure} bytevector->uint-list bv endianness size\n"
"@deffnx {C Function} scm_bytevector_to_uint_list (bv, endianness, size)\n"
"Return a list of unsigned integers of @var{size} bytes representing the\n"
"contents of @var{bv}, decoded according to @var{endianness}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7021
msgid ""
"@deffn {Scheme Procedure} bytevector->sint-list bv endianness size\n"
"@deffnx {C Function} scm_bytevector_to_sint_list (bv, endianness, size)\n"
"Return a list of signed integers of @var{size} bytes representing the\n"
"contents of @var{bv}, decoded according to @var{endianness}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7027
msgid ""
"@deffn {Scheme Procedure} uint-list->bytevector lst endianness size\n"
"@deffnx {C Function} scm_uint_list_to_bytevector (lst, endianness, size)\n"
"Return a new bytevector containing the unsigned integers listed in\n"
"@var{lst} and encoded on @var{size} bytes according to @var{endianness}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7033
msgid ""
"@deffn {Scheme Procedure} sint-list->bytevector lst endianness size\n"
"@deffnx {C Function} scm_sint_list_to_bytevector (lst, endianness, size)\n"
"Return a new bytevector containing the signed integers listed in\n"
"@var{lst} and encoded on @var{size} bytes according to @var{endianness}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7036
msgid ""
"@node Bytevectors as Floats\n"
"@subsubsection Interpreting Bytevector Contents as Floating Point Numbers"
msgstr ""
"@node Bytevectors as Floats\n"
"@subsubsection Интерпретация Байтового Вектора как Числа с плавающей точкой"

#: api-data.texi:7038
msgid "@cindex IEEE-754 floating point numbers"
msgstr ""

#: api-data.texi:7042
msgid ""
"Bytevector contents can also be accessed as IEEE-754 single- or\n"
"double-precision floating point numbers (respectively 32 and 64-bit\n"
"long) using the procedures described here."
msgstr ""
"Содержимое Байтового Вектора можно получить в виде числа с плавающей\n"
"точкой одиночной или двойной точности IEEE-754 (соответственно длиной \n"
"32 и 64-бита) используя процедуры описанные здесь."

#: api-data.texi:7050
msgid ""
"@deffn {Scheme Procedure} bytevector-ieee-single-ref bv index endianness\n"
"@deffnx {Scheme Procedure} bytevector-ieee-double-ref bv index endianness\n"
"@deffnx {C Function} scm_bytevector_ieee_single_ref (bv, index, endianness)\n"
"@deffnx {C Function} scm_bytevector_ieee_double_ref (bv, index, endianness)\n"
"Return the IEEE-754 single-precision floating point number from @var{bv}\n"
"at @var{index} according to @var{endianness}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7058
msgid ""
"@deffn {Scheme Procedure} bytevector-ieee-single-set! bv index value "
"endianness\n"
"@deffnx {Scheme Procedure} bytevector-ieee-double-set! bv index value "
"endianness\n"
"@deffnx {C Function} scm_bytevector_ieee_single_set_x (bv, index, value, "
"endianness)\n"
"@deffnx {C Function} scm_bytevector_ieee_double_set_x (bv, index, value, "
"endianness)\n"
"Store real number @var{value} in @var{bv} at @var{index} according to\n"
"@var{endianness}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7060
msgid "Specialized procedures are also available:"
msgstr ""

#: api-data.texi:7068
msgid ""
"@deffn {Scheme Procedure} bytevector-ieee-single-native-ref bv index\n"
"@deffnx {Scheme Procedure} bytevector-ieee-double-native-ref bv index\n"
"@deffnx {C Function} scm_bytevector_ieee_single_native_ref (bv, index)\n"
"@deffnx {C Function} scm_bytevector_ieee_double_native_ref (bv, index)\n"
"Return the IEEE-754 single-precision floating point number from @var{bv}\n"
"at @var{index} according to the host's native endianness.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7076
msgid ""
"@deffn {Scheme Procedure} bytevector-ieee-single-native-set! bv index value\n"
"@deffnx {Scheme Procedure} bytevector-ieee-double-native-set! bv index "
"value\n"
"@deffnx {C Function} scm_bytevector_ieee_single_native_set_x (bv, index, "
"value)\n"
"@deffnx {C Function} scm_bytevector_ieee_double_native_set_x (bv, index, "
"value)\n"
"Store real number @var{value} in @var{bv} at @var{index} according to\n"
"the host's native endianness.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7080
msgid ""
"@node Bytevectors as Strings\n"
"@subsubsection Interpreting Bytevector Contents as Unicode Strings"
msgstr ""
"@node Bytevectors as Strings\n"
"@subsubsection Итерпретация содержимого Байтового Вектора как строки Unicode"

#: api-data.texi:7082
msgid "@cindex Unicode string encoding"
msgstr ""

#: api-data.texi:7086
msgid ""
"Bytevector contents can also be interpreted as Unicode strings encoded\n"
"in one of the most commonly available encoding formats.\n"
"@xref{Representing Strings as Bytes}, for a more generic interface."
msgstr ""
"Содержимое байтового вектора также может быть интерпретировано как\n"
"строки Unicode, закодированные в одном из самых широко распространенных\n"
"форматов кодирования.\n"
"@xref{Representing Strings as Bytes}, для более общего интерфейса."

#: api-data.texi:7090
msgid ""
"@lisp\n"
"(utf8->string (u8-list->bytevector '(99 97 102 101)))\n"
"@result{} \"cafe\""
msgstr ""

#: api-data.texi:7094
msgid ""
"(string->utf8 \"caf@'e\") ;; SMALL LATIN LETTER E WITH ACUTE ACCENT\n"
"@result{} #vu8(99 97 102 195 169)\n"
"@end lisp"
msgstr ""

#: api-data.texi:7100
msgid ""
"@deftypefn {Scheme Procedure} {} string-utf8-length str\n"
"@deftypefnx {C function} SCM scm_string_utf8_length (str)\n"
"@deftypefnx {C function} size_t scm_c_string_utf8_length (str)\n"
"Return the number of bytes in the UTF-8 representation of @var{str}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:7112
msgid ""
"@deffn {Scheme Procedure} string->utf8 str\n"
"@deffnx {Scheme Procedure} string->utf16 str [endianness]\n"
"@deffnx {Scheme Procedure} string->utf32 str [endianness]\n"
"@deffnx {C Function} scm_string_to_utf8 (str)\n"
"@deffnx {C Function} scm_string_to_utf16 (str, endianness)\n"
"@deffnx {C Function} scm_string_to_utf32 (str, endianness)\n"
"Return a newly allocated bytevector that contains the UTF-8, UTF-16, or\n"
"UTF-32 (aka. UCS-4) encoding of @var{str}.  For UTF-16 and UTF-32,\n"
"@var{endianness} should be the symbol @code{big} or @code{little}; when "
"omitted,\n"
"it defaults to big endian.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7124
msgid ""
"@deffn {Scheme Procedure} utf8->string utf\n"
"@deffnx {Scheme Procedure} utf16->string utf [endianness]\n"
"@deffnx {Scheme Procedure} utf32->string utf [endianness]\n"
"@deffnx {C Function} scm_utf8_to_string (utf)\n"
"@deffnx {C Function} scm_utf16_to_string (utf, endianness)\n"
"@deffnx {C Function} scm_utf32_to_string (utf, endianness)\n"
"Return a newly allocated string that contains from the UTF-8-, UTF-16-,\n"
"or UTF-32-decoded contents of bytevector @var{utf}.  For UTF-16 and UTF-32,\n"
"@var{endianness} should be the symbol @code{big} or @code{little}; when "
"omitted,\n"
"it defaults to big endian.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7127
msgid ""
"@node Bytevectors as Arrays\n"
"@subsubsection Accessing Bytevectors with the Array API"
msgstr ""
"@node Bytevectors as Arrays\n"
"@subsubsection Доступ к Байтовому вектору через API работы с Массивами"

#: api-data.texi:7131
msgid ""
"As an extension to the R6RS, Guile allows bytevectors to be manipulated\n"
"with the @dfn{array} procedures (@pxref{Arrays}).  When using these\n"
"APIs, bytes are accessed one at a time as 8-bit unsigned integers:"
msgstr ""
"В качестве расширения для R6RS, Guile позволяет управлять байтовыми\n"
"векторами с помощью процедур работы с массивами (@pxref{Arrays}).  \n"
"При использовании этого API, байты доспупны по одному как 8-битовы\n"
"целые числа без знака:"

#: api-data.texi:7134
msgid ""
"@example\n"
"(define bv #vu8(0 1 2 3))"
msgstr ""

#: api-data.texi:7137
msgid ""
"(array? bv)\n"
"@result{} #t"
msgstr ""

#: api-data.texi:7140
msgid ""
"(array-rank bv)\n"
"@result{} 1"
msgstr ""

#: api-data.texi:7143
msgid ""
"(array-ref bv 2)\n"
"@result{} 2"
msgstr ""

#: api-data.texi:7148
msgid ""
";; Note the different argument order on array-set!.\n"
"(array-set! bv 77 2)\n"
"(array-ref bv 2)\n"
"@result{} 77"
msgstr ""

#: api-data.texi:7152
msgid ""
"(array-type bv)\n"
"@result{} vu8\n"
"@end example"
msgstr ""

#: api-data.texi:7156
msgid ""
"@node Bytevectors as Uniform Vectors\n"
"@subsubsection Accessing Bytevectors with the SRFI-4 API"
msgstr ""
"@node Bytevectors as Uniform Vectors\n"
"@subsubsection Доступ к Байтовому Вектору через SRFI-4 API"

#: api-data.texi:7159
msgid ""
"Bytevectors may also be accessed with the SRFI-4 API. @xref{SRFI-4 and\n"
"Bytevectors}, for more information."
msgstr ""
"Доступ к байтовым векторам также возможен с помощью SRFI-4 API. @xref{SRFI-4 "
"and\n"
"Bytevectors}, для получения более подробной информации."

#: api-data.texi:7164
msgid ""
"@node Arrays\n"
"@subsection Arrays\n"
"@tpindex Arrays"
msgstr ""
"@node Arrays\n"
"@subsection Массивы(Arrays)\n"
"@tpindex Arrays"

#: api-data.texi:7168
msgid ""
"@dfn{Arrays} are a collection of cells organized into an arbitrary\n"
"number of dimensions.  Each cell can be accessed in constant time by\n"
"supplying an index for each dimension."
msgstr ""
"@dfn{Arrays} Массивы представляют собой набор ячеек, организованных в\n"
"произвольное число измерений. Каждую ячейку можно получить в течении\n"
"фиксированного времени, указав индекс для каждого измерения."

#: api-data.texi:7176
msgid ""
"In the current implementation, an array uses a vector of some kind for\n"
"the actual storage of its elements.  Any kind of vector will do, so you\n"
"can have arrays of uniform numeric values, arrays of characters, arrays\n"
"of bits, and of course, arrays of arbitrary Scheme values.  For example,\n"
"arrays with an underlying @code{c64vector} might be nice for digital\n"
"signal processing, while arrays made from a @code{u8vector} might be\n"
"used to hold gray-scale images."
msgstr ""
"В текущей реализации массив использует какой либо вектор для реального\n"
"хранения своих элементов. Любой вектор будет работать, поэтому вы можете\n"
"иметь массивы единых числовых значений, массивы символов, массивы бит\n"
"и конечно массивы произвольных значений Scheme.  Например, массивы\n"
"с базовым типом @code{c64vector} могут быть хороши для обработки \n"
"цифровых сигналов, в то время как массивы созданные из @code{u8vector},\n"
"могут использоваться для хранения изображений в серой шкалой цветности."

#: api-data.texi:7186
msgid ""
"The number of dimensions of an array is called its @dfn{rank}.  Thus,\n"
"a matrix is an array of rank 2, while a vector has rank 1.  When\n"
"accessing an array element, you have to specify one exact integer for\n"
"each dimension.  These integers are called the @dfn{indices} of the\n"
"element.  An array specifies the allowed range of indices for each\n"
"dimension via an inclusive lower and upper bound.  These bounds can\n"
"well be negative, but the upper bound must be greater than or equal to\n"
"the lower bound minus one.  When all lower bounds of an array are\n"
"zero, it is called a @dfn{zero-origin} array."
msgstr ""
"Число измерений массива называется его рангом @dfn{rank}.  Таким\n"
"образом, матрица представляет собой массив ранга 2, а вектор имеет\n"
"ранг 1. При доступе к элементу массива вы должны указать одно точное\n"
"целое для каждого его измерения. Эти целые числа называются индексами\n"
"элемента массива. Массив задает допустимый диапазон индексов для каждого\n"
"измерения через инклюзивные нижние и верхнии границы. Эти границы\n"
"могут быть отритцательными, но верхняя граница должна быть больше нижней \n"
"границы минус 1. Когад все нижние границы равны нулю, он называется\n"
"массивом с нулевым началом. @dfn{zero-origin}."

#: api-data.texi:7190
msgid ""
"Arrays can be of rank 0, which could be interpreted as a scalar.\n"
"Thus, a zero-rank array can store exactly one object and the list of\n"
"indices of this element is the empty list."
msgstr ""
"Массивы могут иметь ранг 0, который можно интерпретировать как скаляр.\n"
"Таким образом, массив нулевого ранга может хранить ровно один объект,\n"
"а список индексов этого элемента - пустой список."

#: api-data.texi:7196
msgid ""
"Arrays contain zero elements when one of their dimensions has a zero\n"
"length.  These empty arrays maintain information about their shape: a\n"
"matrix with zero columns and 3 rows is different from a matrix with 3\n"
"columns and zero rows, which again is different from a vector of\n"
"length zero."
msgstr ""
"Массивы содержат 0 элементов, когда одна из размерностей равна нулю.\n"
"Эти пустые массивы сохраняют информацию об их форме: матрица с нулевыми\n"
"столбцами и 3 строками отличается от матрицы с тремя столбцами и\n"
"нулем строк, что в свою очередь отличается от вектора нулевой длины."

#: api-data.texi:7200
msgid ""
"The array procedures are all polymorphic, treating strings, uniform\n"
"numeric vectors, bytevectors, bit vectors and ordinary vectors as one\n"
"dimensional arrays."
msgstr ""
"Процедуры работающие с массивами являются полиморфными, они обрабатывают\n"
"строки, унифицированные числовые вектора, байтовые вектора, и обычные\n"
"вектора как одномерные массивы."

#: api-data.texi:7208
msgid ""
"@menu\n"
"* Array Syntax::                \n"
"* Array Procedures::            \n"
"* Shared Arrays::               \n"
"* Arrays as arrays of arrays::\n"
"* Accessing Arrays from C::     \n"
"@end menu"
msgstr ""

#: api-data.texi:7211
msgid ""
"@node Array Syntax\n"
"@subsubsection Array Syntax"
msgstr ""
"@node Array Syntax\n"
"@subsubsection Синтаксис определения Массивов"

#: api-data.texi:7216
msgid ""
"An array is displayed as @code{#} followed by its rank, followed by a\n"
"tag that describes the underlying vector, optionally followed by\n"
"information about its shape, and finally followed by the cells,\n"
"organized into dimensions using parentheses."
msgstr ""
"Массив отображается как решетка @code{#}, за которой следует ранг,\n"
"за которым следует тег, который описывает основной вектор, необязательно\n"
"сопровождаемый информацией о его форме, и наконце следуют ячейки, \n"
"организованные по размерностям с помощью круглых скобок."

#: api-data.texi:7218
msgid "In more words, the array tag is of the form"
msgstr "Другими словами, тег массива имеет вид:"

#: api-data.texi:7222
msgid ""
"@example\n"
"  #<rank><vectag><@@lower><:len><@@lower><:len>...\n"
"@end example"
msgstr ""

#: api-data.texi:7228
msgid ""
"where @code{<rank>} is a positive integer in decimal giving the rank of\n"
"the array.  It is omitted when the rank is 1 and the array is non-shared\n"
"and has zero-origin (see below).  For shared arrays and for a non-zero\n"
"origin, the rank is always printed even when it is 1 to distinguish\n"
"them from ordinary vectors."
msgstr ""
"где @code{<rank>} - положительное целое число в десятичном значении, "
"задающее\n"
"ранг массива. Он может быть опущен когда ранг равен 1, а массив не разделен\n"
"и имеет начальный элемент с нулевым индексом (см. ниже).  Для разделяемых\n"
"массивов и массивов с ненулевым начальным индексом, ранг указывается "
"всегда, \n"
"даже когда он единичный, и их отличают от обычных векторов."

#: api-data.texi:7232
msgid ""
"The @code{<vectag>} part is the tag for a uniform numeric vector, like\n"
"@code{u8}, @code{s16}, etc, @code{b} for bitvectors, or @code{a} for\n"
"strings.  It is empty for ordinary vectors."
msgstr ""
"Часть @code{<vectag>} является тегом для унифицированного числовго вектора,\n"
"такого как @code{u8}, @code{s16}, и др., @code{b} для битового вектора, "
"или \n"
"@code{a} для стороки.  Он пуст для обычных векторов."

#: api-data.texi:7237
msgid ""
"The @code{<@@lower>} part is a @samp{@@} character followed by a signed\n"
"integer in decimal giving the lower bound of a dimension.  There is one\n"
"@code{<@@lower>} for each dimension.  When all lower bounds are zero,\n"
"all @code{<@@lower>} parts are omitted."
msgstr ""
"Часть @code{<@@lower>} начинается с символа @samp{@@} за которым следует\n"
"целое число со знаком десятичном значении, которое дает нижнюю границу\n"
"размерности массива.  Для каждого измерения существует один "
"@code{<@@lower>} \n"
"Когда все нижние границы равны нулю, все части @code{<@@lower>} опускаются."

#: api-data.texi:7245
msgid ""
"The @code{<:len>} part is a @samp{:} character followed by an unsigned\n"
"integer in decimal giving the length of a dimension.  Like for the lower\n"
"bounds, there is one @code{<:len>} for each dimension, and the\n"
"@code{<:len>} part always follows the @code{<@@lower>} part for a\n"
"dimension.  Lengths are only then printed when they can't be deduced\n"
"from the nested lists of elements of the array literal, which can happen\n"
"when at least one length is zero."
msgstr ""
"Часть @code{<:len>} начинается символом @samp{:}, за которым следует\n"
"целое число без знака в десятичном значении, дающее длину размерности.\n"
"Как и для нижних границ, для каждого измерения существует только одна\n"
"длина @code{<:len>}, и часть @code{<:len>} всегда следует за частью\n"
"@code{<@@lower>} для каждого измерения.  Только длины печатаются,\n"
"когда массив не может быть выведен из за вложенных списков элементов\n"
"массива, что может произойти когда длина хотя бы одной размерности\n"
"равна нулю."

#: api-data.texi:7249
msgid ""
"As a special case, an array of rank 0 is printed as\n"
"@code{#0<vectag>(<scalar>)}, where @code{<scalar>} is the result of\n"
"printing the single element of the array."
msgstr ""
"В качестве специального случая, массив с рангом равным 0 печтатется\n"
"как @code{#0<vectag>(<scalar>)}, где  @code{<scalar>} - это результат\n"
"печати одного элемента массива."

#: api-data.texi:7251
msgid "Thus, "
msgstr "Таким образом,"

#: api-data.texi:7256
msgid ""
"@table @code\n"
"@item #(1 2 3)\n"
"is an ordinary array of rank 1 with lower bound 0 in dimension 0.\n"
"(I.e., a regular vector.)"
msgstr ""
"@table @code\n"
"@item #(1 2 3)\n"
"это обычный массив ранга 1 с нижней границей 0 в размерности 0\n"
"(т.е, a это обычный вектор)"

#: api-data.texi:7259
msgid ""
"@item #@@2(1 2 3)\n"
"is an ordinary array of rank 1 with lower bound 2 in dimension 0."
msgstr ""
"@item #@@2(1 2 3)\n"
"это обычный массив ранга 1 с нижней границей равной 2 в размерности 0."

#: api-data.texi:7263
msgid ""
"@item #2((1 2 3) (4 5 6))\n"
"is a non-uniform array of rank 2; a 2@cross{}3 matrix with index ranges "
"0..1\n"
"and 0..2."
msgstr ""
"@item #2((1 2 3) (4 5 6))\n"
"это не унифицированный(содержащий элементы различных типов) массив ранга "
"2; \n"
"матрица 2@cross{}3 с индексами в области 0..1 и 0..2."

#: api-data.texi:7266
msgid ""
"@item #u32(0 1 2)\n"
"is a uniform u8 array of rank 1."
msgstr ""
"@item #u32(0 1 2)\n"
"унифицированный массив типа u32 ранга 1."

#: api-data.texi:7269
msgid ""
"@item #2u32@@2@@3((1 2) (2 3))\n"
"is a uniform u32 array of rank 2 with index ranges 2..3 and 3..4."
msgstr ""
"@item #2u32@@2@@3((1 2) (2 3))\n"
"унифицированный массив с элементами типа u32 ранга 2 с индексами\n"
"в пределах 2..3 и 3..4."

#: api-data.texi:7273
msgid ""
"@item #2()\n"
"is a two-dimensional array with index ranges 0..-1 and 0..-1, i.e.@:\n"
"both dimensions have length zero."
msgstr ""
"@item #2()\n"
"представляет собой двухмерный массив с диапазонами индексов 0..-1 и\n"
" 0..-1, т.е обе размерности имеют нулевую длину."

#: api-data.texi:7277
msgid ""
"@item #2:0:2()\n"
"is a two-dimensional array with index ranges 0..-1 and 0..1, i.e.@: the\n"
"first dimension has length zero, but the second has length 2."
msgstr ""
"@item #2:0:2()\n"
"представляет собой двумерный массив с индексами 0..-1 и 0..1, т.е.\n"
"первая размрность имеет нулевую длину, а вторая имеет длину 2."

#: api-data.texi:7280
msgid ""
"@item #0(12)\n"
"is a rank-zero array with contents 12."
msgstr ""
"@item #0(12)\n"
"это массив с рангом 0 содержащий число 12."

#: api-data.texi:7282
msgctxt "api-data.texi:7282"
msgid "@end table"
msgstr ""

#: api-data.texi:7285
msgid ""
"In addition, bytevectors are also arrays, but use a different syntax\n"
"(@pxref{Bytevectors}):"
msgstr ""
"Кроме того, байтовый вектор (bytevectors) также является массивом, но\n"
"использует другой синтаксис:\n"
"(@pxref{Bytevectors}):"

#: api-data.texi:7287
msgid "@table @code"
msgstr ""

#: api-data.texi:7290
msgid ""
"@item #vu8(1 2 3)\n"
"is a 3-byte long bytevector, with contents 1, 2, 3."
msgstr ""
"@item #vu8(1 2 3)\n"
"представляет собой байтовый вектор длиной в 3-байта, содержащий 1, 2, 3."

#: api-data.texi:7292
msgctxt "api-data.texi:7292"
msgid "@end table"
msgstr ""

#: api-data.texi:7295
msgid ""
"@node Array Procedures\n"
"@subsubsection Array Procedures"
msgstr ""
"@node Array Procedures\n"
"@subsubsection Процедуры работающие с Массивами"

#: api-data.texi:7298
msgid ""
"When an array is created, the range of each dimension must be\n"
"specified, e.g., to create a 2@cross{}3 array with a zero-based index:"
msgstr ""
"Когда создается массив, диапазон каждго измерения должен быть\n"
"определен, например, для создания массива 2@cross{}3 с\n"
"индексами начинающимися с нуля:"

#: api-data.texi:7302
msgid ""
"@example\n"
"(make-array 'ho 2 3) @result{} #2((ho ho ho) (ho ho ho))\n"
"@end example"
msgstr ""

#: api-data.texi:7305
msgid ""
"The range of each dimension can also be given explicitly, e.g., another\n"
"way to create the same array:"
msgstr ""
"Диапазон каждого измерения также может быть задан явно, другой способ\n"
"создания тогоже массива:"

#: api-data.texi:7309
msgid ""
"@example\n"
"(make-array 'ho '(0 1) '(0 2)) @result{} #2((ho ho ho) (ho ho ho))\n"
"@end example"
msgstr ""

#: api-data.texi:7314
msgid ""
"The following procedures can be used with arrays (or vectors).  An\n"
"argument shown as @var{idx}@dots{} means one parameter for each\n"
"dimension in the array.  A @var{idxlist} argument means a list of such\n"
"values, one for each dimension."
msgstr ""
"Следующие процедуры могут использоваться с массивами(или векторами).\n"
"Аргумент, показанный как @var{idx}@dots{} означает один параметр для "
"каждого\n"
"измерения в массива.  Аргумент @var{idxlist} означает список таких "
"значений,\n"
"по одному для каждого измерения."

#: api-data.texi:7320
msgid ""
"@deffn {Scheme Procedure} array? obj\n"
"@deffnx {C Function} scm_array_p (obj, unused)\n"
"Return @code{#t} if the @var{obj} is an array, and @code{#f} if\n"
"not."
msgstr ""

#: api-data.texi:7325
msgid ""
"The second argument to scm_array_p is there for historical reasons,\n"
"but it is not used.  You should always pass @code{SCM_UNDEFINED} as\n"
"its value.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7331
msgid ""
"@deffn {Scheme Procedure} typed-array? obj type\n"
"@deffnx {C Function} scm_typed_array_p (obj, type)\n"
"Return @code{#t} if the @var{obj} is an array of type @var{type}, and\n"
"@code{#f} if not.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7335
msgid ""
"@deftypefn {C Function} int scm_is_array (SCM obj)\n"
"Return @code{1} if the @var{obj} is an array and @code{0} if not.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:7340
msgid ""
"@deftypefn {C Function} int scm_is_typed_array (SCM obj, SCM type)\n"
"Return @code{0} if the @var{obj} is an array of type @var{type}, and\n"
"@code{1} if not.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:7345
msgid ""
"@deffn {Scheme Procedure} make-array fill bound @dots{}\n"
"@deffnx {C Function} scm_make_array (fill, bounds)\n"
"Equivalent to @code{(make-typed-array #t @var{fill} @var{bound} ...)}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7350
msgid ""
"@deffn {Scheme Procedure} make-typed-array type fill bound @dots{}\n"
"@deffnx {C Function} scm_make_typed_array (type, fill, bounds)\n"
"Create and return an array that has as many dimensions as there are\n"
"@var{bound}s and (maybe) fill it with @var{fill}."
msgstr ""

#: api-data.texi:7354
msgid ""
"The underlying storage vector is created according to @var{type},\n"
"which must be a symbol whose name is the `vectag' of the array as\n"
"explained above, or @code{#t} for ordinary, non-specialized arrays."
msgstr ""

#: api-data.texi:7358
msgid ""
"For example, using the symbol @code{f64} for @var{type} will create an\n"
"array that uses a @code{f64vector} for storing its elements, and\n"
"@code{a} will use a string."
msgstr ""

#: api-data.texi:7365
msgid ""
"When @var{fill} is not the special @emph{unspecified} value, the new\n"
"array is filled with @var{fill}.  Otherwise, the initial contents of\n"
"the array is unspecified.  The special @emph{unspecified} value is\n"
"stored in the variable @code{*unspecified*} so that for example\n"
"@code{(make-typed-array 'u32 *unspecified* 4)} creates a uninitialized\n"
"@code{u32} vector of length 4."
msgstr ""

#: api-data.texi:7373
msgid ""
"Each @var{bound} may be a positive non-zero integer @var{n}, in which\n"
"case the index for that dimension can range from 0 through @var{n}-1; or\n"
"an explicit index range specifier in the form @code{(LOWER UPPER)},\n"
"where both @var{lower} and @var{upper} are integers, possibly less than\n"
"zero, and possibly the same number (however, @var{lower} cannot be\n"
"greater than @var{upper}).\n"
"@end deffn"
msgstr ""

#: api-data.texi:7378
msgid ""
"@deffn {Scheme Procedure} list->array dimspec list\n"
"Equivalent to @code{(list->typed-array #t @var{dimspec}\n"
"@var{list})}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7383
msgid ""
"@deffn {Scheme Procedure} list->typed-array type dimspec list\n"
"@deffnx {C Function} scm_list_to_typed_array (type, dimspec, list)\n"
"Return an array of the type indicated by @var{type} with elements the\n"
"same as those of @var{list}."
msgstr ""

#: api-data.texi:7391
msgid ""
"The argument @var{dimspec} determines the number of dimensions of the\n"
"array and their lower bounds.  When @var{dimspec} is an exact integer,\n"
"it gives the number of dimensions directly and all lower bounds are\n"
"zero.  When it is a list of exact integers, then each element is the\n"
"lower index bound of a dimension, and there will be as many dimensions\n"
"as elements in the list.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7399
msgid ""
"@deffn {Scheme Procedure} array-type array\n"
"@deffnx {C Function} scm_array_type (array)\n"
"Return the type of @var{array}.  This is the `vectag' used for\n"
"printing @var{array} (or @code{#t} for ordinary arrays) and can be\n"
"used with @code{make-typed-array} to create an array of the same kind\n"
"as @var{array}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7403
msgid ""
"@deffn {Scheme Procedure} array-ref array idx @dots{}\n"
"@deffnx {C Function} scm_array_ref (array, idxlist)\n"
"Return the element at @code{(idx @dots{})} in @var{array}."
msgstr ""

#: api-data.texi:7409
msgid ""
"@example\n"
"(define a (make-array 999 '(1 2) '(3 4)))\n"
"(array-ref a 2 4) @result{} 999\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:7414
msgid ""
"@deffn {Scheme Procedure} array-in-bounds? array idx @dots{}\n"
"@deffnx {C Function} scm_array_in_bounds_p (array, idxlist)\n"
"Return @code{#t} if the given indices would be acceptable to\n"
"@code{array-ref}."
msgstr ""

#: api-data.texi:7421
msgid ""
"@example\n"
"(define a (make-array #f '(1 2) '(3 4)))\n"
"(array-in-bounds? a 2 3) @result{} #t\n"
"(array-in-bounds? a 0 0) @result{} #f\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:7426
msgid ""
"@deffn {Scheme Procedure} array-set! array obj idx @dots{}\n"
"@deffnx {C Function} scm_array_set_x (array, obj, idxlist)\n"
"Set the element at @code{(idx @dots{})} in @var{array} to @var{obj}.\n"
"The return value is unspecified."
msgstr ""

#: api-data.texi:7433
msgid ""
"@example\n"
"(define a (make-array #f '(0 1) '(0 1)))\n"
"(array-set! a #t 1 1)\n"
"a @result{} #2((#f #f) (#f #t))\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:7438
msgid ""
"@deffn {Scheme Procedure} array-shape array\n"
"@deffnx {Scheme Procedure} array-dimensions array\n"
"@deffnx {C Function} scm_array_dimensions (array)\n"
"Return a list of the bounds for each dimension of @var{array}."
msgstr ""

#: api-data.texi:7443
msgid ""
"@code{array-shape} gives @code{(@var{lower} @var{upper})} for each\n"
"dimension.  @code{array-dimensions} instead returns just\n"
"@math{@var{upper}+1} for dimensions with a 0 lower bound.  Both are\n"
"suitable as input to @code{make-array}."
msgstr ""

#: api-data.texi:7445
msgctxt "api-data.texi:7445"
msgid "For example,"
msgstr ""

#: api-data.texi:7452
msgid ""
"@example\n"
"(define a (make-array 'foo '(-1 3) 5))\n"
"(array-shape a)      @result{} ((-1 3) (0 4))\n"
"(array-dimensions a) @result{} ((-1 3) 5)\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:7459
msgid ""
"@deffn {Scheme Procedure} array-length array\n"
"@deffnx {C Function} scm_array_length (array)\n"
"@deffnx {C Function} size_t scm_c_array_length (array)\n"
"Return the length of an array: its first dimension. It is an error to\n"
"ask for the length of an array of rank 0.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7464
msgid ""
"@deffn {Scheme Procedure} array-rank array\n"
"@deffnx {C Function} scm_array_rank (array)\n"
"Return the rank of @var{array}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7468
msgid ""
"@deftypefn {C Function} size_t scm_c_array_rank (SCM array)\n"
"Return the rank of @var{array} as a @code{size_t}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:7474
msgid ""
"@deffn {Scheme Procedure} array->list array\n"
"@deffnx {C Function} scm_array_to_list (array)\n"
"Return a list consisting of all the elements, in order, of\n"
"@var{array}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7486
msgid ""
"@c  FIXME: Describe how the order affects the copying (it matters for\n"
"@c  shared arrays with the same underlying root vector, presumably).\n"
"@c\n"
"@deffn {Scheme Procedure} array-copy! src dst\n"
"@deffnx {Scheme Procedure} array-copy-in-order! src dst\n"
"@deffnx {C Function} scm_array_copy_x (src, dst)\n"
"Copy every element from vector or array @var{src} to the corresponding\n"
"element of @var{dst}.  @var{dst} must have the same rank as @var{src},\n"
"and be at least as large in each dimension.  The return value is\n"
"unspecified.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7492
msgid ""
"@deffn {Scheme Procedure} array-fill! array fill\n"
"@deffnx {C Function} scm_array_fill_x (array, fill)\n"
"Store @var{fill} in every element of @var{array}.  The value returned\n"
"is unspecified.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7500
msgid ""
"@c begin (texi-doc-string \"guile\" \"array-equal?\")\n"
"@deffn {Scheme Procedure} array-equal? array @dots{}\n"
"Return @code{#t} if all arguments are arrays with the same shape, the\n"
"same type, and have corresponding elements which are either\n"
"@code{equal?} or @code{array-equal?}.  This function differs from\n"
"@code{equal?} (@pxref{Equality}) in that all arguments must be arrays.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7506
msgid ""
"@c  FIXME: array-for-each doesn't say what happens if the sources have\n"
"@c  different index ranges.  The code currently iterates over the\n"
"@c  indices of the first and expects the others to cover those.  That\n"
"@c  at least vaguely matches array-map!, but is it meant to be a\n"
"@c  documented feature?"
msgstr ""

#: api-data.texi:7513
msgid ""
"@deffn {Scheme Procedure} array-map! dst proc src @dots{}\n"
"@deffnx {Scheme Procedure} array-map-in-order! dst proc src @dots{}\n"
"@deffnx {C Function} scm_array_map_x (dst, proc, srclist)\n"
"Set each element of the @var{dst} array to values obtained from calls to\n"
"@var{proc}.  The list of @var{src} arguments may be empty.  The value\n"
"returned is unspecified."
msgstr ""

#: api-data.texi:7518
msgid ""
"Each call is @code{(@var{proc} @var{elem} @dots{})}, where each\n"
"@var{elem} is from the corresponding @var{src} array, at the\n"
"@var{dst} index.  @code{array-map-in-order!} makes the calls in\n"
"row-major order, @code{array-map!} makes them in an unspecified order."
msgstr ""

#: api-data.texi:7524
msgid ""
"The @var{src} arrays must have the same number of dimensions as\n"
"@var{dst}, and must have a range for each dimension which covers the\n"
"range in @var{dst}.  This ensures all @var{dst} indices are valid in\n"
"each @var{src}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7530
msgid ""
"@deffn {Scheme Procedure} array-for-each proc src1 src2 @dots{}\n"
"@deffnx {C Function} scm_array_for_each (proc, src1, srclist)\n"
"Apply @var{proc} to each tuple of elements of @var{src1} @var{src2}\n"
"@dots{}, in row-major order.  The value returned is unspecified.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7535
msgid ""
"@deffn {Scheme Procedure} array-index-map! dst proc\n"
"@deffnx {C Function} scm_array_index_map_x (dst, proc)\n"
"Set each element of the @var{dst} array to values returned by calls to\n"
"@var{proc}.  The value returned is unspecified."
msgstr ""

#: api-data.texi:7539
msgid ""
"Each call is @code{(@var{proc} @var{i1} @dots{} @var{iN})}, where\n"
"@var{i1}@dots{}@var{iN} is the destination index, one parameter for\n"
"each dimension.  The order in which the calls are made is unspecified."
msgstr ""

#: api-data.texi:7542
msgid ""
"For example, to create a @m{4\\times4, 4x4} matrix representing a\n"
"cyclic group,"
msgstr ""

#: api-data.texi:7560
msgid ""
"@tex\n"
"\\advance\\leftskip by 2\\lispnarrowing {\n"
"$\\left(\\matrix{%\n"
"0 & 1 & 2 & 3 \\cr\n"
"1 & 2 & 3 & 0 \\cr\n"
"2 & 3 & 0 & 1 \\cr\n"
"3 & 0 & 1 & 2 \\cr\n"
"}\\right)$} \\par\n"
"@end tex\n"
"@ifnottex\n"
"@example\n"
"    / 0 1 2 3 \\\n"
"    | 1 2 3 0 |\n"
"    | 2 3 0 1 |\n"
"    \\ 3 0 1 2 /\n"
"@end example\n"
"@end ifnottex"
msgstr ""

#: api-data.texi:7567
msgid ""
"@example\n"
"(define a (make-array #f 4 4))\n"
"(array-index-map! a (lambda (i j)\n"
"                      (modulo (+ i j) 4)))\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:7570
msgid ""
"An additional array function is available in the module\n"
"@code{(ice-9 arrays)}. It can be used with:"
msgstr ""

#: api-data.texi:7574
msgid ""
"@example\n"
"(use-modules (ice-9 arrays))\n"
"@end example"
msgstr ""

#: api-data.texi:7582
msgid ""
"@deffn {Scheme Procedure} array-copy src\n"
"Return a new array with the same elements, type and shape as\n"
"@var{src}. However, the array increments may not be the same as those of\n"
"@var{src}. In the current implementation, the returned array will be in\n"
"row-major order, but that might change in the future. Use\n"
"@code{array-copy!} on an array of known order if that is a concern.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7585
msgid ""
"@node Shared Arrays\n"
"@subsubsection Shared Arrays"
msgstr ""
"@node Shared Arrays\n"
"@subsubsection Общие Массивы"

#: api-data.texi:7592
msgid ""
"@deffn {Scheme Procedure} make-shared-array oldarray mapfunc bound @dots{}\n"
"@deffnx {C Function} scm_make_shared_array (oldarray, mapfunc, boundlist)\n"
"Return a new array which shares the storage of @var{oldarray}.\n"
"Changes made through either affect the same underlying storage.  The\n"
"@var{bound} @dots{} arguments are the shape of the new array, the same\n"
"as @code{make-array} (@pxref{Array Procedures})."
msgstr ""
"@deffn {Scheme Procedure} make-shared-array oldarray mapfunc bound @dots{}\n"
"@deffnx {C Function} scm_make_shared_array (oldarray, mapfunc, boundlist)\n"
"Возвращает новый массив, который разделяет хранилище @var{oldarray}.\n"
"Изменения, произведенные в нем, влияют на общее хранилище.  Аргументы\n"
"@var{bound} @dots{} определяют границы нового массива, такие же как и в\n"
"@code{make-array} (@pxref{Array Procedures})."

#: api-data.texi:7598
msgid ""
"@var{mapfunc} translates coordinates from the new array to the\n"
"@var{oldarray}.  It's called as @code{(@var{mapfunc} newidx1 @dots{})}\n"
"with one parameter for each dimension of the new array, and should\n"
"return a list of indices for @var{oldarray}, one for each dimension of\n"
"@var{oldarray}."
msgstr ""
"@var{mapfunc} переводит координаты из нового массива в старый\n"
"@var{oldarray}. Она вызывается как @code{(@var{mapfunc} newidx1 @dots{})}\n"
"с одним параметром для каждого измерения нового массива, и должна возращать\n"
"список индексов для старого массива @var{oldarray}, по одному для каждого\n"
"измерения @var{oldarray}."

#: api-data.texi:7603
msgid ""
"@var{mapfunc} must be affine linear, meaning that each @var{oldarray}\n"
"index must be formed by adding integer multiples (possibly negative)\n"
"of some or all of @var{newidx1} etc, plus a possible integer offset.\n"
"The multiples and offset must be the same in each call."
msgstr ""
"@var{mapfunc} должна быть афинно линейной, что означает, что каждый\n"
"индекс в старом массиве @var{oldarray} должен быть сформирован \n"
"добавлением (возможно отритцательным) целочисленных множителей, \n"
"некоторых или всех новых индексов @var{newidx1} etc, плюс \n"
"возможно целочисленное мещение.\n"
"В каждом вызове множители и смещения должны быть одинаковыми."

#: api-data.texi:7610
msgid ""
"@sp 1\n"
"One good use for a shared array is to restrict the range of some\n"
"dimensions, so as to apply say @code{array-for-each} or\n"
"@code{array-fill!} to only part of an array.  The plain @code{list}\n"
"function can be used for @var{mapfunc} in this case, making no changes\n"
"to the index values.  For example,"
msgstr ""
"@sp 1\n"
"Одно полезное использование для разделяемого массива - это ограничение\n"
"диапазона некоторых измерений, чтобы применить функцию \n"
"@code{array-for-each} или @code{array-fill!} только к части массива.  \n"
"Функции @code{list} может использоваться как @var{mapfunc},  в этом \n"
"случае не изменяются значения индексов массива.\n"
"Например,"

#: api-data.texi:7615
msgid ""
"@example\n"
"(make-shared-array #2((a b c) (d e f) (g h i)) list 3 2)\n"
"@result{} #2((a b) (d e) (g h))\n"
"@end example"
msgstr ""

#: api-data.texi:7618
msgid ""
"The new array can have fewer dimensions than @var{oldarray}, for\n"
"example to take a column from an array."
msgstr ""

#: api-data.texi:7625
msgid ""
"@example\n"
"(make-shared-array #2((a b c) (d e f) (g h i))\n"
"                   (lambda (i) (list i 2))\n"
"                   '(0 2))\n"
"@result{} #1(c f i)\n"
"@end example"
msgstr ""

#: api-data.texi:7628
msgid ""
"A diagonal can be taken by using the single new array index for both\n"
"row and column in the old array.  For example,"
msgstr ""

#: api-data.texi:7635
msgid ""
"@example\n"
"(make-shared-array #2((a b c) (d e f) (g h i))\n"
"                   (lambda (i) (list i i))\n"
"                   '(0 2))\n"
"@result{} #1(a e i)\n"
"@end example"
msgstr ""

#: api-data.texi:7640
msgid ""
"Dimensions can be increased by for instance considering portions of a\n"
"one dimensional array as rows in a two dimensional array.\n"
"(@code{array-contents} below can do the opposite, flattening an\n"
"array.)"
msgstr ""

#: api-data.texi:7647
msgid ""
"@example\n"
"(make-shared-array #1(a b c d e f g h i j k l)\n"
"                   (lambda (i j) (list (+ (* i 3) j)))\n"
"                   4 3)\n"
"@result{} #2((a b c) (d e f) (g h i) (j k l))\n"
"@end example"
msgstr ""

#: api-data.texi:7650
msgid ""
"By negating an index the order that elements appear can be reversed.\n"
"The following just reverses the column order,"
msgstr ""

#: api-data.texi:7657
msgid ""
"@example\n"
"(make-shared-array #2((a b c) (d e f) (g h i))\n"
"                   (lambda (i j) (list i (- 2 j)))\n"
"                   3 3)\n"
"@result{} #2((c b a) (f e d) (i h g))\n"
"@end example"
msgstr ""

#: api-data.texi:7660
msgid ""
"A fixed offset on indexes allows for instance a change from a 0 based\n"
"to a 1 based array,"
msgstr ""

#: api-data.texi:7669
msgid ""
"@example\n"
"(define x #2((a b c) (d e f) (g h i)))\n"
"(define y (make-shared-array x\n"
"                             (lambda (i j) (list (1- i) (1- j)))\n"
"                             '(1 3) '(1 3)))\n"
"(array-ref x 0 0) @result{} a\n"
"(array-ref y 1 1) @result{} a\n"
"@end example"
msgstr ""

#: api-data.texi:7672
msgid ""
"A multiple on an index allows every Nth element of an array to be\n"
"taken.  The following is every third element,"
msgstr ""

#: api-data.texi:7679
msgid ""
"@example\n"
"(make-shared-array #1(a b c d e f g h i j k l)\n"
"                   (lambda (i) (list (* i 3)))\n"
"                   4)\n"
"@result{} #1(a d g j)\n"
"@end example"
msgstr ""

#: api-data.texi:7684
msgid ""
"The above examples can be combined to make weird and wonderful\n"
"selections from an array, but it's important to note that because\n"
"@var{mapfunc} must be affine linear, arbitrary permutations are not\n"
"possible."
msgstr ""

#: api-data.texi:7690
msgid ""
"In the current implementation, @var{mapfunc} is not called for every\n"
"access to the new array but only on some sample points to establish a\n"
"base and stride for new array indices in @var{oldarray} data.  A few\n"
"sample points are enough because @var{mapfunc} is linear.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7695
msgid ""
"@deffn {Scheme Procedure} shared-array-increments array\n"
"@deffnx {C Function} scm_shared_array_increments (array)\n"
"For each dimension, return the distance between elements in the root "
"vector.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7700
msgid ""
"@deffn {Scheme Procedure} shared-array-offset array\n"
"@deffnx {C Function} scm_shared_array_offset (array)\n"
"Return the root vector index of the first element in the array.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7705
msgid ""
"@deffn {Scheme Procedure} shared-array-root array\n"
"@deffnx {C Function} scm_shared_array_root (array)\n"
"Return the root vector of a shared array.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7714
msgid ""
"@deffn {Scheme Procedure} array-contents array [strict]\n"
"@deffnx {C Function} scm_array_contents (array, strict)\n"
"If @var{array} may be @dfn{unrolled} into a one dimensional shared array\n"
"without changing their order (last subscript changing fastest), then\n"
"@code{array-contents} returns that shared array, otherwise it returns\n"
"@code{#f}.  All arrays made by @code{make-array} and\n"
"@code{make-typed-array} may be unrolled, some arrays made by\n"
"@code{make-shared-array} may not be."
msgstr ""

#: api-data.texi:7719
msgid ""
"If the optional argument @var{strict} is provided, a shared array will\n"
"be returned only if its elements are stored internally contiguous in\n"
"memory.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7728
msgid ""
"@deffn {Scheme Procedure} transpose-array array dim1 dim2 @dots{}\n"
"@deffnx {C Function} scm_transpose_array (array, dimlist)\n"
"Return an array sharing contents with @var{array}, but with\n"
"dimensions arranged in a different order.  There must be one\n"
"@var{dim} argument for each dimension of @var{array}.\n"
"@var{dim1}, @var{dim2}, @dots{} should be integers between 0\n"
"and the rank of the array to be returned.  Each integer in that\n"
"range must appear at least once in the argument list."
msgstr ""

#: api-data.texi:7734
msgid ""
"The values of @var{dim1}, @var{dim2}, @dots{} correspond to\n"
"dimensions in the array to be returned, and their positions in the\n"
"argument list to dimensions of @var{array}.  Several @var{dim}s\n"
"may have the same value, in which case the returned array will\n"
"have smaller rank than @var{array}."
msgstr ""

#: api-data.texi:7742
msgid ""
"@lisp\n"
"(transpose-array '#2((a b) (c d)) 1 0) @result{} #2((a c) (b d))\n"
"(transpose-array '#2((a b) (c d)) 0 0) @result{} #1(a d)\n"
"(transpose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 1 0) @result{}\n"
"                #2((a 4) (b 5) (c 6))\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:7745
msgid ""
"@node Arrays as arrays of arrays\n"
"@subsubsection Arrays as arrays of arrays"
msgstr ""
"@node Arrays as arrays of arrays\n"
"@subsubsection Массивы как массивы массивов"

#: api-data.texi:7747
msgid "@cindex array cell"
msgstr ""

#: api-data.texi:7751
msgid ""
"Mathematically, one can see an array of rank @math{n} (an\n"
"@math{n}-array) as an array of lower rank where the elements are\n"
"themselves arrays (`cells')."
msgstr ""
"Математически, можно увидеть массив ранга @math{n} (н-мерный массив @math{n}-"
"array)\n"
"как массив более низкого ранга, где сами элементы представляют собой "
"массивы\n"
"(`ячейки')."

#: api-data.texi:7754
msgid ""
"@cindex array frame\n"
"@cindex frame rank"
msgstr ""

#: api-data.texi:7761
msgid ""
"We speak of the first @math{n-k} dimensions of the array as the\n"
"@math{n-k}-`frame' of the array, while the last @math{k} dimensions are\n"
"the dimensions of the @math{k}-`cells'. For example, a 3-array can be\n"
"seen as a 2-array of vectors (1-arrays) or as a 1-array of matrices\n"
"(2-arrays). In each case, the vectors or matrices are the 1-cells or\n"
"2-cells of the array. This terminology originates in the J language."
msgstr ""
"Мы говорим о первых @math{n-k} размерностях массива как о\n"
"@math{n-k}-`каркасе' массива, тогда как последние @math{k} размерностей\n"
"являются @math{k}- измерениями `ячеек'. Например, можно видеть 3х мерный\n"
"массив может быть рассмотрен как 2 мерный -массив векторов (1-мерный "
"массив)\n"
"или как 1-мерный массив матриц размером(2-мерный массив). В каждом случае\n"
"векторы или матрицы являются 1 мерными ячеками или двумерными ячеками \n"
"массива.  Эта терминология возникает в J языке."

#: api-data.texi:7764
msgid ""
"@cindex array slice\n"
"@cindex prefix slice"
msgstr ""

#: api-data.texi:7771
msgid ""
"The more vague concept of a `slice' refers to a subset of the array\n"
"where some indices are fixed and others are left free. As a Guile data\n"
"object, a cell is the same as a `prefix slice' (the first @math{n-k}\n"
"indices into the original array are fixed), except that a 0-cell is not\n"
"a shared array of the original array, but a 0-slice (where all the\n"
"indices into the original array are fixed) is."
msgstr ""
"Более неопределенная концепция `среза' относится к подмножеству \n"
"массвов, где некоторые индексы фиксируются, а другие остаются \n"
"свбодными. В качестве объекта данных Guile ячейка совпадает\n"
"с префиксом срез `prefix slice' (первые @math{n-k} индексов\n"
"в исходном массиве фиксируются), за исключением того, что 0-ячека\n"
"не может являтся общим массивом исходного массива, но 0-срез \n"
"(где все индексы в исходном массиве фиксированы) является."

#: api-data.texi:7773
msgid "@cindex enclosed array"
msgstr ""

#: api-data.texi:7778
msgid ""
"Before @w{version 2.0}, Guile had a feature called `enclosed arrays' to\n"
"create special `array of arrays' objects. The functions in this section\n"
"do not need special types; instead, the frame rank is stated in each\n"
"function call, either implicitly or explicitly."
msgstr ""
"До версси @w{version 2.0}, у Guile была функция называемая закрытытием\n"
"масссива `enclosed arrays' для создания специального объекта массива "
"массивов.\n"
"Функции в этом разделе не нуждаются в специальных типах, весто этого ранг\n"
"каркаса(frame) указывается в каждом вызове функции, либо неявно либо явно."

#: api-data.texi:7786
msgid ""
"@deffn {Scheme Procedure} array-cell-ref array idx @dots{}\n"
"@deffnx {C Function} scm_array_cell_ref (array, idxlist)\n"
"If the length of @var{idxlist} equals the rank @math{n} of @var{array},\n"
"return the element at @code{(idx @dots{})}, just like @code{(array-ref\n"
"array idx @dots{})}. If, however, the length @math{k} of @var{idxlist}\n"
"is smaller than @math{n}, then return the @math{(n-k)}-cell of\n"
"@var{array} given by @var{idxlist}, as a shared array."
msgstr ""

#: api-data.texi:7788
msgctxt "api-data.texi:7788"
msgid "For example:"
msgstr ""

#: api-data.texi:7795
msgid ""
"@lisp\n"
"(array-cell-ref #2((a b) (c d)) 0) @result{} #(a b)\n"
"(array-cell-ref #2((a b) (c d)) 1) @result{} #(c d)\n"
"(array-cell-ref #2((a b) (c d)) 1 1) @result{} d\n"
"(array-cell-ref #2((a b) (c d))) @result{} #2((a b) (c d))\n"
"@end lisp"
msgstr ""

#: api-data.texi:7797
msgid "@code{(apply array-cell-ref array indices)} is equivalent to"
msgstr ""

#: api-data.texi:7806
msgid ""
"@lisp\n"
"(let ((len (length indices)))\n"
"  (if (= (array-rank a) len)\n"
"    (apply array-ref a indices)\n"
"    (apply make-shared-array a\n"
"           (lambda t (append indices t))\n"
"           (drop (array-dimensions a) len))))\n"
"@end lisp"
msgstr ""

#: api-data.texi:7808
msgctxt "api-data.texi:7808"
msgid "@end deffn"
msgstr ""

#: api-data.texi:7815
msgid ""
"@deffn {Scheme Procedure} array-slice array idx @dots{}\n"
"@deffnx {C Function} scm_array_slice (array, idxlist)\n"
"Like @code{(array-cell-ref array idx @dots{})}, but return a 0-rank\n"
"shared array into @var{ARRAY} if the length of @var{idxlist} matches the\n"
"rank of @var{array}. This can be useful when using @var{ARRAY} as a\n"
"place to write to."
msgstr ""

#: api-data.texi:7817
msgid "Compare:"
msgstr ""

#: api-data.texi:7826
msgid ""
"@lisp\n"
"(array-cell-ref #2((a b) (c d)) 1 1) @result{} d\n"
"(array-slice #2((a b) (c d)) 1 1) @result{} #0(d)\n"
"(define a (make-array 'a 2 2))\n"
"(array-fill! (array-slice a 1 1) 'b)\n"
"a @result{} #2((a a) (a b)).\n"
"(array-fill! (array-cell-ref a 1 1) 'b) @result{} error: not an array\n"
"@end lisp"
msgstr ""

#: api-data.texi:7828
msgid "@code{(apply array-slice array indices)} is equivalent to"
msgstr ""

#: api-data.texi:7835
msgid ""
"@lisp\n"
"(apply make-shared-array a\n"
"  (lambda t (append indices t))\n"
"  (drop (array-dimensions a) (length indices)))\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: api-data.texi:7847
msgid ""
"@deffn {Scheme Procedure} array-cell-set! array x idx @dots{}\n"
"@deffnx {C Function} scm_array_cell_set_x (array, x, idxlist)\n"
"If the length of @var{idxlist} equals the rank @math{n} of\n"
"@var{array}, set the element at @code{(idx @dots{})} of @var{array} to\n"
"@var{x}, just like @code{(array-set! array x idx @dots{})}. If,\n"
"however, the length @math{k} of @var{idxlist} is smaller than\n"
"@math{n}, then copy the @math{(n-k)}-rank array @var{x}\n"
"into the @math{(n-k)}-cell of @var{array} given by\n"
"@var{idxlist}. In this case, the last @math{(n-k)} dimensions of\n"
"@var{array} and the dimensions of @var{x} must match exactly."
msgstr ""

#: api-data.texi:7849
msgid "This function returns the modified @var{array}."
msgstr ""

#: api-data.texi:7851
msgctxt "api-data.texi:7851"
msgid "For example:"
msgstr ""

#: api-data.texi:7858
msgid ""
"@lisp\n"
"(array-cell-set! (make-array 'a 2 2) b 1 1)\n"
"  @result{} #2((a a) (a b))\n"
"(array-cell-set! (make-array 'a 2 2) #(x y) 1)\n"
"  @result{} #2((a a) (x y))\n"
"@end lisp"
msgstr ""

#: api-data.texi:7862
msgid ""
"Note that @code{array-cell-set!} will expect elements, not arrays, when\n"
"the destination has rank 0. Use @code{array-slice} for the opposite\n"
"behavior."
msgstr ""

#: api-data.texi:7870
msgid ""
"@lisp\n"
"(array-cell-set! (make-array 'a 2 2) #0(b) 1 1)\n"
"  @result{} #2((a a) (a #0(b)))\n"
"(let ((a (make-array 'a 2 2)))\n"
"  (array-copy! #0(b) (array-slice a 1 1)) a)\n"
"  @result{} #2((a a) (a b))\n"
"@end lisp"
msgstr ""

#: api-data.texi:7872
msgid "@code{(apply array-cell-set! array x indices)} is equivalent to"
msgstr ""

#: api-data.texi:7880
msgid ""
"@lisp\n"
"(let ((len (length indices)))\n"
"  (if (= (array-rank array) len)\n"
"    (apply array-set! array x indices)\n"
"    (array-copy! x (apply array-cell-ref array indices)))\n"
"  array)\n"
"@end lisp"
msgstr ""

#: api-data.texi:7882
msgctxt "api-data.texi:7882"
msgid "@end deffn"
msgstr ""

#: api-data.texi:7890
msgid ""
"@deffn {Scheme Procedure} array-slice-for-each frame-rank op x @dots{}\n"
"@deffnx {C Function} scm_array_slice_for_each (array, frame_rank, op, "
"xlist)\n"
"Each @var{x} must be an array of rank ≥ @var{frame-rank}, and\n"
"the first @var{frame-rank} dimensions of each @var{x} must all be the\n"
"same. @var{array-slice-for-each} calls @var{op} with each set of\n"
"(rank(@var{x}) - @var{frame-rank})-cells from @var{x}, in unspecified order."
msgstr ""

#: api-data.texi:7895
msgid ""
"@var{array-slice-for-each} allows you to loop over cells of any rank\n"
"without having to carry an index list or construct shared arrays\n"
"manually. The slices passed to @var{op} are always shared arrays of\n"
"@var{X}, even if they are of rank 0, so it is possible to write to them."
msgstr ""

#: api-data.texi:7897
msgid "This function returns an unspecified value."
msgstr ""

#: api-data.texi:7899
msgid "For example, to sort the rows of rank-2 array @code{a}:"
msgstr ""

#: api-data.texi:7903
msgid ""
"@lisp\n"
"(array-slice-for-each 1 (lambda (x) (sort! x <)) a)\n"
"@end lisp"
msgstr ""

#: api-data.texi:7913
msgid ""
"As another example, let @code{a} be a rank-2 array where each row is a\n"
"2-element vector @math{(x,y)}.  Let's compute the arguments of these\n"
"vectors and store them in rank-1 array @code{b}.\n"
"@lisp\n"
"(array-slice-for-each 1\n"
"  (lambda (a b)\n"
"    (array-set! b (atan (array-ref a 1) (array-ref a 0))))\n"
"  a b)\n"
"@end lisp"
msgstr ""

#: api-data.texi:7915
msgid "@code{(apply array-slice-for-each frame-rank op x)} is equivalent to"
msgstr ""

#: api-data.texi:7926
msgid ""
"@lisp\n"
"(let ((frame (take (array-dimensions (car x)) frank)))\n"
"  (unless (every (lambda (x)\n"
"                   (equal? frame (take (array-dimensions x) frank)))\n"
"                 (cdr x))\n"
"    (error))\n"
"  (array-index-map!\n"
"    (apply make-shared-array (make-array #t) (const '()) frame)\n"
"    (lambda i (apply op (map (lambda (x) (apply array-slice x i)) x)))))\n"
"@end lisp"
msgstr ""

#: api-data.texi:7928
msgctxt "api-data.texi:7928"
msgid "@end deffn"
msgstr ""

#: api-data.texi:7934
msgid ""
"@deffn {Scheme Procedure} array-slice-for-each-in-order frame-rank op x "
"@dots{}\n"
"@deffnx {C Function} scm_array_slice_for_each_in_order (array, frame_rank, "
"op, xlist)\n"
"Same as @code{array-slice-for-each}, but the arguments are traversed\n"
"sequentially and in row-major order.\n"
"@end deffn"
msgstr ""

#: api-data.texi:7937
msgid ""
"@node Accessing Arrays from C\n"
"@subsubsection Accessing Arrays from C"
msgstr ""
"@node Accessing Arrays from C\n"
"@subsubsection Доступ к Массивам из Си"

#: api-data.texi:7942
msgid ""
"For interworking with external C code, Guile provides an API to allow C\n"
"code to access the elements of a Scheme array.  In particular, for\n"
"uniform numeric arrays, the API exposes the underlying uniform data as a\n"
"C array of numbers of the relevant type."
msgstr ""
"Для взаимодействия с внешним кодом Си Guile предоставляет API, позволяющий\n"
"Си-коду получать доступ к элементам массивов Scheme. В частности, для\n"
"унифицированных числовых массивов API предоставляет лежащие в их основе\n"
"данные как Си массив чисел соответствующего типа."

#: api-data.texi:7949
msgid ""
"While pointers to the elements of an array are in use, the array itself\n"
"must be protected so that the pointer remains valid.  Such a protected\n"
"array is said to be @dfn{reserved}.  A reserved array can be read but\n"
"modifications to it that would cause the pointer to its elements to\n"
"become invalid are prevented.  When you attempt such a modification, an\n"
"error is signalled."
msgstr ""
"Хотя указатели на элементы массива используются, сам массив должен\n"
"быть защищен, так что указатель остается в силе. Говорят что такой\n"
"защищенный массив зарезервирован. Зарезервированный массив может\n"
"быть прочитан, но изменения в нем, указываемых ссылкой элементов,\n"
"недопустимы. При попытке такой модификации выдается сигнал ошибки."

#: api-data.texi:7953
msgid ""
"(This is similar to locking the array while it is in use, but without\n"
"the danger of a deadlock.  In a multi-threaded program, you will need\n"
"additional synchronization to avoid modifying reserved arrays.)"
msgstr ""
"(Это похоже на блокировку массива во время его использования,\n"
"но без опасности \"смертельной\" блокировки. В многопоточной программе\n"
"вам потребуется дополнительная синхронизация, что бы избежать\n"
"изменения зарезервированных массивов.)"

#: api-data.texi:7958
msgid ""
"You must take care to always unreserve an array after reserving it,\n"
"even in the presence of non-local exits.  If a non-local exit can\n"
"happen between these two calls, you should install a dynwind context\n"
"that releases the array when it is left (@pxref{Dynamic Wind})."
msgstr ""
"Вы должны позаботиться о том что бы всегда востанавливать из\n"
"резерва массив после его резервирования, даже если имеются нелокальные\n"
"выходы. Если между двумя этими вызовами может произойти\n"
"нелокальный выход, вы должны установить контекст dynwind, который\n"
"освобождает массив когда он оставлен. (@pxref{Dynamic Wind})."

#: api-data.texi:7962
msgid ""
"In addition, array reserving and unreserving must be properly\n"
"paired.  For instance, when reserving two or more arrays in a certain\n"
"order, you need to unreserve them in the opposite order."
msgstr ""
"Кроме того, резрвирование и восстановление из резерва должны\n"
"быть сопряжены. Например при резервировании двух и более \n"
"массивов в определенном порядке вам необходимо осовбодить\n"
"(востановить из резерва) их\n"
"в противоположном порядке."

#: api-data.texi:7970
msgid ""
"Once you have reserved an array and have retrieved the pointer to its\n"
"elements, you must figure out the layout of the elements in memory.\n"
"Guile allows slices to be taken out of arrays without actually making a\n"
"copy, such as making an alias for the diagonal of a matrix that can be\n"
"treated as a vector.  Arrays that result from such an operation are not\n"
"stored contiguously in memory and when working with their elements\n"
"directly, you need to take this into account."
msgstr ""
"После того как вы зарезервировали массив и извлекли указатель на его\n"
"элементы, вы должны определить расположение элементов в памяти.\n"
"Guile позволяет вырезать фрагменты из массива без фактического \n"
"создания копии, например, создание псевдонима для диагонали матрицы\n"
"который можно рассматривать как вектор. Массивы, которые не\n"
"являются результатом такой операции, не сохраняются в памяти и при\n"
"работе с их элементами на прямую, нужно обращать на это внимание."

#: api-data.texi:7975
msgid ""
"The layout of array elements in memory can be defined via a\n"
"@emph{mapping function} that computes a scalar position from a vector of\n"
"indices.  The scalar position then is the offset of the element with the\n"
"given indices from the start of the storage block of the array."
msgstr ""
"Размещение элементов массива в памяти можно определить с помощью функции\n"
"@emph{mapping function} отображения, которая вычисляет позицию из вектора\n"
"индексов. Тогда скалярное положение будет смещением элемента с указанными\n"
"индексами от начала блока хранилища массива."

#: api-data.texi:7984
msgid ""
"In Guile, this mapping function is restricted to be @dfn{affine}: all\n"
"mapping functions of Guile arrays can be written as @code{p = b +\n"
"c[0]*i[0] + c[1]*i[1] + ... + c[n-1]*i[n-1]} where @code{i[k]} is the\n"
"@nicode{k}th index and @code{n} is the rank of the array.  For\n"
"example, a matrix of size 3x3 would have @code{b == 0}, @code{c[0] ==\n"
"3} and @code{c[1] == 1}.  When you transpose this matrix (with\n"
"@code{transpose-array}, say), you will get an array whose mapping\n"
"function has @code{b == 0}, @code{c[0] == 1} and @code{c[1] == 3}."
msgstr ""
"В Guile, эта функция отображения ограниченна аффинным преобразованием\n"
"@dfn{affine}: все функции отображения массивов в  Guile могут быть\n"
"записаны как @code{p = b + c[0]*i[0] + c[1]*i[1] + ... \n"
"+ c[n-1]*i[n-1]} где @code{i[k]} это @nicode{k}й индекс и @code{n} это\n"
"ранг массива.  Например, матрица размера  3x3 будет иметь @code{b == 0}, \n"
"@code{c[0] == 3} и @code{c[1] == 1}.  Когда вы перенесете эту матрицу\n"
"(с помощью скажем @code{transpose-array}), вы получите массив, функция\n"
"отображения которого будет @code{b == 0}, @code{c[0] == 1} и @code{c[1] == "
"3}."

#: api-data.texi:7987
msgid ""
"The function @code{scm_array_handle_dims} gives you (indirect) access to\n"
"the coefficients @code{c[k]}."
msgstr ""
"Функция @code{scm_array_handle_dims} дает вамu (косвенный) доступ к \n"
"коэффциэнтам  @code{c[k]}."

#: api-data.texi:7992
msgid ""
"@c XXX\n"
"Note that there are no functions for accessing the elements of a\n"
"character array yet.  Once the string implementation of Guile has been\n"
"changed to use Unicode, we will provide them."
msgstr ""
"@c XXX\n"
"Обратите внимание: нет функций для доступа к элементам массива символов.\n"
"После того, как строковая реализация в Guile была изменена для "
"использования\n"
"Unicode, мы используем ее."

#: api-data.texi:7999
msgid ""
"@deftp {C Type} scm_t_array_handle\n"
"This is a structure type that holds all information necessary to manage\n"
"the reservation of arrays as explained above.  Structures of this type\n"
"must be allocated on the stack and must only be accessed by the\n"
"functions listed below.\n"
"@end deftp"
msgstr ""

#: api-data.texi:8008
msgid ""
"@deftypefn {C Function} void scm_array_get_handle (SCM array, "
"scm_t_array_handle *handle)\n"
"Reserve @var{array}, which must be an array, and prepare @var{handle} to\n"
"be used with the functions below.  You must eventually call\n"
"@code{scm_array_handle_release} on @var{handle}, and do this in a\n"
"properly nested fashion, as explained above.  The structure pointed to\n"
"by @var{handle} does not need to be initialized before calling this\n"
"function.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:8013
msgid ""
"@deftypefn {C Function} void scm_array_handle_release (scm_t_array_handle "
"*handle)\n"
"End the array reservation represented by @var{handle}.  After a call to\n"
"this function, @var{handle} might be used for another reservation.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:8017
msgid ""
"@deftypefn {C Function} size_t scm_array_handle_rank (scm_t_array_handle "
"*handle)\n"
"Return the rank of the array represented by @var{handle}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:8021
msgid ""
"@deftp {C Type} scm_t_array_dim\n"
"This structure type holds information about the layout of one dimension\n"
"of an array.  It includes the following fields:"
msgstr ""

#: api-data.texi:8028
msgid ""
"@table @code\n"
"@item  ssize_t lbnd\n"
"@itemx ssize_t ubnd\n"
"The lower and upper bounds (both inclusive) of the permissible index\n"
"range for the given dimension.  Both values can be negative, but\n"
"@var{lbnd} is always less than or equal to @var{ubnd}."
msgstr ""

#: api-data.texi:8034
msgid ""
"@item ssize_t inc\n"
"The distance from one element of this dimension to the next.  Note, too,\n"
"that this can be negative.\n"
"@end table\n"
"@end deftp"
msgstr ""

#: api-data.texi:8042
msgid ""
"@deftypefn {C Function} {const scm_t_array_dim *} scm_array_handle_dims "
"(scm_t_array_handle *handle)\n"
"Return a pointer to a C vector of information about the dimensions of\n"
"the array represented by @var{handle}.  This pointer is valid as long as\n"
"the array remains reserved.  As explained above, the\n"
"@code{scm_t_array_dim} structures returned by this function can be used\n"
"calculate the position of an element in the storage block of the array\n"
"from its indices."
msgstr ""

#: api-data.texi:8047
msgid ""
"This position can then be used as an index into the C array pointer\n"
"returned by the various @code{scm_array_handle_<foo>_elements}\n"
"functions, or with @code{scm_array_handle_ref} and\n"
"@code{scm_array_handle_set}."
msgstr ""

#: api-data.texi:8050
msgid ""
"Here is how one can compute the position @var{pos} of an element given\n"
"its indices in the vector @var{indices}:"
msgstr ""

#: api-data.texi:8056
msgid ""
"@example\n"
"ssize_t indices[RANK];\n"
"scm_t_array_dim *dims;\n"
"ssize_t pos;\n"
"size_t i;"
msgstr ""

#: api-data.texi:8066
msgid ""
"pos = 0;\n"
"for (i = 0; i < RANK; i++)\n"
"  @{\n"
"    if (indices[i] < dims[i].lbnd || indices[i] > dims[i].ubnd)\n"
"      out_of_range ();\n"
"    pos += (indices[i] - dims[i].lbnd) * dims[i].inc;\n"
"  @}\n"
"@end example\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:8074
msgid ""
"@deftypefn {C Function} ssize_t scm_array_handle_pos (scm_t_array_handle "
"*handle, SCM indices)\n"
"Compute the position corresponding to @var{indices}, a list of\n"
"indices.  The position is computed as described above for\n"
"@code{scm_array_handle_dims}.  The number of the indices and their\n"
"range is checked and an appropriate error is signalled for invalid\n"
"indices.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:8080
msgid ""
"@deftypefn {C Function} SCM scm_array_handle_ref (scm_t_array_handle "
"*handle, ssize_t pos)\n"
"Return the element at position @var{pos} in the storage block of the\n"
"array represented by @var{handle}.  Any kind of array is acceptable.  No\n"
"range checking is done on @var{pos}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:8087
msgid ""
"@deftypefn {C Function} void scm_array_handle_set (scm_t_array_handle "
"*handle, ssize_t pos, SCM val)\n"
"Set the element at position @var{pos} in the storage block of the array\n"
"represented by @var{handle} to @var{val}.  Any kind of array is\n"
"acceptable.  No range checking is done on @var{pos}.  An error is\n"
"signalled when the array can not store @var{val}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:8093
msgid ""
"@deftypefn {C Function} {const SCM *} scm_array_handle_elements "
"(scm_t_array_handle *handle)\n"
"Return a pointer to the elements of a ordinary array of general Scheme\n"
"values (i.e., a non-uniform array) for reading.  This pointer is valid\n"
"as long as the array remains reserved.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:8098
msgid ""
"@deftypefn {C Function} {SCM *} scm_array_handle_writable_elements "
"(scm_t_array_handle *handle)\n"
"Like @code{scm_array_handle_elements}, but the pointer is good for\n"
"reading and writing.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:8104
msgid ""
"@deftypefn {C Function} {const void *} scm_array_handle_uniform_elements "
"(scm_t_array_handle *handle)\n"
"Return a pointer to the elements of a uniform numeric array for reading.\n"
"This pointer is valid as long as the array remains reserved.  The size\n"
"of each element is given by @code{scm_array_handle_uniform_element_size}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:8109
msgid ""
"@deftypefn {C Function} {void *} scm_array_handle_uniform_writable_elements "
"(scm_t_array_handle *handle)\n"
"Like @code{scm_array_handle_uniform_elements}, but the pointer is good\n"
"reading and writing.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:8114
msgid ""
"@deftypefn {C Function} size_t scm_array_handle_uniform_element_size "
"(scm_t_array_handle *handle)\n"
"Return the size of one element of the uniform numeric array represented\n"
"by @var{handle}.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:8130
msgid ""
"@deftypefn  {C Function} {const scm_t_uint8 *} scm_array_handle_u8_elements "
"(scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {const scm_t_int8 *} scm_array_handle_s8_elements "
"(scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {const scm_t_uint16 *} "
"scm_array_handle_u16_elements (scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {const scm_t_int16 *} scm_array_handle_s16_elements "
"(scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {const scm_t_uint32 *} "
"scm_array_handle_u32_elements (scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {const scm_t_int32 *} scm_array_handle_s32_elements "
"(scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {const scm_t_uint64 *} "
"scm_array_handle_u64_elements (scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {const scm_t_int64 *} scm_array_handle_s64_elements "
"(scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {const float *} scm_array_handle_f32_elements "
"(scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {const double *} scm_array_handle_f64_elements "
"(scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {const float *} scm_array_handle_c32_elements "
"(scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {const double *} scm_array_handle_c64_elements "
"(scm_t_array_handle *handle)\n"
"Return a pointer to the elements of a uniform numeric array of the\n"
"indicated kind for reading.  This pointer is valid as long as the array\n"
"remains reserved."
msgstr ""

#: api-data.texi:8135
msgid ""
"The pointers for @code{c32} and @code{c64} uniform numeric arrays point\n"
"to pairs of floating point numbers.  The even index holds the real part,\n"
"the odd index the imaginary part of the complex number.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:8151
msgid ""
"@deftypefn {C Function} {scm_t_uint8 *} "
"scm_array_handle_u8_writable_elements (scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {scm_t_int8 *} "
"scm_array_handle_s8_writable_elements (scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {scm_t_uint16 *} "
"scm_array_handle_u16_writable_elements (scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {scm_t_int16 *} "
"scm_array_handle_s16_writable_elements (scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {scm_t_uint32 *} "
"scm_array_handle_u32_writable_elements (scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {scm_t_int32 *} "
"scm_array_handle_s32_writable_elements (scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {scm_t_uint64 *} "
"scm_array_handle_u64_writable_elements (scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {scm_t_int64 *} "
"scm_array_handle_s64_writable_elements (scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {float *} scm_array_handle_f32_writable_elements "
"(scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {double *} scm_array_handle_f64_writable_elements "
"(scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {float *} scm_array_handle_c32_writable_elements "
"(scm_t_array_handle *handle)\n"
"@deftypefnx {C Function} {double *} scm_array_handle_c64_writable_elements "
"(scm_t_array_handle *handle)\n"
"Like @code{scm_array_handle_<kind>_elements}, but the pointer is good\n"
"for reading and writing.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:8155
msgid ""
"@deftypefn {C Function} {const scm_t_uint32 *} scm_array_handle_bit_elements "
"(scm_t_array_handle *handle)\n"
"Return a pointer to the words that store the bits of the represented\n"
"array, which must be a bit array."
msgstr ""

#: api-data.texi:8159
msgid ""
"Unlike other arrays, bit arrays have an additional offset that must be\n"
"figured into index calculations.  That offset is returned by\n"
"@code{scm_array_handle_bit_elements_offset}."
msgstr ""

#: api-data.texi:8164
msgid ""
"To find a certain bit you first need to calculate its position as\n"
"explained above for @code{scm_array_handle_dims} and then add the\n"
"offset.  This gives the absolute position of the bit, which is always a\n"
"non-negative integer."
msgstr ""

#: api-data.texi:8168
msgid ""
"Each word of the bit array storage block contains exactly 32 bits, with\n"
"the least significant bit in that word having the lowest absolute\n"
"position number.  The next word contains the next 32 bits."
msgstr ""

#: api-data.texi:8171
msgid ""
"Thus, the following code can be used to access a bit whose position\n"
"according to @code{scm_array_handle_dims} is given in @var{pos}:"
msgstr ""

#: api-data.texi:8179
msgid ""
"@example\n"
"SCM bit_array;\n"
"scm_t_array_handle handle;\n"
"scm_t_uint32 *bits;\n"
"ssize_t pos;\n"
"size_t abs_pos;\n"
"size_t word_pos, mask;"
msgstr ""

#: api-data.texi:8182
msgid ""
"scm_array_get_handle (&bit_array, &handle);\n"
"bits = scm_array_handle_bit_elements (&handle);"
msgstr ""

#: api-data.texi:8187
msgid ""
"pos = ...\n"
"abs_pos = pos + scm_array_handle_bit_elements_offset (&handle);\n"
"word_pos = abs_pos / 32;\n"
"mask = 1L << (abs_pos % 32);"
msgstr ""

#: api-data.texi:8190
msgid ""
"if (bits[word_pos] & mask)\n"
"  /* bit is set. */"
msgstr ""

#: api-data.texi:8193
msgid ""
"scm_array_handle_release (&handle);\n"
"@end example"
msgstr ""

#: api-data.texi:8195
msgctxt "api-data.texi:8195"
msgid "@end deftypefn"
msgstr ""

#: api-data.texi:8201
msgid ""
"@deftypefn {C Function} {scm_t_uint32 *} "
"scm_array_handle_bit_writable_elements (scm_t_array_handle *handle)\n"
"Like @code{scm_array_handle_bit_elements} but the pointer is good for\n"
"reading and writing.  You must take care not to modify bits outside of\n"
"the allowed index range of the array, even for contiguous arrays.\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:8204
msgid ""
"@node VLists\n"
"@subsection VLists"
msgstr ""

#: api-data.texi:8206
msgid "@cindex vlist"
msgstr ""

#: api-data.texi:8211
msgid ""
"The @code{(ice-9 vlist)} module provides an implementation of the "
"@dfn{VList}\n"
"data structure designed by Phil Bagwell in 2002.  VLists are immutable "
"lists,\n"
"which can contain any Scheme object.  They improve on standard Scheme "
"linked\n"
"lists in several areas:"
msgstr ""
"Модуль @code{(ice-9 vlist)} обеспечивает реализацию структуры данных "
"@dfn{VList},\n"
"разработанной Phil Bagwell в 2002.  VLists это неизменяемые списки, которые\n"
"могут содержать любой объект  Scheme.  Он улучшает стандартные связаные "
"списки\n"
"Scheme в нескольких областях:"

#: api-data.texi:8215
msgid ""
"@itemize\n"
"@item\n"
"Random access has typically constant-time complexity."
msgstr ""
"@itemize\n"
"@item\n"
"Произвольный доступ выполняется за постоянное время."

#: api-data.texi:8219
msgid ""
"@item\n"
"Computing the length of a VList has time complexity logarithmic in the "
"number of\n"
"elements."
msgstr ""
"@item\n"
"Вычисление длины VList имеет логарифмическую сложность от числа элементов."

#: api-data.texi:8222
msgid ""
"@item\n"
"VLists use less storage space than standard lists."
msgstr ""
"@item\n"
"VLists использует меньше места для хранения, чем\n"
"стандартные списки."

#: api-data.texi:8227
msgid ""
"@item\n"
"VList elements are stored in contiguous regions, which improves memory "
"locality\n"
"and leads to more efficient use of hardware caches.\n"
"@end itemize"
msgstr ""
"@item\n"
"Элементы VList хранятся в смежных областях, что улучшает распределение "
"памяти\n"
"и приводит к более эффективному использованию аппаратных кэшей.\n"
"@end itemize"

#: api-data.texi:8233
msgid ""
"The idea behind VLists is to store vlist elements in increasingly large\n"
"contiguous blocks (implemented as vectors here).  These blocks are linked to "
"one\n"
"another using a pointer to the next block and an offset within that block.  "
"The\n"
"size of these blocks form a geometric series with ratio\n"
"@code{block-growth-factor} (2 by default)."
msgstr ""
"Идея VLists заключается в том, чтобы хранить элементы vlist в более крупных\n"
"смежных блоках (реализованных здесь как векторы).  Эти блоки связаны друг с\n"
"другом с помощью указателя на следующий блок и смещения внутри этого блока.\n"
"Размер этих блоков формирует геометрический ряд с коэффициэнтом роста:\n"
"@code{block-growth-factor} (по умолчанию 2)."

#: api-data.texi:8236
msgid ""
"The VList structure also serves as the basis for the @dfn{VList-based hash\n"
"lists} or ``vhashes'', an immutable dictionary type (@pxref{VHashes})."
msgstr ""
"Структура VList также служит основой для хэш-списков на основе @dfn{хэш-"
"список\n"
"на осонове VList} или ``vhashes'', неизменный тип словаря (@pxref{VHashes})."

#: api-data.texi:8239
msgid ""
"However, the current implementation in @code{(ice-9 vlist)} has several\n"
"noteworthy shortcomings:"
msgstr ""
"Однако текущая реализация @code{(ice-9 vlist)} имеет несколько\n"
"примечательных недостатков:"

#: api-data.texi:8241
msgid "@itemize"
msgstr ""

#: api-data.texi:8248
msgid ""
"@item\n"
"It is @emph{not} thread-safe.  Although operations on vlists are all\n"
"@dfn{referentially transparent} (i.e., purely functional), adding elements "
"to a\n"
"vlist with @code{vlist-cons} mutates part of its internal structure, which "
"makes\n"
"it non-thread-safe.  This could be fixed, but it would slow down\n"
"@code{vlist-cons}."
msgstr ""
"@item\n"
"Он не является потокобезопасным.  Хотя операции с vlists все \n"
"@dfn{ссылочно прозрачны} (т.е. чисто функциональны), добавление элементов в\n"
"vlist с помощью @code{vlist-cons} изменяет часть внутренней структуры, "
"которая\n"
"делает его потоко небезопасным.  Это может быть исправлено, но это замедлит\n"
"@code{vlist-cons}."

#: api-data.texi:8253
msgid ""
"@item\n"
"@code{vlist-cons} always allocates at least as much memory as @code{cons}.\n"
"Again, Phil Bagwell describes how to fix it, but that would require tuning "
"the\n"
"garbage collector in a way that may not be generally beneficial."
msgstr ""
"@item\n"
"@code{vlist-cons} всегда выделяет как минимум столько же памяти, сколько и "
"@code{cons}.\n"
"Опять же, Phil Bagwell описывает как это исправить, но это потребует "
"настройки \n"
"сборщика мусора способом который может быть не совсем полезен."

#: api-data.texi:8258
msgid ""
"@item\n"
"@code{vlist-cons} is a Scheme procedure compiled to bytecode, and it does "
"not\n"
"compete with the straightforward C implementation of @code{cons}, and with "
"the\n"
"fact that the VM has a special @code{cons} instruction."
msgstr ""
"@item\n"
"@code{vlist-cons} это процедура Scheme компилируемая в байт-код, и оне не "
"может\n"
"конкурировать с простой Си реализациейand операции @code{cons}, и тем, что "
"VM \n"
"имеет специальную инструкцию  @code{cons}."

#: api-data.texi:8260
msgid "@end itemize"
msgstr ""

#: api-data.texi:8262
msgid "We hope to address these in the future."
msgstr "Мы надеемся их решить в будущем."

#: api-data.texi:8266
msgid ""
"The programming interface exported by @code{(ice-9 vlist)} is defined "
"below.\n"
"Most of it is the same as SRFI-1 with an added @code{vlist-} prefix to "
"function\n"
"names."
msgstr ""
"Интерфейс программирования, экспортируемый @code{(ice-9 vlist)} определен "
"ниже.\n"
"Большая часть так же как SRFI-1 с добавлением префикса  @code{vlist-} в "
"имена\n"
"функций."

#: api-data.texi:8270
msgid ""
"@deffn {Scheme Procedure} vlist? obj\n"
"Return true if @var{obj} is a VList.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8276
msgid ""
"@defvr {Scheme Variable} vlist-null\n"
"The empty VList.  Note that it's possible to create an empty VList not\n"
"@code{eq?} to @code{vlist-null}; thus, callers should always use\n"
"@code{vlist-null?} when testing whether a VList is empty.\n"
"@end defvr"
msgstr ""

#: api-data.texi:8280
msgid ""
"@deffn {Scheme Procedure} vlist-null? vlist\n"
"Return true if @var{vlist} is empty.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8284
msgid ""
"@deffn {Scheme Procedure} vlist-cons item vlist\n"
"Return a new vlist with @var{item} as its head and @var{vlist} as its tail.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8288
msgid ""
"@deffn {Scheme Procedure} vlist-head vlist\n"
"Return the head of @var{vlist}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8292
msgid ""
"@deffn {Scheme Procedure} vlist-tail vlist\n"
"Return the tail of @var{vlist}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8296
msgid ""
"@defvr {Scheme Variable} block-growth-factor\n"
"A fluid that defines the growth factor of VList blocks, 2 by default.\n"
"@end defvr"
msgstr ""

#: api-data.texi:8298
msgid ""
"The functions below provide the usual set of higher-level list operations."
msgstr ""

#: api-data.texi:8304
msgid ""
"@deffn {Scheme Procedure} vlist-fold proc init vlist\n"
"@deffnx {Scheme Procedure} vlist-fold-right proc init vlist\n"
"Fold over @var{vlist}, calling @var{proc} for each element, as for SRFI-1\n"
"@code{fold} and @code{fold-right} (@pxref{SRFI-1, @code{fold}}).\n"
"@end deffn"
msgstr ""

#: api-data.texi:8309
msgid ""
"@deffn {Scheme Procedure} vlist-ref vlist index\n"
"Return the element at index @var{index} in @var{vlist}.  This is typically "
"a\n"
"constant-time operation.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8314
msgid ""
"@deffn {Scheme Procedure} vlist-length vlist\n"
"Return the length of @var{vlist}.  This is typically logarithmic in the "
"number\n"
"of elements in @var{vlist}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8319
msgid ""
"@deffn {Scheme Procedure} vlist-reverse vlist\n"
"Return a new @var{vlist} whose content are those of @var{vlist} in reverse\n"
"order.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8323
msgid ""
"@deffn {Scheme Procedure} vlist-map proc vlist\n"
"Map @var{proc} over the elements of @var{vlist} and return a new vlist.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8327
msgid ""
"@deffn {Scheme Procedure} vlist-for-each proc vlist\n"
"Call @var{proc} on each element of @var{vlist}.  The result is unspecified.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8332
msgid ""
"@deffn {Scheme Procedure} vlist-drop vlist count\n"
"Return a new vlist that does not contain the @var{count} first elements of\n"
"@var{vlist}.  This is typically a constant-time operation.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8337
msgid ""
"@deffn {Scheme Procedure} vlist-take vlist count\n"
"Return a new vlist that contains only the @var{count} first elements of\n"
"@var{vlist}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8342
msgid ""
"@deffn {Scheme Procedure} vlist-filter pred vlist\n"
"Return a new vlist containing all the elements from @var{vlist} that "
"satisfy\n"
"@var{pred}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8347
msgid ""
"@deffn {Scheme Procedure} vlist-delete x vlist [equal?]\n"
"Return a new vlist corresponding to @var{vlist} without the elements\n"
"@var{equal?} to @var{x}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8353
msgid ""
"@deffn {Scheme Procedure} vlist-unfold p f g seed [tail-gen]\n"
"@deffnx {Scheme Procedure} vlist-unfold-right p f g seed [tail]\n"
"Return a new vlist, as for SRFI-1 @code{unfold} and @code{unfold-right}\n"
"(@pxref{SRFI-1, @code{unfold}}).\n"
"@end deffn"
msgstr ""

#: api-data.texi:8357
msgid ""
"@deffn {Scheme Procedure} vlist-append vlist @dots{}\n"
"Append the given vlists and return the resulting vlist.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8361
msgid ""
"@deffn {Scheme Procedure} list->vlist lst\n"
"Return a new vlist whose contents correspond to @var{lst}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8365
msgid ""
"@deffn {Scheme Procedure} vlist->list vlist\n"
"Return a new list whose contents match those of @var{vlist}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8368
msgid ""
"@node Record Overview\n"
"@subsection Record Overview"
msgstr ""
"@node Record Overview\n"
"@subsection Записи Обзор(Record Overview)"

#: api-data.texi:8371
msgid ""
"@cindex record\n"
"@cindex structure"
msgstr ""

#: api-data.texi:8376
msgid ""
"@dfn{Records}, also called @dfn{structures}, are Scheme's primary\n"
"mechanism to define new disjoint types.  A @dfn{record type} defines a\n"
"list of @dfn{fields} that instances of the type consist of.  This is like\n"
"C's @code{struct}."
msgstr ""
"@dfn{Записи(Records)}, также называемые @dfn{Структурами(structures)}, \n"
"являются основным механизмом Scheme для определения новых типов.  \n"
"@dfn{Тип записи} определяет списко полей, из которых состоят экземпляры\n"
"этого типа. Это похоже на структыры Си."

#: api-data.texi:8381
msgid ""
"Historically, Guile has offered several different ways to define record\n"
"types and to create records, offering different features, and making\n"
"different trade-offs.  Over the years, each ``standard'' has also come\n"
"with its own new record interface, leading to a maze of record APIs."
msgstr ""
"Исторически сложилось так, что Guile предлагае несколько различных\n"
"способов определения типов записей и создания записи, предлагая\n"
"разные функции и идя на разные компромисы. На протяжении многих\n"
"лет каждый ``Стандарт'' также имеет свой собственный новый интерфес\n"
"работы с записями. что привело к лабиринту API интерфейсов для работы\n"
"с записями."

#: api-data.texi:8389
msgid ""
"At the highest level is SRFI-9, a high-level record interface\n"
"implemented by most Scheme implementations (@pxref{SRFI-9 Records}).  It\n"
"defines a simple and efficient syntactic abstraction of record types and\n"
"their associated type predicate, fields, and field accessors.  SRFI-9 is\n"
"suitable for most uses, and this is the recommended way to create record\n"
"types in Guile.  Similar high-level record APIs include SRFI-35\n"
"(@pxref{SRFI-35}) and R6RS records (@pxref{rnrs records syntactic})."
msgstr ""
"На самом высшем уровне стоит SRFI-9, высокоуровневый интерфес работы\n"
"с записями, реализованный в большинстве реализаций Scheme \n"
"(@pxref{SRFI-9 Records}).  Он определяет простую и эффективную "
"синтаксическую\n"
"абстракцию типо записей и связанных ними типов полей и функцй доступа к "
"этим\n"
"полям.  SRFI-9 подходит для большинства применений, и рекомендуется для \n"
"создания записей в  Guile.  Аналогичные высокоуровневые интерфесы включают\n"
"SRFI-35 (@pxref{SRFI-35}) и записи R6RS (@pxref{rnrs records syntactic})."

#: api-data.texi:8395
msgid ""
"Then comes Guile's historical ``records'' API (@pxref{Records}).  Record\n"
"types defined this way are first-class objects.  Introspection\n"
"facilities are available, allowing users to query the list of fields or\n"
"the value of a specific field at run-time, without prior knowledge of\n"
"the type."
msgstr ""
"Затем(исторически) появился Guile API ``records'' (@pxref{Records}).  \n"
"Типы записей определенные таким образом, являются первыми классовыми\n"
"объектами. Имеются интроспективные объекты позволяющие пользователям\n"
"запрашивать список полей или значение определенного поля во время\n"
"выполнения без предварительного знания его типа."

#: api-data.texi:8400
msgid ""
"Finally, the common denominator of these interfaces is Guile's\n"
"@dfn{structure} API (@pxref{Structures}).  Guile's structures are the\n"
"low-level building block for all other record APIs.  Application writers\n"
"will normally not need to use it."
msgstr ""
"Наконец, общим знаменателем этих интерфесов является  Guile API\n"
"@dfn{Структуры(structure)}  (@pxref{Structures}).  Структуры Guile\n"
"это низкоуровневый строительный блок для всех других API работы с \n"
"записями.  Пользователям приложений как правило не нужно будет их\n"
"использовать."

#: api-data.texi:8403
msgid ""
"Records created with these APIs may all be pattern-matched using Guile's\n"
"standard pattern matcher (@pxref{Pattern Matching})."
msgstr ""
"Записи, созданные с помощью этих APIs могут быть все сопоставлены с \n"
"образцом используемым Guile стандартным поиском по шаблону.\n"
"(@pxref{Pattern Matching})."

#: api-data.texi:8407
msgid ""
"@node SRFI-9 Records\n"
"@subsection SRFI-9 Records"
msgstr ""
"@node SRFI-9 Records\n"
"@subsection Записи по спецификации (SRFI-9)"

#: api-data.texi:8410
msgid ""
"@cindex SRFI-9\n"
"@cindex record"
msgstr ""

#: api-data.texi:8415
msgid ""
"SRFI-9 standardizes a syntax for defining new record types and creating\n"
"predicate, constructor, and field getter and setter functions.  In Guile\n"
"this is the recommended option to create new record types (@pxref{Record\n"
"Overview}).  It can be used with:"
msgstr ""
"SRFI-9 стандартиризует синтаксис для определения новых типов записей и\n"
"создания предикатов, конструкторов и функций доступа к полям(get, set).\n"
"В Guile это рекомендуемый вариант создания новых типов записей  \n"
"(@pxref{Record Overview}).  Его можно использовать загрузив модуль:"

#: api-data.texi:8419
msgid ""
"@example\n"
"(use-modules (srfi srfi-9))\n"
"@end example"
msgstr ""

#: api-data.texi:8425
msgid ""
"@deffn {Scheme Syntax} define-record-type type @* (constructor fieldname "
"@dots{}) @* predicate @* (fieldname accessor [modifier]) @dots{}\n"
"@sp 1\n"
"Create a new record type, and make various @code{define}s for using\n"
"it.  This syntax can only occur at the top-level, not nested within\n"
"some other form."
msgstr ""
"@deffn {Scheme Syntax} define-record-type type @* (constructor fieldname "
"@dots{}) @* predicate @* (fieldname accessor [modifier]) @dots{}\n"
"@sp 1\n"
"Создает новый тип записи и создает для этого различные определения.\n"
"Этот синтаксис работает только на верхнем уровне, и не подходит для\n"
"вложения в какую либо другую форму."

#: api-data.texi:8429
msgid ""
"@var{type} is bound to the record type, which is as per the return\n"
"from the core @code{make-record-type}.  @var{type} also provides the\n"
"name for the record, as per @code{record-type-name}."
msgstr ""
"@var{type} связь с символом типа записи, который соотвествует возвращаемому\n"
"из функции @code{make-record-type}.  @var{type} также предоставляет имя\n"
"записи, согласно @code{record-type-name}."

#: api-data.texi:8435
msgid ""
"@var{constructor} is bound to a function to be called as\n"
"@code{(@var{constructor} fieldval @dots{})} to create a new record of\n"
"this type.  The arguments are initial values for the fields, one\n"
"argument for each field, in the order they appear in the\n"
"@code{define-record-type} form."
msgstr ""
"@var{constructor} связь с функцией, которая будет вызываться как\n"
"@code{(@var{constructor} fieldval @dots{})}, чтобы создать новую\n"
"запись этого типа. Аргументы представляют собой начальные значения\n"
" для полей, один аргумент для каждого поля, в том порядке, в котором\n"
"они появляются в форме определения типа записи \n"
"@code{define-record-type}."

#: api-data.texi:8439
msgid ""
"The @var{fieldname}s provide the names for the record fields, as per\n"
"the core @code{record-type-fields} etc, and are referred to in the\n"
"subsequent accessor/modifier forms."
msgstr ""
"Имена полей @var{fieldname}s представляют имена для полей записи,\n"
"в соответствии с  @code{record-type-fields} и т.д., и упоминаются\n"
"в последующих формах  доступа/изменения (accessor/modifier)."

#: api-data.texi:8443
msgid ""
"@var{predicate} is bound to a function to be called as\n"
"@code{(@var{predicate} obj)}.  It returns @code{#t} or @code{#f}\n"
"according to whether @var{obj} is a record of this type."
msgstr ""
"@var{predicate} связан с функцией, которая будет вызываться как:\n"
"@code{(@var{predicate} obj)}.  Он возвращает @code{#t} или @code{#f}\n"
"в зависимости от того, является ли @var{obj} записью этого типа\n"
"или нет."

#: api-data.texi:8450
msgid ""
"Each @var{accessor} is bound to a function to be called\n"
"@code{(@var{accessor} record)} to retrieve the respective field from a\n"
"@var{record}.  Similarly each @var{modifier} is bound to a function to\n"
"be called @code{(@var{modifier} record val)} to set the respective\n"
"field in a @var{record}.\n"
"@end deffn"
msgstr ""
"Каждый @var{accessor} привязан к функции, которая должна быть вызвана как:\n"
"@code{(@var{accessor} record)}, что бы получить соответствующее поле из\n"
"@var{record}.  Аналогично, каждый @var{modifier} привязан к функции "
"вызываемой\n"
"как: @code{(@var{modifier} record val)}, чтобы установить соответствующее\n"
"значение поля в записи @var{record}.\n"
"@end deffn"

#: api-data.texi:8453
msgid ""
"@noindent\n"
"An example will illustrate typical usage,"
msgstr ""
"@noindent\n"
"Пример иллюстрирует типичное использование,"

#: api-data.texi:8462
msgid ""
"@example\n"
"(define-record-type <employee>\n"
"  (make-employee name age salary)\n"
"  employee?\n"
"  (name    employee-name)\n"
"  (age     employee-age    set-employee-age!)\n"
"  (salary  employee-salary set-employee-salary!))\n"
"@end example"
msgstr ""

#: api-data.texi:8468
msgid ""
"This creates a new employee data type, with name, age and salary\n"
"fields.  Accessor functions are created for each field, but no\n"
"modifier function for the name (the intention in this example being\n"
"that it's established only when an employee object is created).  These\n"
"can all then be used as for example,"
msgstr ""
"Он создает новый тип данных СОТРУДНИК employee с полями имени, возраста\n"
"и заработной платы. Функции доступа создаются для каждого поля, но нет \n"
"функции модификатора для имени (цель заключается в том, чтобы оно\n"
"устнавливалось только при создании объекта employee)  Объекты этого\n"
"типа могут быть созданы и использованы, например:"

#: api-data.texi:8471
msgid ""
"@example\n"
"<employee> @result{} #<record-type <employee>>"
msgstr ""

#: api-data.texi:8473
msgid "(define fred (make-employee \"Fred\" 45 20000.00))"
msgstr ""

#: api-data.texi:8478
msgid ""
"(employee? fred)        @result{} #t\n"
"(employee-age fred)     @result{} 45\n"
"(set-employee-salary! fred 25000.00)  ;; pay rise\n"
"@end example"
msgstr ""

#: api-data.texi:8482
msgid ""
"The functions created by @code{define-record-type} are ordinary\n"
"top-level @code{define}s.  They can be redefined or @code{set!} as\n"
"desired, exported from a module, etc."
msgstr ""
"Функции, созданные методом @code{define-record-type} являются обычными\n"
"определениями верхнего уровня.  Их можно переопределять или устанавливать\n"
"по желанию, экспортировать из модуля и т.д."

#: api-data.texi:8484
msgid "@unnumberedsubsubsec Non-toplevel Record Definitions"
msgstr "@unnumberedsubsubsec Определение записей не на верхнем уровне."

#: api-data.texi:8489
msgid ""
"The SRFI-9 specification explicitly disallows record definitions in a\n"
"non-toplevel context, such as inside @code{lambda} body or inside a\n"
"@var{let} block.  However, Guile's implementation does not enforce that\n"
"restriction."
msgstr ""
"Спецификация SRFI-9 явно запрещает определения записей в контексте\n"
"отличном от верхнего уровня, например внутри тела лямбда@code{lambda}\n"
"блока или внутри блока @var{let}.  Однако рализация Guile не соблюдает\n"
"это ограничение."

#: api-data.texi:8491
msgid "@unnumberedsubsubsec Custom Printers"
msgstr "@unnumberedsubsubsec Пользовательская Печать"

#: api-data.texi:8495
msgid ""
"You may use @code{set-record-type-printer!} to customize the default "
"printing\n"
"behavior of records.  This is a Guile extension and is not part of SRFI-9.  "
"It\n"
"is located in the @nicode{(srfi srfi-9 gnu)} module."
msgstr ""
"Вы можете использовать @code{set-record-type-printer!} для настройки "
"поведения\n"
"печати по умолчанию для записей.  Это расширение  Guile и не является "
"частью\n"
"SRFI-9.  Оно расположено в модуле @nicode{(srfi srfi-9 gnu)}."

#: api-data.texi:8501
msgid ""
"@deffn {Scheme Syntax} set-record-type-printer! type proc\n"
"Where @var{type} corresponds to the first argument of @code{define-record-"
"type},\n"
"and @var{proc} is a procedure accepting two arguments, the record to print, "
"and\n"
"an output port.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Syntax} set-record-type-printer! type proc\n"
"Где @var{type} соответствует первому аргументу @code{define-record-type},\n"
"а @var{proc} процедура, принимающая два аргумента, запись(record) для печати "
"и\n"
"выходной порт.\n"
"@end deffn"

#: api-data.texi:8504
msgid ""
"@noindent\n"
"This example prints the employee's name in brackets, for instance "
"@code{[Fred]}."
msgstr ""
"@noindent\n"
"Этот пример печатает имя сотрудника в скобках, например @code{[Fred]}."

#: api-data.texi:8512
msgid ""
"@example\n"
"(set-record-type-printer! <employee>\n"
"  (lambda (record port)\n"
"    (write-char #\\[ port)\n"
"    (display (employee-name record) port)\n"
"    (write-char #\\] port)))\n"
"@end example"
msgstr ""

#: api-data.texi:8514
msgid "@unnumberedsubsubsec Functional ``Setters''"
msgstr ""

#: api-data.texi:8516
msgid "@cindex functional setters"
msgstr ""

#: api-data.texi:8520
msgid ""
"When writing code in a functional style, it is desirable to never alter\n"
"the contents of records.  For such code, a simple way to return new\n"
"record instances based on existing ones is highly desirable."
msgstr ""
"При написании кода в функциональном стиле желательно никогда не изменять\n"
"содержимое записей. Для такого кода простой способ возврата новых "
"экземпляров\n"
"записей желательно выполнять на основе сущетствующих."

#: api-data.texi:8527
msgid ""
"The @code{(srfi srfi-9 gnu)} module extends SRFI-9 with facilities to\n"
"return new record instances based on existing ones, only with one or\n"
"more field values changed---@dfn{functional setters}.  First, the\n"
"@code{define-immutable-record-type} works like\n"
"@code{define-record-type}, except that fields are immutable and setters\n"
"are defined as functional setters."
msgstr ""
"Модуль @code{(srfi srfi-9 gnu)} расширеяет SRFI-9 возможностью возврата\n"
"новой записи экземпляра на основе существующей, с только одним или \n"
"несколькими значениями полей, изменненными с помощью функции ---\n"
"@dfn{functional setters}.  Во-первых,  тип @code{define-immutable-record-"
"type}\n"
"работает как @code{define-record-type}, за исключением того что эти поля\n"
"являются не изменяемыми, а функции изменния определяются как функциональные\n"
"functional setters."

#: api-data.texi:8536
msgid ""
"@deffn {Scheme Syntax} define-immutable-record-type type @* (constructor "
"fieldname @dots{}) @* predicate @* (fieldname accessor [modifier]) @dots{}\n"
"Define @var{type} as a new record type, like @code{define-record-type}.\n"
"However, the record type is made @emph{immutable} (records may not be\n"
"mutated, even with @code{struct-set!}), and any @var{modifier} is\n"
"defined to be a functional setter---a procedure that returns a new\n"
"record instance with the specified field changed, and leaves the\n"
"original unchanged (see example below.)\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Syntax} define-immutable-record-type type @* (constructor "
"fieldname @dots{}) @* predicate @* (fieldname accessor [modifier]) @dots{}\n"
"Определяет @var{type} как новый тип записи, подобно @code{define-record-"
"type}.\n"
"Однако, запись type станоиться не изменяемой @emph{immutable} (записи не "
"могут\n"
"быть изменены даже с помощью функции @code{struct-set!}), и любой "
"модификатор\n"
"@var{modifier} определеяется как функциональный установщик(functional "
"setter)\n"
"---процедура которая возвращает новый экземпляр записи с указанным "
"изменненым\n"
"значением поля и оставляет исходную запись неизменной.(См пример ниже.)\n"
"@end deffn"

#: api-data.texi:8540
msgid ""
"@noindent\n"
"In addition, the generic @code{set-field} and @code{set-fields} macros\n"
"may be applied to any SRFI-9 record."
msgstr ""
"@noindent\n"
"Кроме того, общие макросы @code{set-field} и @code{set-fields} могут \n"
"применяться к любой записи SRFI-9."

#: api-data.texi:8545
msgid ""
"@deffn {Scheme Syntax} set-field record (field sub-fields ...) value\n"
"Return a new record of @var{record}'s type whose fields are equal to\n"
"the corresponding fields of @var{record} except for the one specified by\n"
"@var{field}."
msgstr ""
"@deffn {Scheme Syntax} set-field record (field sub-fields ...) value\n"
"Возвращает новую запись типа @var{record}, поля которой равны\n"
"соответствующим полям записи @var{record}, кроме поля указанного\n"
"@var{field}."

#: api-data.texi:8551
msgid ""
"@var{field} must be the name of the getter corresponding to the field of\n"
"@var{record} being ``set''.  Subsequent @var{sub-fields} must be record\n"
"getters designating sub-fields within that field value to be set (see\n"
"example below.)\n"
"@end deffn"
msgstr ""

#: api-data.texi:8557
msgid ""
"@deffn {Scheme Syntax} set-fields record ((field sub-fields ...) value) ...\n"
"Like @code{set-field}, but can be used to set more than one field at a\n"
"time.  This expands to code that is more efficient than a series of\n"
"single @code{set-field} calls.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8560
msgid ""
"To illustrate the use of functional setters, let's assume these two\n"
"record type definitions:"
msgstr ""
"Чтобы проилюстрировать использование функциональных установщиков(functional "
"setters)\n"
"давайте предположим эти два определения типа записей:"

#: api-data.texi:8568
msgid ""
"@example\n"
"(define-record-type <address>\n"
"  (address street city country)\n"
"  address?\n"
"  (street  address-street)\n"
"  (city    address-city)\n"
"  (country address-country))"
msgstr ""

#: api-data.texi:8576
msgid ""
"(define-immutable-record-type <person>\n"
"  (person age email address)\n"
"  person?\n"
"  (age     person-age set-person-age)\n"
"  (email   person-email set-person-email)\n"
"  (address person-address set-person-address))\n"
"@end example"
msgstr ""

#: api-data.texi:8580
msgid ""
"@noindent\n"
"First, note that the @code{<person>} record type definition introduces\n"
"named functional setters.  These may be used like this:"
msgstr ""
"@noindent\n"
"Во-первых, обратите внимание, что определение типа записи @code{<person>}\n"
"вводит именнованные функциональные установщики.\n"
"Они могут быть использованы следующим образом:"

#: api-data.texi:8584
msgid ""
"@example\n"
"(define fsf-address\n"
"  (address \"Franklin Street\" \"Boston\" \"USA\"))"
msgstr ""

#: api-data.texi:8587
msgid ""
"(define rms\n"
"  (person 30 \"rms@@gnu.org\" fsf-address))"
msgstr ""

#: api-data.texi:8593
msgid ""
"(and (equal? (set-person-age rms 60)\n"
"             (person 60 \"rms@@gnu.org\" fsf-address))\n"
"     (= (person-age rms) 30))\n"
"@result{} #t\n"
"@end example"
msgstr ""

#: api-data.texi:8597
msgid ""
"@noindent\n"
"Here, the original @code{<person>} record, to which @var{rms} is bound,\n"
"is left unchanged."
msgstr ""
"@noindent\n"
"Здесь, исходная запись @code{<person>}, к которой привязана @var{rms},\n"
"остается неизменной."

#: api-data.texi:8600
msgid ""
"Now, suppose we want to change both the street and age of @var{rms}.\n"
"This can be achieved using @code{set-fields}:"
msgstr ""
"Теперь предположим, что мы хотим изменить как улицу, так и возраст "
"@var{rms}.\n"
"Это может быть достигнуто использованием @code{set-fields}:"

#: api-data.texi:8608
msgid ""
"@example\n"
"(set-fields rms\n"
"  ((person-age) 60)\n"
"  ((person-address address-street) \"Temple Place\"))\n"
"@result{} #<<person> age: 60 email: \"rms@@gnu.org\"\n"
"  address: #<<address> street: \"Temple Place\" city: \"Boston\" country: "
"\"USA\">>\n"
"@end example"
msgstr ""

#: api-data.texi:8614
msgid ""
"@noindent\n"
"Notice how the above changed two fields of @var{rms}, including the\n"
"@code{street} field of its @code{address} field, in a concise way.  Also\n"
"note that @code{set-fields} works equally well for types defined with\n"
"just @code{define-record-type}."
msgstr ""
"@noindent\n"
"Обратите внимание, как вышеизложенное изменило два поля @var{rms}, включая\n"
"поле улицы @code{street} в его адресе @code{address}.  Также обратите\n"
"внимание, что @code{set-fields} работает одинаково для типов, определенных\n"
"с помощью @code{define-record-type}."

#: api-data.texi:8617
msgid ""
"@node Records\n"
"@subsection Records"
msgstr ""
"@node Records\n"
"@subsection Записи(Records)"

#: api-data.texi:8620
msgid ""
"A @dfn{record type} is a first class object representing a user-defined\n"
"data type.  A @dfn{record} is an instance of a record type."
msgstr ""
"Тип Запись @dfn{record type} это первый объект класса представляющего\n"
"пользовательский тип данных.  Запись @dfn{record} это экземпляр типа\n"
"записи."

#: api-data.texi:8624
msgid ""
"Note that in many ways, this interface is too low-level for every-day\n"
"use.  Most uses of records are better served by SRFI-9 records.\n"
"@xref{SRFI-9 Records}."
msgstr ""
"Обратите внимание, что во многих отношениях этот интерфейс слишком\n"
"низкоуровневый для повседневного использования.  Большинство примениней\n"
"записи лучше обслживаются записями SRFI-9.\n"
"@xref{SRFI-9 Records}."

#: api-data.texi:8628
msgid ""
"@deffn {Scheme Procedure} record? obj\n"
"Return @code{#t} if @var{obj} is a record of any type and @code{#f}\n"
"otherwise."
msgstr ""

#: api-data.texi:8632
msgid ""
"Note that @code{record?} may be true of any Scheme value; there is no\n"
"promise that records are disjoint with other Scheme types.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8635
msgid ""
"@deffn {Scheme Procedure} make-record-type type-name field-names [print]\n"
"Create and return a new @dfn{record-type descriptor}."
msgstr ""

#: api-data.texi:8640
msgid ""
"@var{type-name} is a string naming the type.  Currently it's only used\n"
"in the printed representation of records, and in diagnostics.\n"
"@var{field-names} is a list of symbols naming the fields of a record\n"
"of the type.  Duplicates are not allowed among these symbols."
msgstr ""

#: api-data.texi:8644
msgid ""
"@example\n"
"(make-record-type \"employee\" '(name age salary))\n"
"@end example"
msgstr ""

#: api-data.texi:8650
msgid ""
"The optional @var{print} argument is a function used by\n"
"@code{display}, @code{write}, etc, for printing a record of the new\n"
"type.  It's called as @code{(@var{print} record port)} and should look\n"
"at @var{record} and write to @var{port}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8663
msgid ""
"@deffn {Scheme Procedure} record-constructor rtd [field-names]\n"
"Return a procedure for constructing new members of the type represented\n"
"by @var{rtd}.  The returned procedure accepts exactly as many arguments\n"
"as there are symbols in the given list, @var{field-names}; these are\n"
"used, in order, as the initial values of those fields in a new record,\n"
"which is returned by the constructor procedure.  The values of any\n"
"fields not named in that list are unspecified.  The @var{field-names}\n"
"argument defaults to the list of field names in the call to\n"
"@code{make-record-type} that created the type represented by @var{rtd};\n"
"if the @var{field-names} argument is provided, it is an error if it\n"
"contains any duplicates or any symbols not in the default list.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8670
msgid ""
"@deffn {Scheme Procedure} record-predicate rtd\n"
"Return a procedure for testing membership in the type represented by\n"
"@var{rtd}.  The returned procedure accepts exactly one argument and\n"
"returns a true value if the argument is a member of the indicated record\n"
"type; it returns a false value otherwise.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8680
msgid ""
"@deffn {Scheme Procedure} record-accessor rtd field-name\n"
"Return a procedure for reading the value of a particular field of a\n"
"member of the type represented by @var{rtd}.  The returned procedure\n"
"accepts exactly one argument which must be a record of the appropriate\n"
"type; it returns the current value of the field named by the symbol\n"
"@var{field-name} in that record.  The symbol @var{field-name} must be a\n"
"member of the list of field-names in the call to @code{make-record-type}\n"
"that created the type represented by @var{rtd}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8692
msgid ""
"@deffn {Scheme Procedure} record-modifier rtd field-name\n"
"Return a procedure for writing the value of a particular field of a\n"
"member of the type represented by @var{rtd}.  The returned procedure\n"
"accepts exactly two arguments: first, a record of the appropriate type,\n"
"and second, an arbitrary Scheme value; it modifies the field named by\n"
"the symbol @var{field-name} in that record to contain the given value.\n"
"The returned value of the modifier procedure is unspecified.  The symbol\n"
"@var{field-name} must be a member of the list of field-names in the call\n"
"to @code{make-record-type} that created the type represented by\n"
"@var{rtd}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8702
msgid ""
"@deffn {Scheme Procedure} record-type-descriptor record\n"
"Return a record-type descriptor representing the type of the given\n"
"record.  That is, for example, if the returned descriptor were passed to\n"
"@code{record-predicate}, the resulting predicate would return a true\n"
"value when passed the given record.  Note that it is not necessarily the\n"
"case that the returned descriptor is the one that was passed to\n"
"@code{record-constructor} in the call that created the constructor\n"
"procedure that created the given record.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8709
msgid ""
"@deffn {Scheme Procedure} record-type-name rtd\n"
"Return the type-name associated with the type represented by rtd.  The\n"
"returned value is @code{eqv?} to the @var{type-name} argument given in\n"
"the call to @code{make-record-type} that created the type represented by\n"
"@var{rtd}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8716
msgid ""
"@deffn {Scheme Procedure} record-type-fields rtd\n"
"Return a list of the symbols naming the fields in members of the type\n"
"represented by @var{rtd}.  The returned value is @code{equal?} to the\n"
"field-names argument given in the call to @code{make-record-type} that\n"
"created the type represented by @var{rtd}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8721
msgid ""
"@node Structures\n"
"@subsection Structures\n"
"@tpindex Structures"
msgstr ""
"@node Structures\n"
"@subsection Структуры(Structures)\n"
"@tpindex Structures"

#: api-data.texi:8726
msgid ""
"A @dfn{structure} is a first class data type which holds Scheme values\n"
"or C words in fields numbered 0 upwards.  A @dfn{vtable} is a structure\n"
"that represents a structure type, giving field types and permissions,\n"
"and an optional print function for @code{write} etc."
msgstr ""
"Структура@dfn{structure} - это первый класс, тип данных, который содержит\n"
"значения Scheme или слова Си в полях, пронумерованных от нуля и выше.\n"
"@dfn{vtable} - это структура, представляющая тип структуры, предоставляющей\n"
"типы полей и разрешений доступа и дополнительной функции печати для\n"
"@code{write} и т.д."

#: api-data.texi:8732
msgid ""
"Structures are lower level than records (@pxref{Records}).  Usually,\n"
"when you need to represent structured data, you just want to use\n"
"records.  But sometimes you need to implement new kinds of structured\n"
"data abstractions, and for that purpose structures are useful.  Indeed,\n"
"records in Guile are implemented with structures."
msgstr ""
"Структуры(Structures) представляют более низкий уровень абстракций\n"
"по сравнению с записями (@pxref{Records}).  Как правило,\n"
"когда вам нужно представлять структурированные данные, вы просто хотите\n"
"использовать записи. Но иногда вам необходимо реализовать новые виды\n"
"абстракций структурированных данных, и для этой цели структуры полезны.\n"
"Действительно, записи в Guile реализованы со структурами."

#: api-data.texi:8740
msgid ""
"@menu\n"
"* Vtables::\n"
"* Structure Basics::\n"
"* Vtable Contents::\n"
"* Meta-Vtables::\n"
"* Vtable Example::\n"
"@end menu"
msgstr ""

#: api-data.texi:8743
msgid ""
"@node Vtables\n"
"@subsubsection Vtables"
msgstr ""

#: api-data.texi:8747
msgid ""
"A vtable is a structure type, specifying its layout, and other\n"
"information.  A vtable is actually itself a structure, but there's no\n"
"need to worry about that initially (@pxref{Vtable Contents}.)"
msgstr ""
"vtable это тип структуры, определяющий ее схему, и другую информацию.\n"
"Фактически vtable сама является структурой, но в здесь не нужно "
"беспокоиться\n"
"об этом. (@pxref{Vtable Contents}.)"

#: api-data.texi:8750
msgid ""
"@deffn {Scheme Procedure} make-vtable fields [print]\n"
"Create a new vtable."
msgstr ""

#: api-data.texi:8755
msgid ""
"@var{fields} is a string describing the fields in the structures to be\n"
"created.  Each field is represented by two characters, a type letter\n"
"and a permissions letter, for example @code{\"pw\"}.  The types are as\n"
"follows."
msgstr ""

#: api-data.texi:8760
msgid ""
"@itemize @bullet{}\n"
"@item\n"
"@code{p} -- a Scheme value.  ``p'' stands for ``protected'' meaning\n"
"it's protected against garbage collection."
msgstr ""

#: api-data.texi:8767
msgid ""
"@item\n"
"@code{u} -- an arbitrary word of data (an @code{scm_t_bits}).  At the\n"
"Scheme level it's read and written as an unsigned integer.  ``u'' stands\n"
"for ``unboxed'', as it's stored as a raw value without additional type\n"
"annotations.\n"
"@end itemize"
msgstr ""

#: api-data.texi:8769
msgid "The second letter for each field is a permission code,"
msgstr ""

#: api-data.texi:8777
msgid ""
"@itemize @bullet{}\n"
"@item\n"
"@code{w} -- writable, the field can be read and written.\n"
"@item\n"
"@code{r} -- read-only, the field can be read but not written.\n"
"@item\n"
"@end itemize"
msgstr ""

#: api-data.texi:8779
msgid "Here are some examples."
msgstr ""

#: api-data.texi:8785
msgid ""
"@example\n"
"(make-vtable \"pw\")      ;; one writable field\n"
"(make-vtable \"prpw\")    ;; one read-only and one writable\n"
"(make-vtable \"pwuwuw\")  ;; one scheme and two unboxed\n"
"@end example"
msgstr ""

#: api-data.texi:8792
msgid ""
"The optional @var{print} argument is a function called by\n"
"@code{display} and @code{write} (etc) to give a printed representation\n"
"of a structure created from this vtable.  It's called\n"
"@code{(@var{print} struct port)} and should look at @var{struct} and\n"
"write to @var{port}.  The default print merely gives a form like\n"
"@samp{#<struct ADDR:ADDR>} with a pair of machine addresses."
msgstr ""

#: api-data.texi:8795
msgid ""
"The following print function for example shows the two fields of its\n"
"structure."
msgstr ""

#: api-data.texi:8804
msgid ""
"@example\n"
"(make-vtable \"prpw\"\n"
"             (lambda (struct port)\n"
"               (format port \"#<~a and ~a>\"\n"
"                       (struct-ref struct 0)\n"
"                       (struct-ref struct 1))))\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:8808
msgid ""
"@node Structure Basics\n"
"@subsubsection Structure Basics"
msgstr ""

#: api-data.texi:8812
msgid ""
"This section describes the basic procedures for working with structures.\n"
"@code{make-struct/no-tail} creates a structure, and @code{struct-ref}\n"
"and @code{struct-set!} access its fields."
msgstr ""

#: api-data.texi:8816
msgid ""
"@deffn {Scheme Procedure} make-struct/no-tail vtable init @dots{}\n"
"Create a new structure, with layout per the given @var{vtable}\n"
"(@pxref{Vtables})."
msgstr ""

#: api-data.texi:8822
msgid ""
"The optional @var{init}@dots{} arguments are initial values for the\n"
"fields of the structure.  This is the only way to\n"
"put values in read-only fields.  If there are fewer @var{init}\n"
"arguments than fields then the defaults are @code{#f} for a Scheme\n"
"field (type @code{p}) or 0 for an unboxed field (type @code{u})."
msgstr ""

#: api-data.texi:8827
msgid ""
"The name is a bit strange, we admit.  The reason for it is that Guile\n"
"used to have a @code{make-struct} that took an additional argument;\n"
"while we deprecate that old interface, @code{make-struct/no-tail} is the\n"
"new name for this functionality."
msgstr ""

#: api-data.texi:8829
msgctxt "api-data.texi:8829"
msgid "For example,"
msgstr ""

#: api-data.texi:8837
msgid ""
"@example\n"
"(define v (make-vtable \"prpwpw\"))\n"
"(define s (make-struct/no-tail v 123 \"abc\" 456))\n"
"(struct-ref s 0) @result{} 123\n"
"(struct-ref s 1) @result{} \"abc\"\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:8845
msgid ""
"@deftypefn {C Function} SCM scm_make_struct (SCM vtable, SCM tail_size, SCM "
"init_list)\n"
"@deftypefnx {C Function} SCM scm_c_make_struct (SCM vtable, SCM tail_size, "
"SCM init, ...)\n"
"@deftypefnx {C Function} SCM scm_c_make_structv (SCM vtable, SCM tail_size, "
"size_t n_inits, scm_t_bits init[])\n"
"There are a few ways to make structures from C.  @code{scm_make_struct}\n"
"takes a list, @code{scm_c_make_struct} takes variable arguments\n"
"terminated with SCM_UNDEFINED, and @code{scm_c_make_structv} takes a\n"
"packed array."
msgstr ""

#: api-data.texi:8848
msgid ""
"For all of these, @var{tail_size} should be zero (as a SCM value).\n"
"@end deftypefn"
msgstr ""

#: api-data.texi:8853
msgid ""
"@deffn {Scheme Procedure} struct? obj\n"
"@deffnx {C Function} scm_struct_p (obj)\n"
"Return @code{#t} if @var{obj} is a structure, or @code{#f} if not.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8858
msgid ""
"@deffn {Scheme Procedure} struct-ref struct n\n"
"@deffnx {C Function} scm_struct_ref (struct, n)\n"
"Return the contents of field number @var{n} in @var{struct}.  The\n"
"first field is number 0."
msgstr ""

#: api-data.texi:8861
msgid ""
"An error is thrown if @var{n} is out of range.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8866
msgid ""
"@deffn {Scheme Procedure} struct-set! struct n value\n"
"@deffnx {C Function} scm_struct_set_x (struct, n, value)\n"
"Set field number @var{n} in @var{struct} to @var{value}.  The first\n"
"field is number 0."
msgstr ""

#: api-data.texi:8870
msgid ""
"An error is thrown if @var{n} is out of range, or if the field cannot\n"
"be written because it's @code{r} read-only.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8873
msgid ""
"Unboxed fields (those with type @code{u}) need to be accessed with\n"
"special procedures."
msgstr ""

#: api-data.texi:8884
msgid ""
"@deffn {Scheme Procedure} struct-ref/unboxed struct n\n"
"@deffnx {Scheme Procedure} struct-set!/unboxed struct n value\n"
"@deffnx {C Function} scm_struct_ref_unboxed (struct, n)\n"
"@deffnx {C Function} scm_struct_set_x_unboxed (struct, n, value)\n"
"Like @code{struct-ref} and @code{struct-set!}, except that these may\n"
"only be used on unboxed fields.  @code{struct-ref/unboxed} will always\n"
"return a positive integer.  Likewise, @code{struct-set!/unboxed} takes\n"
"an unsigned integer as the @var{value} argument, and will signal an\n"
"error otherwise.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8888
msgid ""
"@deffn {Scheme Procedure} struct-vtable struct\n"
"@deffnx {C Function} scm_struct_vtable (struct)\n"
"Return the vtable that describes @var{struct}."
msgstr ""

#: api-data.texi:8892
msgid ""
"The vtable is effectively the type of the structure.  See @ref{Vtable\n"
"Contents}, for more on vtables.\n"
"@end deffn"
msgstr ""

#: api-data.texi:8896
msgid ""
"@node Vtable Contents\n"
"@subsubsection Vtable Contents"
msgstr ""

#: api-data.texi:8902
msgid ""
"A vtable is itself a structure.  It has a specific set of fields\n"
"describing various aspects of its @dfn{instances}: the structures\n"
"created from a vtable.  Some of the fields are internal to Guile, some\n"
"of them are part of the public interface, and there may be additional\n"
"fields added on by the user."
msgstr ""

#: api-data.texi:8908
msgid ""
"Every vtable has a field for the layout of their instances, a field for\n"
"the procedure used to print its instances, and a field for the name of\n"
"the vtable itself.  Access to the layout and printer is exposed directly\n"
"via field indexes.  Access to the vtable name is exposed via accessor\n"
"procedures."
msgstr ""

#: api-data.texi:8915
msgid ""
"@defvr {Scheme Variable} vtable-index-layout\n"
"@defvrx {C Macro} scm_vtable_index_layout\n"
"The field number of the layout specification in a vtable.  The layout\n"
"specification is a symbol like @code{pwpw} formed from the fields\n"
"string passed to @code{make-vtable}, or created by\n"
"@code{make-struct-layout} (@pxref{Meta-Vtables})."
msgstr ""

#: api-data.texi:8920
msgid ""
"@example\n"
"(define v (make-vtable \"pwpw\" 0))\n"
"(struct-ref v vtable-index-layout) @result{} pwpw\n"
"@end example"
msgstr ""

#: api-data.texi:8924
msgid ""
"This field is read-only, since the layout of structures using a vtable\n"
"cannot be changed.\n"
"@end defvr"
msgstr ""

#: api-data.texi:8929
msgid ""
"@defvr {Scheme Variable} vtable-index-printer\n"
"@defvrx {C Macro} scm_vtable_index_printer\n"
"The field number of the printer function.  This field contains @code{#f}\n"
"if the default print function should be used."
msgstr ""

#: api-data.texi:8936
msgid ""
"@example\n"
"(define (my-print-func struct port)\n"
"  ...)\n"
"(define v (make-vtable \"pwpw\" my-print-func))\n"
"(struct-ref v vtable-index-printer) @result{} my-print-func\n"
"@end example"
msgstr ""

#: api-data.texi:8940
msgid ""
"This field is writable, allowing the print function to be changed\n"
"dynamically.\n"
"@end defvr"
msgstr ""

#: api-data.texi:8948
msgid ""
"@deffn {Scheme Procedure} struct-vtable-name vtable\n"
"@deffnx {Scheme Procedure} set-struct-vtable-name! vtable name\n"
"@deffnx {C Function} scm_struct_vtable_name (vtable)\n"
"@deffnx {C Function} scm_set_struct_vtable_name_x (vtable, name)\n"
"Get or set the name of @var{vtable}.  @var{name} is a symbol and is\n"
"used in the default print function when printing structures created\n"
"from @var{vtable}."
msgstr ""

#: api-data.texi:8952
msgid ""
"@example\n"
"(define v (make-vtable \"pw\"))\n"
"(set-struct-vtable-name! v 'my-name)"
msgstr ""

#: api-data.texi:8957
msgid ""
"(define s (make-struct v 0))\n"
"(display s) @print{} #<my-name b7ab3ae0:b7ab3730>\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:8961
msgid ""
"@node Meta-Vtables\n"
"@subsubsection Meta-Vtables"
msgstr ""

#: api-data.texi:8966
msgid ""
"As a structure, a vtable also has a vtable, which is also a structure.\n"
"Structures, their vtables, the vtables of the vtables, and so on form a\n"
"tree of structures.  Making a new structure adds a leaf to the tree, and\n"
"if that structure is a vtable, it may be used to create other leaves."
msgstr ""

#: api-data.texi:8970
msgid ""
"If you traverse up the tree of vtables, via calling\n"
"@code{struct-vtable}, eventually you reach a root which is the vtable of\n"
"itself:"
msgstr ""

#: api-data.texi:8985
msgid ""
"@example\n"
"scheme@@(guile-user)> (current-module)\n"
"$1 = #<directory (guile-user) 221b090>\n"
"scheme@@(guile-user)> (struct-vtable $1)\n"
"$2 = #<record-type module>\n"
"scheme@@(guile-user)> (struct-vtable $2)\n"
"$3 = #<<standard-vtable> 12c30a0>\n"
"scheme@@(guile-user)> (struct-vtable $3)\n"
"$4 = #<<standard-vtable> 12c3fa0>\n"
"scheme@@(guile-user)> (struct-vtable $4)\n"
"$5 = #<<standard-vtable> 12c3fa0>\n"
"scheme@@(guile-user)> <standard-vtable>\n"
"$6 = #<<standard-vtable> 12c3fa0>\n"
"@end example"
msgstr ""

#: api-data.texi:8991
msgid ""
"In this example, we can say that @code{$1} is an instance of @code{$2},\n"
"@code{$2} is an instance of @code{$3}, @code{$3} is an instance of\n"
"@code{$4}, and @code{$4}, strangely enough, is an instance of itself.\n"
"The value bound to @code{$4} in this console session also bound to\n"
"@code{<standard-vtable>} in the default environment."
msgstr ""

#: api-data.texi:8995
msgid ""
"@defvr {Scheme Variable} <standard-vtable>\n"
"A meta-vtable, useful for making new vtables.\n"
"@end defvr"
msgstr ""

#: api-data.texi:9000
msgid ""
"All of these values are structures.  All but @code{$1} are vtables.  As\n"
"@code{$2} is an instance of @code{$3}, and @code{$3} is a vtable, we can\n"
"say that @code{$3} is a @dfn{meta-vtable}: a vtable that can create\n"
"vtables."
msgstr ""

#: api-data.texi:9008
msgid ""
"With this definition, we can specify more precisely what a vtable is: a\n"
"vtable is a structure made from a meta-vtable.  Making a structure from\n"
"a meta-vtable runs some special checks to ensure that the first field of\n"
"the structure is a valid layout.  Additionally, if these checks see that\n"
"the layout of the child vtable contains all the required fields of a\n"
"vtable, in the correct order, then the child vtable will also be a\n"
"meta-table, inheriting a magical bit from the parent."
msgstr ""

#: api-data.texi:9014
msgid ""
"@deffn {Scheme Procedure} struct-vtable? obj\n"
"@deffnx {C Function} scm_struct_vtable_p (obj)\n"
"Return @code{#t} if @var{obj} is a vtable structure: an instance of a\n"
"meta-vtable.\n"
"@end deffn"
msgstr ""

#: api-data.texi:9018
msgid ""
"@code{<standard-vtable>} is a root of the vtable tree.  (Normally there\n"
"is only one root in a given Guile process, but due to some legacy\n"
"interfaces there may be more than one.)"
msgstr ""

#: api-data.texi:9024
msgid ""
"The set of required fields of a vtable is the set of fields in the\n"
"@code{<standard-vtable>}, and is bound to @code{standard-vtable-fields}\n"
"in the default environment.  It is possible to create a meta-vtable that\n"
"with additional fields in its layout, which can be used to create\n"
"vtables with additional data:"
msgstr ""

#: api-data.texi:9035
msgid ""
"@example\n"
"scheme@@(guile-user)> (struct-ref $3 vtable-index-layout)\n"
"$6 = pruhsruhpwphuhuhprprpw\n"
"scheme@@(guile-user)> (struct-ref $4 vtable-index-layout)\n"
"$7 = pruhsruhpwphuhuh\n"
"scheme@@(guile-user)> standard-vtable-fields \n"
"$8 = \"pruhsruhpwphuhuh\"\n"
"scheme@@(guile-user)> (struct-ref $2 vtable-offset-user)\n"
"$9 = module\n"
"@end example"
msgstr ""

#: api-data.texi:9041
msgid ""
"In this continuation of our earlier example, @code{$2} is a vtable that\n"
"has extra fields, because its vtable, @code{$3}, was made from a\n"
"meta-vtable with an extended layout.  @code{vtable-offset-user} is a\n"
"convenient definition that indicates the number of fields in\n"
"@code{standard-vtable-fields}."
msgstr ""

#: api-data.texi:9045
msgid ""
"@defvr {Scheme Variable} standard-vtable-fields\n"
"A string containing the ordered set of fields that a vtable must have.\n"
"@end defvr"
msgstr ""

#: api-data.texi:9049
msgid ""
"@defvr {Scheme Variable} vtable-offset-user\n"
"The first index in a vtable that is available for a user.\n"
"@end defvr"
msgstr ""

#: api-data.texi:9056
msgid ""
"@deffn {Scheme Procedure} make-struct-layout fields\n"
"@deffnx {C Function} scm_make_struct_layout (fields)\n"
"Return a structure layout symbol, from a @var{fields} string.\n"
"@var{fields} is as described under @code{make-vtable}\n"
"(@pxref{Vtables}).  An invalid @var{fields} string is an error.\n"
"@end deffn"
msgstr ""

#: api-data.texi:9058
msgid "With these definitions, one can define @code{make-vtable} in this way:"
msgstr ""

#: api-data.texi:9065
msgid ""
"@example\n"
"(define* (make-vtable fields #:optional printer)\n"
"  (make-struct/no-tail <standard-vtable>\n"
"    (make-struct-layout fields)\n"
"    printer))\n"
"@end example"
msgstr ""

#: api-data.texi:9069
msgid ""
"@node Vtable Example\n"
"@subsubsection Vtable Example"
msgstr ""

#: api-data.texi:9074
msgid ""
"Let us bring these points together with an example.  Consider a simple\n"
"object system with single inheritance.  Objects will be normal\n"
"structures, and classes will be vtables with three extra class fields:\n"
"the name of the class, the parent class, and the list of fields."
msgstr ""

#: api-data.texi:9077
msgid ""
"So, first we need a meta-vtable that allocates instances with these\n"
"extra class fields."
msgstr ""

#: api-data.texi:9084
msgid ""
"@example\n"
"(define <class>\n"
"  (make-vtable\n"
"   (string-append standard-vtable-fields \"pwpwpw\")\n"
"   (lambda (x port)\n"
"     (format port \"<<class> ~a>\" (class-name x)))))"
msgstr ""

#: api-data.texi:9089
msgid ""
"(define (class? x)\n"
"  (and (struct? x)\n"
"       (eq? (struct-vtable x) <class>)))\n"
"@end example"
msgstr ""

#: api-data.texi:9094
msgid ""
"To make a structure with a specific meta-vtable, we will use\n"
"@code{make-struct/no-tail}, passing it the computed instance layout and\n"
"printer, as with @code{make-vtable}, and additionally the extra three\n"
"class fields."
msgstr ""

#: api-data.texi:9107
msgid ""
"@example\n"
"(define (make-class name parent fields)\n"
"  (let* ((fields (compute-fields parent fields))\n"
"         (layout (compute-layout fields)))\n"
"    (make-struct/no-tail <class>\n"
"      layout \n"
"      (lambda (x port)\n"
"        (print-instance x port))\n"
"      name\n"
"      parent\n"
"      fields)))\n"
"@end example"
msgstr ""

#: api-data.texi:9112
msgid ""
"Instances will store their associated data in slots in the structure: as\n"
"many slots as there are fields.  The @code{compute-layout} procedure\n"
"below can compute a layout, and @code{field-index} returns the slot\n"
"corresponding to a field."
msgstr ""

#: api-data.texi:9117
msgid ""
"@example\n"
"(define-syntax-rule (define-accessor name n)\n"
"  (define (name obj)\n"
"    (struct-ref obj n)))"
msgstr ""

#: api-data.texi:9122
msgid ""
";; Accessors for classes\n"
"(define-accessor class-name (+ vtable-offset-user 0))\n"
"(define-accessor class-parent (+ vtable-offset-user 1))\n"
"(define-accessor class-fields (+ vtable-offset-user 2))"
msgstr ""

#: api-data.texi:9127
msgid ""
"(define (compute-fields parent fields)\n"
"  (if parent\n"
"      (append (class-fields parent) fields)\n"
"      fields))"
msgstr ""

#: api-data.texi:9131
msgid ""
"(define (compute-layout fields)\n"
"  (make-struct-layout\n"
"   (string-concatenate (make-list (length fields) \"pw\"))))"
msgstr ""

#: api-data.texi:9134
msgid ""
"(define (field-index class field)\n"
"  (list-index (class-fields class) field))"
msgstr ""

#: api-data.texi:9143
msgid ""
"(define (print-instance x port)\n"
"  (format port \"<~a\" (class-name (struct-vtable x)))\n"
"  (for-each (lambda (field idx)\n"
"              (format port \" ~a: ~a\" field (struct-ref x idx)))\n"
"            (class-fields (struct-vtable x))\n"
"            (iota (length (class-fields (struct-vtable x)))))\n"
"  (format port \">\"))\n"
"@end example"
msgstr ""

#: api-data.texi:9145
msgid "So, at this point we can actually make a few classes:"
msgstr ""

#: api-data.texi:9149
msgid ""
"@example\n"
"(define-syntax-rule (define-class name parent field ...)\n"
"  (define name (make-class 'name parent '(field ...))))"
msgstr ""

#: api-data.texi:9152
msgid ""
"(define-class <surface> #f\n"
"  width height)"
msgstr ""

#: api-data.texi:9156
msgid ""
"(define-class <window> <surface>\n"
"  x y)\n"
"@end example"
msgstr ""

#: api-data.texi:9158
msgid "And finally, make an instance:"
msgstr ""

#: api-data.texi:9163
msgid ""
"@example\n"
"(make-struct/no-tail <window> 400 300 10 20)\n"
"@result{} <<window> width: 400 height: 300 x: 10 y: 20>\n"
"@end example"
msgstr ""

#: api-data.texi:9170
msgid ""
"And that's that.  Note that there are many possible optimizations and\n"
"feature enhancements that can be made to this object system, and the\n"
"included GOOPS system does make most of them.  For more simple use\n"
"cases, the records facility is usually sufficient.  But sometimes you\n"
"need to make new kinds of data abstractions, and for that purpose,\n"
"structs are here."
msgstr ""

#: api-data.texi:9174
msgid ""
"@node Dictionary Types\n"
"@subsection Dictionary Types"
msgstr ""
"@node Dictionary Types\n"
"@subsection Тип Словарь(Dictionary Types)"

#: api-data.texi:9184
msgid ""
"A @dfn{dictionary} object is a data structure used to index\n"
"information in a user-defined way.  In standard Scheme, the main\n"
"aggregate data types are lists and vectors.  Lists are not really\n"
"indexed at all, and vectors are indexed only by number\n"
"(e.g.@: @code{(vector-ref foo 5)}).  Often you will find it useful\n"
"to index your data on some other type; for example, in a library\n"
"catalog you might want to look up a book by the name of its\n"
"author.  Dictionaries are used to help you organize information in\n"
"such a way."
msgstr ""
"Объект Словарь @dfn{dictionary} - это структура данных, используемая\n"
"для индексирования информации способом определяемым пользователем.\n"
"В стандартном Scheme, основными агрегирующими типами данных являются\n"
"списки и вектора. Списки не индексируются вообще, а векторы индексируются\n"
"только по числу (например@: @code{(vector-ref foo 5)}).  Часто вам\n"
"будет полезно проиндексировать ваши данные по другому типу,\n"
"например, в библиотеке вы можете захотеть найти книгу по имени ее\n"
"автора.  Использование Словаря поможет вам организовать информацию\n"
"таким образом."

#: api-data.texi:9189
msgid ""
"An @dfn{association list} (or @dfn{alist} for short) is a list of\n"
"key-value pairs.  Each pair represents a single quantity or\n"
"object; the @code{car} of the pair is a key which is used to\n"
"identify the object, and the @code{cdr} is the object's value."
msgstr ""
"Ассоциативный список @dfn{association list} (или кратко @dfn{alist})\n"
"представляет собой список пар ключ-значение. Каждая пара представляет\n"
"собой единую величину или объект; @code{car} для пары - дает ключ,\n"
"который используется для идентификации объекта, а @code{cdr} дает\n"
"значение объекта."

#: api-data.texi:9194
msgid ""
"A @dfn{hash table} also permits you to index objects with\n"
"arbitrary keys, but in a way that makes looking up any one object\n"
"extremely fast.  A well-designed hash system makes hash table\n"
"lookups almost as fast as conventional array or vector references."
msgstr ""
"Хеш-таблица @dfn{hash table} также позволяет вам индексировать объекты\n"
"с помощью произвольных ключей, но таким образом, чтобы сделать поиск\n"
"любого объекта чрезвычайно быстрым. Хрошо разработанная хеш-система\n"
"делает хэш таблицы почти такими же быстрыми, как и обычные массивы или\n"
"вектры ссылок."

#: api-data.texi:9202
msgid ""
"Alists are popular among Lisp programmers because they use only\n"
"the language's primitive operations (lists, @dfn{car}, @dfn{cdr}\n"
"and the equality primitives).  No changes to the language core are\n"
"necessary.  Therefore, with Scheme's built-in list manipulation\n"
"facilities, it is very convenient to handle data stored in an\n"
"association list.  Also, alists are highly portable and can be\n"
"easily implemented on even the most minimal Lisp systems."
msgstr ""
"Alists популярны среди программистов Lisp, потому что они используют\n"
"только примитивные оперции языка:(lists, @dfn{car}, @dfn{cdr}\n"
"и примитивы равенства).  Никаких изменений в ядре языка.\n"
"Поэтому, благодаря встроенным средствам управления списками Scheme\n"
"очень удобно обрабатывать данные хранящиеся в ассоциативном списке\n"
"Также, alist отличается высокой переносимостью и могут быть реализованы\n"
"даже в самых минимальных системах Lisp."

#: api-data.texi:9207
msgid ""
"However, alists are inefficient, especially for storing large\n"
"quantities of data.  Because we want Guile to be useful for large\n"
"software systems as well as small ones, Guile provides a rich set\n"
"of tools for using either association lists or hash tables."
msgstr ""
"Однако, alist неэффективен, особенно для хранения большого количества "
"данных.\n"
"Поскольку мы(разработчки) хотим, чтобы Guile был полезен для больших\n"
"программных систем, а также для небольших, Guile предоставляет богатый\n"
"набор инструментов для использования ассоциативных списков или хеш-таблиц."

#: api-data.texi:9215
msgid ""
"@node Association Lists\n"
"@subsection Association Lists\n"
"@tpindex Association Lists\n"
"@tpindex Alist\n"
"@cindex association List\n"
"@cindex alist\n"
"@cindex database"
msgstr ""
"@node Association Lists\n"
"@subsection Ассоциативные списки(Association Lists)\n"
"@tpindex Association Lists\n"
"@tpindex Alist\n"
"@cindex association List\n"
"@cindex alist\n"
"@cindex database"

#: api-data.texi:9221
msgid ""
"An association list is a conventional data structure that is often used\n"
"to implement simple key-value databases.  It consists of a list of\n"
"entries in which each entry is a pair.  The @dfn{key} of each entry is\n"
"the @code{car} of the pair and the @dfn{value} of each entry is the\n"
"@code{cdr}."
msgstr ""
"Ассоциативный список представляет собой обычную структуру данных,\n"
"которая часто используется для реализации баз данных со структурой\n"
"ключ-значение. Она состоит из списка полей, в которых каждая запись\n"
"представляет собой пару.  Ключ @dfn{key} каждой записи, содержиться в\n"
"начале пары @code{car}, а значение @dfn{value} в конце каждой записи "
"@code{cdr}."

#: api-data.texi:9229
msgid ""
"@example\n"
"ASSOCIATION LIST ::=  '( (KEY1 . VALUE1)\n"
"                         (KEY2 . VALUE2)\n"
"                         (KEY3 . VALUE3)\n"
"                         @dots{}\n"
"                       )\n"
"@end example"
msgstr ""

#: api-data.texi:9232
msgid ""
"@noindent\n"
"Association lists are also known, for short, as @dfn{alists}."
msgstr ""
"@noindent\n"
"Ассоциативный список также исвестен, как @dfn{alists}."

#: api-data.texi:9240
msgid ""
"The structure of an association list is just one example of the infinite\n"
"number of possible structures that can be built using pairs and lists.\n"
"As such, the keys and values in an association list can be manipulated\n"
"using the general list structure procedures @code{cons}, @code{car},\n"
"@code{cdr}, @code{set-car!}, @code{set-cdr!} and so on.  However,\n"
"because association lists are so useful, Guile also provides specific\n"
"procedures for manipulating them."
msgstr ""
"Структура списка ассоциаций - всего лишь один пример бесконечного числа\n"
"возможных структур, которые могут быть построены с использованием\n"
"пар и списков. Таким образом, ключами и значениями в списке ассоциаций\n"
"можно манипулировать с использованием общих процедур управления списками:\n"
"@code{cons}, @code{car}, @code{cdr}, @code{set-car!}, @code{set-cdr!} и\n"
"так далее. Однако, поскольку списки ассоциаций настолько полезны, Guile\n"
"также предоставляет конкретные процедуры для манипулирования ими."

#: api-data.texi:9249
msgid ""
"@menu\n"
"* Alist Key Equality::\n"
"* Adding or Setting Alist Entries::\n"
"* Retrieving Alist Entries::\n"
"* Removing Alist Entries::\n"
"* Sloppy Alist Functions::\n"
"* Alist Example::\n"
"@end menu"
msgstr ""

#: api-data.texi:9252
msgid ""
"@node Alist Key Equality\n"
"@subsubsection Alist Key Equality"
msgstr ""
"@node Alist Key Equality\n"
"@subsubsection Сравнение ключей (Alist Key Equality)"

#: api-data.texi:9258
msgid ""
"All of Guile's dedicated association list procedures, apart from\n"
"@code{acons}, come in three flavours, depending on the level of equality\n"
"that is required to decide whether an existing key in the association\n"
"list is the same as the key that the procedure call uses to identify the\n"
"required entry."
msgstr ""
"Все связанные с Guile процедуры работы с ассоциативными списками, "
"представленны\n"
"в трех вариантах, в зависимости от уровня равенства, необходимого для "
"принятия\n"
"решения о том, существует ли соответствующий ключ в списке ассоциаций "
"совпадающий\n"
"с ключем, который используется вызовом процедуры для идентификации "
"требуемой\n"
"записи."

#: api-data.texi:9263
msgid ""
"@itemize @bullet\n"
"@item\n"
"Procedures with @dfn{assq} in their name use @code{eq?} to determine key\n"
"equality."
msgstr ""
"@itemize @bullet\n"
"@item\n"
"Процедуры с @dfn{assq} в их имени используется @code{eq?} для определения\n"
"равенства с ключем."

#: api-data.texi:9267
msgid ""
"@item\n"
"Procedures with @dfn{assv} in their name use @code{eqv?} to determine\n"
"key equality."
msgstr ""
"@item\n"
"Процедуры с @dfn{assv} в их имени используют @code{eqv?} для определения\n"
"равенстваа с ключем."

#: api-data.texi:9272
msgid ""
"@item\n"
"Procedures with @dfn{assoc} in their name use @code{equal?} to\n"
"determine key equality.\n"
"@end itemize"
msgstr ""
"@item\n"
"Процедуры с @dfn{assoc} в их имени используется @code{equal?} для "
"определения\n"
"равенства с ключем.\n"
"@end itemize"

#: api-data.texi:9275
msgid ""
"@code{acons} is an exception because it is used to build association\n"
"lists which do not require their entries' keys to be unique."
msgstr ""
"@code{acons} - исключение, поскольку она используется для создания\n"
"списков ассоциаций, которые не требуют что бы ключи записей были\n"
"уникальны."

#: api-data.texi:9278
msgid ""
"@node Adding or Setting Alist Entries\n"
"@subsubsection Adding or Setting Alist Entries"
msgstr ""
"@node Adding or Setting Alist Entries\n"
"@subsubsection Добавление или Установка записей AList(Adding or Setting "
"Alist Entries)"

#: api-data.texi:9285
msgid ""
"@code{acons} adds a new entry to an association list and returns the\n"
"combined association list.  The combined alist is formed by consing the\n"
"new entry onto the head of the alist specified in the @code{acons}\n"
"procedure call.  So the specified alist is not modified, but its\n"
"contents become shared with the tail of the combined alist that\n"
"@code{acons} returns."
msgstr ""
"@code{acons} добавляет новую запись в списко ассоциаций и возвращает\n"
"объединенный список ассоциаций. Объединенный список ассоциаций формируется\n"
"путем вставки новой записи в начало alist указанного в вызове процедуры\n"
"@code{acons}.  Таким образом, указанный  alist не изменяется, но его \n"
"содержимое становиться разделяемым окончанием объединенного списка\n"
"ассоциаций  alist который возвращает @code{acons}."

#: api-data.texi:9288
msgid ""
"In the most common usage of @code{acons}, a variable holding the\n"
"original association list is updated with the combined alist:"
msgstr ""
"При более общем использовании @code{acons}, переменная содержащая исходный\n"
"список ассоциаций изменяется при создании общего alist:"

#: api-data.texi:9292
msgid ""
"@example\n"
"(set! address-list (acons name address address-list))\n"
"@end example"
msgstr ""

#: api-data.texi:9296
msgid ""
"In such cases, it doesn't matter that the old and new values of\n"
"@code{address-list} share some of their contents, since the old value is\n"
"usually no longer independently accessible."
msgstr ""
"В таких случаях не имеет значения, что старые и новые значения\n"
"@code{address-list} разделены в их контексте, поскольку старое\n"
"значение, как правило, больше не доступно, по независимой ссылке."

#: api-data.texi:9301
msgid ""
"Note that @code{acons} adds the specified new entry regardless of\n"
"whether the alist may already contain entries with keys that are, in\n"
"some sense, the same as that of the new entry.  Thus @code{acons} is\n"
"ideal for building alists where there is no concept of key uniqueness."
msgstr ""
"Обратите внимание, что @code{acons} добавляет указанную запись независимо\n"
"от того, что alist уже может содержать запись с таким же ключем.  Таким\n"
"образом @code{acons} идеально подходит для создания alists, где нет \n"
"требования уникальности ключей."

#: api-data.texi:9307
msgid ""
"@example\n"
"(set! task-list (acons 3 \"pay gas bill\" '()))\n"
"task-list\n"
"@result{}\n"
"((3 . \"pay gas bill\"))"
msgstr ""

#: api-data.texi:9313
msgid ""
"(set! task-list (acons 3 \"tidy bedroom\" task-list))\n"
"task-list\n"
"@result{}\n"
"((3 . \"tidy bedroom\") (3 . \"pay gas bill\"))\n"
"@end example"
msgstr ""

#: api-data.texi:9322
msgid ""
"@code{assq-set!}, @code{assv-set!} and @code{assoc-set!} are used to add\n"
"or replace an entry in an association list where there @emph{is} a\n"
"concept of key uniqueness.  If the specified association list already\n"
"contains an entry whose key is the same as that specified in the\n"
"procedure call, the existing entry is replaced by the new one.\n"
"Otherwise, the new entry is consed onto the head of the old association\n"
"list to create the combined alist.  In all cases, these procedures\n"
"return the combined alist."
msgstr ""
"@code{assq-set!}, @code{assv-set!} и @code{assoc-set!} используются для\n"
"добавления или замены записи в ассоциативном списке в котором есть "
"требование\n"
"ункиальности ключей.  Если список указанный как ассоциативный уже содержит\n"
"запись, ключ которой совпадает с тем, который указан в вызове процедуры,\n"
"существующая запись заменяется новой. Иначе новая запись заноситься в "
"начало\n"
"старого списка ассоциаций для создания объединенного  alist.  Во всех "
"случаях,\n"
"эти процедуры возвращают объединенный  alist."

#: api-data.texi:9327
msgid ""
"@code{assq-set!} and friends @emph{may} destructively modify the\n"
"structure of the old association list in such a way that an existing\n"
"variable is correctly updated without having to @code{set!} it to the\n"
"value returned:"
msgstr ""
"@code{assq-set!} и друзья @emph{могут} разрушить структуру старого\n"
"списка ассоциаций таким образом, чтобы существующая переменная\n"
"была правильно обновлена без необходимости вызывать @code{set!}\n"
"для возвращаемого значения:"

#: api-data.texi:9332
msgid ""
"@example\n"
"address-list\n"
"@result{}\n"
"((\"mary\" . \"34 Elm Road\") (\"james\" . \"16 Bow Street\"))"
msgstr ""

#: api-data.texi:9336
msgid ""
"(assoc-set! address-list \"james\" \"1a London Road\")\n"
"@result{}\n"
"((\"mary\" . \"34 Elm Road\") (\"james\" . \"1a London Road\"))"
msgstr ""

#: api-data.texi:9341
msgctxt "api-data.texi:9341"
msgid ""
"address-list\n"
"@result{}\n"
"((\"mary\" . \"34 Elm Road\") (\"james\" . \"1a London Road\"))\n"
"@end example"
msgstr ""

#: api-data.texi:9343
msgid "Or they may not:"
msgstr "Или они не могут:"

#: api-data.texi:9349
msgid ""
"@example\n"
"(assoc-set! address-list \"bob\" \"11 Newington Avenue\")\n"
"@result{}\n"
"((\"bob\" . \"11 Newington Avenue\") (\"mary\" . \"34 Elm Road\")\n"
" (\"james\" . \"1a London Road\"))"
msgstr ""

#: api-data.texi:9354
msgctxt "api-data.texi:9354"
msgid ""
"address-list\n"
"@result{}\n"
"((\"mary\" . \"34 Elm Road\") (\"james\" . \"1a London Road\"))\n"
"@end example"
msgstr ""

#: api-data.texi:9358
msgid ""
"The only safe way to update an association list variable when adding or\n"
"replacing an entry like this is to @code{set!} the variable to the\n"
"returned value:"
msgstr ""
"Единственный безопасный способ обновить переменную список ассоциаций\n"
"при добавлении или замене записей, вызвать @code{set!} к переменной\n"
"для возвращаемого значения:"

#: api-data.texi:9367
msgid ""
"@example\n"
"(set! address-list\n"
"      (assoc-set! address-list \"bob\" \"11 Newington Avenue\"))\n"
"address-list\n"
"@result{}\n"
"((\"bob\" . \"11 Newington Avenue\") (\"mary\" . \"34 Elm Road\")\n"
" (\"james\" . \"1a London Road\"))\n"
"@end example"
msgstr ""

#: api-data.texi:9372
msgid ""
"Because of this slight inconvenience, you may find it more convenient to\n"
"use hash tables to store dictionary data.  If your application will not\n"
"be modifying the contents of an alist very often, this may not make much\n"
"difference to you."
msgstr ""
"Из-за этого небольшого неудобства вам может быть удобнее использовать\n"
"хеш-таблицы для хранения данных словаря. Если ваше приложение не\n"
"будет изменять содержимое alist очень часто это может не иметь большого\n"
"значения для вас."

#: api-data.texi:9378
msgid ""
"If you need to keep the old value of an association list in a form\n"
"independent from the list that results from modification by\n"
"@code{acons}, @code{assq-set!}, @code{assv-set!} or @code{assoc-set!},\n"
"use @code{list-copy} to copy the old association list before modifying\n"
"it."
msgstr ""
"Если вам необходимо сохранить старое значение списка ассоциаций в \n"
"форме, независимой от списка, который будет результатом модификации\n"
"@code{acons}, @code{assq-set!}, @code{assv-set!} или @code{assoc-set!},\n"
"используйте @code{list-copy}, чтобы скопировать старый список ассоциаций,\n"
"прежде чем изменять его."

#: api-data.texi:9386
msgid ""
"@deffn {Scheme Procedure} acons key value alist\n"
"@deffnx {C Function} scm_acons (key, value, alist)\n"
"Add a new key-value pair to @var{alist}.  A new pair is\n"
"created whose car is @var{key} and whose cdr is @var{value}, and the\n"
"pair is consed onto @var{alist}, and the new list is returned.  This\n"
"function is @emph{not} destructive; @var{alist} is not modified.\n"
"@end deffn"
msgstr ""

#: api-data.texi:9397
msgid ""
"@deffn {Scheme Procedure} assq-set! alist key val\n"
"@deffnx {Scheme Procedure} assv-set! alist key value\n"
"@deffnx {Scheme Procedure} assoc-set! alist key value\n"
"@deffnx {C Function} scm_assq_set_x (alist, key, val)\n"
"@deffnx {C Function} scm_assv_set_x (alist, key, val)\n"
"@deffnx {C Function} scm_assoc_set_x (alist, key, val)\n"
"Reassociate @var{key} in @var{alist} with @var{value}: find any existing\n"
"@var{alist} entry for @var{key} and associate it with the new\n"
"@var{value}.  If @var{alist} does not contain an entry for @var{key},\n"
"add a new one.  Return the (possibly new) alist."
msgstr ""

#: api-data.texi:9402
msgid ""
"These functions do not attempt to verify the structure of @var{alist},\n"
"and so may cause unusual results if passed an object that is not an\n"
"association list.\n"
"@end deffn"
msgstr ""

#: api-data.texi:9408
msgid ""
"@node Retrieving Alist Entries\n"
"@subsubsection Retrieving Alist Entries\n"
"@rnindex assq\n"
"@rnindex assv\n"
"@rnindex assoc"
msgstr ""
"@node Retrieving Alist Entries\n"
"@subsubsection Получение записей Alist (Retrieving Alist Entries)\n"
"@rnindex assq\n"
"@rnindex assv\n"
"@rnindex assoc"

#: api-data.texi:9413
msgid ""
"@code{assq}, @code{assv} and @code{assoc} find the entry in an alist\n"
"for a given key, and return the @code{(@var{key} . @var{value})} pair.\n"
"@code{assq-ref}, @code{assv-ref} and @code{assoc-ref} do a similar\n"
"lookup, but return just the @var{value}."
msgstr ""
"@code{assq}, @code{assv} и @code{assoc} ищут запись в  alist\n"
"для заданного ключа(key), и возвращают пару @code{(@var{key} . "
"@var{value})}.\n"
"@code{assq-ref}, @code{assv-ref} и @code{assoc-ref} делают аналогичный\n"
"поиск, но возвращают только значение @var{value}."

#: api-data.texi:9423
msgid ""
"@deffn {Scheme Procedure} assq key alist\n"
"@deffnx {Scheme Procedure} assv key alist\n"
"@deffnx {Scheme Procedure} assoc key alist\n"
"@deffnx {C Function} scm_assq (key, alist)\n"
"@deffnx {C Function} scm_assv (key, alist)\n"
"@deffnx {C Function} scm_assoc (key, alist)\n"
"Return the first entry in @var{alist} with the given @var{key}.  The\n"
"return is the pair @code{(KEY . VALUE)} from @var{alist}.  If there's\n"
"no matching entry the return is @code{#f}."
msgstr ""

#: api-data.texi:9428
msgid ""
"@code{assq} compares keys with @code{eq?}, @code{assv} uses\n"
"@code{eqv?} and @code{assoc} uses @code{equal?}.  See also SRFI-1\n"
"which has an extended @code{assoc} (@ref{SRFI-1 Association Lists}).\n"
"@end deffn"
msgstr ""

#: api-data.texi:9437
msgid ""
"@deffn {Scheme Procedure} assq-ref alist key\n"
"@deffnx {Scheme Procedure} assv-ref alist key\n"
"@deffnx {Scheme Procedure} assoc-ref alist key\n"
"@deffnx {C Function} scm_assq_ref (alist, key)\n"
"@deffnx {C Function} scm_assv_ref (alist, key)\n"
"@deffnx {C Function} scm_assoc_ref (alist, key)\n"
"Return the value from the first entry in @var{alist} with the given\n"
"@var{key}, or @code{#f} if there's no such entry."
msgstr ""

#: api-data.texi:9440
msgid ""
"@code{assq-ref} compares keys with @code{eq?}, @code{assv-ref} uses\n"
"@code{eqv?} and @code{assoc-ref} uses @code{equal?}."
msgstr ""

#: api-data.texi:9444
msgid ""
"Notice these functions have the @var{key} argument last, like other\n"
"@code{-ref} functions, but this is opposite to what @code{assq}\n"
"etc above use."
msgstr ""

#: api-data.texi:9449
msgid ""
"When the return is @code{#f} it can be either @var{key} not found, or\n"
"an entry which happens to have value @code{#f} in the @code{cdr}.  Use\n"
"@code{assq} etc above if you need to differentiate these cases.\n"
"@end deffn"
msgstr ""

#: api-data.texi:9453
msgid ""
"@node Removing Alist Entries\n"
"@subsubsection Removing Alist Entries"
msgstr ""
"@node Removing Alist Entries\n"
"@subsubsection Удаление записей Alist (Removing Alist Entries)"

#: api-data.texi:9459
msgid ""
"To remove the element from an association list whose key matches a\n"
"specified key, use @code{assq-remove!}, @code{assv-remove!} or\n"
"@code{assoc-remove!} (depending, as usual, on the level of equality\n"
"required between the key that you specify and the keys in the\n"
"association list)."
msgstr ""
"Чтобы удалить элемент из списка ассоциаций, ключ которого соответствует\n"
"указанному ключу, ипсользуйте @code{assq-remove!}, @code{assv-remove!} или\n"
"@code{assoc-remove!} (в зависимости, как обычно, от уровня требуемого\n"
"равенства между указанным ключем и ключами из списка ассоциаций)."

#: api-data.texi:9464
msgid ""
"As with @code{assq-set!} and friends, the specified alist may or may not\n"
"be modified destructively, and the only safe way to update a variable\n"
"containing the alist is to @code{set!} it to the value that\n"
"@code{assq-remove!} and friends return."
msgstr ""
"Как и с @code{assq-set!} и друзьями, указываемый alist может или не может\n"
"быть разрушающе изменен, и единственный безопасный способ обновить\n"
"переменную, содержащую alist использовать @code{set!} чтобы установить\n"
"значение, которое возрващает @code{assq-remove!} и друзья."

#: api-data.texi:9470
msgid ""
"@example\n"
"address-list\n"
"@result{}\n"
"((\"bob\" . \"11 Newington Avenue\") (\"mary\" . \"34 Elm Road\")\n"
" (\"james\" . \"1a London Road\"))"
msgstr ""

#: api-data.texi:9476
msgid ""
"(set! address-list (assoc-remove! address-list \"mary\"))\n"
"address-list\n"
"@result{}\n"
"((\"bob\" . \"11 Newington Avenue\") (\"james\" . \"1a London Road\"))\n"
"@end example"
msgstr ""

#: api-data.texi:9486
msgid ""
"Note that, when @code{assq/v/oc-remove!} is used to modify an\n"
"association list that has been constructed only using the corresponding\n"
"@code{assq/v/oc-set!}, there can be at most one matching entry in the\n"
"alist, so the question of multiple entries being removed in one go does\n"
"not arise.  If @code{assq/v/oc-remove!} is applied to an association\n"
"list that has been constructed using @code{acons}, or an\n"
"@code{assq/v/oc-set!} with a different level of equality, or any mixture\n"
"of these, it removes only the first matching entry from the alist, even\n"
"if the alist might contain further matching entries.  For example:"
msgstr ""

#: api-data.texi:9494
msgid ""
"@example\n"
"(define address-list '())\n"
"(set! address-list (assq-set! address-list \"mary\" \"11 Elm Street\"))\n"
"(set! address-list (assq-set! address-list \"mary\" \"57 Pine Drive\"))\n"
"address-list\n"
"@result{}\n"
"((\"mary\" . \"57 Pine Drive\") (\"mary\" . \"11 Elm Street\"))"
msgstr ""

#: api-data.texi:9500
msgid ""
"(set! address-list (assoc-remove! address-list \"mary\"))\n"
"address-list\n"
"@result{}\n"
"((\"mary\" . \"11 Elm Street\"))\n"
"@end example"
msgstr ""

#: api-data.texi:9508
msgid ""
"In this example, the two instances of the string \"mary\" are not the same\n"
"when compared using @code{eq?}, so the two @code{assq-set!} calls add\n"
"two distinct entries to @code{address-list}.  When compared using\n"
"@code{equal?}, both \"mary\"s in @code{address-list} are the same as the\n"
"\"mary\" in the @code{assoc-remove!} call, but @code{assoc-remove!} stops\n"
"after removing the first matching entry that it finds, and so one of the\n"
"\"mary\" entries is left in place."
msgstr ""

#: api-data.texi:9518
msgid ""
"@deffn {Scheme Procedure} assq-remove! alist key\n"
"@deffnx {Scheme Procedure} assv-remove! alist key\n"
"@deffnx {Scheme Procedure} assoc-remove! alist key\n"
"@deffnx {C Function} scm_assq_remove_x (alist, key)\n"
"@deffnx {C Function} scm_assv_remove_x (alist, key)\n"
"@deffnx {C Function} scm_assoc_remove_x (alist, key)\n"
"Delete the first entry in @var{alist} associated with @var{key}, and return\n"
"the resulting alist.\n"
"@end deffn"
msgstr ""

#: api-data.texi:9521
msgid ""
"@node Sloppy Alist Functions\n"
"@subsubsection Sloppy Alist Functions"
msgstr ""
"@node Sloppy Alist Functions\n"
"@subsubsection Пренебрегающие ошибками функции Alist"

#: api-data.texi:9526
msgid ""
"@code{sloppy-assq}, @code{sloppy-assv} and @code{sloppy-assoc} behave\n"
"like the corresponding non-@code{sloppy-} procedures, except that they\n"
"return @code{#f} when the specified association list is not well-formed,\n"
"where the non-@code{sloppy-} versions would signal an error."
msgstr ""
"@code{sloppy-assq}, @code{sloppy-assv} и @code{sloppy-assoc} ведут себя\n"
"также как соответствующие не пренебрежительные@code{sloppy-} функцкии, \n"
"за исключением того, что они возвращают @code{#f}, если указанный им \n"
"список ассоциаций не является корректным, где не-@code{sloppy-} версии \n"
"функций выбрасывают сигнал ошибки."

#: api-data.texi:9531
msgid ""
"Specifically, there are two conditions for which the non-@code{sloppy-}\n"
"procedures signal an error, which the @code{sloppy-} procedures handle\n"
"instead by returning @code{#f}.  Firstly, if the specified alist as a\n"
"whole is not a proper list:"
msgstr ""
"В частности, существуют два условия, при которых не "
"пренебрегабщие@code{sloppy-}\n"
"функции сигнализируют об ошибке, которую пренебрежительные @code{sloppy-} \n"
"процедуры обрабатывают возвращая @code{#f}.  Во-первых, если указанный "
"alist\n"
"в целом не является правильным списком:"

#: api-data.texi:9538
msgid ""
"@example\n"
"(assoc \"mary\" '((1 . 2) (\"key\" . \"door\") . \"open sesame\"))\n"
"@result{}\n"
"ERROR: In procedure assoc in expression (assoc \"mary\" (quote #)):\n"
"ERROR: Wrong type argument in position 2 (expecting\n"
"   association list): ((1 . 2) (\"key\" . \"door\") . \"open sesame\")"
msgstr ""

#: api-data.texi:9543
msgid ""
"(sloppy-assoc \"mary\" '((1 . 2) (\"key\" . \"door\") . \"open sesame\"))\n"
"@result{}\n"
"#f\n"
"@end example"
msgstr ""

#: api-data.texi:9546
msgid ""
"@noindent\n"
"Secondly, if one of the entries in the specified alist is not a pair:"
msgstr ""
"@noindent\n"
"Во-вторых, если одна из записей в указанном alist не является парой:"

#: api-data.texi:9553
msgid ""
"@example\n"
"(assoc 2 '((1 . 1) 2 (3 . 9)))\n"
"@result{}\n"
"ERROR: In procedure assoc in expression (assoc 2 (quote #)):\n"
"ERROR: Wrong type argument in position 2 (expecting\n"
"   association list): ((1 . 1) 2 (3 . 9))"
msgstr ""

#: api-data.texi:9558
msgid ""
"(sloppy-assoc 2 '((1 . 1) 2 (3 . 9)))\n"
"@result{}\n"
"#f\n"
"@end example"
msgstr ""

#: api-data.texi:9563
msgid ""
"Unless you are explicitly working with badly formed association lists,\n"
"it is much safer to use the non-@code{sloppy-} procedures, because they\n"
"help to highlight coding and data errors that the @code{sloppy-}\n"
"versions would silently cover up."
msgstr ""

#: api-data.texi:9569
msgid ""
"@deffn {Scheme Procedure} sloppy-assq key alist\n"
"@deffnx {C Function} scm_sloppy_assq (key, alist)\n"
"Behaves like @code{assq} but does not do any error checking.\n"
"Recommended only for use in Guile internals.\n"
"@end deffn"
msgstr ""

#: api-data.texi:9575
msgid ""
"@deffn {Scheme Procedure} sloppy-assv key alist\n"
"@deffnx {C Function} scm_sloppy_assv (key, alist)\n"
"Behaves like @code{assv} but does not do any error checking.\n"
"Recommended only for use in Guile internals.\n"
"@end deffn"
msgstr ""

#: api-data.texi:9581
msgid ""
"@deffn {Scheme Procedure} sloppy-assoc key alist\n"
"@deffnx {C Function} scm_sloppy_assoc (key, alist)\n"
"Behaves like @code{assoc} but does not do any error checking.\n"
"Recommended only for use in Guile internals.\n"
"@end deffn"
msgstr ""

#: api-data.texi:9584
msgid ""
"@node Alist Example\n"
"@subsubsection Alist Example"
msgstr ""
"@node Alist Example\n"
"@subsubsection Пример Alist"

#: api-data.texi:9586
msgid "Here is a longer example of how alists may be used in practice."
msgstr ""
"Вот более длинный пример того, как списки ассоциаций могут \n"
"использоваться на практике."

#: api-data.texi:9591
msgid ""
"@lisp\n"
"(define capitals '((\"New York\" . \"Albany\")\n"
"                   (\"Oregon\"   . \"Salem\")\n"
"                   (\"Florida\"  . \"Miami\")))"
msgstr ""

#: api-data.texi:9595
msgid ""
";; What's the capital of Oregon?\n"
"(assoc \"Oregon\" capitals)       @result{} (\"Oregon\" . \"Salem\")\n"
"(assoc-ref capitals \"Oregon\")   @result{} \"Salem\""
msgstr ""

#: api-data.texi:9604
msgid ""
";; We left out South Dakota.\n"
"(set! capitals\n"
"      (assoc-set! capitals \"South Dakota\" \"Pierre\"))\n"
"capitals\n"
"@result{} ((\"South Dakota\" . \"Pierre\")\n"
"    (\"New York\" . \"Albany\")\n"
"    (\"Oregon\" . \"Salem\")\n"
"    (\"Florida\" . \"Miami\"))"
msgstr ""

#: api-data.texi:9613
msgid ""
";; And we got Florida wrong.\n"
"(set! capitals\n"
"      (assoc-set! capitals \"Florida\" \"Tallahassee\"))\n"
"capitals\n"
"@result{} ((\"South Dakota\" . \"Pierre\")\n"
"    (\"New York\" . \"Albany\")\n"
"    (\"Oregon\" . \"Salem\")\n"
"    (\"Florida\" . \"Tallahassee\"))"
msgstr ""

#: api-data.texi:9622
msgid ""
";; After Oregon secedes, we can remove it.\n"
"(set! capitals\n"
"      (assoc-remove! capitals \"Oregon\"))\n"
"capitals\n"
"@result{} ((\"South Dakota\" . \"Pierre\")\n"
"    (\"New York\" . \"Albany\")\n"
"    (\"Florida\" . \"Tallahassee\"))\n"
"@end lisp"
msgstr ""

#: api-data.texi:9625
msgid ""
"@node VHashes\n"
"@subsection VList-Based Hash Lists or ``VHashes''"
msgstr ""
"@node VHashes\n"
"@subsection Базирующийся на VList Хеш-Список или ``VHashes''"

#: api-data.texi:9628
msgid ""
"@cindex VList-based hash lists\n"
"@cindex VHash"
msgstr ""

#: api-data.texi:9634
msgid ""
"The @code{(ice-9 vlist)} module provides an implementation of @dfn{VList-"
"based\n"
"hash lists} (@pxref{VLists}).  VList-based hash lists, or @dfn{vhashes}, are "
"an\n"
"immutable dictionary type similar to association lists that maps @dfn{keys} "
"to\n"
"@dfn{values}.  However, unlike association lists, accessing a value given "
"its\n"
"key is typically a constant-time operation."
msgstr ""
"Модуль @code{(ice-9 vlist)} предоставляет реализацию хеш списка на основе\n"
"@dfn{VList} (@pxref{VLists}).  Базирующийся на VList  хеш список, или "
"@dfn{vhashes},\n"
"является типом неизменяемого словаря, аналогичный списку ассоциаций, "
"который\n"
"сопоставляет ключу@dfn{keys} - значение@dfn{values}.  Однако, в отличие от\n"
"списка ассоцаций, доступ к значению с учетом его ключа, как правило, "
"является\n"
"операцией с постоянным временем выполнения."

#: api-data.texi:9638
msgid ""
"The VHash programming interface of @code{(ice-9 vlist)} is mostly the same "
"as\n"
"that of association lists found in SRFI-1, with procedure names prefixed by\n"
"@code{vhash-} instead of @code{alist-} (@pxref{SRFI-1 Association Lists})."
msgstr ""
"Программный интерфейс VHash @code{(ice-9 vlist)} в основном такой же, как "
"у \n"
"списка ассоциаций, из SRFI-1, с именами процедур предваряемыми "
"@code{vhash-}\n"
"вместо @code{alist-} (@pxref{SRFI-1 Association Lists})."

#: api-data.texi:9640
msgid "In addition, vhashes can be manipulated using VList operations:"
msgstr ""
"Кроме того, vhashes можно манипулировать с помощью операций\n"
"VList:"

#: api-data.texi:9644
msgid ""
"@example\n"
"(vlist-head (vhash-consq 'a 1 vlist-null))\n"
"@result{} (a . 1)"
msgstr ""

#: api-data.texi:9647
msgid ""
"(define vh1 (vhash-consq 'b 2 (vhash-consq 'a 1 vlist-null)))\n"
"(define vh2 (vhash-consq 'c 3 (vlist-tail vh1)))"
msgstr ""

#: api-data.texi:9657
msgid ""
"(vhash-assq 'a vh2)\n"
"@result{} (a . 1)\n"
"(vhash-assq 'b vh2)\n"
"@result{} #f\n"
"(vhash-assq 'c vh2)\n"
"@result{} (c . 3)\n"
"(vlist->list vh2)\n"
"@result{} ((c . 3) (a . 1))\n"
"@end example"
msgstr ""

#: api-data.texi:9660
msgid ""
"However, keep in mind that procedures that construct new VLists\n"
"(@code{vlist-map}, @code{vlist-filter}, etc.) return raw VLists, not vhashes:"
msgstr ""

#: api-data.texi:9665
msgid ""
"@example\n"
"(define vh (alist->vhash '((a . 1) (b . 2) (c . 3)) hashq))\n"
"(vhash-assq 'a vh)\n"
"@result{} (a . 1)"
msgstr ""

#: api-data.texi:9671
msgid ""
"(define vl\n"
"  ;; This will create a raw vlist.\n"
"  (vlist-filter (lambda (key+value) (odd? (cdr key+value))) vh))\n"
"(vhash-assq 'a vl)\n"
"@result{} ERROR: Wrong type argument in position 2"
msgstr ""

#: api-data.texi:9675
msgid ""
"(vlist->list vl)\n"
"@result{} ((a . 1) (c . 3))\n"
"@end example"
msgstr ""

#: api-data.texi:9679
msgid ""
"@deffn {Scheme Procedure} vhash? obj\n"
"Return true if @var{obj} is a vhash.\n"
"@end deffn"
msgstr ""

#: api-data.texi:9690
msgid ""
"@deffn {Scheme Procedure} vhash-cons key value vhash [hash-proc]\n"
"@deffnx {Scheme Procedure} vhash-consq key value vhash\n"
"@deffnx {Scheme Procedure} vhash-consv key value vhash\n"
"Return a new hash list based on @var{vhash} where @var{key} is associated "
"with\n"
"@var{value}, using @var{hash-proc} to compute the hash of @var{key}.\n"
"@var{vhash} must be either @code{vlist-null} or a vhash returned by a "
"previous\n"
"call to @code{vhash-cons}.  @var{hash-proc} defaults to @code{hash} "
"(@pxref{Hash\n"
"Table Reference, @code{hash} procedure}).  With @code{vhash-consq}, the\n"
"@code{hashq} hash function is used; with @code{vhash-consv} the "
"@code{hashv}\n"
"hash function is used."
msgstr ""

#: api-data.texi:9694
msgid ""
"All @code{vhash-cons} calls made to construct a vhash should use the same\n"
"@var{hash-proc}.  Failing to do that, the result is undefined.\n"
"@end deffn"
msgstr ""

#: api-data.texi:9704
msgid ""
"@deffn {Scheme Procedure} vhash-assoc key vhash [equal? [hash-proc]]\n"
"@deffnx {Scheme Procedure} vhash-assq key vhash\n"
"@deffnx {Scheme Procedure} vhash-assv key vhash\n"
"Return the first key/value pair from @var{vhash} whose key is equal to "
"@var{key}\n"
"according to the @var{equal?} equality predicate (which defaults to\n"
"@code{equal?}), and using @var{hash-proc} (which defaults to @code{hash}) "
"to\n"
"compute the hash of @var{key}.  The second form uses @code{eq?} as the "
"equality\n"
"predicate and @code{hashq} as the hash function; the last form uses "
"@code{eqv?}\n"
"and @code{hashv}."
msgstr ""

#: api-data.texi:9709
msgid ""
"Note that it is important to consistently use the same hash function for\n"
"@var{hash-proc} as was passed to @code{vhash-cons}.  Failing to do that, "
"the\n"
"result is unpredictable.\n"
"@end deffn"
msgstr ""

#: api-data.texi:9718
msgid ""
"@deffn {Scheme Procedure} vhash-delete key vhash [equal? [hash-proc]]\n"
"@deffnx {Scheme Procedure} vhash-delq key vhash\n"
"@deffnx {Scheme Procedure} vhash-delv key vhash\n"
"Remove all associations from @var{vhash} with @var{key}, comparing keys "
"with\n"
"@var{equal?} (which defaults to @code{equal?}), and computing the hash of\n"
"@var{key} using @var{hash-proc} (which defaults to @code{hash}).  The "
"second\n"
"form uses @code{eq?} as the equality predicate and @code{hashq} as the hash\n"
"function; the last one uses @code{eqv?} and @code{hashv}."
msgstr ""

#: api-data.texi:9722
msgid ""
"Again the choice of @var{hash-proc} must be consistent with previous calls "
"to\n"
"@code{vhash-cons}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:9731
msgid ""
"@deffn {Scheme Procedure} vhash-fold proc init vhash\n"
"@deffnx {Scheme Procedure} vhash-fold-right proc init vhash\n"
"Fold over the key/value elements of @var{vhash} in the given direction,\n"
"with each call to @var{proc} having the form @code{(@var{proc} key value\n"
"result)}, where @var{result} is the result of the previous call to\n"
"@var{proc} and @var{init} the value of @var{result} for the first call\n"
"to @var{proc}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:9739
msgid ""
"@deffn {Scheme Procedure} vhash-fold* proc init key vhash [equal? [hash]]\n"
"@deffnx {Scheme Procedure} vhash-foldq* proc init key vhash\n"
"@deffnx {Scheme Procedure} vhash-foldv* proc init key vhash\n"
"Fold over all the values associated with @var{key} in @var{vhash}, with "
"each\n"
"call to @var{proc} having the form @code{(proc value result)}, where\n"
"@var{result} is the result of the previous call to @var{proc} and @var{init} "
"the\n"
"value of @var{result} for the first call to @var{proc}."
msgstr ""

#: api-data.texi:9743
msgid ""
"Keys in @var{vhash} are hashed using @var{hash} are compared using "
"@var{equal?}.\n"
"The second form uses @code{eq?} as the equality predicate and @code{hashq} "
"as\n"
"the hash function; the third one uses @code{eqv?} and @code{hashv}."
msgstr ""

#: api-data.texi:9745
msgid "Example:"
msgstr ""

#: api-data.texi:9749
msgid ""
"@example\n"
"(define vh\n"
"  (alist->vhash '((a . 1) (a . 2) (z . 0) (a . 3))))"
msgstr ""

#: api-data.texi:9752
msgid ""
"(vhash-fold* cons '() 'a vh)\n"
"@result{} (3 2 1)"
msgstr ""

#: api-data.texi:9757
msgid ""
"(vhash-fold* cons '() 'z vh)\n"
"@result{} (0)\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:9763
msgid ""
"@deffn {Scheme Procedure} alist->vhash alist [hash-proc]\n"
"Return the vhash corresponding to @var{alist}, an association list, using\n"
"@var{hash-proc} to compute key hashes.  When omitted, @var{hash-proc} "
"defaults\n"
"to @code{hash}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:9768
msgid ""
"@node Hash Tables\n"
"@subsection Hash Tables\n"
"@tpindex Hash Tables"
msgstr ""
"@node Hash Tables\n"
"@subsection Хеш Таблица(Hash Tables)\n"
"@tpindex Hash Tables"

#: api-data.texi:9776
msgid ""
"Hash tables are dictionaries which offer similar functionality as\n"
"association lists: They provide a mapping from keys to values.  The\n"
"difference is that association lists need time linear in the size of\n"
"elements when searching for entries, whereas hash tables can normally\n"
"search in constant time.  The drawback is that hash tables require a\n"
"little bit more memory, and that you can not use the normal list\n"
"procedures (@pxref{Lists}) for working with them."
msgstr ""
"Хеш-таблицы это словари, которые пердлагают функциональность аналогичную\n"
"спискам ассоциций: предоставлять сопоставление от ключей к значениям. \n"
"Разница в том, что спики ассоциаций требует время линейно зависящее от\n"
"количества элементов в списке, тогда как хеш-таблицы обычно могут\n"
"искать за постоянное время. Недостатком является то, что хеш-таблицы\n"
"требуеют немного больше памяти, и что вы не можете испльзовать\n"
"обычные процедуры работы со списками (@pxref{Lists}) для работы \n"
"с ними."

#: api-data.texi:9781
msgid ""
"@menu\n"
"* Hash Table Examples::         Demonstration of hash table usage.\n"
"* Hash Table Reference::        Hash table procedure descriptions.\n"
"@end menu"
msgstr ""

#: api-data.texi:9785
msgid ""
"@node Hash Table Examples\n"
"@subsubsection Hash Table Examples"
msgstr ""
"@node Hash Table Examples\n"
"@subsubsection Пример Хеш-Таблицы"

#: api-data.texi:9788
msgid ""
"For demonstration purposes, this section gives a few usage examples of\n"
"some hash table procedures, together with some explanation what they do."
msgstr ""
"Для демонстрационных целей в этом разделе приведены несколько примеров\n"
"использования некоторых процедур работы с хеш-таблицами, а также некоторое\n"
"объяснение того, что они делают."

#: api-data.texi:9791
msgid ""
"First we start by creating a new hash table with 31 slots, and\n"
"populate it with two key/value pairs."
msgstr ""
"Сначала мы начинаем с создания новой хеш-таблицы с 31-им слотом, \n"
"и заполняем ее двумя парами  ключ/значение."

#: api-data.texi:9794
msgid ""
"@lisp\n"
"(define h (make-hash-table 31))"
msgstr ""

#: api-data.texi:9799
msgid ""
";; This is an opaque object\n"
"h\n"
"@result{}\n"
"#<hash-table 0/31>"
msgstr ""

#: api-data.texi:9804
msgid ""
";; Inserting into a hash table can be done with hashq-set!\n"
"(hashq-set! h 'foo \"bar\")\n"
"@result{}\n"
"\"bar\""
msgstr ""

#: api-data.texi:9808
msgid ""
"(hashq-set! h 'braz \"zonk\")\n"
"@result{}\n"
"\"zonk\""
msgstr ""

#: api-data.texi:9814
msgid ""
";; Or with hash-create-handle!\n"
"(hashq-create-handle! h 'frob #f)\n"
"@result{}\n"
"(frob . #f)\n"
"@end lisp"
msgstr ""

#: api-data.texi:9822
msgid ""
"You can get the value for a given key with the procedure\n"
"@code{hashq-ref}, but the problem with this procedure is that you\n"
"cannot reliably determine whether a key does exists in the table.  The\n"
"reason is that the procedure returns @code{#f} if the key is not in\n"
"the table, but it will return the same value if the key is in the\n"
"table and just happens to have the value @code{#f}, as you can see in\n"
"the following examples."
msgstr ""
"Вы можете получить значение для данного ключа с помощью процедуры\n"
"@code{hashq-ref}, но проблема с этой процедурой заключается в том,\n"
"что вы не можете надежно определить, существует ли ключ в таблице.\n"
"Причина в том, что процедура возвращает @code{#f} если ключа нет\n"
"в таблице, но она будет возвращать тоже значение, если ключ находиться\n"
"в таблице, а значение просто  равно @code{#f}, что вы можете увидеть\n"
"в следующих примерах."

#: api-data.texi:9827
msgid ""
"@lisp\n"
"(hashq-ref h 'foo)\n"
"@result{}\n"
"\"bar\""
msgstr ""

#: api-data.texi:9831
msgid ""
"(hashq-ref h 'frob)\n"
"@result{}\n"
"#f"
msgstr ""

#: api-data.texi:9836
msgid ""
"(hashq-ref h 'not-there)\n"
"@result{}\n"
"#f\n"
"@end lisp"
msgstr ""

#: api-data.texi:9841
msgid ""
"It is often better is to use the procedure @code{hashq-get-handle},\n"
"which makes a distinction between the two cases.  Just like @code{assq},\n"
"this procedure returns a key/value-pair on success, and @code{#f} if the\n"
"key is not found."
msgstr ""
"Зачастую лучше использовать процедуру @code{hashq-get-handle}, которая\n"
"делает различие между двумя случаями. Как и  @code{assq}, эта процедура\n"
"возвращает пару ключ/значение(key/value) при успешном завершении, и "
"@code{#f}\n"
"если ключ не найден."

#: api-data.texi:9846
msgid ""
"@lisp\n"
"(hashq-get-handle h 'foo)\n"
"@result{}\n"
"(foo . \"bar\")"
msgstr ""

#: api-data.texi:9851
msgid ""
"(hashq-get-handle h 'not-there)\n"
"@result{}\n"
"#f\n"
"@end lisp"
msgstr ""

#: api-data.texi:9855
msgid ""
"Interesting results can be computed by using @code{hash-fold} to work\n"
"through each element.  This example will count the total number of\n"
"elements:"
msgstr ""
"Интересные результаты могут быть вычислены с помощью @code{hash-fold}\n"
"работающей с каждым элементом хеш-таблицы. В этом примере будет подсчитано\n"
"общее количество элементов."

#: api-data.texi:9861
msgid ""
"@lisp\n"
"(hash-fold (lambda (key value seed) (+ 1 seed)) 0 h)\n"
"@result{}\n"
"3\n"
"@end lisp"
msgstr ""

#: api-data.texi:9865
msgid ""
"The same thing can be done with the procedure @code{hash-count}, which\n"
"can also count the number of elements matching a particular predicate.\n"
"For example, count the number of elements with string values:"
msgstr ""
"То же самое можно сделать с помощью процедуры @code{hash-count}, которая\n"
"также может подсчитать количество элементов, соответствующих определенному\n"
"предикату. Например, подсчитаем количество элементов со строковыми "
"значениями:"

#: api-data.texi:9871
msgid ""
"@lisp\n"
"(hash-count (lambda (key value) (string? value)) h)\n"
"@result{}\n"
"2\n"
"@end lisp"
msgstr ""

#: api-data.texi:9873
msgid "Counting all the elements is a simple task using @code{const}:"
msgstr "Подсчет всех элементов - простая задача, использующая @code{const}:"

#: api-data.texi:9879
msgid ""
"@lisp\n"
"(hash-count (const #t) h)\n"
"@result{}\n"
"3\n"
"@end lisp"
msgstr ""

#: api-data.texi:9882
msgid ""
"@node Hash Table Reference\n"
"@subsubsection Hash Table Reference"
msgstr ""
"@node Hash Table Reference\n"
"@subsubsection Справочник по Хеш-Таблицам"

#: api-data.texi:9885
msgid ""
"@c  FIXME: Describe in broad terms what happens for resizing, and what\n"
"@c  the initial size means for this."
msgstr ""

#: api-data.texi:9891
msgid ""
"Like the association list functions, the hash table functions come in\n"
"several varieties, according to the equality test used for the keys.\n"
"Plain @code{hash-} functions use @code{equal?}, @code{hashq-}\n"
"functions use @code{eq?}, @code{hashv-} functions use @code{eqv?}, and\n"
"the @code{hashx-} functions use an application supplied test."
msgstr ""
"Подобно функциям списка ассоциаций, функции хеш-таблицы делятся на \n"
"несколько разновидностей, согласно теста равенства, испльзуемого\n"
"для сравнения ключей. Обычные хеш-@code{hash-} функции используют "
"@code{equal?}, \n"
"функции с префиксом @code{hashq-} используют @code{eq?}, с префиксом "
"@code{hashv-}\n"
"испльзуют @code{eqv?}, и функции @code{hashx-} испльзуют приложение\n"
"предоставляющее для тест."

#: api-data.texi:9895
msgid ""
"A single @code{make-hash-table} creates a hash table suitable for use\n"
"with any set of functions, but it's imperative that just one set is\n"
"then used consistently, or results will be unpredictable."
msgstr ""
"Простой вызов @code{make-hash-table} создает хеш-таблицу, подходящую\n"
"для использования с любым набором функций, но очень важно, чтобы только\n"
"один набор использовался с данной таблице, или результаты будут\n"
"непредсказуемыми."

#: api-data.texi:9900
msgid ""
"Hash tables are implemented as a vector indexed by a hash value formed\n"
"from the key, with an association list of key/value pairs for each\n"
"bucket in case distinct keys hash together.  Direct access to the\n"
"pairs in those lists is provided by the @code{-handle-} functions."
msgstr ""
"Хеш-таблицы реализуются как вектор, индексированный хеш-значением,\n"
"сформированным из ключа, с ассоциативным списком пар ключ/значение\n"
"для каждой ячейки в случае конфликта значений хеша ключа. Прямой\n"
"доступ к парам в этих спиках обеспечивается с помощью @code{-handle-}\n"
"функций."

#: api-data.texi:9906
msgid ""
"When the number of entries in a hash table goes above a threshold, the\n"
"vector is made larger and the entries are rehashed, to prevent the\n"
"bucket lists from becoming too long and slowing down accesses.  When the\n"
"number of entries goes below a threshold, the vector is shrunk to save\n"
"space."
msgstr ""
"Когда количество записей в хэш-таблице превышает пороговое значение, вектор\n"
"увеличивается, и записи перезаписываются, чтобы списки ячеек не становились\n"
"слишком длинными и замедлся доступ. Когда количество записей становиться\n"
"ниже порогового значения, вектор сокращается, чтобы сэкономить место."

#: api-data.texi:9912
msgid ""
"For the @code{hashx-} ``extended'' routines, an application supplies a\n"
"@var{hash} function producing an integer index like @code{hashq} etc\n"
"below, and an @var{assoc} alist search function like @code{assq} etc\n"
"(@pxref{Retrieving Alist Entries}).  Here's an example of such\n"
"functions implementing case-insensitive hashing of string keys,"
msgstr ""
"Для расширенных функций @code{hashx-}, приложение предоставляет\n"
"хеш-@var{hash} функцию, вычисляющую целочисленный индекс, например\n"
"@code{hashq} и т.д., а также функцию поиска по ключу подобную \n"
"@var{assoc} для alist или как @code{assq} и т.д.\n"
"(@pxref{Retrieving Alist Entries}).  Вот пример таких функций\n"
"внедрения нечувствительных к регистру хэширования строковых ключей."

#: api-data.texi:9916
msgid ""
"@example\n"
"(use-modules (srfi srfi-1)\n"
"             (srfi srfi-13))"
msgstr ""

#: api-data.texi:9921
msgid ""
"(define (my-hash str size)\n"
"  (remainder (string-hash-ci str) size))\n"
"(define (my-assoc str alist)\n"
"  (find (lambda (pair) (string-ci=? str (car pair))) alist))"
msgstr ""

#: api-data.texi:9924
msgid ""
"(define my-table (make-hash-table))\n"
"(hashx-set! my-hash my-assoc my-table \"foo\" 123)"
msgstr ""

#: api-data.texi:9928
msgid ""
"(hashx-ref my-hash my-assoc my-table \"FOO\")\n"
"@result{} 123\n"
"@end example"
msgstr ""

#: api-data.texi:9937
msgid ""
"In a @code{hashx-} @var{hash} function the aim is to spread keys\n"
"across the vector, so bucket lists don't become long.  But the actual\n"
"values are arbitrary as long as they're in the range 0 to\n"
"@math{@var{size}-1}.  Helpful functions for forming a hash value, in\n"
"addition to @code{hashq} etc below, include @code{symbol-hash}\n"
"(@pxref{Symbol Keys}), @code{string-hash} and @code{string-hash-ci}\n"
"(@pxref{String Comparison}), and @code{char-set-hash}\n"
"(@pxref{Character Set Predicates/Comparison})."
msgstr ""
"В @code{hashx-} цель функции @var{hash} состоит в том, чтобы рапределять\n"
"ключи по вектору, поэтому списки ячеек вектора не становятся длинными.\n"
"Но фактические значения произвольны, если они находятся в диапазоне от 0 \n"
"до @math{@var{size}-1}.  Полезные функции для формирования хеш-значения,\n"
"в дополнение к @code{hashq} и т.д, включают @code{symbol-hash}\n"
"(@pxref{Symbol Keys}), @code{string-hash} и @code{string-hash-ci}\n"
"(@pxref{String Comparison}), и @code{char-set-hash}\n"
"(@pxref{Character Set Predicates/Comparison})."

#: api-data.texi:9942
msgid ""
"@sp 1\n"
"@deffn {Scheme Procedure} make-hash-table [size]\n"
"Create a new hash table object, with an optional minimum\n"
"vector @var{size}."
msgstr ""

#: api-data.texi:9949
msgid ""
"When @var{size} is given, the table vector will still grow and shrink\n"
"automatically, as described above, but with @var{size} as a minimum.\n"
"If an application knows roughly how many entries the table will hold\n"
"then it can use @var{size} to avoid rehashing when initial entries are\n"
"added.\n"
"@end deffn"
msgstr ""
"Когда задан размер @var{size}, вектор таблицы будет расти и автоматически\n"
"сокращаться, как описано выше, но размер будет минимум @var{size}.\n"
"Если приложение, знает как много записей будет удерживать таблица, тогда\n"
"оно может размер, чтобы избежать повторного рехеширования когда будут\n"
"добавляться записи.\n"
"@end deffn"

#: api-data.texi:9956
msgid ""
"@deffn {Scheme Procedure} alist->hash-table alist\n"
"@deffnx {Scheme Procedure} alist->hashq-table alist\n"
"@deffnx {Scheme Procedure} alist->hashv-table alist\n"
"@deffnx {Scheme Procedure} alist->hashx-table hash assoc alist\n"
"Convert @var{alist} into a hash table. When keys are repeated in\n"
"@var{alist}, the leftmost association takes precedence."
msgstr ""

#: api-data.texi:9961
msgid ""
"@example\n"
"(use-modules (ice-9 hash-table))\n"
"(alist->hash-table '((foo . 1) (bar . 2)))\n"
"@end example"
msgstr ""

#: api-data.texi:9964
msgid ""
"When converting to an extended hash table, custom @var{hash} and\n"
"@var{assoc} procedures must be provided."
msgstr ""

#: api-data.texi:9968
msgid ""
"@example\n"
"(alist->hashx-table hash assoc '((foo . 1) (bar . 2)))\n"
"@end example"
msgstr ""

#: api-data.texi:9970
msgctxt "api-data.texi:9970"
msgid "@end deffn"
msgstr ""

#: api-data.texi:9975
msgid ""
"@deffn {Scheme Procedure} hash-table? obj\n"
"@deffnx {C Function} scm_hash_table_p (obj)\n"
"Return @code{#t} if @var{obj} is a abstract hash table object.\n"
"@end deffn"
msgstr ""

#: api-data.texi:9980
msgid ""
"@deffn {Scheme Procedure} hash-clear! table\n"
"@deffnx {C Function} scm_hash_clear_x (table)\n"
"Remove all items from @var{table} (without triggering a resize).\n"
"@end deffn"
msgstr ""

#: api-data.texi:9993
msgid ""
"@deffn {Scheme Procedure} hash-ref table key [dflt]\n"
"@deffnx {Scheme Procedure} hashq-ref table key [dflt]\n"
"@deffnx {Scheme Procedure} hashv-ref table key [dflt]\n"
"@deffnx {Scheme Procedure} hashx-ref hash assoc table key [dflt]\n"
"@deffnx {C Function} scm_hash_ref (table, key, dflt)\n"
"@deffnx {C Function} scm_hashq_ref (table, key, dflt)\n"
"@deffnx {C Function} scm_hashv_ref (table, key, dflt)\n"
"@deffnx {C Function} scm_hashx_ref (hash, assoc, table, key, dflt)\n"
"Lookup @var{key} in the given hash @var{table}, and return the\n"
"associated value.  If @var{key} is not found, return @var{dflt}, or\n"
"@code{#f} if @var{dflt} is not given.\n"
"@end deffn"
msgstr ""

#: api-data.texi:10006
msgid ""
"@deffn {Scheme Procedure} hash-set! table key val\n"
"@deffnx {Scheme Procedure} hashq-set! table key val\n"
"@deffnx {Scheme Procedure} hashv-set! table key val\n"
"@deffnx {Scheme Procedure} hashx-set! hash assoc table key val\n"
"@deffnx {C Function} scm_hash_set_x (table, key, val)\n"
"@deffnx {C Function} scm_hashq_set_x (table, key, val)\n"
"@deffnx {C Function} scm_hashv_set_x (table, key, val)\n"
"@deffnx {C Function} scm_hashx_set_x (hash, assoc, table, key, val)\n"
"Associate @var{val} with @var{key} in the given hash @var{table}.  If\n"
"@var{key} is already present then it's associated value is changed.\n"
"If it's not present then a new entry is created.\n"
"@end deffn"
msgstr ""

#: api-data.texi:10018
msgid ""
"@deffn {Scheme Procedure} hash-remove! table key\n"
"@deffnx {Scheme Procedure} hashq-remove! table key\n"
"@deffnx {Scheme Procedure} hashv-remove! table key\n"
"@deffnx {Scheme Procedure} hashx-remove! hash assoc table key\n"
"@deffnx {C Function} scm_hash_remove_x (table, key)\n"
"@deffnx {C Function} scm_hashq_remove_x (table, key)\n"
"@deffnx {C Function} scm_hashv_remove_x (table, key)\n"
"@deffnx {C Function} scm_hashx_remove_x (hash, assoc, table, key)\n"
"Remove any association for @var{key} in the given hash @var{table}.\n"
"If @var{key} is not in @var{table} then nothing is done.\n"
"@end deffn"
msgstr ""

#: api-data.texi:10028
msgid ""
"@deffn {Scheme Procedure} hash key size\n"
"@deffnx {Scheme Procedure} hashq key size\n"
"@deffnx {Scheme Procedure} hashv key size\n"
"@deffnx {C Function} scm_hash (key, size)\n"
"@deffnx {C Function} scm_hashq (key, size)\n"
"@deffnx {C Function} scm_hashv (key, size)\n"
"Return a hash value for @var{key}.  This is a number in the range\n"
"@math{0} to @math{@var{size}-1}, which is suitable for use in a hash\n"
"table of the given @var{size}."
msgstr ""

#: api-data.texi:10033
msgid ""
"Note that @code{hashq} and @code{hashv} may use internal addresses of\n"
"objects, so if an object is garbage collected and re-created it can\n"
"have a different hash value, even when the two are notionally\n"
"@code{eq?}.  For instance with symbols,"
msgstr ""

#: api-data.texi:10039
msgid ""
"@example\n"
"(hashq 'something 123)   @result{} 19\n"
"(gc)\n"
"(hashq 'something 123)   @result{} 62\n"
"@end example"
msgstr ""

#: api-data.texi:10045
msgid ""
"In normal use this is not a problem, since an object entered into a\n"
"hash table won't be garbage collected until removed.  It's only if\n"
"hashing calculations are somehow separated from normal references that\n"
"its lifetime needs to be considered.\n"
"@end deffn"
msgstr ""

#: api-data.texi:10058
msgid ""
"@deffn {Scheme Procedure} hash-get-handle table key\n"
"@deffnx {Scheme Procedure} hashq-get-handle table key\n"
"@deffnx {Scheme Procedure} hashv-get-handle table key\n"
"@deffnx {Scheme Procedure} hashx-get-handle hash assoc table key\n"
"@deffnx {C Function} scm_hash_get_handle (table, key)\n"
"@deffnx {C Function} scm_hashq_get_handle (table, key)\n"
"@deffnx {C Function} scm_hashv_get_handle (table, key)\n"
"@deffnx {C Function} scm_hashx_get_handle (hash, assoc, table, key)\n"
"Return the @code{(@var{key} . @var{value})} pair for @var{key} in the\n"
"given hash @var{table}, or @code{#f} if @var{key} is not in\n"
"@var{table}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:10072
msgid ""
"@deffn {Scheme Procedure} hash-create-handle! table key init\n"
"@deffnx {Scheme Procedure} hashq-create-handle! table key init\n"
"@deffnx {Scheme Procedure} hashv-create-handle! table key init\n"
"@deffnx {Scheme Procedure} hashx-create-handle! hash assoc table key init\n"
"@deffnx {C Function} scm_hash_create_handle_x (table, key, init)\n"
"@deffnx {C Function} scm_hashq_create_handle_x (table, key, init)\n"
"@deffnx {C Function} scm_hashv_create_handle_x (table, key, init)\n"
"@deffnx {C Function} scm_hashx_create_handle_x (hash, assoc, table, key, "
"init)\n"
"Return the @code{(@var{key} . @var{value})} pair for @var{key} in the\n"
"given hash @var{table}.  If @var{key} is not in @var{table} then\n"
"create an entry for it with @var{init} as the value, and return that\n"
"pair.\n"
"@end deffn"
msgstr ""

#: api-data.texi:10081
msgid ""
"@deffn {Scheme Procedure} hash-map->list proc table\n"
"@deffnx {Scheme Procedure} hash-for-each proc table\n"
"@deffnx {C Function} scm_hash_map_to_list (proc, table)\n"
"@deffnx {C Function} scm_hash_for_each (proc, table)\n"
"Apply @var{proc} to the entries in the given hash @var{table}.  Each\n"
"call is @code{(@var{proc} @var{key} @var{value})}.  @code{hash-map->list}\n"
"returns a list of the results from these calls, @code{hash-for-each}\n"
"discards the results and returns an unspecified value."
msgstr ""

#: api-data.texi:10086
msgid ""
"Calls are made over the table entries in an unspecified order, and for\n"
"@code{hash-map->list} the order of the values in the returned list is\n"
"unspecified.  Results will be unpredictable if @var{table} is modified\n"
"while iterating."
msgstr ""

#: api-data.texi:10089
msgid ""
"For example the following returns a new alist comprising all the\n"
"entries from @code{mytable}, in no particular order."
msgstr ""

#: api-data.texi:10094
msgid ""
"@example\n"
"(hash-map->list cons mytable)\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:10100
msgid ""
"@deffn {Scheme Procedure} hash-for-each-handle proc table\n"
"@deffnx {C Function} scm_hash_for_each_handle (proc, table)\n"
"Apply @var{proc} to the entries in the given hash @var{table}.  Each\n"
"call is @code{(@var{proc} @var{handle})}, where @var{handle} is a\n"
"@code{(@var{key} . @var{value})} pair. Return an unspecified value."
msgstr ""

#: api-data.texi:10104
msgid ""
"@code{hash-for-each-handle} differs from @code{hash-for-each} only in\n"
"the argument list of @var{proc}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:10113
msgid ""
"@deffn {Scheme Procedure} hash-fold proc init table\n"
"@deffnx {C Function} scm_hash_fold (proc, init, table)\n"
"Accumulate a result by applying @var{proc} to the elements of the\n"
"given hash @var{table}.  Each call is @code{(@var{proc} @var{key}\n"
"@var{value} @var{prior-result})}, where @var{key} and @var{value} are\n"
"from the @var{table} and @var{prior-result} is the return from the\n"
"previous @var{proc} call.  For the first call, @var{prior-result} is\n"
"the given @var{init} value."
msgstr ""

#: api-data.texi:10117
msgid ""
"Calls are made over the table entries in an unspecified order.\n"
"Results will be unpredictable if @var{table} is modified while\n"
"@code{hash-fold} is running."
msgstr ""

#: api-data.texi:10120
msgid ""
"For example, the following returns a count of how many keys in\n"
"@code{mytable} are strings."
msgstr ""

#: api-data.texi:10127
msgid ""
"@example\n"
"(hash-fold (lambda (key value prior)\n"
"             (if (string? key) (1+ prior) prior))\n"
"           0 mytable)\n"
"@end example\n"
"@end deffn"
msgstr ""

#: api-data.texi:10135
msgid ""
"@deffn {Scheme Procedure} hash-count pred table\n"
"@deffnx {C Function} scm_hash_count (pred, table)\n"
"Return the number of elements in the given hash @var{table} that cause\n"
"@code{(@var{pred} @var{key} @var{value})} to return true.  To quickly\n"
"determine the total number of elements, use @code{(const #t)} for\n"
"@var{pred}.\n"
"@end deffn"
msgstr ""

#: api-data.texi:10138
msgid ""
"@node Other Types\n"
"@subsection Other Types"
msgstr ""
"@node Other Types\n"
"@subsection Другие Типы"

#: api-data.texi:10140
msgid "Procedures are documented in their own section.  @xref{Procedures}."
msgstr "Процедуры описаны в их собственном разделе.  @xref{Procedures}."

#: api-data.texi:10143
msgid ""
"Variable objects are documented as part of the description of Guile's\n"
"module system: see @ref{Variables}."
msgstr ""
"Переменные документируются как часть описания модульной системы Guile:\n"
"См. @ref{Variables}."

#: api-data.texi:10145
msgid "@xref{Scheduling}, for discussion of threads, mutexes, and so on."
msgstr "@xref{Scheduling}, для обсуждения потоков, мьютексов и т.д."

#: api-data.texi:10147
msgid "Ports are described in the section on I/O: see @ref{Input and Output}."
msgstr "Порты описаны в разделе I/O: см. @ref{Input and Output}."

#: api-data.texi:10150
msgid ""
"Regular expressions are described in their own section: see @ref{Regular\n"
"Expressions}."
msgstr ""
"Регулярные выражения описаны в их собственном разделе: см. @ref{Regular\n"
"Expressions}."

#: api-data.texi:10153
msgid ""
"There are quite a number of additional data types documented in this\n"
"manual; if you feel a link is missing here, please file a bug."
msgstr ""
"Существует целый ряд дополнительных  типов данных, задокументированных\n"
"в этом руководстве, если вы думаете что здесь отсутствует ссылка, сообщите\n"
"об ошибке."

#: api-data.texi:10156
msgid ""
"@c Local Variables:\n"
"@c TeX-master: \"guile.texi\"\n"
"@c End:"
msgstr ""
