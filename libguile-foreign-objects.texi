@c -*-texinfo-*-
@c This is part of the GNU Guile Reference Manual.
@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005, 2010, 2011, 2013, 2014
@c   Free Software Foundation, Inc.
@c See the file guile.texi for copying conditions.

@node Defining New Foreign Object Types
@section Определение новых типов внешних объектов

Тип внешних объектов(@dfn{foreign object type}) является механизмом Guile
для импорта объектов и типов из Си или других языков в систему Guile.
Если у вас есть Си тип @code{struct foo}, например, вы можете определить
соответствующий тип внешнего объекта Guile, который позволит обрабатывать
коду Scheme объекты указывающие @code{struct foo *}.

Чтобы определить новый тип внешних объектов, программист предоставляет Guile
некоторую существенную информацию о типе --- какое у него имя, сколько у него
полей, и есть ли финализатор (если есть) --- и Guile выделяет для него новый тип
для него. Внешние объекты могут быть доступны из  Scheme или из Си.

@menu
* Defining Foreign Object Types::       
* Creating Foreign Objects::          
* Type Checking of Foreign Objects::                
* Foreign Object Memory Management::    
* Foreign Objects and Scheme::    
@end menu

@node Defining Foreign Object Types
@subsection Определение типов Внешних Объектов

Чтобы создать новый тип внешних объектов из Си, вызовите
@code{scm_make_foreign_object_type}.  Он возвращает значение типа
@code{SCM}, которое идентифицирует новый тип.

Вот как можно объявить новый тип, представляющий восьмибитные черно-белые
изображения:

@example
#include <libguile.h>

struct image @{
  int width, height;
  char *pixels;

  /* The name of this image */
  SCM name;

  /* A function to call when this image is
     modified, e.g., to update the screen,
     or SCM_BOOL_F if no action necessary */
  SCM update_func;
@};

static SCM image_type image_type;

void
init_image_type (void)
@{
  SCM name, slots;
  scm_t_struct_finalize finalizer;

  name = scm_from_utf8_symbol ("image");
  slots = scm_list_1 (scm_from_utf8_symbol ("data"));
  finalizer = NULL;

  image_type =
    scm_make_foreign_object_type (name, slots, finalizer);
@}
@end example

Результатом является инициализированное значение @code{image_type}, которое
идентифицирует новый тип внешних объектов. В следующем разделе описано, как
создавать внешние объекты и как обращаться к их слотам.

@node Creating Foreign Objects
@subsection Создание Внешних Объектов

Внешние объекты содержат ноль и более ``слотов'' данных.  Слот может содержать
указатель, целое число которое вписывается в @code{size_t} или @code{ssize_t},
или значение @code{SCM}.

Все объекты данного типа внешних объектов имеют одинаковое количество
слотов. В примере из предыдущего раздела, тип изображение(@code{image})
имеет один слот, потому что список слотов переданый в @code{scm_make_foreign_object_type}
имеет длину равную одному.  (Фактические имена , присвоенные слотам,
несущественны для большинства пользователей интерфейса Си, но могут быть
испльзованы на стороне  Scheme, чтобы осмотреть внешний объект.)

Чтобы создать внешний объект и инициализировать его первый слот, вызовите
@code{scm_make_foreign_object_1 (@var{type}, @var{first_slot_value})}.
Аналогично вызываютсся конструкторы для инициализции 0, 1, 2, или 3
слотов, или инициализация @var{n} слотов через массив.  @xref{Foreign
Objects}, для получения полной информации. Любые поля, которые явно не 
инициализированы, устанавливаются в 0.

Чтобы получить или установить значение слота по индексу, вы можете 
использовать функции @code{scm_foreign_object_ref} и @code{scm_foreign_object_set_x}.
Эти функции принимают и возвращают значения как указатели @code{void *};
существуют процедуры для  доступа к слотам целых чисел со знаком и без знака,
соответственно, такие как @code{_signed_ref} и @code{_unsigned_set_x}

Поля внешних объектов, которые являются указателями, могут быть сложными
для управления. Если возможно, лучше всего что бы вся память, на которую
ссылается внешний объект, управлялась сборщиком мусора. Такимо образом,
сборщик мусора может автоматически гарантировать доступность памяти, когда
это необходимо, и освобождать память, когда она становиться недоступной.
Если это не так для вашей программы - например, если вы предоставляете
объект Scheme который был выделен какой-либо другой не Guile частью вашей
программы -- тогда вам, вероятно, понадобиться реализовать финализатор.  
@xref{Foreign Object Memory Management}, для получения дополнительной информации.

Продолжая пример из предыдущего раздела, если глобальная переменная
@code{image_type} содержит тип возвращаемый @code{scm_make_foreign_object_type}, 
вот как мы могли бы построить внешний объект, чье поле ``data'' содержит указатель
на только что выделенную структуру @code{struct image}:

@example
SCM
make_image (SCM name, SCM s_width, SCM s_height)
@{
  struct image *image;
  int width = scm_to_int (s_width);
  int height = scm_to_int (s_height);

  /* Allocate the `struct image'.  Because we
     use scm_gc_malloc, this memory block will
     be automatically reclaimed when it becomes
     inaccessible, and its members will be traced
     by the garbage collector.  */
  image = (struct image *)
    scm_gc_malloc (sizeof (struct image), "image");

  image->width = width;
  image->height = height;

  /* Allocating the pixels with
     scm_gc_malloc_pointerless means that the
     pixels data is collectable by GC, but
     that GC shouldn't spend time tracing its
     contents for nested pointers because there
     aren't any.  */
  image->pixels =
    scm_gc_malloc_pointerless (width * height, "image pixels");

  image->name = name;
  image->update_func = SCM_BOOL_F;

  /* Now wrap the struct image* in a new foreign
     object, and return that object.  */
  return scm_make_foreign_object_1 (image_type, image);
@}
@end example

Мы используем @code{scm_gc_malloc_pointerless} для буфера пикселей, чтобы
сообщить сборщику мусора не сканировать его на указатели. Вызов
@code{scm_gc_malloc}, @code{scm_make_foreign_object_1}, и
@code{scm_gc_malloc_pointerless} вызывает исключение в условиях отсутствия
памяти; сборщик мусора может вернуть ране выделенную память, если это
призойдет.

@node Type Checking of Foreign Objects
@subsection Проверка Типа Внешнего Объекта

Функции, работающие с внешними объектами, должны проверять, что принятое
@code{SCM} значение действительно правильного типа перед доступом к его
данным. Они могут сделать это с помощью @code{scm_assert_foreign_object_type}.

Например, вот простая функция, которая работает с объектом изображения и
проверяет тип своего аргумента.

@example
SCM
clear_image (SCM image_obj)
@{
  int area;
  struct image *image;

  scm_assert_foreign_object_type (image_type, image_obj);

  image = scm_foreign_object_ref (image_obj, 0);
  area = image->width * image->height;
  memset (image->pixels, 0, area);

  /* Invoke the image's update function.  */
  if (scm_is_true (image->update_func))
    scm_call_0 (image->update_func);

  return SCM_UNSPECIFIED;
@}
@end example

@node Foreign Object Memory Management
@subsection Управление памятью Внешних Объектов

После того как внешний объект был освобожден для системы Scheme, он
должен быть готов к сборке мусора.  В приведенном выше примере, вся память
связанная с внешним объектом, управляется сборщиком мусора, поскольку
мы использовали функции распределения памяти @code{scm_gc_}. 
Таким образом, особого внимания не требуется: сборщик мусора автоматически
сканирует ее и восстанавливает неиспользуемую память.

Однако, когда данные связанные с внешним объектом, управляются каким-либо другим способом -
например, память выделяемая @code{malloc} или файловые дискрипторы--- для них можно указать
функцию @dfn{finalizer} для освобождения этих ресурсов, когда внешний объект будет утилизироваться.

Как описано в разделе @pxref{Garbage Collection}, сборщик мусора Guile
при необходимости восстановит недоступную память. Этот процесс утилизации
выполняется одновременно с основной программой. Когда Guile анализирует
кучу и определяет, что память объекта может быть восстановлена, эта память
помещается в   ``список свободной памяти(free list)'' объектов, которые могут
быть утилизированы. Обычно это его конец ---объект доступен для немедленного
повторного использования.  Однако некоторые объекты могут иметь связанные с ними
``финализаторы(finalizers)'' --- функции, которые вызываются для утилизируемых
объектов для выполнения любых действий по внешней очистки.

Финализаторы это сложная работа и лучше их избегать. Они могут быть вызваны
в неожиданное время, или вообще не вызваны --- например, они не вызываются
при завершении процесса.  Они не помогают сборщику мусора в его работе; на самом
деле, они являются препятствием.  Кроме того, они нарушают внутренний учет
сборщика мусора. Сборщик мусора(GC) решает сканировать кучу, когда он думает, что
это необходимо, после некоторого выделения. Финализируемые объекты всегда представляют
собой некоторый выделенный объем, который невидим для сборщика мусора. Эффект может заключаться
в том, что фактическое использование ресурсов системы с финализируемыми объектами выше
чем предполагает о них сборщик мусора(GC).

Все это оговорки в сторону, некоторые типы внешних объектов требуют финализаторов.
Например, если у нас тип внешнего объекта, который являлся оберткой для файлового
дескриптора--- и мы не предлагаем это, поскольку у Guile уже есть порты
---тогда вы можете определить этот тип следующим образом:

@example
static SCM file_type;

static void
finalize_file (SCM file)
@{
  int fd = scm_foreign_object_signed_ref (file, 0);
  if (fd >= 0)
    @{
      scm_foreign_object_signed_set_x (file, 0, -1);
      close (fd);
    @}
@}

static void
init_file_type (void)
@{
  SCM name, slots;
  scm_t_struct_finalize finalizer;

  name = scm_from_utf8_symbol ("file");
  slots = scm_list_1 (scm_from_utf8_symbol ("fd"));
  finalizer = finalize_file;

  image_type =
    scm_make_foreign_object_type (name, slots, finalizer);
@}

static SCM
make_file (int fd)
@{
  return scm_make_foreign_object_1 (file_type, (void *) fd);
@}
@end example

@cindex finalizer
@cindex finalization

Обратите внимание, что финализатор может быть вызван способами и во время,
которое вы не ожидаете. В частности, если пользовательский Guile построен
с поддержкой потоков, финализатор может быть вызван из любого потока, в
котором работает Guile.  В Guile 2.0, финализаторы вызываются через ``asyncs'',
который перемежает их с помощью кода Scheme; @pxref{Asyncs}.  В Guile 2.2
будет выделенный поток финализации, чтобы быть уверенными что поток
финализации не работает в критической секции другого потока не известного
Guile.

В любом случае, финализаторы запускаются одновременно с основной программой,
и поэтому им необходимо быть асинхронными и потоко-безопасными(thread-safe).
Если по какой-то причине это невозможно, например потому что вы встраиваете 
Guile в какое-то приложение, которое не является потоко-безопасным, у
вас есть несколько способов действий. Один заключается в том, чтобы использовать
опекунов(guardians) вместо финализаторов и организовать передачу объектов
опекунам для финализации. @xref{Guardians}, за дальнейшей инофрмацией.
Другой способ  - полностью отключить автоматическую финализацию и организовать
вызов @code{scm_run_finalizers ()} в соответствующих точках.  @xref{Foreign Objects}, 
для получения дополнительной информации об этих интерфейсах.

Финализаторам разрешено выделять память, иметь доступ к памяти управляемой
сборщиком мусора(GC), и вообще делать все, что может сделать любой код
пользователя Guile.  Это было не так в 1.8, где финализаторы были гораздо
более ограничены. В частности, в Guile 2.0, финализаторы могут реанимировать
объекты. Мы не рекомендуем, чтобы пользователи использовали эту возможность,
однако как реанимированный объект может повторно открыть другие финализированные
объекты которые повторно финализируются при возвращении обратно в Scheme.
Эти объекты не будут финилизироваться повторно, но они могут привести проблеме
использования памяти после освобождения(use-after-free) для кода, который обрабатывает
объекты этого конкретного типа внешних объектов.  Защищаясь от этой возможности,
надежные процедуры финализации должны очищать состояние от внешнего объекта, как в
приведенном выше примере @code{free_file}.

Одно, последнее предостережение.  Финализаторы внешних объектов связвны со
сроком жизни внешнего бъекта, но не его полей. Если вы получаете доступ к
полю финализируемого внешнего объекта, и не организуете сохранение ссылки на
сам внешний объект, может случиться так, что внешний объект будет финализирован,
пока вы работаете с его полем.

Например, рассмотрим процедуру чтения некоторых данных из файла, из нашего примера
выше.

@example
SCM
read_bytes (SCM file, SCM n)
@{
  int fd;
  SCM buf;
  size_t len, pos;

  scm_assert_foreign_object_type (file_type, file);

  fd = scm_foreign_object_signed_ref (file, 0);
  if (fd < 0)
    scm_wrong_type_arg_msg ("read-bytes", SCM_ARG1,
                            file, "open file");

  len = scm_to_size_t (n);
  SCM buf = scm_c_make_bytevector (scm_to_size_t (n));

  pos = 0;
  while (pos < len)
    @{
      char *bytes = SCM_BYTEVECTOR_CONTENTS (buf);
      ssize_t count = read (fd, bytes + pos, len - pos);
      if (count < 0)
        scm_syserror ("read-bytes");
      if (count == 0)
        break;
      pos += count;
    @}

  scm_remember_upto_here_1 (file);

  return scm_values (scm_list_2 (buf, scm_from_size_t (pos)));
@}
@end example

После прелюдии, используется только значение @code{fd} и компилятору C 
нет необходимости сохранять объект @code{file}(т.е оптимизирующий код
компилятора может уничтожить ссылку на этот объект и выделить ее для 
использования другим объектом).  Если вызов @code{scm_c_make_bytevector}
приведет к сборке мусора, ссылки на @code{file} может не оказаться в стеке или
где нибудь еще и он может быть финализирован(закрыт), оставив вызов @code{read}
для чтения закрытого (или, в многопоточной программе, возможно повторно используемый)
файлового дескриптора.  Использование вызова @code{scm_remember_upto_here_1} предотвращает это,
создавая ссылку на @code{file} полсе доступа ко всем данным.  @xref{Garbage Collection
Functions}.

@code{scm_remember_upto_here_1} требуется только для финализируемых объектов,
поскольку сбор мусора других значений невидим для программы
-- он происходит когда это необходимо, и не является наблюдаемым. Но если вы
сможете, уберечь себя от головной боли, создайте свою программу таким образом,
чтобы финализация в ней была бы не нужна.

@node Foreign Objects and Scheme
@subsection Внешние Объекты и Scheme

Также возможно создавать внешние объекты и типы объектов из
Scheme и получать доступ к полям внешних объектов из Scheme.  Например,
пример файла(file) из последнего раздела может быть эквивалентно выражен
следующим образом:

@example
(define-module (my-file)
  #:use-module (system foreign-object)
  #:use-module ((oop goops) #:select (make))
  #:export (make-file))

(define (finalize-file file)
  (let ((fd (struct-ref file 0)))
    (unless (< fd 0)
      (struct-set! file 0 -1)
      (close-fdes fd))))

(define <file>
  (make-foreign-object-type '<file> '(fd)
                            #:finalizer finalize-file))

(define (make-file fd)
  (make <file> #:fd fd))
@end example

Здесь мы видим, что результат @code{make-foreign-object-type}, который
эквивалентен вызову@code{scm_make_foreign_object_type}, является структурой
vtable.  @xref{Vtables}, для получения дополнительной информацииn. Чтобы создать
экземпляр внешнего объекта, который действительно является структурой Guile, мы
использкем @code{make}.  (Мы моглибы использовать @code{make-struct/no-tail}, 
но для детализации, добавляем финализатор в метод инициализации @code{initialize} 
вызываемый @code{make}).  Для доспупа к полям, мы используем @code{struct-ref} и
@code{struct-set!}.  @xref{Structure Basics}.

Существует удобный синтаксис @code{define-foreign-object-type}, который
определяет тип, наряду с констурктором и процедурами доступа(getters) для полей.
Сооответствующий вызов @code{define-foreign-object-type} для объекта
типа файла(file) может выглядеть так:

@example
(use-modules (system foreign-object))

(define-foreign-object-type <file>
  make-file
  (fd)
  #:finalizer finalize-file)
@end example

Здесь определяется тип @code{<file>} с одним полем, конструктором @code{make-file},
и процедурой доступа для поля @code{fd}, связанная с @code{fd}.

Типы внешних объектов это не только vtable, но и фактически классы GOOPS,
как это отмечено выше.  см. @xref{GOOPS}, для получения дополнительной
информации о системе объектно-ориентированного программирования  Guile.
Таким образом, можно определить методы печать(print) и равно(equality)
используя GOOPS:

@example
(use-modules (oop goops))

(define-method (write (file <file>) port)
  ;; Assuming existence of the `fd' getter
  (format port "#<<file> ~a>" (fd file)))

(define-method (equal? (a <file>) (b <file>))
  (eqv? (fd a) (fd b)))
@end example

Можно даже создавать подклассы внешних объектов.

@example
(define-class <named-file> (<file>)
  (name #:init-keyword #:name #:init-value #f #:accessor name))
@end example

Возникает вопрос, как строяться эти значения, учитвывая что, @code{make-file}
возвращает просто старый объект @code{<file>}.  Оказывается, вы можете использовать
интерфейс постороения GOOPS, где каждое поле внешнего объекта имеет связанный
аргумент инициализации - ключевое слово.

@example
(define* (my-open-file name #:optional (flags O_RDONLY))
  (make <named-file> #:fd (open-fdes name flags) #:name name))

(define-method (write (file <named-file>) port)
  (format port "#<<file> ~s ~a>" (name file) (fd file)))
@end example

См. @xref{Foreign Objects}, для полной документации по интерфейсам Scheme
к внешним объектам. См.  @xref{GOOPS}, для получения дополнительных сведений
о GOOPS.

В заключении, вы можете удивиться, как эта система поддерживает инкапсуляцию
чувствительных(sensitive) значений.  Первое, мы должны признать, что некоторые
объекты по существу не безопасны и имеют глобальных охват(область действия). Например,
в Си, целостность и конфеденциальность части программы находиться в милости от каждой
другой части этой программы, поскольку любая часть программы может читать или писать
что нибудь в это адресное пространство.  В то же время, принципиальный доступ к струрированным
данным организован в Си в лексических границах(области видимости); если вы не не открываете
процедуры доступа для своего объекта, вы доверяете другим частям программы, что они не 
обошли этот барьер.

Ситуация не отличается в Scheme.  Хотя небезопасных конструкций в Scheme
значительно меньше чем в Си, они существуют. Модуль @code{(system foreign)}
может использоваться для нарушения конфиденциальности и целостности, и
не должен размещаться ненадежным кодом. Хотя @code{struct-ref} и 
@code{struct-set!} менее опасны, они по прежнему имеют способность
насквозь проходить сквозь абстракции.
Выполнение @code{struct-set!} на слоте с внешним объектом может вызвать
сбой небезопасного внешнего кода. В конечном счете, структуры в Scheme
являются возможностью для абстрагирования, а не самими абстракциями.

Это оставляет нам лексические возможности, такие как конструкторы и
процедуры доступа. Здесь, где заключается инкапсуляция: практическая степень,
в которой внутренности ваших внешних объектов раскрывается степень,
которой их процедуры доступа являются лексически доступными в коде пользователя.
Если вы хотите разрешить пользователям ссылаться на поля вашего внешнего объекта,
предоставьте им процедуру получения доступа к полю(getter).  В противном случае
вы должны предположить, что доступ к вашему объекту возможен только из вашего кода,
который имеет соответствующие полномочия, или через код со сквозным доступом
@code{struct-ref} и такой, который имеет сквозные полномочия.