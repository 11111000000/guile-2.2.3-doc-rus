#
# NuINu <don't@send.my>, 2019.
#
#. extracted from /home/bear/work/guile/doc/guile/en/api-utility.texi
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-07 12:37+0300\n"
"PO-Revision-Date: 2019-03-13 16:05+0300\n"
"Last-Translator: NuINu <don't@send.my>\n"
"Language-Team: Russian <don't@send.my>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Gtranslator 2.91.7\n"
"Plural-Forms: nplurals=5; plural=n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : "
"4;\n"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C)  1996, 1997, 2000, 2001, 2002, 2003, 2004, 2011, 2012, "
"2013, 2014\n"
"@c   Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:9
msgid ""
"@node Utility Functions\n"
"@section General Utility Functions"
msgstr ""
"@node Utility Functions\n"
"@section Общие Утилиты(Служебные Функции)"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:11
msgctxt "/home/bear/work/guile/doc/guile/en/api-utility.texi:11"
msgid "@c FIXME::martin: Review me!"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:15
msgid ""
"This chapter contains information about procedures which are not cleanly\n"
"tied to a specific data type.  Because of their wide range of\n"
"applications, they are collected in a @dfn{utility} chapter."
msgstr ""
"Эта глава содержит информацию о процедурах, которые н привязаны к "
"конкретному\n"
"типу данных. Из-за широкого спектра их приложений, они собраны в главу "
"Утилиты\n"
"(@dfn{utility})."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:24
msgid ""
"@menu\n"
"* Equality::                    When are two values `the same'?\n"
"* Object Properties::           A modern interface to object properties.\n"
"* Sorting::                     Sort utility procedures.\n"
"* Copying::                     Copying deep structures.\n"
"* General Conversion::          Converting objects to strings.\n"
"* Hooks::                       User-customizable event lists.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:30
msgid ""
"@node Equality\n"
"@subsection Equality\n"
"@cindex sameness\n"
"@cindex equality"
msgstr ""
"@node Equality\n"
"@subsection Равенство\n"
"@cindex sameness\n"
"@cindex equality"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:34
msgid ""
"There are three kinds of core equality predicates in Scheme, described\n"
"below.  The same kinds of comparisons arise in other functions, like\n"
"@code{memq} and friends (@pxref{List Searching})."
msgstr ""
"В Scheme есть три типа основных предикатов равенства, описанных ниже.\n"
"Такие же виды сравнений возникают в других функциях, таких как\n"
"@code{memq} и ее друзьях (@pxref{List Searching})."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:40
msgid ""
"For all three tests, objects of different types are never equal.  So\n"
"for instance a list and a vector are not @code{equal?}, even if their\n"
"contents are the same.  Exact and inexact numbers are considered\n"
"different types too, and are hence not equal even if their values are\n"
"the same."
msgstr ""
"Для всех трех проверок, объекты разных типов никогда не бывают равными.\n"
"Так, например экземпляр списка и вектора не равны (not @code{equal?}),\n"
"даже если их содержимое одинаково. Точные и не точные числа также\n"
"рассмотриваются как различные типы, и следовательно они не равны, даже\n"
"если их значения одинаковы."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:45
msgid ""
"@code{eq?} tests just for the same object (essentially a pointer\n"
"comparison).  This is fast, and can be used when searching for a\n"
"particular object, or when working with symbols or keywords (which are\n"
"always unique objects)."
msgstr ""
"@code{eq?} просто проверяет является ли объект тем же самым (по сути, это\n"
"сравнение указателей).  Это быстро, и может использоваться при поиске\n"
"определенного объекта или при работе с символами или ключевыми словами\n"
"(которые всегда являются уникальными объектами)."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:50
msgid ""
"@code{eqv?} extends @code{eq?} to look at the value of numbers and\n"
"characters.  It can for instance be used somewhat like @code{=}\n"
"(@pxref{Comparison}) but without an error if one operand isn't a\n"
"number."
msgstr ""
"@code{eqv?} расширеят @code{eq?} и смотрит на значение чисел и символьных\n"
"знаков.  Это может быть использовано для экземплякров подобно @code{=}\n"
"(@pxref{Comparison}) но без ошибки, если операнд не является числом."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:56
msgid ""
"@code{equal?} goes further, it looks (recursively) into the contents\n"
"of lists, vectors, etc.  This is good for instance on lists that have\n"
"been read or calculated in various places and are the same, just not\n"
"made up of the same pairs.  Such lists look the same (when printed),\n"
"and @code{equal?} will consider them the same."
msgstr ""
"@code{equal?} идет дальше, он просматривает (рекурсивно) содержимое\n"
"списков, векторов и т.д.  Это хорошо, например, для экземпляров списков,\n"
"которые были прочитаны или вычислены в разных местах и являются теми же\n"
"самыми, только не состоят из одних и тех же пар.  Такие списки выглядят\n"
"одинаково(когда их печатают) и @code{equal?} будет считать их равными."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:63
msgid ""
"@sp 1\n"
"@deffn {Scheme Procedure} eq? x y\n"
"@deffnx {C Function} scm_eq_p (x, y)\n"
"@rnindex eq?\n"
"Return @code{#t} if @var{x} and @var{y} are the same object, except\n"
"for numbers and characters.  For example,"
msgstr ""
"@sp 1\n"
"@deffn {Scheme Procedure} eq? x y\n"
"@deffnx {C Function} scm_eq_p (x, y)\n"
"@rnindex eq?\n"
"Возвращает @code{#t} если @var{x} и @var{y} один и тот же объект, за\n"
"исключением цифр и символьных знаков. Например,"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:67
msgid ""
"@example\n"
"(define x (vector 1 2 3))\n"
"(define y (vector 1 2 3))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:71
msgid ""
"(eq? x x)  @result{} #t\n"
"(eq? x y)  @result{} #f\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:75
msgid ""
"Numbers and characters are not equal to any other object, but the\n"
"problem is they're not necessarily @code{eq?} to themselves either.\n"
"This is even so when the number comes directly from a variable,"
msgstr ""
"Числа и символьные знаки не равны никаким другим объектам, но проблема в "
"том,\n"
"что они не обязательно равны @code{eq?} самим себе.\n"
"Это так, даже когда приходит число прямо из переменной."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:80
msgid ""
"@example\n"
"(let ((n (+ 2 3)))\n"
"  (eq? n n))       @result{} *unspecified*\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:84
msgid ""
"Generally @code{eqv?} below should be used when comparing numbers or\n"
"characters.  @code{=} (@pxref{Comparison}) or @code{char=?}\n"
"(@pxref{Characters}) can be used too."
msgstr ""
"Вообще @code{eqv?} описанное ниже, следует использовать при сравнении чисел\n"
"или символьных знаков.  @code{=} (@pxref{Comparison}) or @code{char=?}\n"
"(@pxref{Characters}) тоже может быть спользовано."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:90
msgid ""
"It's worth noting that end-of-list @code{()}, @code{#t}, @code{#f}, a\n"
"symbol of a given name, and a keyword of a given name, are unique\n"
"objects.  There's just one of each, so for instance no matter how\n"
"@code{()} arises in a program, it's the same object and can be\n"
"compared with @code{eq?},"
msgstr ""
"Стоит отметить, что конец списка @code{()}, @code{#t}, @code{#f}, символ\n"
"данного имени, и ключевое слово данного имени, являются уникальными\n"
"объектами.  Для каждого экземпляра это один и тот же объект. Не зависимо от\n"
"того, как @code{()} возникает в программе, это один и тот же объект и его \n"
"можно сравнивать используя @code{eq?},"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:95
msgid ""
"@example\n"
"(define x (cdr '(123)))\n"
"(define y (cdr '(456)))\n"
"(eq? x y) @result{} #t"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:100
msgid ""
"(define x (string->symbol \"foo\"))\n"
"(eq? x 'foo) @result{} #t\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:104
msgid ""
"@deftypefn {C Function} int scm_is_eq (SCM x, SCM y)\n"
"Return @code{1} when @var{x} and @var{y} are equal in the sense of\n"
"@code{eq?}, otherwise return @code{0}."
msgstr ""
"@deftypefn {C Function} int scm_is_eq (SCM x, SCM y)\n"
"Возвращает @code{1} когда @var{x} и @var{y} являются эквивалентными в\n"
"смысле @code{eq?}, иначе возвращает @code{0}."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:110
msgid ""
"@findex ==\n"
"The @code{==} operator should not be used on @code{SCM} values, an\n"
"@code{SCM} is a C type which cannot necessarily be compared using\n"
"@code{==} (@pxref{The SCM Type}).\n"
"@end deftypefn"
msgstr ""
"@findex ==\n"
"Оператор @code{==} не должен использоваться для значений @code{SCM},\n"
"@code{SCM} это тип данных си который нельзя непосредственно сравнивать\n"
"исползуя @code{==} (@pxref{The SCM Type}).\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:117
msgid ""
"@sp 1\n"
"@deffn {Scheme Procedure} eqv? x y\n"
"@deffnx {C Function} scm_eqv_p (x, y)\n"
"@rnindex eqv?\n"
"Return @code{#t} if @var{x} and @var{y} are the same object, or for\n"
"characters and numbers the same value."
msgstr ""
"@sp 1\n"
"@deffn {Scheme Procedure} eqv? x y\n"
"@deffnx {C Function} scm_eqv_p (x, y)\n"
"@rnindex eqv?\n"
"Возвращает @code{#t} если @var{x} и @var{y} это один и тот же объект или\n"
"для символьных знаков и чисел имеющих одно и тоже значение."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:121
msgid ""
"On objects except characters and numbers, @code{eqv?} is the same as\n"
"@code{eq?} above, it's true if @var{x} and @var{y} are the same\n"
"object."
msgstr ""
"На объекты, за исключением символьных знаков и чисел, @code{eqv?} \n"
"действует так же как @code{eq?} выше, сравнение даст истину если \n"
"@var{x} и @var{y} являются одним и темже объектом."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:125
msgid ""
"If @var{x} and @var{y} are numbers or characters, @code{eqv?} compares\n"
"their type and value.  An exact number is not @code{eqv?} to an\n"
"inexact number (even if their value is the same)."
msgstr ""
"Если @var{x} и @var{y} являются числами или символьными знаками, "
"@code{eqv?} \n"
"сравнивает их тип и значение. Точные числа не будут равны @code{eqv?} не "
"точным\n"
"числам(даже если их значения одинаковы)."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:131
msgid ""
"@example\n"
"(eqv? 3 (+ 1 2)) @result{} #t\n"
"(eqv? 1 1.0)     @result{} #f\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:138
msgid ""
"@sp 1\n"
"@deffn {Scheme Procedure} equal? x y\n"
"@deffnx {C Function} scm_equal_p (x, y)\n"
"@rnindex equal?\n"
"Return @code{#t} if @var{x} and @var{y} are the same type, and their\n"
"contents or value are equal."
msgstr ""
"@sp 1\n"
"@deffn {Scheme Procedure} equal? x y\n"
"@deffnx {C Function} scm_equal_p (x, y)\n"
"@rnindex equal?\n"
"возвращает @code{#t} если @var{x} и @var{y} одинакового типа и их "
"содержимое\n"
"или значение являются равным."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:142
msgid ""
"For a pair, string, vector, array or structure, @code{equal?} compares the\n"
"contents, and does so using the same @code{equal?} recursively,\n"
"so a deep structure can be traversed."
msgstr ""
"Для пар, строк, векторов, массивов или структур, @code{equal?} сравнивает "
"их\n"
"содержимое, и делает так используя  @code{equal?} рекурсивно,\n"
"поэтому может быть пройдена структура произвольной глубины."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:147
msgid ""
"@example\n"
"(equal? (list 1 2 3) (list 1 2 3))   @result{} #t\n"
"(equal? (list 1 2 3) (vector 1 2 3)) @result{} #f\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:152
msgid ""
"For other objects, @code{equal?} compares as per @code{eqv?} above,\n"
"which means characters and numbers are compared by type and value (and\n"
"like @code{eqv?}, exact and inexact numbers are not @code{equal?},\n"
"even if their value is the same)."
msgstr ""
"Для других объектов, @code{equal?} сравнивает как @code{eqv?} выше,\n"
"что означает что символьные знакии числа сравниваются по типу и значению\n"
"(как в @code{eqv?}, точные и неточные числа не равны - not @code{equal?},\n"
"даже если их значения одинаковы)."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:157
msgid ""
"@example\n"
"(equal? 3 (+ 1 2)) @result{} #t\n"
"(equal? 1 1.0)     @result{} #f\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:161
msgid ""
"Hash tables are currently only compared as per @code{eq?}, so two\n"
"different tables are not @code{equal?}, even if their contents are the\n"
"same."
msgstr ""
"Хеш-таблицы в настоящее время сравниваются только в соответствии с "
"@code{eq?},\n"
"поэтому длв разные таблицы не равны(not @code{equal?}), даже если их "
"содержимое\n"
"одно и тоже."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:165
msgid ""
"@code{equal?} does not support circular data structures, it may go\n"
"into an infinite loop if asked to compare two circular lists or\n"
"similar."
msgstr ""
"@code{equal?} не поддерживает циклические структуры данных, он может\n"
"зациклиться, если попросить сравинить два циклическвих списка или\n"
"аналогичные структуры."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:175
msgid ""
"GOOPS object types (@pxref{GOOPS}), including foreign object types\n"
"(@pxref{Defining New Foreign Object Types}), can have an @code{equal?}\n"
"implementation specialized on two values of the same type.  If\n"
"@code{equal?} is called on two GOOPS objects of the same type,\n"
"@code{equal?} will dispatch out to a generic function.  This lets an\n"
"application traverse the contents or control what is considered\n"
"@code{equal?} for two objects of such a type.  If there's no such\n"
"handler, the default is to just compare as per @code{eq?}.\n"
"@end deffn"
msgstr ""
"Типы объектов GOOPS (@pxref{GOOPS}), влючая типы внешних объектов\n"
"(@pxref{Defining New Foreign Object Types}), могут иметь специальную\n"
"реализацию @code{equal?} для сравнения двух значений одного типа.\n"
"Если @code{equal?} вызван для двух объектов GOOPS одинакового типа,\n"
"@code{equal?} отправит вызов на обобщенную функцию.  Это позволяет\n"
"приложению просматривать содержимое или контролировать то, что считается\n"
"равным @code{equal?} для двух объектов одинакового типа. Если такого\n"
"обработчика нет, по умолчанию просто сравнивается как @code{eq?}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:179
msgid ""
"@node Object Properties\n"
"@subsection Object Properties"
msgstr ""
"@node Object Properties\n"
"@subsection Object Properties"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:184
msgid ""
"It's often useful to associate a piece of additional information with a\n"
"Scheme object even though that object does not have a dedicated slot\n"
"available in which the additional information could be stored.  Object\n"
"properties allow you to do just that."
msgstr ""
"IЧасто полезно связать часть дополнительной информации с объектом \n"
"Scheme даже когда объект не имеет выделенного слота, в котором\n"
"дополнительная информация может быть сохранена.  Свойства объекта\n"
"позволяют вам сделать это."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:189
msgid ""
"Guile's representation of an object property is a procedure-with-setter\n"
"(@pxref{Procedures with Setters}) that can be used with the generalized\n"
"form of @code{set!} (REFFIXME) to set and retrieve that property for any\n"
"Scheme object.  So, setting a property looks like this:"
msgstr ""
"В Guile представлении свойства объекта является процедурой с установщиком\n"
"(@pxref{Procedures with Setters}) которую можно использовать  с обобщенной\n"
"формой @code{set!} (REFFIXME) чтобы установить и получить свойство для\n"
"любого объекта Scheme.  Итак, установка свойств выглядит так:"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:194
msgid ""
"@lisp\n"
"(set! (my-property obj1) value-for-obj1)\n"
"(set! (my-property obj2) value-for-obj2)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:197
msgid ""
"@noindent\n"
"And retrieving values of the same property looks like this:"
msgstr ""
"@noindent\n"
"и получение значения одного и того же свойства выглядит следующим\n"
"образом:"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:202
msgid ""
"@lisp\n"
"(my-property obj1)\n"
"@result{}\n"
"value-for-obj1"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:207
msgid ""
"(my-property obj2)\n"
"@result{}\n"
"value-for-obj2\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:210
msgid ""
"To create an object property in the first place, use the\n"
"@code{make-object-property} procedure:"
msgstr ""
"Чтобы создать свойство объекта в первую очередь используйте\n"
"процедуру @code{make-object-property}:"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:214
msgid ""
"@lisp\n"
"(define my-property (make-object-property))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:222
msgid ""
"@deffn {Scheme Procedure} make-object-property\n"
"Create and return an object property.  An object property is a\n"
"procedure-with-setter that can be called in two ways.  @code{(set!\n"
"(@var{property} @var{obj}) @var{val})} sets @var{obj}'s @var{property}\n"
"to @var{val}.  @code{(@var{property} @var{obj})} returns the current\n"
"setting of @var{obj}'s @var{property}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} make-object-property\n"
"Создает и возвращает свойство объекта.  Свойство объекта является\n"
"процедурой с установщиком(procedure-with-setter) котороую можно вызвать\n"
"двумя способами.  @code{(set! (@var{property} @var{obj}) @var{val})} \n"
"устанавлилвает свойство  @var{property} объекта @var{obj} в значение  \n"
"@var{val}.  @code{(@var{property} @var{obj})} возвращает текущее\n"
"значение свойства @var{property} объекта @var{obj} .\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:226
msgid ""
"A single object property created by @code{make-object-property} can\n"
"associate distinct property values with all Scheme values that are\n"
"distinguishable by @code{eq?} (ruling out numeric values)."
msgstr ""
"Одно свойство объекта созданное с помощью @code{make-object-property}\n"
"может связать отдельное свойство значения со всеми значениями Scheme\n"
"которые различаются по @code{eq?} (исключая числовые значения)."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:233
msgid ""
"Internally, object properties are implemented using a weak key hash\n"
"table.  This means that, as long as a Scheme value with property values\n"
"is protected from garbage collection, its property values are also\n"
"protected.  When the Scheme value is collected, its entry in the\n"
"property table is removed and so the (ex-) property values are no longer\n"
"protected by the table."
msgstr ""
"Внутренне, свойства объекта реализуются с использованием хеш-таблицы слабых\n"
"ключей.  Это означает, что пока значение Scheme связанное со значениями "
"свойств\n"
"защищены от сборки мусора, значение его свойства также защищены.\n"
"Когда значение Scheme собирается сборщиком мусора, его запись в таблице\n"
"свойств удаляется и поэтому значение экс-свойства больше не защищено\n"
"таблицей."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:238
msgid ""
"Guile also implements a more traditional Lispy interface to properties,\n"
"in which each object has an list of key-value pairs associated with it.\n"
"Properties in that list are keyed by symbols.  This is a legacy\n"
"interface; you should use weak hash tables or object properties instead."
msgstr ""
"Guile также реализует более традиционный списковый интерфейс поддерживающий\n"
"свойства, в котором каждый объект имеет список пар ключ - значение, "
"связанный\n"
"с ним. Свойства в этом списке обозначены символами. Это устаревший "
"интерфейс;\n"
"Вы должны использовать слабые хеш-таблицы или свойства объектов вместо него."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:243
msgid ""
"@deffn {Scheme Procedure} object-properties obj\n"
"@deffnx {C Function} scm_object_properties (obj)\n"
"Return @var{obj}'s property list.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} object-properties obj\n"
"@deffnx {C Function} scm_object_properties (obj)\n"
"Возвращает список свойств @var{obj}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:248
msgid ""
"@deffn {Scheme Procedure} set-object-properties! obj alist\n"
"@deffnx {C Function} scm_set_object_properties_x (obj, alist)\n"
"Set @var{obj}'s property list to @var{alist}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} set-object-properties! obj alist\n"
"@deffnx {C Function} scm_set_object_properties_x (obj, alist)\n"
"Устанавливает список свойств объекта @var{obj} в @var{alist}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:253
msgid ""
"@deffn {Scheme Procedure} object-property obj key\n"
"@deffnx {C Function} scm_object_property (obj, key)\n"
"Return the property of @var{obj} with name @var{key}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} object-property obj key\n"
"@deffnx {C Function} scm_object_property (obj, key)\n"
"Возвращает свойство объекта @var{obj} с именем @var{key}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:259
msgid ""
"@deffn {Scheme Procedure} set-object-property! obj key value\n"
"@deffnx {C Function} scm_set_object_property_x (obj, key, value)\n"
"In @var{obj}'s property list, set the property named @var{key}\n"
"to @var{value}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} set-object-property! obj key value\n"
"@deffnx {C Function} scm_set_object_property_x (obj, key, value)\n"
"В списке свойств объекта @var{obj} устанавливает свойство с именем "
"@var{key}\n"
"в значение @var{value}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:263
msgid ""
"@node Sorting\n"
"@subsection Sorting"
msgstr ""
"@node Sorting\n"
"@subsection Сортировка"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:265
msgctxt "/home/bear/work/guile/doc/guile/en/api-utility.texi:265"
msgid "@c FIXME::martin: Review me!"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:269
msgid ""
"@cindex sorting\n"
"@cindex sorting lists\n"
"@cindex sorting vectors"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:274
msgid ""
"Sorting is very important in computer programs.  Therefore, Guile comes\n"
"with several sorting procedures built-in.  As always, procedures with\n"
"names ending in @code{!} are side-effecting, that means that they may\n"
"modify their parameters in order to produce their results."
msgstr ""
"Сортировка очень важна в компьютерных программах.  Таким образом, Guile \n"
"поставляется с несколькими встроенными процедурами сортировки. Как всегда,\n"
"процедуры заканчивающиеся знаком @code{!} имеют побочные эффекты, это "
"означает\n"
"что они могут изменять свои параметры для получения результатов."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:278
msgid ""
"The first group of procedures can be used to merge two lists (which must\n"
"be already sorted on their own) and produce sorted lists containing\n"
"all elements of the input lists."
msgstr ""
"Первая группа процедур может использоваться для объединения двух списков\n"
"(которые должны быть уже отсортированы самостоятельно) и создает\n"
"отсортированные списки содержащие все элементы входных списков."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:289
msgid ""
"@deffn {Scheme Procedure} merge alist blist less\n"
"@deffnx {C Function} scm_merge (alist, blist, less)\n"
"Merge two already sorted lists into one.\n"
"Given two lists @var{alist} and @var{blist}, such that\n"
"@code{(sorted? alist less?)} and @code{(sorted? blist less?)},\n"
"return a new list in which the elements of @var{alist} and\n"
"@var{blist} have been stably interleaved so that\n"
"@code{(sorted? (merge alist blist less?) less?)}.\n"
"Note:  this does _not_ accept vectors.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} merge alist blist less\n"
"@deffnx {C Function} scm_merge (alist, blist, less)\n"
"Объединяет два уже отсортированных списка в один.\n"
"Предоставляются два списка @var{alist} и @var{blist}, такие как\n"
"@code{(sorted? alist less?)} и @code{(sorted? blist less?)},\n"
"возвращается новый список состоящий из элементов @var{alist} и \n"
"@var{blist} чередующихся так чтобы остаться отсортированными\n"
"@code{(sorted? (merge alist blist less?) less?)}.\n"
"Примечание:  функция не принимает векторы!\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:300
msgid ""
"@deffn {Scheme Procedure} merge! alist blist less\n"
"@deffnx {C Function} scm_merge_x (alist, blist, less)\n"
"Takes two lists @var{alist} and @var{blist} such that\n"
"@code{(sorted? alist less?)} and @code{(sorted? blist less?)} and\n"
"returns a new list in which the elements of @var{alist} and\n"
"@var{blist} have been stably interleaved so that\n"
" @code{(sorted? (merge alist blist less?) less?)}.\n"
"This is the destructive variant of @code{merge}\n"
"Note:  this does _not_ accept vectors.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} merge! alist blist less\n"
"@deffnx {C Function} scm_merge_x (alist, blist, less)\n"
"Принимает два уже отсортированных списка @var{alist} и @var{blist},\n"
"такие как @code{(sorted? alist less?)} и @code{(sorted? blist less?)},\n"
"возвращается новый список состоящий из элементов @var{alist} и \n"
"@var{blist} чередующихся так чтобы остаться отсортированными\n"
"@code{(sorted? (merge alist blist less?) less?)}. Это деструктивный\n"
"вариант слияния.\n"
"Примечание:  функция не принимает векторы!\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:310
msgid ""
"The following procedures can operate on sequences which are either\n"
"vectors or list.  According to the given arguments, they return sorted\n"
"vectors or lists, respectively.  The first of the following procedures\n"
"determines whether a sequence is already sorted, the other sort a given\n"
"sequence.  The variants with names starting with @code{stable-} are\n"
"special in that they maintain a special property of the input sequences:\n"
"If two or more elements are the same according to the comparison\n"
"predicate, they are left in the same order as they appeared in the\n"
"input."
msgstr ""
"Следующие процедуры могут работать с последовательностями, которые являются\n"
"векторами или списками. Согласно предоставленным аргументам, онги "
"возвращают\n"
"отсортированные вектора или списки, соответственно. Первая из следующих "
"процедур\n"
"определяет, отсортирована ли последовательность, другая сортирует заданную\n"
"последовательность. Варианты с именами, начинающимися с @code{stable-}, "
"отличаются\n"
"тем, что они поддерживают специальное свойство входных последовательностей: "
"если два\n"
"или более элемента являются уже соответствующими предикату сравнения,  они "
"остаются\n"
"в том же порядке, в котором они появились на входе."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:318
msgid ""
"@deffn {Scheme Procedure} sorted? items less\n"
"@deffnx {C Function} scm_sorted_p (items, less)\n"
"Return @code{#t} if @var{items} is a list or vector such that,\n"
"for each element @var{x} and the next element @var{y} of\n"
"@var{items}, @code{(@var{less} @var{y} @var{x})} returns\n"
"@code{#f}.  Otherwise return @code{#f}.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} sorted? items less\n"
"@deffnx {C Function} scm_sorted_p (items, less)\n"
"Возвращает @code{#t} если @var{items} является списком или вектором\n"
"таким, что для каждого элемента @var{x} и следующего элемента @var{y}\n"
"из @var{items}, функция @code{(@var{less} @var{y} @var{x})} возвращает\n"
"@code{#f}.  В противном случае возвращает @code{#f}.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:325
msgid ""
"@deffn {Scheme Procedure} sort items less\n"
"@deffnx {C Function} scm_sort (items, less)\n"
"Sort the sequence @var{items}, which may be a list or a\n"
"vector.  @var{less} is used for comparing the sequence\n"
"elements.  This is not a stable sort.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} sort items less\n"
"@deffnx {C Function} scm_sort (items, less)\n"
"Сортирует элементы последовательности @var{items}, которые могут\n"
"быть списком или вектором. Процедура @var{less} исползуется для\n"
"сравнения элементов последовательности. Это не стабильная сортировка.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:334
msgid ""
"@deffn {Scheme Procedure} sort! items less\n"
"@deffnx {C Function} scm_sort_x (items, less)\n"
"Sort the sequence @var{items}, which may be a list or a\n"
"vector.  @var{less} is used for comparing the sequence\n"
"elements.  The sorting is destructive, that means that the\n"
"input sequence is modified to produce the sorted result.\n"
"This is not a stable sort.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} sort! items less\n"
"@deffnx {C Function} scm_sort_x (items, less)\n"
"Сортирует элементы последовательности @var{items}, которые могут\n"
"быть списком или вектором. Процедура @var{less} исползуется для\n"
"сравнения элементов последовательности. Это деструктивная сортировка,\n"
"это означает, что входная последовательность модифицируется для \n"
"получения отсортированного результата.\n"
"Это не стабильная сортировка.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:341
msgid ""
"@deffn {Scheme Procedure} stable-sort items less\n"
"@deffnx {C Function} scm_stable_sort (items, less)\n"
"Sort the sequence @var{items}, which may be a list or a\n"
"vector. @var{less} is used for comparing the sequence elements.\n"
"This is a stable sort.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} stable-sort items less\n"
"@deffnx {C Function} scm_stable_sort (items, less)\n"
"Сортирует последовательность @var{items}, которая может быть списком\n"
"или вектором. @var{less} используется для сравнения элементов \n"
"последовательности. Это стабильная сортировка.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:350
msgid ""
"@deffn {Scheme Procedure} stable-sort! items less\n"
"@deffnx {C Function} scm_stable_sort_x (items, less)\n"
"Sort the sequence @var{items}, which may be a list or a\n"
"vector. @var{less} is used for comparing the sequence elements.\n"
"The sorting is destructive, that means that the input sequence\n"
"is modified to produce the sorted result.\n"
"This is a stable sort.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} stable-sort! items less\n"
"@deffnx {C Function} scm_stable_sort_x (items, less)\n"
"Сортирует последовательность @var{items}, которая может быть списком\n"
"или вектором. @var{less} используется для сравнения элементов \n"
"последовательности. Это деструктивная сортировка, это означает, \n"
"что входная последовательность модифицируется для \n"
"получения отсортированного результата.\n"
"Это стабильная сортировка.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:353
msgid ""
"The procedures in the last group only accept lists or vectors as input,\n"
"as their names indicate."
msgstr ""
"Процедуры в последней группе принимают в качестве входных данных только "
"списки\n"
"или векторы, на что укзаывают их имена."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:359
msgid ""
"@deffn {Scheme Procedure} sort-list items less\n"
"@deffnx {C Function} scm_sort_list (items, less)\n"
"Sort the list @var{items}, using @var{less} for comparing the\n"
"list elements. This is a stable sort.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} sort-list items less\n"
"@deffnx {C Function} scm_sort_list (items, less)\n"
"Сортирует список @var{items}, используя @var{less} для сравнения\n"
"элементов списка. Это стабильная сортировка.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:367
msgid ""
"@deffn {Scheme Procedure} sort-list! items less\n"
"@deffnx {C Function} scm_sort_list_x (items, less)\n"
"Sort the list @var{items}, using @var{less} for comparing the\n"
"list elements. The sorting is destructive, that means that the\n"
"input list is modified to produce the sorted result.\n"
"This is a stable sort.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} sort-list! items less\n"
"@deffnx {C Function} scm_sort_list_x (items, less)\n"
"Сортирует список @var{items}, используя @var{less} для сравнения\n"
"элементов списка. Это деструктивная сортировка, это означает, \n"
"что входной список модифицируется для получения отсортированного \n"
"результата. Это стабильная сортировка.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:376
msgid ""
"@deffn {Scheme Procedure} restricted-vector-sort! vec less startpos endpos\n"
"@deffnx {C Function} scm_restricted_vector_sort_x (vec, less, startpos, "
"endpos)\n"
"Sort the vector @var{vec}, using @var{less} for comparing\n"
"the vector elements.  @var{startpos} (inclusively) and\n"
"@var{endpos} (exclusively) delimit\n"
"the range of the vector which gets sorted.  The return value\n"
"is not specified.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} restricted-vector-sort! vec less startpos endpos\n"
"@deffnx {C Function} scm_restricted_vector_sort_x (vec, less, startpos, "
"endpos)\n"
"Сортирует вектор @var{vec}, исползуя @var{less} для сравнения элементов\n"
"вектора.  @var{startpos} (включая) и @var{endpos} (исключая) разграничивают\n"
"диапазон вектора, который сортируется. Возвращаемое значение не определено.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:380
msgid ""
"@node Copying\n"
"@subsection Copying Deep Structures"
msgstr ""
"@node Copying\n"
"@subsection Копирования Глубоких Структур"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:382
msgctxt "/home/bear/work/guile/doc/guile/en/api-utility.texi:382"
msgid "@c FIXME::martin: Review me!"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:388
msgid ""
"The procedures for copying lists (@pxref{Lists}) only produce a flat\n"
"copy of the input list, and currently Guile does not even contain\n"
"procedures for copying vectors.  @code{copy-tree} can be used for these\n"
"application, as it does not only copy the spine of a list, but also\n"
"copies any pairs in the cars of the input lists."
msgstr ""
"Процедуры копирования списков (@pxref{Lists}) дают только поверхнустную\n"
"копию входного списка, и в настоящее время Guile даже не содержит процедур\n"
"для копирования векторов.  @code{copy-tree} может быть использована для\n"
"глубинного копирования, так как она не только копирует верхнуюю структуру \n"
"списка, но также копирует любые пары во входных списках."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:397
msgid ""
"@deffn {Scheme Procedure} copy-tree obj\n"
"@deffnx {C Function} scm_copy_tree (obj)\n"
"Recursively copy the data tree that is bound to @var{obj}, and return\n"
"the new data structure.  @code{copy-tree} recurses down the\n"
"contents of both pairs and vectors (since both cons cells and vector\n"
"cells may point to arbitrary objects), and stops recursing when it hits\n"
"any other object.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} copy-tree obj\n"
"@deffnx {C Function} scm_copy_tree (obj)\n"
"Рекурсивно копирует дерево данных, которое связано с @var{obj}, и "
"возвращает\n"
"новую структуру данных.  @code{copy-tree} рекурсивно просматривает "
"содержимое\n"
"как пар, таки векторов (так как обе ячейки cons и векторные ячейки могут\n"
"указывать на произвольные объекты), и останавливает повторение при "
"попадании\n"
"в любой другой объект.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:401
msgid ""
"@node General Conversion\n"
"@subsection General String Conversion"
msgstr ""
"@node General Conversion\n"
"@subsection Общее преобразование в Строки"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:403
msgctxt "/home/bear/work/guile/doc/guile/en/api-utility.texi:403"
msgid "@c FIXME::martin: Review me!"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:409
msgid ""
"When debugging Scheme programs, but also for providing a human-friendly\n"
"interface, a procedure for converting any Scheme object into string\n"
"format is very useful.  Conversion from/to strings can of course be done\n"
"with specialized procedures when the data type of the object to convert\n"
"is known, but with this procedure, it is often more comfortable."
msgstr ""
"При отладке программ Scheme, а также для обеспечения удобного для "
"пользователя\n"
"интерфейса, процедура препобразования произвольного объекта Scheme в "
"формат \n"
"строки очень полезна.  Преобразование из/в строки конечно может быть "
"выполнено\n"
"с помощью специальных процедур, когда тип данных объекта предназначенного "
"для\n"
"преобразования известен, но этой процедурой очень часто гораздо удобнее "
"пользоваться."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:415
msgid ""
"@code{object->string} converts an object by using a print procedure for\n"
"writing to a string port, and then returning the resulting string.\n"
"Converting an object back from the string is only possible if the object\n"
"type has a read syntax and the read syntax is preserved by the printing\n"
"procedure."
msgstr ""
"@code{object->string} преобразует объект, используя процедуру печати для\n"
"записи строки в порт, и возвращает результирующую строку.\n"
"Преобразование в объект обратно из строки возможно только в том случае, "
"если\n"
"тип объекта имеет синтаксис чтения, и синтаксис чтения сохраняется "
"процедурой\n"
"печати."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:422
msgid ""
"@deffn {Scheme Procedure} object->string obj [printer]\n"
"@deffnx {C Function} scm_object_to_string (obj, printer)\n"
"Return a Scheme string obtained by printing @var{obj}.\n"
"Printing function can be specified by the optional second\n"
"argument @var{printer} (default: @code{write}).\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} object->string obj [printer]\n"
"@deffnx {C Function} scm_object_to_string (obj, printer)\n"
"Возвращает строку Scheme, полученную при печати @var{obj}.\n"
"Функция печати может быть указана необязательным вторым\n"
"аргументом @var{printer} (по умолчанию: @code{write}).\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:427
msgid ""
"@node Hooks\n"
"@subsection Hooks\n"
"@tpindex Hooks"
msgstr ""
"@node Hooks\n"
"@subsection Хуки(К(Х)рюки, ;-) Крючки, Зацепки)\n"
"@tpindex Hooks"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:434
msgid ""
"A hook is a list of procedures to be called at well defined points in\n"
"time.  Typically, an application provides a hook @var{h} and promises\n"
"its users that it will call all of the procedures in @var{h} at a\n"
"defined point in the application's processing.  By adding its own\n"
"procedure to @var{h}, an application user can tap into or even influence\n"
"the progress of the application."
msgstr ""
"Хук это список процедур, которые должны вызваться в четко определенные\n"
"моменты времени. Как правило, приложение предоставляет хук @var{h} и\n"
"обещате своим пользователям, что оно вызвовет все процедуры из @var{h} \n"
"в определенный момент времени при выполнении приложения.  Добавляя свою\n"
"сообственную процедуру к @var{h}, пользователь приложения может "
"подключиться\n"
"или даже повлиять на ход выполнения приложения."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:437
msgid ""
"Guile itself provides several such hooks for debugging and customization\n"
"purposes: these are listed in a subsection below."
msgstr ""
"Сам Guile предоставляет несколько таких хуков для отладки и настройки:\n"
"они перечислены в подразделе ниже."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:443
msgid ""
"When an application first creates a hook, it needs to know how many\n"
"arguments will be passed to the hook's procedures when the hook is run.\n"
"The chosen number of arguments (which may be none) is declared when the\n"
"hook is created, and all the procedures that are added to that hook must\n"
"be capable of accepting that number of arguments."
msgstr ""
"Когда приложение впервые создает хук, оно должно знать, сколько аргументов\n"
"будет передаваться процедурам из хука, когда хук будет запускаться.\n"
"Выбранное количество аргументов (которых может и не быть) объявляется при\n"
"создании хука, и все процедуры, которые добавляются к этому хуку должны "
"быть\n"
"способны принимать такое количество аргументов."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:449
msgid ""
"A hook is created using @code{make-hook}.  A procedure can be added to\n"
"or removed from a hook using @code{add-hook!} or @code{remove-hook!},\n"
"and all of a hook's procedures can be removed together using\n"
"@code{reset-hook!}.  When an application wants to run a hook, it does so\n"
"using @code{run-hook}."
msgstr ""
"Хук создается с помощью @code{make-hook}.  Процедура может быть добавлена\n"
"или удалена из хука использованием @code{add-hook!} или @code{remove-"
"hook!},\n"
"и все процедуры хука можно удалить используя @code{reset-hook!}.  Когда \n"
"приложению необходимо запустить хук, оно делает это используя @code{run-"
"hook}."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:457
msgid ""
"@menu\n"
"* Hook Example::                Hook usage by example.\n"
"* Hook Reference::              Reference of all hook procedures.\n"
"* C Hooks::                     Hooks for use from C code.\n"
"* GC Hooks::                    Garbage collection hooks.\n"
"* REPL Hooks::                  Hooks into the Guile REPL.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:461
msgid ""
"@node Hook Example\n"
"@subsubsection Hook Usage by Example"
msgstr ""
"@node Hook Example\n"
"@subsubsection Пример Использования Хука"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:465
msgid ""
"Hook usage is shown by some examples in this section.  First, we will\n"
"define a hook of arity 2 --- that is, the procedures stored in the hook\n"
"will have to accept two arguments."
msgstr ""
"Использование хуков показано на нескольких примерах в этом разделе. Сначала\n"
"мы определяем хук арности(размерности) 2 --- т.е. процедуры хранящиеся в "
"хуке\n"
"должны будут принимать два аргумента."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:471
msgid ""
"@lisp\n"
"(define hook (make-hook 2))\n"
"hook\n"
"@result{} #<hook 2 40286c90>\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:476
msgid ""
"Now we are ready to add some procedures to the newly created hook with\n"
"@code{add-hook!}.  In the following example, two procedures are added,\n"
"which print different messages and do different things with their\n"
"arguments."
msgstr ""
"Теперь мы готовы добавить несколько процедур к вновь созданному хуку с \n"
"помощью @code{add-hook!}.  В следующем примере добавлены две процедуры,\n"
"которые печатают разные сообщения и делают разные вещи со своими \n"
"аргументами."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:487
msgid ""
"@lisp\n"
"(add-hook! hook (lambda (x y)\n"
"                    (display \"Foo: \")\n"
"                    (display (+ x y))\n"
"                    (newline)))\n"
"(add-hook! hook (lambda (x y)\n"
"                    (display \"Bar: \")\n"
"                    (display (* x y))\n"
"                    (newline)))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:490
msgid ""
"Once the procedures have been added, we can invoke the hook using\n"
"@code{run-hook}."
msgstr ""
"Как только процедуры были добавлены, мы можем вызвать хук используя\n"
"@code{run-hook}."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:496
msgid ""
"@lisp\n"
"(run-hook hook 3 4)\n"
"@print{} Bar: 12\n"
"@print{} Foo: 7\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:503
msgid ""
"Note that the procedures are called in the reverse of the order with\n"
"which they were added.  This is because the default behaviour of\n"
"@code{add-hook!} is to add its procedure to the @emph{front} of the\n"
"hook's procedure list.  You can force @code{add-hook!} to add its\n"
"procedure to the @emph{end} of the list instead by providing a third\n"
"@code{#t} argument on the second call to @code{add-hook!}."
msgstr ""
"Обратите внимание, что процедуры вызываются в обратном порядке, в котором\n"
"они были добавлены.  Это потому, что стандартным поведением функции\n"
"@code{add-hook!} является добавление процедуры в начало(@emph{front})\n"
"списка процедур хука.  Вы можете заставить @code{add-hook!} добавить вашу\n"
"процедуру в конец (@emph{end}) списка, предоставив третий аргумент равный\n"
"@code{#t} во втором вызове @code{add-hook!}."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:514
msgid ""
"@lisp\n"
"(add-hook! hook (lambda (x y)\n"
"                    (display \"Foo: \")\n"
"                    (display (+ x y))\n"
"                    (newline)))\n"
"(add-hook! hook (lambda (x y)\n"
"                    (display \"Bar: \")\n"
"                    (display (* x y))\n"
"                    (newline))\n"
"                    #t)             ; @r{<- Change here!}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:519
msgid ""
"(run-hook hook 3 4)\n"
"@print{} Foo: 7\n"
"@print{} Bar: 12\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:523
msgid ""
"@node Hook Reference\n"
"@subsubsection Hook Reference"
msgstr ""
"@node Hook Reference\n"
"@subsubsection Ссылка на Хук"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:530
msgid ""
"When you create a hook with @code{make-hook}, you must specify the arity\n"
"of the procedures which can be added to the hook.  If the arity is not\n"
"given explicitly as an argument to @code{make-hook}, it defaults to\n"
"zero.  All procedures of a given hook must have the same arity, and when\n"
"the procedures are invoked using @code{run-hook}, the number of\n"
"arguments passed must match the arity specified at hook creation time."
msgstr ""
"Когда вы создаете хук с помощью @code{make-hook}, вы можете указать арность\n"
"(размерность) процедур, которые можно добавить к хуку. Если арность не "
"указана\n"
"в качестве аргумента @code{make-hook}, по умолчанию она будет равно нулю.\n"
"Все процедуры данного хука должны быть одинаковой арности, и когда "
"процедуры\n"
"вызываются с использованием @code{run-hook}, количество передаваемых "
"аргументов\n"
"должно соответствовать арности указанной во время создания хука."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:537
msgid ""
"The order in which procedures are added to a hook matters.  If the third\n"
"parameter to @code{add-hook!} is omitted or is equal to @code{#f}, the\n"
"procedure is added in front of the procedures which might already be on\n"
"that hook, otherwise the procedure is added at the end.  The procedures\n"
"are always called from the front to the end of the list when they are\n"
"invoked via @code{run-hook}."
msgstr ""
"Порядок в котором процедуры добавляются к хуку имеет значение.  Если третий\n"
"параметр @code{add-hook!} пропущен или равен @code{#f}, процедура "
"добавляется\n"
"перед процедурами которые уже были  добавлены к хуку, в противном случае\n"
"процедура добавляется в конец. Процедуры всегда вызываются с начала и до "
"конца\n"
"списка, когда они вызываются через @code{run-hook}."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:541
msgid ""
"The ordering of the list of procedures returned by @code{hook->list}\n"
"matches the order in which those procedures would be called if the hook\n"
"was run using @code{run-hook}."
msgstr ""
"Порядок процедур в списке, возвращаемый @code{hook->list} соответствует\n"
"порядку в котором эти процедуры будут вызваны, если хук будет запущен\n"
"с использованием @code{run-hook}."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:545
msgid ""
"Note that the C functions in the following entries are for handling\n"
"@dfn{Scheme-level} hooks in C.  There are also @dfn{C-level} hooks which\n"
"have their own interface (@pxref{C Hooks})."
msgstr ""
"Обратите внимание, что функции Си в следующих записях предназначены для\n"
"обработки хуков уровня схемы(@dfn{Scheme-level}) на Си.  Существуют также \n"
"хуки уровня Си(@dfn{C-level}) которые имеют собственный интерфейс (@pxref{C "
"Hooks})."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:552
msgid ""
"@deffn {Scheme Procedure} make-hook [n_args]\n"
"@deffnx {C Function} scm_make_hook (n_args)\n"
"Create a hook for storing procedure of arity @var{n_args}.\n"
"@var{n_args} defaults to zero.  The returned value is a hook\n"
"object to be used with the other hook procedures.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} make-hook [n_args]\n"
"@deffnx {C Function} scm_make_hook (n_args)\n"
"Создает хук для хранения процедур размерности(арности) @var{n_args}.\n"
"@var{n_args} по умолчанию равен нулю.  Возвращаемое значение является\n"
"объектом хуком, который будет использоваться с другими процедурами\n"
"хука.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:557
msgid ""
"@deffn {Scheme Procedure} hook? x\n"
"@deffnx {C Function} scm_hook_p (x)\n"
"Return @code{#t} if @var{x} is a hook, @code{#f} otherwise.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} hook? x\n"
"@deffnx {C Function} scm_hook_p (x)\n"
"Возвращает @code{#t} если @var{x} это хук, @code{#f} иначе.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:563
msgid ""
"@deffn {Scheme Procedure} hook-empty? hook\n"
"@deffnx {C Function} scm_hook_empty_p (hook)\n"
"Return @code{#t} if @var{hook} is an empty hook, @code{#f}\n"
"otherwise.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} hook-empty? hook\n"
"@deffnx {C Function} scm_hook_empty_p (hook)\n"
"Возвращает @code{#t} если @var{hook} это пустой хук, @code{#f}\n"
"иначе.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:571
msgid ""
"@deffn {Scheme Procedure} add-hook! hook proc [append_p]\n"
"@deffnx {C Function} scm_add_hook_x (hook, proc, append_p)\n"
"Add the procedure @var{proc} to the hook @var{hook}. The\n"
"procedure is added to the end if @var{append_p} is true,\n"
"otherwise it is added to the front.  The return value of this\n"
"procedure is not specified.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} add-hook! hook proc [append_p]\n"
"@deffnx {C Function} scm_add_hook_x (hook, proc, append_p)\n"
"Добавляет процедуру @var{proc} к хуку @var{hook}. Процедура\n"
"добавляется в конец если @var{append_p} равен истине,\n"
"иначе она добавляется в начало. Возвращаемое значение этой\n"
"процедурой не указано.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:577
msgid ""
"@deffn {Scheme Procedure} remove-hook! hook proc\n"
"@deffnx {C Function} scm_remove_hook_x (hook, proc)\n"
"Remove the procedure @var{proc} from the hook @var{hook}.  The\n"
"return value of this procedure is not specified.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} remove-hook! hook proc\n"
"@deffnx {C Function} scm_remove_hook_x (hook, proc)\n"
"Удаляет процедуру @var{proc} из хука @var{hook}.  Возвращаемое\n"
"значение этой процедурой не указано.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:583
msgid ""
"@deffn {Scheme Procedure} reset-hook! hook\n"
"@deffnx {C Function} scm_reset_hook_x (hook)\n"
"Remove all procedures from the hook @var{hook}.  The return\n"
"value of this procedure is not specified.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} reset-hook! hook\n"
"@deffnx {C Function} scm_reset_hook_x (hook)\n"
"Удаляет все процедуры из хука @var{hook}.  Возвращаемое\n"
"этой процедурой значение не указано.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:588
msgid ""
"@deffn {Scheme Procedure} hook->list hook\n"
"@deffnx {C Function} scm_hook_to_list (hook)\n"
"Convert the procedure list of @var{hook} to a list.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} hook->list hook\n"
"@deffnx {C Function} scm_hook_to_list (hook)\n"
"Преобразует список процедур хука @var{hook} в список.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:595
msgid ""
"@deffn {Scheme Procedure} run-hook hook arg @dots{}\n"
"@deffnx {C Function} scm_run_hook (hook, args)\n"
"Apply all procedures from the hook @var{hook} to the arguments @var{arg}\n"
"@enddots{}.  The order of the procedure application is first to last.\n"
"The return value of this procedure is not specified.\n"
"@end deffn"
msgstr ""
"@deffn {Scheme Procedure} run-hook hook arg @dots{}\n"
"@deffnx {C Function} scm_run_hook (hook, args)\n"
"Применяет все процедуры из хука @var{hook} к аргументам @var{arg}\n"
"@enddots{}.  Порядок применения процедур от первого к последнему.\n"
"Возвращаемое этой процедурой значение не указано.\n"
"@end deffn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:600
msgid ""
"If, in C code, you are certain that you have a hook object and well\n"
"formed argument list for that hook, you can also use\n"
"@code{scm_c_run_hook}, which is identical to @code{scm_run_hook} but\n"
"does no type checking."
msgstr ""
"Если , в коде Сиe, вы уверены что есть объект хук и правильно "
"сформированный\n"
"список аргументов для хука, вы можете также использовать\n"
"@code{scm_c_run_hook}, который идентичен to @code{scm_run_hook} но не \n"
"проверяет типы."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:606
msgid ""
"@deftypefn {C Function} void scm_c_run_hook (SCM hook, SCM args)\n"
"The same as @code{scm_run_hook} but without any type checking to confirm\n"
"that @var{hook} is actually a hook object and that @var{args} is a\n"
"well-formed list matching the arity of the hook.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Function} void scm_c_run_hook (SCM hook, SCM args)\n"
"То же, что и @code{scm_run_hook} но без проверки типа для подтверждения\n"
"того что @var{hook} на самом деле является хук объектом и  этот @var{args}\n"
"представляет собой правильно сформированный список соответствующей арности\n"
"хука.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:609
msgid ""
"For C code, @code{SCM_HOOKP} is a faster alternative to\n"
"@code{scm_hook_p}:"
msgstr ""
"Для Си кода @code{SCM_HOOKP} более быстрая альтернатива\n"
"@code{scm_hook_p}:"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:613
msgid ""
"@deftypefn {C Macro} int SCM_HOOKP (x)\n"
"Return 1 if @var{x} is a Scheme-level hook, 0 otherwise.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Macro} int SCM_HOOKP (x)\n"
"Возвращает 1 если @var{x} это хук уровня Схемы(Scheme-level), иначе 0.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:617
msgid ""
"@node C Hooks\n"
"@subsubsection Hooks For C Code."
msgstr ""
"@node C Hooks\n"
"@subsubsection Хуки для Си кода."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:622
msgid ""
"The hooks already described are intended to be populated by Scheme-level\n"
"procedures.  In addition to this, the Guile library provides an\n"
"independent set of interfaces for the creation and manipulation of hooks\n"
"that are designed to be populated by functions implemented in C."
msgstr ""
"Уже описанные хуки предназначены для исполнения процедур на уровне Схемы\n"
"(Scheme-level). В дополнении к ним, библиотека Guile предоставляет "
"назависимый\n"
"набор интерфейсов для создания и манипулирования хуками, которые "
"предназначены\n"
"для заполнения функциями, реализоованными на Си."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:631
msgid ""
"The original motivation here was to provide a kind of hook that could\n"
"safely be invoked at various points during garbage collection.\n"
"Scheme-level hooks are unsuitable for this purpose as running them could\n"
"itself require memory allocation, which would then invoke garbage\n"
"collection recursively @dots{}  However, it is also the case that these\n"
"hooks are easier to work with than the Scheme-level ones if you only\n"
"want to register C functions with them.  So if that is mainly what your\n"
"code needs to do, you may prefer to use this interface."
msgstr ""
"Первоначальная мотивация здесь заключается в том, чтобы обеспечить совего\n"
"рода хук, который можно было бы безопасно использовать в разные моменты\n"
"во время сборки мусора. Хуки уровня Схемы(Scheme-level) для этого не \n"
"подходят, цель их запуска сама по себе может потребовать выделения памяти,\n"
"что приведет к вызову сборщика мусора рекурсивно @dots{}  Тем не менее,\n"
"это также тот случай, когда эти хуки легче работают с уровнем Схемы\n"
"(Scheme-level), если вы хотите зарегистрировать только функции Си.\n"
"Так что если это в основном то, что должен делать ваш код,\n"
"вы можете предпочесть использовать этот интерфейс."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:634
msgid ""
"To create a C hook, you should allocate storage for a structure of type\n"
"@code{scm_t_c_hook} and then initialize it using @code{scm_c_hook_init}."
msgstr ""
"Для создания Си хука, вы должны выделить хранилище для структуры типа\n"
"@code{scm_t_c_hook} и инициализировать ее используя @code{scm_c_hook_init}."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:639
msgid ""
"@deftp {C Type} scm_t_c_hook\n"
"Data type for a C hook.  The internals of this type should be treated as\n"
"opaque.\n"
"@end deftp"
msgstr ""
"@deftp {C Type} scm_t_c_hook\n"
"Тип данных для Си хука. Внутреннее устройство этого типа должно "
"рассматриваться\n"
"кака не прозрачное, не видимое.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:642
msgid ""
"@deftp {C Enum} scm_t_c_hook_type\n"
"Enumeration of possible hook types, which are:"
msgstr ""
"@deftp {C Enum} scm_t_c_hook_type\n"
"Перечисление возможных типов хуков, как то:"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:657
msgid ""
"@table @code\n"
"@item SCM_C_HOOK_NORMAL\n"
"@vindex SCM_C_HOOK_NORMAL\n"
"Type of hook for which all the registered functions will always be called.\n"
"@item SCM_C_HOOK_OR\n"
"@vindex SCM_C_HOOK_OR\n"
"Type of hook for which the sequence of registered functions will be\n"
"called only until one of them returns C true (a non-NULL pointer).\n"
"@item SCM_C_HOOK_AND\n"
"@vindex SCM_C_HOOK_AND\n"
"Type of hook for which the sequence of registered functions will be\n"
"called only until one of them returns C false (a NULL pointer).\n"
"@end table\n"
"@end deftp"
msgstr ""
"@table @code\n"
"@item SCM_C_HOOK_NORMAL\n"
"@vindex SCM_C_HOOK_NORMAL\n"
"Тип хука, для которого всегда будут вызываться все зарегистрированные "
"функции.\n"
"@item SCM_C_HOOK_OR\n"
"@vindex SCM_C_HOOK_OR\n"
"Тип хука, для которого будет вызываться последовательность "
"зарегистрированных \n"
"функций только до тех пор, пока одна из них не вернет Си истину(т.е не "
"нулевое\n"
"значение).\n"
"@item SCM_C_HOOK_AND\n"
"@vindex SCM_C_HOOK_AND\n"
"Тип хука, для которого будет вызываться последовательность "
"зарегистрированных\n"
"функций только до тех пор, пока одна из них не вернет Си ложь(т.е ноль)\n"
"@end table\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:665
msgid ""
"@deftypefn {C Function} void scm_c_hook_init (scm_t_c_hook *hook, void "
"*hook_data, scm_t_c_hook_type type)\n"
"Initialize the C hook at memory pointed to by @var{hook}.  @var{type}\n"
"should be one of the values of the @code{scm_t_c_hook_type} enumeration,\n"
"and controls how the hook functions will be called.  @var{hook_data} is\n"
"a closure parameter that will be passed to all registered hook functions\n"
"when they are called.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Function} void scm_c_hook_init (scm_t_c_hook *hook, void "
"*hook_data, scm_t_c_hook_type type)\n"
"Инициализирует Си хук  в памяти указываемой @var{hook}.  @var{type}\n"
"должен быть одним из значений перечисления @code{scm_t_c_hook_type},\n"
"и управляет тем как функции хука будут вызываться.  @var{hook_data} это\n"
"параметр замыкания который будет передан всем зарегистрированным функциям\n"
"хука, когда они вызываются.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:669
msgid ""
"To add or remove a C function from a C hook, use @code{scm_c_hook_add}\n"
"or @code{scm_c_hook_remove}.  A hook function must expect three\n"
"@code{void *} parameters which are, respectively:"
msgstr ""
"Чтобы добавить или удалить Си функцию из Си хука, используйте "
"@code{scm_c_hook_add}\n"
"или @code{scm_c_hook_remove}.  Функция хука должна ожидать три параметра\n"
"@code{void *}, соответственно:"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:674
msgid ""
"@table @var\n"
"@item hook_data\n"
"The hook closure data that was specified at the time the hook was\n"
"initialized by @code{scm_c_hook_init}."
msgstr ""
"@table @var\n"
"@item hook_data\n"
"Данные замыкания хука, которые были указаны во время инициализации хука\n"
"@code{scm_c_hook_init}."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:678
msgid ""
"@item func_data\n"
"The function closure data that was specified at the time that that\n"
"function was registered with the hook by @code{scm_c_hook_add}."
msgstr ""
"@item func_data\n"
"Данные замыкания функции, которые были указаны, когда эта функция была\n"
"зарегистрирована с хуком с помощью @code{scm_c_hook_add}."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:683
msgid ""
"@item data\n"
"The call closure data specified by the @code{scm_c_hook_run} call that\n"
"runs the hook.\n"
"@end table"
msgstr ""
"@item data\n"
"Данные замыкания вызова указанные в вызове @code{scm_c_hook_run}, который\n"
"запускает хук.\n"
"@end table"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:688
msgid ""
"@deftp {C Type} scm_t_c_hook_function\n"
"Function type for a C hook function: takes three @code{void *}\n"
"parameters and returns a @code{void *} result.\n"
"@end deftp"
msgstr ""
"@deftp {C Type} scm_t_c_hook_function\n"
"Тип функции для Си функций хук: получает три параметра @code{void *}\n"
"и возвращает результат @code{void *}.\n"
"@end deftp"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:694
msgid ""
"@deftypefn {C Function} void scm_c_hook_add (scm_t_c_hook *hook, "
"scm_t_c_hook_function func, void *func_data, int appendp)\n"
"Add function @var{func}, with function closure data @var{func_data}, to\n"
"the C hook @var{hook}.  The new function is appended to the hook's list\n"
"of functions if @var{appendp} is non-zero, otherwise prepended.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Function} void scm_c_hook_add (scm_t_c_hook *hook, "
"scm_t_c_hook_function func, void *func_data, int appendp)\n"
"Добавляет функцию @var{func}, с данными замыкания функции @var{func_data}, "
"в\n"
"Си хук @var{hook}.  Новая функция добавляется в список функций хука если\n"
"@var{appendp} не равен нулю, в противном случае предваряется списком.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:701
msgid ""
"@deftypefn {C Function} void scm_c_hook_remove (scm_t_c_hook *hook, "
"scm_t_c_hook_function func, void *func_data)\n"
"Remove function @var{func}, with function closure data @var{func_data},\n"
"from the C hook @var{hook}.  @code{scm_c_hook_remove} checks both\n"
"@var{func} and @var{func_data} so as to allow for the same @var{func}\n"
"being registered multiple times with different closure data.\n"
"@end deftypefn"
msgstr ""
"@deftypefn {C Function} void scm_c_hook_remove (scm_t_c_hook *hook, "
"scm_t_c_hook_function func, void *func_data)\n"
"Удаляет функцию @var{func}, с данными замыкания функции @var{func_data},\n"
"из Си хука @var{hook}.  @code{scm_c_hook_remove} проверяет оба\n"
"@var{func} и @var{func_data} что позволяет для одной и той же функции "
"@var{func}\n"
"быть зарегистрированной во множестве мест с различными данными замыкания.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:704
msgid ""
"Finally, to invoke a C hook, call the @code{scm_c_hook_run} function\n"
"specifying the hook and the call closure data for this run:"
msgstr ""
"Наконец, чтобы вызвать Си хук. вызовите функцию @code{scm_c_hook_run} "
"указав\n"
"хук и данные замыкания вызова для его работы:"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:711
msgid ""
"@deftypefn {C Function} {void *} scm_c_hook_run (scm_t_c_hook *hook, void "
"*data)\n"
"Run the C hook @var{hook} will call closure data @var{data}.  Subject to\n"
"the variations for hook types @code{SCM_C_HOOK_OR} and\n"
"@code{SCM_C_HOOK_AND}, @code{scm_c_hook_run} calls @var{hook}'s\n"
"registered functions in turn, passing them the hook's closure data, each\n"
"function's closure data, and the call closure data."
msgstr ""
"@deftypefn {C Function} {void *} scm_c_hook_run (scm_t_c_hook *hook, void "
"*data)\n"
"Запуск Си хука @var{hook} вызовет замыкание данных @var{data}.  С учетом\n"
"вариантов для типа хука @code{SCM_C_HOOK_OR} и\n"
"@code{SCM_C_HOOK_AND}, @code{scm_c_hook_run} вызывая зарегистрированные в\n"
"хуке @var{hook} функции, передавая им данные замыкания хука, данные "
"замыкания\n"
"каждой функции, и данные замыкания вызова."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:715
msgid ""
"@code{scm_c_hook_run}'s return value is the return value of the last\n"
"function to be called.\n"
"@end deftypefn"
msgstr ""
"@code{scm_c_hook_run} возвращаемое значени является возвращенным значением\n"
"последней вызванной функции.\n"
"@end deftypefn"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:719
msgid ""
"@node GC Hooks\n"
"@subsubsection Hooks for Garbage Collection"
msgstr ""
"@node GC Hooks\n"
"@subsubsection Хуки для Сборщика Мусора (GC)"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:722
msgid ""
"Whenever Guile performs a garbage collection, it calls the following\n"
"hooks in the order shown."
msgstr ""
"Всякий раз, когда Guile выполняет сборку мусора, он вызывает следующие хуки\n"
"в указанном порядке."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:727
msgid ""
"@defvr {C Hook} scm_before_gc_c_hook\n"
"C hook called at the very start of a garbage collection, after setting\n"
"@code{scm_gc_running_p} to 1, but before entering the GC critical\n"
"section."
msgstr ""
"@defvr {C Hook} scm_before_gc_c_hook\n"
"Вызывает Си хук в самом начале сборки мусора, после установки\n"
"@code{scm_gc_running_p} в 1, но перед входом GC в критическую секцию."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:732
msgid ""
"If garbage collection is blocked because @code{scm_block_gc} is\n"
"non-zero, GC exits early soon after calling this hook, and no further\n"
"hooks will be called.\n"
"@end defvr"
msgstr ""
"Если сборка мусора заблокирована, потому что @code{scm_block_gc} не\n"
"равен нулю, GC завершает работу раньше, вскоре после вызова этого хука,\n"
"больше никаких хуков не будет вызвано.\n"
"@end defvr"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:737
msgid ""
"@defvr {C Hook} scm_before_mark_c_hook\n"
"C hook called before beginning the mark phase of garbage collection,\n"
"after the GC thread has entered a critical section.\n"
"@end defvr"
msgstr ""
"@defvr {C Hook} scm_before_mark_c_hook\n"
"Хук Си вызывается перед началом фазы пометки сборщика мусора,\n"
"после тогок как поток GC вошел в критическую секцию.\n"
"@end defvr"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:743
msgid ""
"@defvr {C Hook} scm_before_sweep_c_hook\n"
"C hook called before beginning the sweep phase of garbage collection.\n"
"This is the same as at the end of the mark phase, since nothing else\n"
"happens between marking and sweeping.\n"
"@end defvr"
msgstr ""
"@defvr {C Hook} scm_before_sweep_c_hook\n"
"Си хук вызывается перед началом фазы оочистки сборщиком мусора.\n"
"Это тоже же, что и конец фазы маркировки, так что ничего не происходит\n"
"между фазой маркировки и очистки.\n"
"@end defvr"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:748
msgid ""
"@defvr {C Hook} scm_after_sweep_c_hook\n"
"C hook called after the end of the sweep phase of garbage collection,\n"
"but while the GC thread is still inside its critical section.\n"
"@end defvr"
msgstr ""
"@defvr {C Hook} scm_after_sweep_c_hook\n"
"Си хук вызывается после завершения фазы очистки сборщиком мусора,\n"
"но пока поток GC все еще находиться в критической секции.\n"
"@end defvr"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:753
msgid ""
"@defvr {C Hook} scm_after_gc_c_hook\n"
"C hook called at the very end of a garbage collection, after the GC\n"
"thread has left its critical section.\n"
"@end defvr"
msgstr ""
"@defvr {C Hook} scm_after_gc_c_hook\n"
"Хук Си вызывается в самом конце сборки мусора, после того как поток\n"
"GC покинул свою критическую секцию.\n"
"@end defvr"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:761
msgid ""
"@defvr {Scheme Hook} after-gc-hook\n"
"@vindex scm_after_gc_hook\n"
"Scheme hook with arity 0.  This hook is run asynchronously\n"
"(@pxref{Asyncs}) soon after the GC has completed and any other events\n"
"that were deferred during garbage collection have been processed.  (Also\n"
"accessible from C with the name @code{scm_after_gc_hook}.)\n"
"@end defvr"
msgstr ""
"@defvr {Scheme Hook} after-gc-hook\n"
"@vindex scm_after_gc_hook\n"
"Хук Scheme с арностью 0.  Этот хук запускается асинхронно (@pxref{Asyncs})\n"
"вскоре после завершения GC и любых других событий, которые были отложены во\n"
"время процесса сборки мусора.  (Также доступно из Си\n"
"с именем @code{scm_after_gc_hook}.)\n"
"@end defvr"

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:765
msgid ""
"All the C hooks listed here have type @code{SCM_C_HOOK_NORMAL}, are\n"
"initialized with hook closure data NULL, are invoked by\n"
"@code{scm_c_hook_run} with call closure data NULL."
msgstr ""
"Все перечисленные здесь хуки имеют тип @code{SCM_C_HOOK_NORMAL}, и \n"
"инициализируются с данными замыкания хука NULL, и вызываются \n"
"@code{scm_c_hook_run} с данными замыкания вызова NULL."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:774
msgid ""
"@cindex guardians, testing for GC'd objects\n"
"The Scheme hook @code{after-gc-hook} is particularly useful in\n"
"conjunction with guardians (@pxref{Guardians}).  Typically, if you are\n"
"using a guardian, you want to call the guardian after garbage collection\n"
"to see if any of the objects added to the guardian have been collected.\n"
"By adding a thunk that performs this call to @code{after-gc-hook}, you\n"
"can ensure that your guardian is tested after every garbage collection\n"
"cycle."
msgstr ""
"@cindex guardians, testing for GC'd objects\n"
"Хук Scheme @code{after-gc-hook} особенно полезен в сочетании с защитниками\n"
"(guardians) (@pxref{Guardians}).  Как правило, если вы используете "
"защитника,\n"
"вы хотите вызвать хранителя после сборки мусора, что бы увидеть есть ли\n"
"какие либо объекты, добавленные в защитника были собраны.\n"
"Добавляя чанк(thunk), который выполняет вызов к @code{after-gc-hook}, вы "
"можете\n"
"убедиться, что ваш защитникy проверяется после каждого цикла сборки мусора."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:778
msgid ""
"@node REPL Hooks\n"
"@subsubsection Hooks into the Guile REPL"
msgstr ""
"@node REPL Hooks\n"
"@subsubsection Хуки в  Guile REPL\n"
"Документации по ним нет, но выполнив  @code{grep hook *} \n"
"в директории guile/2.2/system/repl можно обнаружить следующие\n"
"хуки:\n"
"@lisp\n"
"command.scm:                (run-hook before-print-hook x)\n"
"debug.scm:                  (run-hook before-print-hook val)\n"
"describe.scm:               (cons <hook>      \"a hook\")\n"
"error-handling.scm:         (run-hook before-error-hook)\n"
"error-handling.scm:         (run-hook after-error-hook)\n"
"repl.scm:                   (run-hook before-eval-hook exp)\n"
"@end lisp\n"
" которые можно попытаться использовать."

#: /home/bear/work/guile/doc/guile/en/api-utility.texi:782
msgid ""
"@c Local Variables:\n"
"@c TeX-master: \"guile.texi\"\n"
"@c End:"
msgstr ""
